(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.cymine = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
/*! imjs - v3.13.0 - 2015-05-08 */

// This library is open source software according to the definition of the
// GNU Lesser General Public Licence, Version 3, (LGPLv3) a copy of which is
// included with this software. All use of this software is covered according to
// the terms of the LGPLv3.
// 
// The copyright is held by InterMine (www.intermine.org) and Alex Kalderimis (alex@intermine.org).

(function (intermine) {
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.imjs=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
(function() {
  exports.ACCEPT_HEADER = {
    'xml': 'application/xml',
    'json': 'application/json',
    'tsv': 'text/tab-separated-values',
    'tab': 'text/tab-separated-values',
    'csv': 'text/comma-separated-values',
    'fasta': 'text/x-fasta',
    'gff3': 'text/x-gff3',
    'bed': 'text/x-bed',
    'objects': 'application/json;type=objects',
    'jsonobjects': 'application/json;type=objects',
    'jsontable': 'application/json;type=table',
    'jsonrows': 'application/json;type=rows',
    'jsoncount': 'application/json;type=count',
    'jsonp': 'application/javascript',
    'jsonpobjects': 'application/javascript;type=objects',
    'jsonptable': 'application/javascript;type=table',
    'jsonprows': 'application/javascript;type=rows',
    'jsonpcount': 'application/javascript;type=count'
  };

}).call(this);

},{}],2:[function(_dereq_,module,exports){
(function (global){
(function() {
  var expose, imjs, merge;

  _dereq_('./shiv');

  module.exports = imjs = _dereq_('./service');

  merge = imjs.utils.merge;

  expose = function(name, thing) {
    if ('function' === typeof define && define.amd) {
      return define(name, [], thing);
    } else {
      return global[name] = thing;
    }
  };

  expose('imjs', imjs);

  if (typeof intermine === 'undefined') {
    expose('intermine', imjs);
  } else {
    expose('intermine', merge(intermine, imjs));
  }

}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./service":10,"./shiv":12}],3:[function(_dereq_,module,exports){
(function() {
  var ACCEPT_HEADER, JSONStream, PESKY_COMMA, URL, URLENC, USER_AGENT, VERSION, blocking, defer, error, getMsg, http, invoke, merge, parseOptions, rejectAfter, streaming, utils, _ref;

  URL = _dereq_('url');

  JSONStream = _dereq_('JSONStream');

  http = _dereq_('http');

  ACCEPT_HEADER = _dereq_('./constants').ACCEPT_HEADER;

  VERSION = _dereq_('./version').VERSION;

  _ref = utils = _dereq_('./util'), error = _ref.error, defer = _ref.defer, merge = _ref.merge, invoke = _ref.invoke;

  USER_AGENT = "node-http/imjs-" + VERSION;

  PESKY_COMMA = /,\s*$/;

  URLENC = "application/x-www-form-urlencoded";

  exports.supports = function() {
    return true;
  };

  streaming = function(opts, resolve, reject) {
    return function(resp) {
      var errors, results;
      if (resp.pipe == null) {
        return reject(new Error('response is not a stream'));
      }
      resp.on('error', reject);
      if ((resp.statusCode != null) && resp.statusCode !== 200) {
        errors = JSONStream.parse('error');
        errors.pause();
        resp.pipe(errors);
        return reject([resp.statusCode, errors]);
      } else {
        results = JSONStream.parse('results.*');
        results.pause();
        resp.pipe(results);
        return resolve(results);
      }
    };
  };

  getMsg = function(_arg, text, e, code) {
    var type, url;
    type = _arg.type, url = _arg.url;
    return "Could not parse response to " + type + " " + url + ": \"" + text + "\" (" + code + ": " + e + ")";
  };

  blocking = function(opts, resolve, reject) {
    return function(resp) {
      var containerBuffer;
      containerBuffer = '';
      resp.on('data', function(chunk) {
        return containerBuffer += chunk;
      });
      resp.on('error', reject);
      return resp.on('end', function() {
        var ct, e, err, f, match, parsed, _ref1;
        ct = resp.headers['content-type'];
        if ('application/json' === ct || /json/.test(opts.dataType) || /json/.test(opts.data.format)) {
          if ('' === containerBuffer && resp.statusCode === 200) {
            return resolve();
          } else {
            try {
              parsed = JSON.parse(containerBuffer);
              if (err = parsed.error) {
                return reject(new Error(err));
              } else {
                return resolve(parsed);
              }
            } catch (_error) {
              e = _error;
              if (resp.statusCode >= 400) {
                return reject(new Error(resp.statusCode));
              } else {
                return reject(new Error(getMsg(opts, containerBuffer, e, resp.statusCode)));
              }
            }
          }
        } else {
          if (match = containerBuffer.match(/\[ERROR\] (\d+)([\s\S]*)/)) {
            return reject(new Error(match[2]));
          } else {
            f = (200 <= (_ref1 = resp.statusCode) && _ref1 < 400) ? resolve : reject;
            return f(containerBuffer);
          }
        }
      });
    };
  };

  exports.iterReq = function(method, path, format) {
    return function(q, page, cb, eb, onEnd) {
      var attach, promise, readErrors, req, _ref1;
      if (page == null) {
        page = {};
      }
      if (cb == null) {
        cb = (function() {});
      }
      if (eb == null) {
        eb = (function() {});
      }
      if (onEnd == null) {
        onEnd = (function() {});
      }
      if (utils.isFunction(page)) {
        _ref1 = [{}, page, cb, eb], page = _ref1[0], cb = _ref1[1], eb = _ref1[2], onEnd = _ref1[3];
      }
      req = merge({
        format: format
      }, page, {
        query: q.toXML()
      });
      attach = function(stream) {
        stream.on('data', cb);
        stream.on('error', eb);
        stream.on('end', onEnd);
        setTimeout((function() {
          if (stream.resume != null) {
            return stream.resume();
          }
        }), 3);
        return stream;
      };
      readErrors = function(_arg) {
        var errors, sc;
        sc = _arg[0], errors = _arg[1];
        errors.on('data', eb);
        errors.on('error', eb);
        errors.on('end', onEnd);
        if (errors.resume != null) {
          errors.resume();
        }
        return error(sc);
      };
      promise = this.makeRequest(method, path, req, null, true);
      promise.then(attach, readErrors);
      return promise;
    };
  };

  rejectAfter = function(timeout, reject, promise) {
    var to;
    to = setTimeout((function() {
      return reject("Request timed out.");
    }), timeout);
    return promise.then(function() {
      return cancelTimeout(to);
    });
  };

  parseOptions = function(opts) {
    var k, parsed, postdata, sep, v, _ref1, _ref2, _ref3;
    if (!opts.url) {
      throw new Error("No url provided in " + (JSON.stringify(opts)));
    }
    if (typeof opts.data === 'string') {
      postdata = opts.data;
      if ((_ref1 = opts.type) === 'GET' || _ref1 === 'DELETE') {
        throw new Error("Invalid request. " + opts.type + " requests must not have bodies");
      }
    } else {
      postdata = utils.querystring(opts.data);
    }
    parsed = URL.parse(opts.url, true);
    parsed.withCredentials = false;
    parsed.method = opts.type || 'GET';
    if (opts.port != null) {
      parsed.port = opts.port;
    }
    parsed.headers = {
      'User-Agent': USER_AGENT,
      'Accept': ACCEPT_HEADER[opts.dataType]
    };
    if (((_ref2 = parsed.method) === 'GET' || _ref2 === 'DELETE') && (postdata != null ? postdata.length : void 0)) {
      sep = /\?/.test(parsed.path) ? '&' : '?';
      parsed.path += sep + postdata;
      postdata = null;
    } else {
      parsed.headers['Content-Type'] = (opts.contentType || URLENC) + '; charset=UTF-8';
      parsed.headers['Content-Length'] = postdata.length;
    }
    if (opts.headers != null) {
      _ref3 = opts.headers;
      for (k in _ref3) {
        v = _ref3[k];
        parsed.headers[k] = v;
      }
    }
    if (opts.auth != null) {
      parsed.auth = opts.auth;
    }
    return [parsed, postdata];
  };

  exports.doReq = function(opts, iter) {
    var e, handler, postdata, promise, reject, req, resolve, timeout, url, _ref1, _ref2;
    _ref1 = defer(), promise = _ref1.promise, resolve = _ref1.resolve, reject = _ref1.reject;
    promise.then(null, opts.error);
    try {
      _ref2 = parseOptions(opts), url = _ref2[0], postdata = _ref2[1];
      handler = (iter ? streaming : blocking)(opts, resolve, reject);
      req = http.request(url, handler);
      req.on('error', function(err) {
        return reject(new Error("Error: " + url.method + " " + opts.url + ": " + err));
      });
      if (postdata != null) {
        req.write(postdata);
      }
      req.end();
      timeout = opts.timeout;
      if (timeout > 0) {
        rejectAfter(timeout, reject, promise);
      }
    } catch (_error) {
      e = _error;
      reject(e);
    }
    return promise;
  };

}).call(this);

},{"./constants":1,"./util":15,"./version":16,"JSONStream":18,"http":50,"url":47}],4:[function(_dereq_,module,exports){
(function() {
  var CategoryResults, IDResolutionJob, IdResults, ONE_MINUTE, concatMap, defer, difference, fold, funcutils, get, id, intermine, uniqBy, withCB,
    __hasProp = {}.hasOwnProperty,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  funcutils = _dereq_('./util');

  intermine = exports;

  uniqBy = funcutils.uniqBy, difference = funcutils.difference, defer = funcutils.defer, withCB = funcutils.withCB, id = funcutils.id, get = funcutils.get, fold = funcutils.fold, concatMap = funcutils.concatMap;

  ONE_MINUTE = 60 * 1000;

  CategoryResults = (function() {
    var getIssueMatches;

    function CategoryResults(results) {
      var k, v;
      for (k in results) {
        if (!__hasProp.call(results, k)) continue;
        v = results[k];
        this[k] = v;
      }
    }

    CategoryResults.prototype.getStats = function(type) {
      if (type != null) {
        return this.stats[type];
      } else {
        return this.stats;
      }
    };

    getIssueMatches = concatMap(get('matches'));

    CategoryResults.prototype.getMatches = function(k) {
      var _ref;
      if (k === 'MATCH') {
        return this.matches[k];
      } else {
        return (_ref = getIssueMatches(this.matches[k])) != null ? _ref : [];
      }
    };

    CategoryResults.prototype.getMatchIds = function(k) {
      if (k != null) {
        return this.getMatches(k).map(get('id'));
      } else {
        return this.allMatchIds();
      }
    };

    CategoryResults.prototype.goodMatchIds = function() {
      return this.getMatchIds('MATCH');
    };

    CategoryResults.prototype.allMatchIds = function() {
      var combineIds;
      combineIds = fold((function(_this) {
        return function(res, issueSet) {
          return res.concat(_this.getMatchIds(issueSet));
        };
      })(this));
      return combineIds(this.goodMatchIds(), ['DUPLICATE', 'WILDCARD', 'TYPE_CONVERTED', 'OTHER']);
    };

    return CategoryResults;

  })();

  IdResults = (function() {
    var flatten, getReasons, isGood, unique;

    unique = uniqBy(id);

    flatten = concatMap(id);

    getReasons = function(match) {
      var k, vals;
      return flatten((function() {
        var _ref, _results;
        _ref = match.identifiers;
        _results = [];
        for (k in _ref) {
          vals = _ref[k];
          _results.push(vals);
        }
        return _results;
      })());
    };

    isGood = function(match, k) {
      return (k == null) || __indexOf.call(getReasons(match), k) >= 0;
    };

    function IdResults(results) {
      var k, v;
      for (k in results) {
        if (!__hasProp.call(results, k)) continue;
        v = results[k];
        this[k] = v;
      }
    }

    IdResults.prototype.getStats = function(type) {
      switch (type) {
        case 'objects':
          return this.getObjectStats();
        case 'identifiers':
          return this.getIdentifierStats();
        default:
          return {
            objects: this.getObjectStats(),
            identifiers: this.getIdentifierStats()
          };
      }
    };

    IdResults.prototype.getIdentifierStats = function() {
      var all, allIdents, issues, matchIdents, matches, toIdents;
      toIdents = function(ms) {
        var ident, match;
        return unique(flatten((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = ms.length; _i < _len; _i++) {
            match = ms[_i];
            _results.push((function() {
              var _results1;
              _results1 = [];
              for (ident in match != null ? match.identifiers : void 0) {
                _results1.push(ident);
              }
              return _results1;
            })());
          }
          return _results;
        })()));
      };
      matchIdents = toIdents(this.getMatches('MATCH'));
      allIdents = toIdents(this.getMatches());
      matches = matchIdents.length;
      all = allIdents.length;
      issues = (difference(allIdents, matchIdents)).length;
      return {
        matches: matches,
        all: all,
        issues: issues
      };
    };

    IdResults.prototype.getObjectStats = function() {
      var all, issues, match, matches;
      matches = this.goodMatchIds().length;
      all = this.allMatchIds().length;
      issues = ((function() {
        var _results;
        _results = [];
        for (id in this) {
          if (!__hasProp.call(this, id)) continue;
          match = this[id];
          if (__indexOf.call(getReasons(match), 'MATCH') < 0) {
            _results.push(id);
          }
        }
        return _results;
      }).call(this)).length;
      return {
        matches: matches,
        all: all,
        issues: issues
      };
    };

    IdResults.prototype.getMatches = function(k) {
      var match, _results;
      _results = [];
      for (id in this) {
        if (!__hasProp.call(this, id)) continue;
        match = this[id];
        if (isGood(match, k)) {
          _results.push(match);
        }
      }
      return _results;
    };

    IdResults.prototype.getMatchIds = function(k) {
      var match, _results;
      _results = [];
      for (id in this) {
        if (!__hasProp.call(this, id)) continue;
        match = this[id];
        if (isGood(match, k)) {
          _results.push(id);
        }
      }
      return _results;
    };

    IdResults.prototype.goodMatchIds = function() {
      return this.getMatchIds('MATCH');
    };

    IdResults.prototype.allMatchIds = function() {
      return this.getMatchIds();
    };

    return IdResults;

  })();

  IDResolutionJob = (function() {
    function IDResolutionJob(uid, service) {
      this.uid = uid;
      this.service = service;
      this.del = __bind(this.del, this);
      this.fetchResults = __bind(this.fetchResults, this);
      this.fetchErrorMessage = __bind(this.fetchErrorMessage, this);
      this.fetchStatus = __bind(this.fetchStatus, this);
    }

    IDResolutionJob.prototype.fetchStatus = function(cb) {
      return withCB(cb, this.service.get("ids/" + this.uid + "/status").then(get('status')));
    };

    IDResolutionJob.prototype.fetchErrorMessage = function(cb) {
      return withCB(cb, this.service.get("ids/" + this.uid + "/status").then(get('message')));
    };

    IDResolutionJob.prototype.fetchResults = function(cb) {
      var gettingRes, gettingVer;
      gettingRes = this.service.get("ids/" + this.uid + "/result").then(get('results'));
      gettingVer = this.service.fetchVersion();
      return gettingVer.then(function(v) {
        return gettingRes.then(function(results) {
          if (v >= 16) {
            return new CategoryResults(results);
          } else {
            return new IdResults(results);
          }
        });
      });
    };

    IDResolutionJob.prototype.del = function(cb) {
      return withCB(cb, this.service.makeRequest('DELETE', "ids/" + this.uid));
    };

    IDResolutionJob.prototype.decay = 50;

    IDResolutionJob.prototype.poll = function(onSuccess, onError, onProgress) {
      var backOff, notify, promise, reject, resolve, resp, _ref;
      _ref = defer(), promise = _ref.promise, resolve = _ref.resolve, reject = _ref.reject;
      promise.then(onSuccess, onError);
      notify = onProgress != null ? onProgress : (function() {});
      resp = this.fetchStatus();
      resp.then(null, reject);
      backOff = this.decay;
      this.decay = Math.min(ONE_MINUTE, backOff * 1.25);
      resp.then((function(_this) {
        return function(status) {
          notify(status);
          switch (status) {
            case 'SUCCESS':
              return _this.fetchResults().then(resolve, reject);
            case 'ERROR':
              return _this.fetchErrorMessage().then(reject, reject);
            default:
              return setTimeout((function() {
                return _this.poll(resolve, reject, notify);
              }), backOff);
          }
        };
      })(this));
      return promise;
    };

    return IDResolutionJob;

  })();

  IDResolutionJob.prototype.wait = IDResolutionJob.prototype.poll;

  IDResolutionJob.create = function(service) {
    return function(uid) {
      return new IDResolutionJob(uid, service);
    };
  };

  intermine.IDResolutionJob = IDResolutionJob;

  intermine.CategoryResults = CategoryResults;

  intermine.IdResults = IdResults;

}).call(this);

},{"./util":15}],5:[function(_dereq_,module,exports){
(function() {
  var INVITES, List, REQUIRES_VERSION, SHARES, TAGS_PATH, dejoin, get, getFolderName, intermine, invoke, isFolder, merge, set, utils, withCB,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  utils = _dereq_('./util');

  intermine = exports;

  merge = utils.merge, withCB = utils.withCB, get = utils.get, invoke = utils.invoke, REQUIRES_VERSION = utils.REQUIRES_VERSION, set = utils.set, dejoin = utils.dejoin;

  TAGS_PATH = "list/tags";

  SHARES = "lists/shares";

  INVITES = 'lists/invitations';

  isFolder = function(t) {
    return t.substr(0, t.indexOf(':')) === '__folder__';
  };

  getFolderName = function(t) {
    return t.substr(t.indexOf(':') + 1);
  };

  List = (function() {
    var getTags;

    function List(properties, service) {
      var k, v;
      this.service = service;
      this._updateTags = __bind(this._updateTags, this);
      this.hasTag = __bind(this.hasTag, this);
      for (k in properties) {
        if (!__hasProp.call(properties, k)) continue;
        v = properties[k];
        this[k] = v;
      }
      this.dateCreated = (this.dateCreated != null) ? new Date(this.dateCreated) : null;
      this.folders = this.tags.filter(isFolder).map(getFolderName);
    }

    List.prototype.hasTag = function(t) {
      return __indexOf.call(this.tags, t) >= 0;
    };

    List.prototype.query = function(view) {
      if (view == null) {
        view = ['*'];
      }
      return this.service.query({
        select: view,
        from: this.type,
        where: [[this.type, 'IN', this.name]]
      });
    };

    List.prototype.del = function(cb) {
      return this.service.makeRequest('DELETE', 'lists', {
        name: this.name
      }, cb);
    };

    getTags = function(_arg) {
      var tags;
      tags = _arg.tags;
      return tags;
    };

    List.prototype._updateTags = function(err, tags) {
      if (err != null) {
        return;
      }
      this.tags = tags.slice();
      return this.folders = this.tags.filter(isFolder).map(getFolderName);
    };

    List.prototype.fetchTags = function(cb) {
      return withCB(this._updateTags, cb, this.service.makeRequest('GET', 'list/tags', {
        name: this.name
      }).then(getTags));
    };

    List.prototype.addTags = function(tags, cb) {
      var req;
      req = {
        name: this.name,
        tags: tags
      };
      return withCB(this._updateTags, cb, this.service.makeRequest('POST', 'list/tags', req).then(getTags));
    };

    List.prototype.removeTags = function(tags, cb) {
      var req;
      req = {
        name: this.name,
        tags: tags
      };
      return withCB(this._updateTags, cb, this.service.makeRequest('DELETE', 'list/tags', req).then(getTags));
    };

    List.prototype.contents = function(cb) {
      return withCB(cb, this.query().then(dejoin).then(invoke('records')));
    };

    List.prototype.rename = function(newName, cb) {
      var promise;
      promise = this.service.post('lists/rename', {
        oldname: this.name,
        newname: newName
      }).then(get('listName')).then((function(_this) {
        return function(n) {
          return _this.name = n;
        };
      })(this)).then(this.service.fetchList);
      return withCB(cb, promise);
    };

    List.prototype.copy = function(opts, cb) {
      var baseName, name, query, tags, _ref, _ref1, _ref2;
      if (opts == null) {
        opts = {};
      }
      if (cb == null) {
        cb = (function() {});
      }
      if (arguments.length === 1 && utils.isFunction(opts)) {
        _ref = [{}, opts], opts = _ref[0], cb = _ref[1];
      }
      if (typeof opts === 'string') {
        opts = {
          name: opts
        };
      }
      name = baseName = (_ref1 = opts.name) != null ? _ref1 : "" + this.name + "_copy";
      tags = this.tags.concat((_ref2 = opts.tags) != null ? _ref2 : []);
      query = this.query(['id']);
      return withCB(cb, this.service.fetchLists().then(invoke('map', get('name'))).then((function(_this) {
        return function(names) {
          var c;
          c = 1;
          while (__indexOf.call(names, name) >= 0) {
            name = "" + baseName + "-" + (c++);
          }
          return query.then(invoke('saveAsList', {
            name: name,
            tags: tags,
            description: _this.description
          }));
        };
      })(this)));
    };

    List.prototype.enrichment = function(opts, cb) {
      return this.service.enrichment(merge({
        list: this.name
      }, opts), cb);
    };

    List.prototype.shareWithUser = function(recipient, cb) {
      return withCB(cb, this.service.post(SHARES, {
        'list': this.name,
        'with': recipient
      }));
    };

    List.prototype.inviteUserToShare = function(recipient, notify, cb) {
      if (notify == null) {
        notify = true;
      }
      if (cb == null) {
        cb = (function() {});
      }
      return withCB(cb, this.service.post(INVITES, {
        list: this.name,
        to: recipient,
        notify: !!notify
      }));
    };

    return List;

  })();

  intermine.List = List;

}).call(this);

},{"./util":15}],6:[function(_dereq_,module,exports){
(function() {
  var JAVA_LANG_OBJ, Model, PathInfo, Table, error, find, flatten, intermine, omap, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Table = _dereq_('./table').Table;

  PathInfo = _dereq_('./path').PathInfo;

  _ref = _dereq_('./util'), flatten = _ref.flatten, find = _ref.find, error = _ref.error, omap = _ref.omap;

  intermine = exports;

  JAVA_LANG_OBJ = new Table({
    name: 'Object',
    tags: [],
    displayName: 'Object',
    attributes: {},
    references: {},
    collections: {}
  });

  Model = (function() {
    function Model(_arg) {
      var classes, liftToTable;
      this.name = _arg.name, classes = _arg.classes;
      this.findCommonType = __bind(this.findCommonType, this);
      this.findSharedAncestor = __bind(this.findSharedAncestor, this);
      this.getAncestorsOf = __bind(this.getAncestorsOf, this);
      this.getSubclassesOf = __bind(this.getSubclassesOf, this);
      this.getPathInfo = __bind(this.getPathInfo, this);
      liftToTable = omap((function(_this) {
        return function(k, v) {
          return [k, new Table(v, _this)];
        };
      })(this));
      this.classes = liftToTable(classes);
      this.classes['java.lang.Object'] = JAVA_LANG_OBJ;
    }

    Model.prototype.getPathInfo = function(path, subcls) {
      return PathInfo.parse(this, path, subcls);
    };

    Model.prototype.getSubclassesOf = function(cls) {
      var cd, clazz, ret, _, _ref1, _ref2;
      clazz = cls && cls.name ? cls : this.classes[cls];
      if (clazz == null) {
        throw new Error("" + cls + " is not a table");
      }
      ret = [clazz.name];
      _ref1 = this.classes;
      for (_ in _ref1) {
        cd = _ref1[_];
        if (_ref2 = clazz.name, __indexOf.call(cd.parents(), _ref2) >= 0) {
          ret = ret.concat(this.getSubclassesOf(cd));
        }
      }
      return ret;
    };

    Model.prototype.getAncestorsOf = function(cls) {
      var clazz, parents;
      clazz = cls && cls.name ? cls : this.classes[cls];
      if (clazz == null) {
        throw new Error("" + cls + " is not a table");
      }
      parents = clazz.parents();
      return parents.filter((function(_this) {
        return function(p) {
          return _this.classes[p];
        };
      })(this)).reduce(((function(_this) {
        return function(as, p) {
          return as.concat(_this.getAncestorsOf(p));
        };
      })(this)), parents);
    };

    Model.prototype.findSharedAncestor = function(classA, classB) {
      var a_ancestry, b_ancestry, firstCommon;
      if (classB === null || classA === null) {
        return null;
      }
      if (classA === classB) {
        return classA;
      }
      a_ancestry = this.getAncestorsOf(classA);
      if (__indexOf.call(a_ancestry, classB) >= 0) {
        return classB;
      }
      b_ancestry = this.getAncestorsOf(classB);
      if (__indexOf.call(b_ancestry, classA) >= 0) {
        return classA;
      }
      firstCommon = find(a_ancestry, function(a) {
        return __indexOf.call(b_ancestry, a) >= 0;
      });
      return firstCommon;
    };

    Model.prototype.findCommonType = function(xs) {
      if (xs == null) {
        xs = [];
      }
      return xs.reduce(this.findSharedAncestor);
    };

    return Model;

  })();

  Model.prototype.makePath = Model.prototype.getPathInfo;

  Model.prototype.findCommonTypeOfMultipleClasses = Model.prototype.findCommonType;

  Model.load = function(data) {
    var e;
    try {
      return new Model(data);
    } catch (_error) {
      e = _error;
      throw new Error("Error loading model: " + e);
    }
  };

  Model.INTEGRAL_TYPES = ["int", "Integer", "long", "Long"];

  Model.FRACTIONAL_TYPES = ["double", "Double", "float", "Float"];

  Model.NUMERIC_TYPES = Model.INTEGRAL_TYPES.concat(Model.FRACTIONAL_TYPES);

  Model.BOOLEAN_TYPES = ["boolean", "Boolean"];

  intermine.Model = Model;

}).call(this);

},{"./path":7,"./table":13,"./util":15}],7:[function(_dereq_,module,exports){
(function() {
  var NAMES, PARSED, PathInfo, any, concatMap, copy, error, get, intermine, makeKey, set, success, utils, withCB,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  intermine = exports;

  utils = _dereq_('./util');

  withCB = utils.withCB, concatMap = utils.concatMap, get = utils.get, any = utils.any, set = utils.set, copy = utils.copy, success = utils.success, error = utils.error;

  NAMES = {};

  PARSED = {};

  makeKey = function(model, path, subclasses) {
    var k, v, _ref;
    return "" + (model != null ? model.name : void 0) + "|" + (model != null ? (_ref = model.service) != null ? _ref.root : void 0 : void 0) + "|" + path + ":" + ((function() {
      var _results;
      _results = [];
      for (k in subclasses) {
        v = subclasses[k];
        _results.push("" + k + "=" + v);
      }
      return _results;
    })());
  };

  PathInfo = (function() {
    function PathInfo(_arg) {
      var _i, _ref;
      this.root = _arg.root, this.model = _arg.model, this.descriptors = _arg.descriptors, this.subclasses = _arg.subclasses, this.displayName = _arg.displayName, this.ident = _arg.ident;
      this.allDescriptors = __bind(this.allDescriptors, this);
      this.getChildNodes = __bind(this.getChildNodes, this);
      this.getDisplayName = __bind(this.getDisplayName, this);
      this.isa = __bind(this.isa, this);
      this.append = __bind(this.append, this);
      this.getParent = __bind(this.getParent, this);
      this.getEndClass = __bind(this.getEndClass, this);
      this.containsCollection = __bind(this.containsCollection, this);
      this.isCollection = __bind(this.isCollection, this);
      this.isReverseReference = __bind(this.isReverseReference, this);
      this.isReference = __bind(this.isReference, this);
      this.isClass = __bind(this.isClass, this);
      this.isAttribute = __bind(this.isAttribute, this);
      this.isRoot = __bind(this.isRoot, this);
      _ref = this.descriptors, this.mid = 2 <= _ref.length ? __slice.call(_ref, 0, _i = _ref.length - 1) : (_i = 0, []), this.end = _ref[_i++];
      if (this.ident == null) {
        this.ident = makeKey(this.model, this, this.subclasses);
      }
    }

    PathInfo.prototype.isRoot = function() {
      return this.descriptors.length === 0;
    };

    PathInfo.prototype.isAttribute = function() {
      return (this.end != null) && !this.isReference();
    };

    PathInfo.prototype.isClass = function() {
      return this.isRoot() || this.isReference();
    };

    PathInfo.prototype.isReference = function() {
      var _ref;
      return ((_ref = this.end) != null ? _ref.referencedType : void 0) != null;
    };

    PathInfo.prototype.isReverseReference = function() {
      var gp, p, referencedType, reverseReference, _ref;
      if (this.isReference() && (this.mid.length > 0)) {
        _ref = this.end, reverseReference = _ref.reverseReference, referencedType = _ref.referencedType;
        p = this.getParent();
        gp = p.getParent();
        return (referencedType != null) && (gp.isa(referencedType)) && (p.end.name === reverseReference);
      }
      return false;
    };

    PathInfo.prototype.isCollection = function() {
      var _ref, _ref1;
      return (_ref = (_ref1 = this.end) != null ? _ref1.isCollection : void 0) != null ? _ref : false;
    };

    PathInfo.prototype.containsCollection = function() {
      return any(this.descriptors, function(x) {
        return x.isCollection;
      });
    };

    PathInfo.prototype.getEndClass = function() {
      var _ref;
      return this.model.classes[this.subclasses[this.toString()] || ((_ref = this.end) != null ? _ref.referencedType : void 0)] || this.root;
    };

    PathInfo.prototype.getParent = function() {
      var data;
      if (this.isRoot()) {
        throw new Error("Root paths do not have parents");
      }
      data = {
        root: this.root,
        model: this.model,
        descriptors: this.mid.slice(),
        subclasses: this.subclasses
      };
      return new PathInfo(data);
    };

    PathInfo.prototype.append = function(attr) {
      var data, fld;
      if (this.isAttribute()) {
        throw new Error("" + this + " is an attribute.");
      }
      fld = typeof attr === 'string' ? this.getType().fields[attr] : attr;
      if (fld == null) {
        throw new Error("" + attr + " is not a field of " + (this.getType()));
      }
      data = {
        root: this.root,
        model: this.model,
        descriptors: this.descriptors.concat([fld]),
        subclasses: this.subclasses
      };
      return new PathInfo(data);
    };

    PathInfo.prototype.isa = function(clazz) {
      var name, type;
      if (clazz == null) {
        return false;
      }
      if (this.isAttribute()) {
        return this.getType() === clazz;
      } else {
        name = clazz.name ? clazz.name : '' + clazz;
        type = this.getType();
        return (name === type.name) || (__indexOf.call(this.model.getAncestorsOf(type), name) >= 0);
      }
    };

    PathInfo.prototype.getDisplayName = function(cb) {
      var cached, custom, params, path;
      if (custom = this.displayName) {
        return success(custom);
      }
      if (this.namePromise == null) {
        this.namePromise = (cached = NAMES[this.ident]) ? success(cached) : this.isRoot() && this.root.displayName ? success(this.root.displayName) : this.model.service == null ? error("No service") : (path = 'model' + (concatMap(function(d) {
          return '/' + d.name;
        }))(this.allDescriptors()), params = (set({
          format: 'json'
        }))(copy(this.subclasses)), this.model.service.get(path, params).then(get('display')).then((function(_this) {
          return function(n) {
            var _name;
            return NAMES[_name = _this.ident] != null ? NAMES[_name] : NAMES[_name] = n;
          };
        })(this)));
      }
      return withCB(cb, this.namePromise);
    };

    PathInfo.prototype.getChildNodes = function() {
      var fld, name, _ref, _ref1, _results;
      _ref1 = ((_ref = this.getEndClass()) != null ? _ref.fields : void 0) || {};
      _results = [];
      for (name in _ref1) {
        fld = _ref1[name];
        _results.push(this.append(fld));
      }
      return _results;
    };

    PathInfo.prototype.allDescriptors = function() {
      return [this.root].concat(this.descriptors);
    };

    PathInfo.prototype.toString = function() {
      return this.allDescriptors().map(get('name')).join('.');
    };

    PathInfo.prototype.equals = function(other) {
      return this === other || (this.ident && (other != null ? other.ident : void 0) === this.ident);
    };

    PathInfo.prototype.getType = function() {
      var _ref, _ref1;
      return ((_ref = this.end) != null ? (_ref1 = _ref.type) != null ? _ref1.replace(/java\.lang\./, '') : void 0 : void 0) || this.getEndClass();
    };

    return PathInfo;

  })();

  PathInfo.prototype.toPathString = PathInfo.prototype.toString;

  PathInfo.parse = function(model, path, subclasses) {
    var cached, cd, descriptors, fld, ident, keyPath, part, parts, root;
    if (subclasses == null) {
      subclasses = {};
    }
    ident = makeKey(model, path, subclasses);
    if (cached = PARSED[ident]) {
      return cached;
    }
    parts = (path + '').split('.');
    root = cd = model.classes[parts.shift()];
    keyPath = root.name;
    descriptors = (function() {
      var _i, _len, _ref, _results;
      _results = [];
      for (_i = 0, _len = parts.length; _i < _len; _i++) {
        part = parts[_i];
        fld = (cd != null ? cd.fields[part] : void 0) || ((_ref = (cd = model.classes[subclasses[keyPath]])) != null ? _ref.fields[part] : void 0);
        if (!fld) {
          throw new Error("Could not find " + part + " in " + cd + " when parsing " + path);
        }
        keyPath += "." + part;
        cd = model.classes[fld.type || fld.referencedType];
        _results.push(fld);
      }
      return _results;
    })();
    return PARSED[ident] = new PathInfo({
      root: root,
      model: model,
      descriptors: descriptors,
      subclasses: subclasses,
      ident: ident
    });
  };

  PathInfo.flushCache = function() {
    PARSED = {};
    return NAMES = {};
  };

  intermine.PathInfo = PathInfo;

}).call(this);

},{"./util":15}],8:[function(_dereq_,module,exports){
(function() {
  var Promise;

  Promise = _dereq_('es6-promise').Promise;

  module.exports = Promise;

}).call(this);

},{"es6-promise":22}],9:[function(_dereq_,module,exports){
(function() {
  var BASIC_ATTRS, CODES, Events, LIST_PIPE, Query, REQUIRES_VERSION, RESULTS_METHODS, SIMPLE_ATTRS, bioUriArgs, conAttrs, conStr, conToJSON, conValStr, concatMap, copyCon, decapitate, didntRemove, f, filter, fold, get, get_canonical_op, headLess, id, idConStr, intermine, interpretConArray, interpretConstraint, invoke, merge, mth, multiConStr, noUndefVals, noValueConStr, partition, removeIrrelevantSortOrders, simpleConStr, stringToSortOrder, stringifySortOrder, toQueryString, typeConStr, union, utils, withCB, _fn, _get_data_fetcher, _i, _j, _len, _len1, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty;

  Events = _dereq_('backbone-events-standalone');

  intermine = exports;

  intermine.xml = _dereq_('./xml');

  utils = _dereq_('./util');

  REQUIRES_VERSION = utils.REQUIRES_VERSION, withCB = utils.withCB, merge = utils.merge, filter = utils.filter, partition = utils.partition, fold = utils.fold, concatMap = utils.concatMap, id = utils.id, get = utils.get, invoke = utils.invoke;

  toQueryString = utils.querystring;

  get_canonical_op = function(orig) {
    var canonical;
    canonical = (orig != null ? orig.toLowerCase : void 0) != null ? Query.OP_DICT[orig.toLowerCase()] : null;
    if (!canonical) {
      throw new Error("Illegal constraint operator: " + orig);
    }
    return canonical;
  };

  BASIC_ATTRS = ['path', 'op', 'code'];

  SIMPLE_ATTRS = BASIC_ATTRS.concat(['value', 'extraValue']);

  RESULTS_METHODS = ['rowByRow', 'eachRow', 'recordByRecord', 'eachRecord', 'records', 'rows', 'table', 'tableRows', 'values'];

  LIST_PIPE = function(service) {
    return utils.compose(service.fetchList, get('listName'));
  };

  CODES = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];

  decapitate = function(x) {
    if (x == null) {
      x = '';
    }
    return x.substr(x.indexOf('.'));
  };

  conValStr = function(v) {
    if (v != null) {
      return "<value>" + (utils.escape(v)) + "</value>";
    } else {
      return "<nullValue/>";
    }
  };

  conAttrs = function(c, names) {
    var k, v;
    return ((function() {
      var _results;
      _results = [];
      for (k in c) {
        v = c[k];
        if ((__indexOf.call(names, k) >= 0)) {
          _results.push("" + k + "=\"" + (utils.escape(v)) + "\" ");
        }
      }
      return _results;
    })()).join('');
  };

  noValueConStr = function(c) {
    return "<constraint " + (conAttrs(c, BASIC_ATTRS)) + "/>";
  };

  typeConStr = function(c) {
    return "<constraint " + (conAttrs(c, ['path', 'type'])) + "/>";
  };

  simpleConStr = function(c) {
    return "<constraint " + (conAttrs(c, SIMPLE_ATTRS)) + "/>";
  };

  multiConStr = function(c) {
    return "<constraint " + (conAttrs(c, BASIC_ATTRS)) + ">" + (concatMap(conValStr)(c.values)) + "</constraint>";
  };

  idConStr = function(c) {
    return "<constraint " + (conAttrs(c, BASIC_ATTRS)) + "ids=\"" + (c.ids.join(',')) + "\"/>";
  };

  conStr = function(c) {
    var _ref;
    if (c.values != null) {
      return multiConStr(c);
    } else if (c.ids != null) {
      return idConStr(c);
    } else if (c.op == null) {
      return typeConStr(c);
    } else if (_ref = c.op, __indexOf.call(Query.NULL_OPS, _ref) >= 0) {
      return noValueConStr(c);
    } else {
      return simpleConStr(c);
    }
  };

  headLess = function(path) {
    return path.replace(/^[^\.]+\./, '');
  };

  copyCon = function(con) {
    var code, editable, extraValue, ids, op, path, switchable, switched, type, value, values;
    path = con.path, type = con.type, op = con.op, value = con.value, values = con.values, extraValue = con.extraValue, ids = con.ids, code = con.code, editable = con.editable, switched = con.switched, switchable = con.switchable;
    ids = ids != null ? ids.slice() : void 0;
    values = values != null ? values.slice() : void 0;
    return noUndefVals({
      path: path,
      type: type,
      op: op,
      value: value,
      values: values,
      extraValue: extraValue,
      ids: ids,
      code: code,
      editable: editable,
      switched: switched,
      switchable: switchable
    });
  };

  conToJSON = function(con) {
    var copy;
    copy = copyCon(con);
    copy.path = headLess(copy.path);
    return copy;
  };

  noUndefVals = function(x) {
    var k, v;
    for (k in x) {
      v = x[k];
      if (v == null) {
        delete x[k];
      }
    }
    return x;
  };

  didntRemove = function(orig, reduced) {
    return "Did not remove a single constraint. original = " + orig + ", reduced = " + reduced;
  };

  interpretConstraint = function(path, con) {
    var constraint, k, keys, v, x, _ref, _ref1;
    constraint = {
      path: path
    };
    if (con === null) {
      constraint.op = 'IS NULL';
    } else if (utils.isArray(con)) {
      constraint.op = 'ONE OF';
      constraint.values = con;
    } else if ((_ref = typeof con) === 'string' || _ref === 'number' || _ref === 'boolean') {
      if (_ref1 = typeof con.toUpperCase === "function" ? con.toUpperCase() : void 0, __indexOf.call(Query.NULL_OPS, _ref1) >= 0) {
        constraint.op = con;
      } else {
        constraint.op = '=';
        constraint.value = con;
      }
    } else {
      keys = (function() {
        var _results;
        _results = [];
        for (k in con) {
          x = con[k];
          _results.push(k);
        }
        return _results;
      })();
      if (__indexOf.call(keys, 'isa') >= 0) {
        if (utils.isArray(con.isa)) {
          constraint.op = k;
          constraint.values = con.isa;
        } else {
          constraint.type = con.isa;
        }
      } else {
        if (__indexOf.call(keys, 'extraValue') >= 0) {
          constraint.extraValue = con.extraValue;
        }
        for (k in con) {
          v = con[k];
          if (!(k !== 'extraValue')) {
            continue;
          }
          constraint.op = k;
          if (utils.isArray(v)) {
            constraint.values = v;
          } else {
            constraint.value = v;
          }
        }
      }
    }
    return constraint;
  };

  interpretConArray = function(conArgs) {
    var a0, constraint, v, _ref;
    conArgs = conArgs.slice();
    constraint = {
      path: conArgs.shift()
    };
    if (conArgs.length === 1) {
      a0 = conArgs[0];
      if (_ref = typeof a0.toUpperCase === "function" ? a0.toUpperCase() : void 0, __indexOf.call(Query.NULL_OPS, _ref) >= 0) {
        constraint.op = a0;
      } else {
        constraint.type = a0;
      }
    } else if (conArgs.length >= 2) {
      constraint.op = conArgs[0];
      v = conArgs[1];
      if (utils.isArray(v)) {
        constraint.values = v;
      } else {
        constraint.value = v;
      }
      if (conArgs.length === 3) {
        constraint.extraValue = conArgs[2];
      }
    }
    return constraint;
  };

  stringifySortOrder = function(sortOrder) {
    var oe;
    return ((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = sortOrder.length; _i < _len; _i++) {
        oe = sortOrder[_i];
        _results.push("" + oe.path + " " + oe.direction);
      }
      return _results;
    })()).join(' ');
  };

  stringToSortOrder = function(str) {
    var i, parts, pathIndices, x, _i, _len, _results;
    if (str == null) {
      return [];
    }
    parts = str.split(/\s+/);
    pathIndices = (function() {
      var _i, _ref, _results;
      _results = [];
      for (x = _i = 0, _ref = parts.length / 2; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        _results.push(x * 2);
      }
      return _results;
    })();
    _results = [];
    for (_i = 0, _len = pathIndices.length; _i < _len; _i++) {
      i = pathIndices[_i];
      _results.push([parts[i], parts[i + 1]]);
    }
    return _results;
  };

  removeIrrelevantSortOrders = function() {
    var oe, oldOrder;
    oldOrder = this.sortOrder;
    this.sortOrder = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = oldOrder.length; _i < _len; _i++) {
        oe = oldOrder[_i];
        if (this.isRelevant(oe.path)) {
          _results.push(oe);
        }
      }
      return _results;
    }).call(this);
    if (oldOrder.length !== this.sortOrder.length) {
      return this.trigger('change:sortorder change:orderby', this.sortOrder.slice());
    }
  };

  Query = (function() {
    var addPI, cAttrs, kids, parseSummary, qAttrs, scFold, toAttrPairs, toPathAndType, xmlAttr;

    Query.JOIN_STYLES = ['INNER', 'OUTER'];

    Query.BIO_FORMATS = ['gff3', 'fasta', 'bed'];

    Query.NULL_OPS = ['IS NULL', 'IS NOT NULL'];

    Query.ATTRIBUTE_VALUE_OPS = ["=", "!=", ">", ">=", "<", "<=", "CONTAINS", "LIKE", "NOT LIKE"];

    Query.MULTIVALUE_OPS = ['ONE OF', 'NONE OF'];

    Query.RANGE_OPS = ['OVERLAPS', 'DOES NOT OVERLAP', 'OUTSIDE', 'WITHIN', 'CONTAINS', 'DOES NOT CONTAIN'];

    Query.TERNARY_OPS = ['LOOKUP'];

    Query.LOOP_OPS = ['=', '!='];

    Query.LIST_OPS = ['IN', 'NOT IN'];

    Query.OP_DICT = {
      '=': '=',
      '==': '==',
      'eq': '=',
      'eqq': '==',
      '!=': '!=',
      'ne': '!=',
      '>': '>',
      'gt': '>',
      '>=': '>=',
      'ge': '>=',
      '<': '<',
      'lt': '<',
      '<=': '<=',
      'le': '<=',
      'contains': 'CONTAINS',
      'CONTAINS': 'CONTAINS',
      'does not contain': 'DOES NOT CONTAIN',
      'DOES NOT CONTAIN': 'DOES NOT CONTAIN',
      'like': 'LIKE',
      'LIKE': 'LIKE',
      'not like': 'NOT LIKE',
      'NOT LIKE': 'NOT LIKE',
      'lookup': 'LOOKUP',
      'IS NULL': 'IS NULL',
      'is null': 'IS NULL',
      'IS NOT NULL': 'IS NOT NULL',
      'is not null': 'IS NOT NULL',
      'ONE OF': 'ONE OF',
      'one of': 'ONE OF',
      'NONE OF': 'NONE OF',
      'none of': 'NONE OF',
      'in': 'IN',
      'not in': 'NOT IN',
      'IN': 'IN',
      'NOT IN': 'NOT IN',
      'WITHIN': 'WITHIN',
      'within': 'WITHIN',
      'OVERLAPS': 'OVERLAPS',
      'overlaps': 'OVERLAPS',
      'DOES NOT OVERLAP': 'DOES NOT OVERLAP',
      'does not overlap': 'DOES NOT OVERLAP',
      'OUTSIDE': 'OUTSIDE',
      'outside': 'OUTSIDE',
      'ISA': 'ISA',
      'isa': 'ISA'
    };

    qAttrs = ['name', 'view', 'sortOrder', 'constraintLogic', 'title', 'description', 'comment'];

    cAttrs = ['path', 'type', 'op', 'code', 'value', 'ids'];

    toAttrPairs = function(el, attrs) {
      var x, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = attrs.length; _i < _len; _i++) {
        x = attrs[_i];
        if (el.hasAttribute(x)) {
          _results.push([x, el.getAttribute(x)]);
        }
      }
      return _results;
    };

    kids = function(el, name) {
      var kid, _i, _len, _ref, _results;
      _ref = el.getElementsByTagName(name);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        kid = _ref[_i];
        _results.push(kid);
      }
      return _results;
    };

    xmlAttr = function(name) {
      return function(el) {
        return el.getAttribute(name);
      };
    };

    Query.fromXML = function(xml) {
      var con, dom, j, pathOf, q, query, styleOf;
      dom = intermine.xml.parse(xml);
      query = kids(dom, 'query')[0] || kids(dom, 'template')[0];
      if (!query) {
        throw new Error("no query in xml");
      }
      pathOf = xmlAttr('path');
      styleOf = xmlAttr('style');
      q = utils.pairsToObj(toAttrPairs(query, qAttrs));
      q.view = q.view.split(/\s+/);
      q.sortOrder = stringToSortOrder(q.sortOrder);
      q.joins = (function() {
        var _i, _len, _ref, _results;
        _ref = kids(query, 'join');
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          j = _ref[_i];
          if (styleOf(j) === 'OUTER') {
            _results.push(pathOf(j));
          }
        }
        return _results;
      })();
      q.constraints = (function() {
        var _i, _len, _ref, _results;
        _ref = kids(query, 'constraint');
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          con = _ref[_i];
          _results.push((function(con) {
            var c, tn, v, values, x;
            c = utils.pairsToObj(toAttrPairs(con, cAttrs));
            if (c.ids != null) {
              c.ids = (function() {
                var _j, _len1, _ref1, _results1;
                _ref1 = c.ids.split(',');
                _results1 = [];
                for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                  x = _ref1[_j];
                  _results1.push(parseInt(x, 10));
                }
                return _results1;
              })();
            }
            values = kids(con, 'value');
            if (values.length) {
              c.values = (function() {
                var _j, _len1, _results1;
                _results1 = [];
                for (_j = 0, _len1 = values.length; _j < _len1; _j++) {
                  v = values[_j];
                  _results1.push(((function() {
                    var _k, _len2, _ref1, _results2;
                    _ref1 = v.childNodes;
                    _results2 = [];
                    for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
                      tn = _ref1[_k];
                      _results2.push(tn.data);
                    }
                    return _results2;
                  })()).join(''));
                }
                return _results1;
              })();
            }
            return c;
          })(con));
        }
        return _results;
      })();
      return q;
    };

    Query.prototype.constraints = [];

    Query.prototype.views = [];

    Query.prototype.joins = {};

    Query.prototype.constraintLogic = '';

    Query.prototype.sortOrder = '';

    Query.prototype.name = null;

    Query.prototype.title = null;

    Query.prototype.comment = null;

    Query.prototype.description = null;

    function Query(properties, service, _arg) {
      var model, prop, summaryFields, _i, _len, _ref, _ref1, _ref10, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
      _ref = _arg != null ? _arg : {}, model = _ref.model, summaryFields = _ref.summaryFields;
      this.addConstraint = __bind(this.addConstraint, this);
      this.expandStar = __bind(this.expandStar, this);
      this.adjustPath = __bind(this.adjustPath, this);
      this.select = __bind(this.select, this);
      if (properties == null) {
        properties = {};
      }
      this.constraints = [];
      this.views = [];
      this.joins = {};
      this.displayNames = utils.copy((_ref1 = (_ref2 = properties.displayNames) != null ? _ref2 : properties.aliases) != null ? _ref1 : {});
      _ref3 = ['name', 'title', 'comment', 'description', 'type'];
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        prop = _ref3[_i];
        if (properties[prop] != null) {
          this[prop] = properties[prop];
        }
      }
      this.service = service != null ? service : {};
      this.model = (_ref4 = model != null ? model : properties.model) != null ? _ref4 : {};
      this.summaryFields = (_ref5 = summaryFields != null ? summaryFields : properties.summaryFields) != null ? _ref5 : {};
      this.root = (_ref6 = properties.root) != null ? _ref6 : properties.from;
      this.maxRows = (_ref7 = (_ref8 = properties.size) != null ? _ref8 : properties.limit) != null ? _ref7 : properties.maxRows;
      this.start = (_ref9 = (_ref10 = properties.start) != null ? _ref10 : properties.offset) != null ? _ref9 : 0;
      this.select(properties.views || properties.view || properties.select || []);
      this.addConstraints(properties.constraints || properties.where || []);
      this.addJoins(properties.joins || properties.join || []);
      this.orderBy(properties.sortOrder || properties.orderBy || []);
      if (properties.constraintLogic != null) {
        this.constraintLogic = properties.constraintLogic;
      }
      this.on('change:views', removeIrrelevantSortOrders, this);
    }

    Query.prototype.removeFromSelect = function(unwanted) {
      var mapFn, so, uw, v;
      if (unwanted == null) {
        unwanted = [];
      }
      unwanted = utils.stringList(unwanted);
      mapFn = utils.compose(this.expandStar, this.adjustPath);
      unwanted = utils.flatten((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = unwanted.length; _i < _len; _i++) {
          uw = unwanted[_i];
          _results.push(mapFn(uw));
        }
        return _results;
      })());
      this.sortOrder = (function() {
        var _i, _len, _ref, _ref1, _results;
        _ref = this.sortOrder;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          so = _ref[_i];
          if (!(_ref1 = so.path, __indexOf.call(unwanted, _ref1) >= 0)) {
            _results.push(so);
          }
        }
        return _results;
      }).call(this);
      this.views = (function() {
        var _i, _len, _ref, _results;
        _ref = this.views;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          v = _ref[_i];
          if (!(__indexOf.call(unwanted, v) >= 0)) {
            _results.push(v);
          }
        }
        return _results;
      }).call(this);
      this.trigger('remove:view', unwanted);
      this.trigger('change:views', this.views);
      return this.trigger('change', this.views);
    };

    Query.prototype.removeConstraint = function(con, silent) {
      var c, iscon, orig, reduced;
      if (silent == null) {
        silent = false;
      }
      orig = this.constraints;
      iscon = typeof con === 'string' ? (function(c) {
        return c.code === con;
      }) : (function(c) {
        var _ref, _ref1;
        return (c.path === con.path) && (c.op === con.op) && (c.value === con.value) && (c.extraValue === con.extraValue) && (con.type === c.type) && (((_ref = c.values) != null ? _ref.join('%%') : void 0) === ((_ref1 = con.values) != null ? _ref1.join('%%') : void 0));
      });
      reduced = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = orig.length; _i < _len; _i++) {
          c = orig[_i];
          if (!iscon(c)) {
            _results.push(c);
          }
        }
        return _results;
      })();
      if (reduced.length !== orig.length - 1) {
        throw new Error(didntRemove(orig, reduced));
      }
      this.constraints = reduced;
      if (!silent) {
        this.trigger('change:constraints');
        this.trigger('change');
        return this.trigger('removed:constraint', utils.find(orig, iscon));
      }
    };

    Query.prototype.addToSelect = function(views, opts) {
      var dups, mapFn, p, toAdd, v, x, _ref, _ref1;
      if (views == null) {
        views = [];
      }
      if (opts == null) {
        opts = {};
      }
      views = utils.stringList(views);
      mapFn = utils.compose(this.expandStar, this.adjustPath);
      toAdd = utils.flatten((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = views.length; _i < _len; _i++) {
          v = views[_i];
          _results.push(mapFn(v));
        }
        return _results;
      })());
      dups = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = toAdd.length; _i < _len; _i++) {
          p = toAdd[_i];
          if (__indexOf.call(this.views, p) >= 0) {
            _results.push(p);
          }
        }
        return _results;
      }).call(this);
      if (dups.length) {
        throw new Error("" + dups + " already in the select list");
      }
      dups = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = toAdd.length; _i < _len; _i++) {
          p = toAdd[_i];
          if (((function() {
            var _j, _len1, _results1;
            _results1 = [];
            for (_j = 0, _len1 = toAdd.length; _j < _len1; _j++) {
              x = toAdd[_j];
              if (x === p) {
                _results1.push(x);
              }
            }
            return _results1;
          })()).length > 1) {
            _results.push(p);
          }
        }
        return _results;
      })();
      if (dups.length) {
        throw new Error("" + dups + " specified multiple times as arguments to addToSelect");
      }
      (_ref = this.views).push.apply(_ref, toAdd);
      if (opts.silent) {
        opts.events = ((_ref1 = opts.events) != null ? _ref1 : []).concat(['change', 'add:view', 'change:views']);
      } else {
        this.trigger('add:view change:views', toAdd);
        this.trigger('change');
      }
      return this;
    };

    Query.prototype.select = function(views, opts) {
      var e, oldViews;
      oldViews = this.views.slice();
      try {
        this.views = [];
        this.addToSelect(views, opts);
      } catch (_error) {
        e = _error;
        this.views = oldViews;
        utils.error(e);
      }
      return this;
    };

    Query.prototype.adjustPath = function(path) {
      path = path && path.name ? path.name : "" + path;
      if (this.root != null) {
        if (!path.match("^" + this.root)) {
          path = this.root + "." + path;
        }
      } else {
        this.root = path.split('.')[0];
      }
      return path;
    };

    Query.prototype.getPossiblePaths = function(depth, allowReverseReferences, predicate) {
      var getPaths, key, ret, test, _base;
      if (depth == null) {
        depth = 3;
      }
      if (allowReverseReferences == null) {
        allowReverseReferences = true;
      }
      if (predicate == null) {
        predicate = null;
      }
      test = typeof predicate === 'string' ? function(p) {
        return p[predicate]();
      } : predicate;
      getPaths = (function(_this) {
        return function(root, d) {
          var cd, field, name, others, path, subPaths;
          path = _this.getPathInfo(root);
          if ((!allowReverseReferences) && path.isReverseReference()) {
            return [];
          } else if (path.isAttribute()) {
            return [path];
          } else {
            cd = path.getType();
            subPaths = concatMap(function(ref) {
              return getPaths("" + root + "." + ref.name, d - 1);
            });
            others = cd && (d > 0) ? subPaths((function() {
              var _ref, _results;
              _ref = cd.fields;
              _results = [];
              for (name in _ref) {
                field = _ref[name];
                _results.push(field);
              }
              return _results;
            })()) : [];
            return [path].concat(others);
          }
        };
      })(this);
      key = "" + depth + "-" + allowReverseReferences;
      if (this._possiblePaths == null) {
        this._possiblePaths = {};
      }
      ret = ((_base = this._possiblePaths)[key] != null ? _base[key] : _base[key] = getPaths(this.root, depth)).slice();
      if (test != null) {
        return ret.filter(test);
      } else {
        return ret;
      }
    };

    Query.prototype.getPathInfo = function(path) {
      var adjusted, pi, _ref;
      adjusted = this.adjustPath(path);
      pi = (_ref = this.model) != null ? typeof _ref.getPathInfo === "function" ? _ref.getPathInfo(adjusted, this.getSubclasses()) : void 0 : void 0;
      if (pi && adjusted in this.displayNames) {
        pi.displayName = this.displayNames[adjusted];
      }
      return pi;
    };

    Query.prototype.makePath = Query.prototype.getPathInfo;

    toPathAndType = function(c) {
      return [c.path, c.type];
    };

    scFold = utils.compose(utils.pairsToObj, utils.map(toPathAndType), filter(get('type')));

    Query.prototype.getSubclasses = function() {
      return scFold(this.constraints);
    };

    Query.prototype.getType = function(path) {
      return this.getPathInfo(path).getType();
    };

    Query.prototype.getViewNodes = function() {
      var p, toParentNode;
      toParentNode = (function(_this) {
        return function(v) {
          return _this.getPathInfo(v).getParent();
        };
      })(this);
      return utils.uniqBy(String, (function() {
        var _i, _len, _ref, _results;
        _ref = this.views;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          p = _ref[_i];
          _results.push(toParentNode(p));
        }
        return _results;
      }).call(this));
    };

    Query.prototype.isInView = function(path) {
      var pi, pstr, _ref;
      pi = this.getPathInfo(path);
      if (!pi) {
        throw new Error("Invalid path: " + path);
      }
      if (pi.isAttribute()) {
        return _ref = pi.toString(), __indexOf.call(this.views, _ref) >= 0;
      } else {
        pstr = pi.toString();
        return utils.any(this.getViewNodes(), function(n) {
          return n.toString() === pstr;
        });
      }
    };

    Query.prototype.isConstrained = function(path, includeAttrs) {
      var pi, test;
      if (includeAttrs == null) {
        includeAttrs = false;
      }
      pi = this.getPathInfo(path);
      if (!pi) {
        throw new Error("Invalid path: " + path);
      }
      test = function(c) {
        return (c.op != null) && c.path === pi.toString();
      };
      if ((!pi.isAttribute()) && includeAttrs) {
        test = (function(_this) {
          return function(c) {
            return (c.op != null) && (c.path === pi.toString() || pi.equals(_this.getPathInfo(c.path).getParent()));
          };
        })(this);
      }
      return utils.any(this.constraints, test);
    };

    Query.prototype.canHaveMultipleValues = function(path) {
      return this.getPathInfo(path).containsCollection();
    };

    Query.prototype.getQueryNodes = function() {
      var c, constrainedNodes, pi, viewNodes;
      viewNodes = this.getViewNodes();
      constrainedNodes = (function() {
        var _i, _len, _ref, _results;
        _ref = this.constraints;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          c = _ref[_i];
          if (!(c.type == null)) {
            continue;
          }
          pi = this.getPathInfo(c.path);
          if (pi.isAttribute()) {
            _results.push(pi.getParent());
          } else {
            _results.push(pi);
          }
        }
        return _results;
      }).call(this);
      return utils.uniqBy(String, viewNodes.concat(constrainedNodes));
    };

    Query.prototype.isInQuery = function(p) {
      var c, pi, pstr, _i, _len, _ref;
      pi = this.getPathInfo(p);
      if (pi) {
        pstr = pi.toPathString();
        _ref = this.views.concat((function() {
          var _j, _len, _ref, _results;
          _ref = this.constraints;
          _results = [];
          for (_j = 0, _len = _ref.length; _j < _len; _j++) {
            c = _ref[_j];
            if (c.type == null) {
              _results.push(c.path);
            }
          }
          return _results;
        }).call(this));
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          p = _ref[_i];
          if (0 === p.indexOf(pstr)) {
            return true;
          }
        }
        return false;
      }
      return true;
    };

    Query.prototype.isRelevant = function(path) {
      var nodes, pi, sought;
      pi = this.getPathInfo(path);
      if (pi.isAttribute()) {
        pi = pi.getParent();
      }
      sought = pi.toString();
      nodes = this.getViewNodes();
      return utils.any(nodes, function(n) {
        return n.toPathString() === sought;
      });
    };

    Query.prototype.expandStar = function(path) {
      var attrViews, cd, expand, fn, n, name, pathStem, starViews;
      if (/\*$/.test(path)) {
        pathStem = path.substr(0, path.lastIndexOf('.'));
        expand = function(x) {
          return pathStem + x;
        };
        cd = this.getType(pathStem);
        if (/\.\*$/.test(path)) {
          if (cd && this.summaryFields[cd.name]) {
            fn = utils.compose(expand, decapitate);
            return (function() {
              var _i, _len, _ref, _results;
              _ref = this.summaryFields[cd.name];
              _results = [];
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                n = _ref[_i];
                if (!this.hasView(n)) {
                  _results.push(fn(n));
                }
              }
              return _results;
            }).call(this);
          }
        } else if (/\.\*\*$/.test(path)) {
          starViews = this.expandStar(pathStem + '.*');
          attrViews = (function() {
            var _results;
            _results = [];
            for (name in cd.attributes) {
              _results.push(expand("." + name));
            }
            return _results;
          })();
          return utils.uniqBy(id, starViews.concat(attrViews));
        }
      }
      return path;
    };

    Query.prototype.isOuterJoin = function(p) {
      return this.joins[this.adjustPath(p)] === 'OUTER';
    };

    Query.prototype.hasView = function(v) {
      var _ref;
      return this.views && (_ref = this.adjustPath(v), __indexOf.call(this.views, _ref) >= 0);
    };

    Query.prototype.count = function(cont) {
      if (this.service.count) {
        return this.service.count(this, cont);
      } else {
        throw new Error("This query has no service with count functionality attached.");
      }
    };

    Query.prototype.appendToList = function(target, cb) {
      var name, processor, req, toRun, updateTarget;
      if (target != null ? target.name : void 0) {
        name = target.name;
        updateTarget = function(err, list) {
          if (err == null) {
            return target.size = list.size;
          }
        };
      } else {
        name = String(target);
        updateTarget = null;
      }
      toRun = this.makeListQuery();
      req = {
        listName: name,
        query: toRun.toXML()
      };
      processor = LIST_PIPE(this.service);
      return withCB(updateTarget, cb, this.service.post('query/append/tolist', req).then(processor));
    };

    Query.prototype.selectPreservingImpliedConstraints = function(paths) {
      var n, toRun, _i, _len, _ref;
      if (paths == null) {
        paths = [];
      }
      toRun = this.clone();
      toRun.select(paths);
      _ref = this.getViewNodes();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        if (!this.isOuterJoined(n)) {
          if (!(toRun.isInView(n || toRun.isConstrained(n))) && (n.getEndClass().fields.id != null)) {
            toRun.addConstraint([n.append('id'), 'IS NOT NULL']);
          }
        }
      }
      return toRun;
    };

    Query.prototype.makeListQuery = function() {
      var paths, _ref;
      paths = this.views.slice();
      if (paths.length !== 1 || !((_ref = paths[0]) != null ? _ref.match(/\.id$/) : void 0)) {
        paths = ['id'];
      }
      return this.selectPreservingImpliedConstraints(paths);
    };

    Query.prototype.saveAsList = function(options, cb) {
      var req, toRun;
      toRun = this.makeListQuery();
      req = utils.copy(options);
      req.listName = req.listName || req.name;
      req.query = toRun.toXML();
      if (options.tags) {
        req.tags = options.tags.join(';');
      }
      return withCB(cb, this.service.post('query/tolist', req).then(LIST_PIPE(this.service)));
    };

    Query.prototype.summarise = function(path, limit, cont) {
      return this.filterSummary(path, '', limit, cont);
    };

    Query.prototype.summarize = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.summarise.apply(this, args);
    };

    parseSummary = function(data) {
      var isNumeric, r, stats, _i, _len, _ref, _ref1;
      isNumeric = ((_ref = data.results[0]) != null ? _ref.max : void 0) != null;
      _ref1 = data.results;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        r = _ref1[_i];
        r.count = parseInt(r.count, 10);
      }
      stats = {
        uniqueValues: data.uniqueValues,
        filteredCount: data.filteredCount
      };
      if (isNumeric) {
        stats = merge(stats, data.results[0]);
      }
      data.stats = stats;
      return data;
    };

    Query.prototype.filterSummary = function(path, term, limit, cont) {
      var req, toRun, _ref;
      if (cont == null) {
        cont = (function() {});
      }
      if (utils.isFunction(limit)) {
        _ref = [limit, null], cont = _ref[0], limit = _ref[1];
      }
      path = this.adjustPath(path);
      toRun = this.clone();
      if (__indexOf.call(toRun.views, path) < 0) {
        toRun.views.push(path);
      }
      req = {
        query: toRun.toXML(),
        summaryPath: path,
        format: 'jsonrows'
      };
      if (limit) {
        req.size = limit;
      }
      if (term) {
        req.filterTerm = term;
      }
      return withCB(cont, this.service.post('query/results', req).then(parseSummary));
    };

    Query.prototype.clone = function(cloneEvents) {
      var cloned, k, v, _ref;
      cloned = new Query(this, this.service);
      if (cloned._callbacks == null) {
        cloned._callbacks = {};
      }
      if (cloneEvents) {
        _ref = this._callbacks;
        for (k in _ref) {
          if (!__hasProp.call(_ref, k)) continue;
          v = _ref[k];
          cloned._callbacks[k] = v;
        }
        cloned.off('change:views', removeIrrelevantSortOrders, this);
      }
      return cloned;
    };

    Query.prototype.next = function() {
      var clone;
      clone = this.clone();
      if (this.maxRows) {
        clone.start = this.start + this.maxRows;
      }
      return clone;
    };

    Query.prototype.previous = function() {
      var clone;
      clone = this.clone();
      if (this.maxRows) {
        clone.start = this.start - this.maxRows;
      } else {
        clone.start = 0;
      }
      return clone;
    };

    Query.prototype.getSortDirection = function(sorted) {
      var a, so;
      a = this.adjustPath(sorted);
      if (!(this.isInQuery(a) || this.isRelevant(a))) {
        throw new Error("" + sorted + " is not in the query");
      }
      so = utils.find(this.sortOrder, function(_arg) {
        var path;
        path = _arg.path;
        return a === path;
      });
      return so != null ? so.direction : void 0;
    };

    Query.prototype.isOuterJoined = function(path) {
      var dir, jp, _ref;
      path = this.adjustPath(path);
      _ref = this.joins;
      for (jp in _ref) {
        dir = _ref[jp];
        if (dir === 'OUTER' && path.indexOf(jp) === 0) {
          return true;
        }
      }
      return false;
    };

    Query.prototype.getOuterJoin = function(path) {
      var joinPaths, k;
      path = this.adjustPath(path);
      joinPaths = ((function() {
        var _results;
        _results = [];
        for (k in this.joins) {
          _results.push(k);
        }
        return _results;
      }).call(this)).sort(function(a, b) {
        return b.length - a.length;
      });
      return utils.find(joinPaths, (function(_this) {
        return function(p) {
          return _this.joins[p] === 'OUTER' && path.indexOf(p) === 0;
        };
      })(this));
    };

    Query.prototype._parse_sort_order = function(input) {
      var direction, k, path, so, v, _ref;
      if (input == null) {
        throw new Error('No input');
      }
      if (typeof input === 'string') {
        so = {
          path: input,
          direction: 'ASC'
        };
      } else if (utils.isArray(input)) {
        path = input[0], direction = input[1];
        so = {
          path: path,
          direction: direction
        };
      } else if (input.path == null) {
        for (k in input) {
          v = input[k];
          _ref = [k, v], path = _ref[0], direction = _ref[1];
        }
        so = {
          path: path,
          direction: direction
        };
      } else {
        path = input.path, direction = input.direction;
        so = {
          path: path,
          direction: direction
        };
      }
      so.path = this.adjustPath(so.path);
      if (so.direction == null) {
        so.direction = 'ASC';
      }
      so.direction = so.direction.toUpperCase();
      return so;
    };

    Query.prototype.addOrSetSortOrder = function(so) {
      var currentDirection, oe;
      so = this._parse_sort_order(so);
      currentDirection = this.getSortDirection(so.path);
      if (currentDirection == null) {
        this.addSortOrder(so);
      } else if (currentDirection !== so.direction) {
        oe = utils.find(this.sortOrder, function(_arg) {
          var path;
          path = _arg.path;
          return path === so.path;
        });
        oe.direction = so.direction;
        this.trigger('change:sortorder', this.sortOrder);
        this.trigger('change');
      }
      return this;
    };

    Query.prototype.addSortOrder = function(so, _arg) {
      var silent;
      silent = (_arg != null ? _arg : {}).silent;
      this.sortOrder.push(this._parse_sort_order(so));
      if (!silent) {
        this.trigger('add:sortorder', so);
        this.trigger('change:sortorder', this.sortOrder);
        return this.trigger('change');
      }
    };

    Query.prototype.orderBy = function(oes, opts) {
      var copy, direction, oe, oldSO, path, _i, _len, _ref;
      if (opts == null) {
        opts = {};
      }
      oldSO = this.sortOrder.slice();
      this.sortOrder = [];
      for (_i = 0, _len = oes.length; _i < _len; _i++) {
        oe = oes[_i];
        this.addSortOrder(this._parse_sort_order(oe), {
          silent: true
        });
      }
      copy = (function() {
        var _j, _len1, _ref, _ref1, _results;
        _ref = this.sortOrder;
        _results = [];
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          _ref1 = _ref[_j], path = _ref1.path, direction = _ref1.direction;
          _results.push({
            path: path,
            direction: direction
          });
        }
        return _results;
      }).call(this);
      this.trigger('set:sortorder', copy);
      if ((stringifySortOrder(oldSO)) !== this.getSorting()) {
        if (opts.silent) {
          opts.events = ((_ref = opts.events) != null ? _ref : []).concat(['change', 'change:sortorder']);
        } else {
          this.trigger('change:sortorder', copy);
          this.trigger('change');
        }
      }
      return this;
    };

    Query.prototype.addJoins = function(joins) {
      var j, k, v, _i, _len, _results, _results1;
      if (utils.isArray(joins)) {
        _results = [];
        for (_i = 0, _len = joins.length; _i < _len; _i++) {
          j = joins[_i];
          _results.push(this.addJoin(j));
        }
        return _results;
      } else {
        _results1 = [];
        for (k in joins) {
          v = joins[k];
          _results1.push(this.addJoin({
            path: k,
            style: v
          }));
        }
        return _results1;
      }
    };

    Query.prototype.addJoin = function(join) {
      if (typeof join === 'string') {
        join = {
          path: join,
          style: 'OUTER'
        };
      }
      return this.setJoinStyle(join.path, join.style);
    };

    Query.prototype.setJoinStyle = function(path, style) {
      if (style == null) {
        style = 'OUTER';
      }
      path = this.adjustPath(path);
      style = style.toUpperCase();
      if (__indexOf.call(Query.JOIN_STYLES, style) < 0) {
        throw new Error("Invalid join style: " + style);
      }
      if (this.joins[path] !== style) {
        this.joins[path] = style;
        this.trigger('change:joins', {
          path: path,
          style: style
        });
        this.trigger('change');
      }
      return this;
    };

    Query.prototype.addConstraints = function(constraints, conj) {
      var c, con, oldLogic, path, _fn, _i, _len;
      if (conj == null) {
        conj = 'and';
      }
      this.__silent__ = true;
      oldLogic = this.constraintLogic;
      if (utils.isArray(constraints)) {
        for (_i = 0, _len = constraints.length; _i < _len; _i++) {
          c = constraints[_i];
          this.addConstraint(c, conj);
        }
      } else {
        _fn = (function(_this) {
          return function(path, con) {
            return _this.addConstraint(interpretConstraint(path, con), conj);
          };
        })(this);
        for (path in constraints) {
          con = constraints[path];
          _fn(path, con);
        }
      }
      this.__silent__ = false;
      this.trigger('add:constraint');
      this.trigger('change:constraints');
      if (oldLogic !== this.constraintLogic) {
        this.trigger('change:logic', this.constraintLogic);
      }
      return this.trigger('change');
    };

    Query.prototype.addConstraint = function(constraint, conj) {
      var i, logic, needsLogicClause, newConLen, newLogic, oldLogic, _ref;
      if (conj == null) {
        conj = 'and';
      }
      if (conj !== 'and' && conj !== 'or') {
        throw new Error('Unknown logical conjunction: ' + conj);
      }
      if (utils.isArray(constraint)) {
        constraint = interpretConArray(constraint);
      } else {
        constraint = copyCon(constraint);
      }
      if (constraint.switched === 'OFF') {
        return this;
      }
      constraint.path = this.adjustPath(constraint.path);
      if (constraint.type == null) {
        constraint.op = get_canonical_op(constraint.op);
      }
      this.constraints.push(constraint);
      needsLogicClause = (conj === 'or') || (((_ref = this.constraintLogic) != null ? _ref.length : void 0) > 0);
      newConLen = this.constraints.length;
      oldLogic = this.constraintLogic;
      if (needsLogicClause) {
        newLogic = newConLen === 2 ? "" + CODES[0] + " " + conj + " " + CODES[1] : (logic = this.constraintLogic, logic || (logic = ((function() {
          var _i, _ref1, _results;
          _results = [];
          for (i = _i = 0, _ref1 = newConLen - 2; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
            _results.push(CODES[i]);
          }
          return _results;
        })()).join(' and ')), "(" + logic + ") " + conj + " " + CODES[newConLen - 1]);
        this.constraintLogic = newLogic;
      }
      if (!this.__silent__) {
        this.trigger('add:constraint', constraint);
        this.trigger('change:constraints');
        if (oldLogic !== this.constraintLogic) {
          this.trigger('change:logic', this.constraintLogic);
        }
        this.trigger('change');
      }
      return this;
    };

    Query.prototype.getSorting = function() {
      return stringifySortOrder(this.sortOrder);
    };

    Query.prototype.getConstraintXML = function() {
      var c, toSerialise;
      toSerialise = (function() {
        var _i, _len, _ref, _results;
        _ref = this.constraints;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          c = _ref[_i];
          if ((c.type == null) || this.isInQuery(c.path)) {
            _results.push(c);
          }
        }
        return _results;
      }).call(this);
      if (toSerialise.length) {
        return concatMap(conStr)(concatMap(id)(partition(function(c) {
          return c.type != null;
        })(toSerialise)));
      } else {
        return '';
      }
    };

    Query.prototype.getJoinXML = function() {
      var p, s, strs;
      strs = (function() {
        var _ref, _results;
        _ref = this.joins;
        _results = [];
        for (p in _ref) {
          s = _ref[p];
          if (this.isInQuery(p) && s === 'OUTER') {
            _results.push("<join path=\"" + p + "\" style=\"OUTER\"/>");
          }
        }
        return _results;
      }).call(this);
      return strs.join('');
    };

    Query.prototype.toXML = function() {
      var attrs, headAttrs, k, v;
      attrs = {
        model: this.model.name,
        view: this.views.join(' '),
        sortOrder: this.getSorting(),
        constraintLogic: this.constraintLogic
      };
      if (this.name != null) {
        attrs.name = this.name;
      }
      headAttrs = ((function() {
        var _results;
        _results = [];
        for (k in attrs) {
          v = attrs[k];
          if (v) {
            _results.push(k + '="' + v + '"');
          }
        }
        return _results;
      })()).join(' ');
      return "<query " + headAttrs + " >" + (this.getJoinXML()) + (this.getConstraintXML()) + "</query>";
    };

    Query.prototype.toJSON = function() {
      var c, direction, path, style, v;
      return noUndefVals({
        name: this.name,
        title: this.title,
        comment: this.comment,
        description: this.description,
        constraintLogic: this.constraintLogic,
        from: this.root,
        select: (function() {
          var _i, _len, _ref, _results;
          _ref = this.views;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            v = _ref[_i];
            _results.push(headLess(v));
          }
          return _results;
        }).call(this),
        orderBy: (function() {
          var _i, _len, _ref, _ref1, _results;
          _ref = this.sortOrder;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            _ref1 = _ref[_i], path = _ref1.path, direction = _ref1.direction;
            _results.push({
              path: headLess(path),
              direction: direction
            });
          }
          return _results;
        }).call(this),
        joins: (function() {
          var _ref, _results;
          _ref = this.joins;
          _results = [];
          for (path in _ref) {
            style = _ref[path];
            if (style === 'OUTER') {
              _results.push(headLess(path));
            }
          }
          return _results;
        }).call(this),
        where: (function() {
          var _i, _len, _ref, _results;
          _ref = this.constraints;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            c = _ref[_i];
            _results.push(conToJSON(c));
          }
          return _results;
        }).call(this)
      });
    };

    Query.prototype.fetchCode = function(lang, cb) {
      var req;
      req = {
        query: this.toXML(),
        lang: lang
      };
      return withCB(cb, this.service.post('query/code', req).then(this.service.VERIFIER).then(get('code')));
    };

    Query.prototype.setName = function(name) {
      this.name = name;
    };

    Query.prototype.save = function(name, cb) {
      return REQUIRES_VERSION(this.service, 16, (function(_this) {
        return function() {
          var req, _ref;
          if (utils.isFunction(name)) {
            _ref = [null, name], name = _ref[0], cb = _ref[1];
          }
          if (name != null) {
            _this.setName(name);
          }
          req = {
            type: 'PUT',
            path: 'user/queries',
            data: _this.toXML(),
            contentType: 'application/xml',
            dataType: 'json'
          };
          return withCB(cb, _this.service.authorise(req)).then(function(authed) {
            return _this.service.doReq(authed);
          }).then(function(resp) {
            return resp.queries;
          });
        };
      })(this));
    };

    Query.prototype.store = function(name, cb) {
      return REQUIRES_VERSION(this.service, 16, (function(_this) {
        return function() {
          var getName, req, updateName, _ref;
          if (utils.isFunction(name)) {
            _ref = [null, name], name = _ref[0], cb = _ref[1];
          }
          if (name != null) {
            _this.setName(name);
          }
          updateName = function(err, name) {
            if (err == null) {
              return _this.setName(name);
            }
          };
          getName = utils.compose(get(_this.name), get('queries'));
          req = {
            type: 'POST',
            path: 'user/queries',
            data: _this.toXML(),
            contentType: 'application/xml',
            dataType: 'json'
          };
          return withCB(cb, updateName, _this.service.authorise(req)).then(function(authed) {
            return _this.service.doReq(authed);
          }).then(getName);
        };
      })(this));
    };

    Query.prototype.saveAsTemplate = function(name, cb) {
      return REQUIRES_VERSION(this.service, 16, (function(_this) {
        return function() {
          var req, _ref;
          if (utils.isFunction(name)) {
            _ref = [null, name], name = _ref[0], cb = _ref[1];
          }
          if (name != null) {
            _this.setName(name);
          }
          if (!_this.name) {
            throw new Error("Templates must have a name");
          }
          req = {
            type: 'POST',
            path: 'templates',
            data: "<template " + (conAttrs(_this, ['name', 'title', 'comment'])) + ">" + (_this.toXML()) + "</template>",
            contentType: 'application/xml',
            dataType: 'json'
          };
          return withCB(cb, _this.service.authorise(req).then(function(authed) {
            return _this.service.doReq(authed);
          }));
        };
      })(this));
    };

    Query.prototype.getCodeURI = function(lang) {
      var req, _ref;
      req = {
        query: this.toXML(),
        lang: lang,
        format: 'text'
      };
      if (((_ref = this.service) != null ? _ref.token : void 0) != null) {
        req.token = this.service.token;
      }
      return "" + this.service.root + "query/code?" + (toQueryString(req));
    };

    Query.prototype.getExportURI = function(format, options) {
      var req, _ref;
      if (format == null) {
        format = 'tab';
      }
      if (options == null) {
        options = {};
      }
      if (__indexOf.call(Query.BIO_FORMATS, format) >= 0) {
        return this["get" + (format.toUpperCase()) + "URI"](options);
      }
      req = merge(options, {
        query: this.toXML(),
        format: format
      });
      if (((_ref = this.service) != null ? _ref.token : void 0) != null) {
        req.token = this.service.token;
      }
      return "" + this.service.root + "query/results?" + (toQueryString(req));
    };

    Query.prototype.needsAuthentication = function() {
      return utils.any(this.constraints, function(c) {
        var _ref;
        return (_ref = c.op) === 'NOT IN' || _ref === 'IN';
      });
    };

    Query.prototype.fetchQID = function(cb) {
      return withCB(cb, this.service.post('queries', {
        query: this.toXML()
      }).then(get('id')));
    };

    addPI = function(p) {
      return p.append('primaryIdentifier').toString();
    };

    Query.prototype.__bio_req = function(types, n) {
      var isSuitable, toRun;
      toRun = this.makeListQuery();
      isSuitable = function(p) {
        return utils.any(types, function(t) {
          return p.isa(t);
        });
      };
      toRun.views = utils.take(n)((function() {
        var _i, _len, _ref, _results;
        _ref = this.getViewNodes();
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          n = _ref[_i];
          if (isSuitable(n)) {
            _results.push(addPI(n));
          }
        }
        return _results;
      }).call(this));
      return {
        query: toRun.toXML(),
        format: 'text'
      };
    };

    Query.prototype._fasta_req = function() {
      return this.__bio_req(["SequenceFeature", 'Protein'], 1);
    };

    Query.prototype._gff3_req = function() {
      return this.__bio_req(['SequenceFeature']);
    };

    Query.prototype._bed_req = Query.prototype._gff3_req;

    return Query;

  })();

  union = fold(function(xs, ys) {
    return xs.concat(ys);
  });

  Query.prototype.toString = Query.prototype.toXML;

  Query.ATTRIBUTE_OPS = union([Query.ATTRIBUTE_VALUE_OPS, Query.MULTIVALUE_OPS, Query.NULL_OPS]);

  Query.REFERENCE_OPS = union([Query.TERNARY_OPS, Query.LOOP_OPS, Query.LIST_OPS]);

  bioUriArgs = function(reqMeth, f) {
    return function(opts, cb) {
      var ensureAttr, obj, req, v, _ref;
      if (opts == null) {
        opts = {};
      }
      if (cb == null) {
        cb = function() {};
      }
      if (utils.isFunction(opts)) {
        _ref = [{}, opts], opts = _ref[0], cb = _ref[1];
      }
      ensureAttr = (function(_this) {
        return function(p) {
          var path;
          path = _this.getPathInfo(p);
          if (path.isAttribute()) {
            return path;
          } else {
            return path.append('id');
          }
        };
      })(this);
      if ((opts != null ? opts.view : void 0) != null) {
        opts.view = (function() {
          var _i, _len, _ref1, _results;
          _ref1 = opts.view;
          _results = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            v = _ref1[_i];
            _results.push(this.getPathInfo(v).toString());
          }
          return _results;
        }).call(this);
      }
      obj = opts["export"] != null ? this.selectPreservingImpliedConstraints(opts["export"].map(ensureAttr)) : this;
      req = merge(obj[reqMeth](), opts);
      return f.call(obj, req, cb);
    };
  };

  _ref = Query.BIO_FORMATS;
  _fn = function(f) {
    var getMeth, reqMeth, uriMeth;
    reqMeth = "_" + f + "_req";
    getMeth = "get" + (f.toUpperCase());
    uriMeth = getMeth + "URI";
    Query.prototype[getMeth] = bioUriArgs(reqMeth, function(req, cb) {
      return withCB(cb, this.service.post('query/results/' + f, req));
    });
    return Query.prototype[uriMeth] = bioUriArgs(reqMeth, function(req, cb) {
      if (this.service.token != null) {
        req.token = this.service.token;
      }
      return "" + this.service.root + "query/results/" + f + "?" + (toQueryString(req));
    });
  };
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    f = _ref[_i];
    _fn(f);
  }

  _get_data_fetcher = function(server_fn) {
    return function() {
      var cbs, page, x, _ref1;
      page = arguments[0], cbs = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (this.service[server_fn]) {
        if (page == null) {
          page = {};
        } else if (utils.isFunction(page)) {
          page = {};
          cbs = (function() {
            var _j, _len1, _results;
            _results = [];
            for (_j = 0, _len1 = arguments.length; _j < _len1; _j++) {
              x = arguments[_j];
              _results.push(x);
            }
            return _results;
          }).apply(this, arguments);
        }
        page = noUndefVals(merge({
          start: this.start,
          size: this.maxRows
        }, page));
        return (_ref1 = this.service)[server_fn].apply(_ref1, [this, page].concat(__slice.call(cbs)));
      } else {
        throw new Error("Service does not provide '" + server_fn + "'.");
      }
    };
  };

  for (_j = 0, _len1 = RESULTS_METHODS.length; _j < _len1; _j++) {
    mth = RESULTS_METHODS[_j];
    Query.prototype[mth] = _get_data_fetcher(mth);
  }

  Events.mixin(Query.prototype);

  Query.prototype.emit = Query.prototype.trigger;

  Query.prototype.bind = Query.prototype.on;

  intermine.Query = Query;

}).call(this);

},{"./util":15,"./xml":17,"backbone-events-standalone":21}],10:[function(_dereq_,module,exports){
(function() {
  var ALWAYS_AUTH, CLASSKEYS, CLASSKEY_PATH, DEFAULT_ERROR_HANDLER, DEFAULT_PROTOCOL, ENRICHMENT_PATH, HAS_PROTOCOL, HAS_SUFFIX, IDResolutionJob, ID_RESOLUTION_PATH, LISTS_PATH, LIST_OPERATION_PATHS, LIST_PIPE, List, MODELS, MODEL_PATH, Model, NEEDS_AUTH, NO_AUTH, PATH_VALUES_PATH, PREF_PATH, Promise, QUERY_RESULTS_PATH, QUICKSEARCH_PATH, Query, RELEASES, RELEASE_PATH, REQUIRES_VERSION, SUBTRACT_PATH, SUFFIX, SUMMARYFIELDS_PATH, SUMMARY_FIELDS, Service, TABLE_ROW_PATH, TEMPLATES_PATH, TO_NAMES, USER_TOKENS, User, VERSIONS, VERSION_PATH, WHOAMI_PATH, WIDGETS, WIDGETS_PATH, WITH_OBJ_PATH, dejoin, error, get, getListFinder, http, invoke, map, merge, p, set, success, to_query_string, utils, version, withCB, _get_or_fetch, _i, _j, _len, _len1, _ref, _ref1,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __slice = [].slice;

  Promise = _dereq_('./promise');

  Model = _dereq_('./model').Model;

  Query = _dereq_('./query').Query;

  List = _dereq_('./lists').List;

  User = _dereq_('./user').User;

  IDResolutionJob = _dereq_('./id-resolution-job').IDResolutionJob;

  version = _dereq_('./version');

  utils = _dereq_('./util');

  http = _dereq_('./http');

  to_query_string = utils.querystring;

  withCB = utils.withCB, map = utils.map, merge = utils.merge, get = utils.get, set = utils.set, invoke = utils.invoke, success = utils.success, error = utils.error, REQUIRES_VERSION = utils.REQUIRES_VERSION, dejoin = utils.dejoin;

  VERSIONS = {};

  CLASSKEYS = {};

  RELEASES = {};

  MODELS = {};

  SUMMARY_FIELDS = {};

  WIDGETS = {};

  DEFAULT_PROTOCOL = "http://";

  VERSION_PATH = "version";

  TEMPLATES_PATH = "templates";

  RELEASE_PATH = "version/release";

  CLASSKEY_PATH = "classkeys";

  LISTS_PATH = "lists";

  MODEL_PATH = "model";

  SUMMARYFIELDS_PATH = "summaryfields";

  QUERY_RESULTS_PATH = "query/results";

  QUICKSEARCH_PATH = "search";

  WIDGETS_PATH = "widgets";

  ENRICHMENT_PATH = "list/enrichment";

  WITH_OBJ_PATH = "listswithobject";

  LIST_OPERATION_PATHS = {
    union: "lists/union",
    intersection: "lists/intersect",
    difference: "lists/diff"
  };

  SUBTRACT_PATH = 'lists/subtract';

  WHOAMI_PATH = "user/whoami";

  TABLE_ROW_PATH = QUERY_RESULTS_PATH + '/tablerows';

  PREF_PATH = 'user/preferences';

  PATH_VALUES_PATH = 'path/values';

  USER_TOKENS = 'user/tokens';

  ID_RESOLUTION_PATH = 'ids';

  NO_AUTH = {};

  _ref = [VERSION_PATH, RELEASE_PATH, CLASSKEY_PATH, WIDGETS_PATH, MODEL_PATH, SUMMARYFIELDS_PATH, QUICKSEARCH_PATH, PATH_VALUES_PATH];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    p = _ref[_i];
    NO_AUTH[p] = true;
  }

  ALWAYS_AUTH = {};

  _ref1 = [WHOAMI_PATH, PREF_PATH, LIST_OPERATION_PATHS, SUBTRACT_PATH, WITH_OBJ_PATH, ENRICHMENT_PATH, TEMPLATES_PATH, USER_TOKENS];
  for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
    p = _ref1[_j];
    ALWAYS_AUTH[p] = true;
  }

  NEEDS_AUTH = function(path, q) {
    if (NO_AUTH[path]) {
      return false;
    } else if (ALWAYS_AUTH[path]) {
      return true;
    } else if (!(q != null ? q.needsAuthentication : void 0)) {
      return true;
    } else {
      return q.needsAuthentication();
    }
  };

  HAS_PROTOCOL = /^https?:\/\//i;

  HAS_SUFFIX = /service\/?$/i;

  SUFFIX = "/service/";

  DEFAULT_ERROR_HANDLER = function(e) {
    var f, _ref2;
    f = (_ref2 = console.error) != null ? _ref2 : console.log;
    return f(e);
  };

  _get_or_fetch = function(propName, store, path, key, cb) {
    var opts, promise, root, useCache, value;
    root = this.root, useCache = this.useCache;
    promise = this[propName] != null ? this[propName] : this[propName] = useCache && (value = store[root]) ? success(value) : (opts = {
      type: 'GET',
      dataType: 'json',
      data: {
        format: 'json'
      }
    }, this.doReq(merge(opts, {
      url: this.root + path
    })).then(function(x) {
      return store[root] = x[key];
    }));
    return withCB(cb, promise);
  };

  getListFinder = function(name) {
    return function(lists) {
      return new Promise(function(resolve, reject) {
        var list;
        if (list = utils.find(lists, function(l) {
          return l.name === name;
        })) {
          return resolve(list);
        } else {
          return reject("List \"" + name + "\" not found among: " + (lists.map(get('name'))));
        }
      });
    };
  };

  LIST_PIPE = function(service, prop) {
    if (prop == null) {
      prop = 'listName';
    }
    return utils.compose(service.fetchList, get(prop));
  };

  TO_NAMES = function(xs) {
    var x, _k, _len2, _ref2, _ref3, _results;
    if (xs == null) {
      xs = [];
    }
    _ref2 = (utils.isArray(xs) ? xs : [xs]);
    _results = [];
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      x = _ref2[_k];
      _results.push((_ref3 = x.name) != null ? _ref3 : x);
    }
    return _results;
  };

  Service = (function() {
    var FIVE_MIN, checkNameParam, getNewUserToken, loadQ, pathValuesReq, toMapByName;

    Service.prototype.doReq = http.doReq;

    function Service(_arg) {
      var noCache;
      this.root = _arg.root, this.token = _arg.token, this.errorHandler = _arg.errorHandler, this.DEBUG = _arg.DEBUG, this.help = _arg.help, noCache = _arg.noCache;
      this.connectAs = __bind(this.connectAs, this);
      this.createList = __bind(this.createList, this);
      this.resolveIds = __bind(this.resolveIds, this);
      this.templateQuery = __bind(this.templateQuery, this);
      this.savedQuery = __bind(this.savedQuery, this);
      this.query = __bind(this.query, this);
      this.fetchRelease = __bind(this.fetchRelease, this);
      this.fetchClassKeys = __bind(this.fetchClassKeys, this);
      this.fetchVersion = __bind(this.fetchVersion, this);
      this.fetchSummaryFields = __bind(this.fetchSummaryFields, this);
      this.fetchModel = __bind(this.fetchModel, this);
      this.fetchWidgetMap = __bind(this.fetchWidgetMap, this);
      this.fetchWidgets = __bind(this.fetchWidgets, this);
      this.complement = __bind(this.complement, this);
      this.fetchListsContaining = __bind(this.fetchListsContaining, this);
      this.fetchList = __bind(this.fetchList, this);
      this.findLists = __bind(this.findLists, this);
      this.fetchLists = __bind(this.fetchLists, this);
      this.fetchTemplates = __bind(this.fetchTemplates, this);
      this.tableRows = __bind(this.tableRows, this);
      this.values = __bind(this.values, this);
      this.rows = __bind(this.rows, this);
      this.records = __bind(this.records, this);
      this.table = __bind(this.table, this);
      this.pathValues = __bind(this.pathValues, this);
      this.fetchUser = __bind(this.fetchUser, this);
      this.whoami = __bind(this.whoami, this);
      this.findById = __bind(this.findById, this);
      this.count = __bind(this.count, this);
      this.enrichment = __bind(this.enrichment, this);
      if (this.root == null) {
        throw new Error("No service root provided. This is required");
      }
      if (!HAS_PROTOCOL.test(this.root)) {
        this.root = DEFAULT_PROTOCOL + this.root;
      }
      if (!HAS_SUFFIX.test(this.root)) {
        this.root = this.root + SUFFIX;
      }
      this.root = this.root.replace(/ice$/, "ice/");
      if (this.errorHandler == null) {
        this.errorHandler = DEFAULT_ERROR_HANDLER;
      }
      if (this.help == null) {
        this.help = 'no.help.available@dev.null';
      }
      this.useCache = !noCache;
      this.getFormat = (function(_this) {
        return function(intended) {
          if (intended == null) {
            intended = 'json';
          }
          return intended;
        };
      })(this);
    }

    Service.prototype.post = function(path, data) {
      return this.makeRequest('POST', path, data);
    };

    Service.prototype.get = function(path, data) {
      return this.makeRequest('GET', path, data);
    };

    Service.prototype.makeRequest = function(method, path, data, cb, indiv) {
      var dataType, errBack, opts, timeout, _ref2, _ref3, _ref4;
      if (method == null) {
        method = 'GET';
      }
      if (path == null) {
        path = '';
      }
      if (data == null) {
        data = {};
      }
      if (cb == null) {
        cb = (function() {});
      }
      if (indiv == null) {
        indiv = false;
      }
      if (utils.isArray(cb)) {
        _ref2 = cb, cb = _ref2[0], errBack = _ref2[1];
      }
      if (utils.isArray(data)) {
        data = utils.pairsToObj(data);
      }
      if (errBack == null) {
        errBack = this.errorHandler;
      }
      data = utils.copy(data);
      dataType = this.getFormat(data.format);
      if (!http.supports(method)) {
        _ref3 = [method, http.getMethod(method)], data.method = _ref3[0], method = _ref3[1];
      }
      opts = {
        data: data,
        dataType: dataType,
        success: cb,
        error: errBack,
        path: path,
        type: method
      };
      if (data.auth != null) {
        opts.auth = data.auth;
        delete opts.data.auth;
      }
      if (data.headers != null) {
        opts.headers = utils.copy(data.headers);
        delete opts.data.headers;
      }
      if (timeout = (_ref4 = data.timeout) != null ? _ref4 : this.timeout) {
        opts.timeout = timeout;
        delete data.timeout;
      }
      return this.authorise(opts).then((function(_this) {
        return function(authed) {
          return _this.doReq(authed, indiv);
        };
      })(this));
    };

    Service.prototype.authorise = function(req) {
      return this.fetchVersion().then((function(_this) {
        return function(version) {
          var opts, pathAdditions, _ref2;
          opts = utils.copy(req);
          if (opts.headers == null) {
            opts.headers = {};
          }
          opts.url = _this.root + opts.path;
          pathAdditions = [];
          if (version < 14) {
            if ('string' === typeof opts.data) {
              pathAdditions.push(['format', opts.dataType]);
            } else {
              opts.data.format = opts.dataType;
            }
          }
          if ((_this.token != null) && NEEDS_AUTH(req.path, (_ref2 = opts.data) != null ? _ref2.query : void 0)) {
            if (version >= 14) {
              opts.headers.Authorization = "Token " + _this.token;
            } else if ('string' === typeof opts.data) {
              pathAdditions.push(['token', _this.token]);
            } else {
              opts.data.token = _this.token;
            }
          }
          if (pathAdditions.length) {
            opts.url += '?' + to_query_string(pathAdditions);
          }
          return opts;
        };
      })(this));
    };

    Service.prototype.enrichment = function(opts, cb) {
      return REQUIRES_VERSION(this, 8, (function(_this) {
        return function() {
          var req;
          req = merge({
            maxp: 0.05,
            correction: 'Holm-Bonferroni'
          }, opts);
          return withCB(cb, _this.get(ENRICHMENT_PATH, req).then(get('results')));
        };
      })(this));
    };

    Service.prototype.search = function(options, cb) {
      if (options == null) {
        options = {};
      }
      if (cb == null) {
        cb = (function() {});
      }
      return REQUIRES_VERSION(this, 9, (function(_this) {
        return function() {
          var k, req, v, _ref2;
          if (utils.isFunction(options)) {
            _ref2 = [options, {}], cb = _ref2[0], options = _ref2[1];
          }
          if (typeof options === 'string') {
            req = {
              q: options
            };
          } else {
            req = {
              q: options.q
            };
            for (k in options) {
              if (!__hasProp.call(options, k)) continue;
              v = options[k];
              if (k !== 'q') {
                req["facet_" + k] = v;
              }
            }
          }
          return withCB(cb, _this.post(QUICKSEARCH_PATH, req));
        };
      })(this));
    };

    Service.prototype.makePath = function(path, subclasses, cb) {
      if (subclasses == null) {
        subclasses = {};
      }
      if (cb == null) {
        cb = (function() {});
      }
      return withCB(cb, this.fetchModel().then(function(m) {
        return m.makePath(path, subclasses);
      }));
    };

    Service.prototype.count = function(q, cb) {
      var promise, req;
      if (cb == null) {
        cb = (function() {});
      }
      promise = !q ? error("Not enough arguments") : q.toPathString != null ? (p = q.isClass() ? q.append('id') : q, this.pathValues(p, 'count')) : q.toXML != null ? (req = {
        query: q,
        format: 'jsoncount'
      }, this.post(QUERY_RESULTS_PATH, req).then(get('count'))) : typeof q === 'string' ? this.fetchModel().then((function(_this) {
        return function(m) {
          var e;
          try {
            return _this.count(m.makePath(q));
          } catch (_error) {
            e = _error;
            return _this.query({
              select: [q]
            }).then(_this.count);
          }
        };
      })(this)) : this.query(q).then(this.count);
      return withCB(cb, promise);
    };

    Service.prototype.findById = function(type, id, fields, cb) {
      var promise, _ref2;
      if (fields == null) {
        fields = ['**'];
      }
      if (cb == null) {
        cb = (function() {});
      }
      if (utils.isFunction(fields)) {
        _ref2 = [['**'], fields], fields = _ref2[0], cb = _ref2[1];
      }
      promise = this.query({
        from: type,
        select: fields,
        where: {
          id: id
        }
      }).then(dejoin).then(invoke('records')).then(get(0));
      return withCB(cb, promise);
    };

    Service.prototype.lookup = function(type, term, context, cb) {
      var promise, _ref2;
      if (utils.isFunction(context)) {
        _ref2 = [null, context], context = _ref2[0], cb = _ref2[1];
      }
      promise = this.query({
        from: type,
        select: ['**'],
        where: [[type, 'LOOKUP', term, context]]
      }).then(dejoin).then(invoke('records'));
      return withCB(cb, promise);
    };

    Service.prototype.find = function(type, term, context, cb) {
      var _ref2;
      if (utils.isFunction(context)) {
        _ref2 = [null, context], context = _ref2[0], cb = _ref2[1];
      }
      return withCB(cb, this.lookup(type, term, context).then(function(found) {
        if ((found == null) || found.length === 0) {
          return error("Nothing found");
        } else if (found.length > 1) {
          return error("Multiple items found: " + (found.slice(0, 3)) + "...");
        } else {
          return success(found[0]);
        }
      }));
    };

    Service.prototype.whoami = function(cb) {
      return REQUIRES_VERSION(this, 9, (function(_this) {
        return function() {
          return withCB(cb, _this.get(WHOAMI_PATH).then(get('user')).then(function(x) {
            return new User(_this, x);
          }));
        };
      })(this));
    };

    Service.prototype.fetchUser = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.whoami.apply(this, args);
    };

    pathValuesReq = function(format, path) {
      return {
        format: format,
        path: String(path),
        typeConstraints: JSON.stringify(path.subclasses)
      };
    };

    Service.prototype.pathValues = function(path, typeConstraints, cb) {
      if (typeConstraints == null) {
        typeConstraints = {};
      }
      return REQUIRES_VERSION(this, 6, (function(_this) {
        return function() {
          var e, format, promise, wanted, _ref2;
          if (typeof typeConstraints === 'string') {
            wanted = typeConstraints;
            typeConstraints = {};
          }
          if (utils.isFunction(typeConstraints)) {
            _ref2 = [cb, typeConstraints], typeConstraints = _ref2[0], cb = _ref2[1];
          }
          if (wanted !== 'count') {
            wanted = 'results';
          }
          format = wanted === 'count' ? 'jsoncount' : 'json';
          promise = (function() {
            var _ref3;
            try {
              return this.fetchModel().then(invoke('makePath', path, (_ref3 = path.subclasses) != null ? _ref3 : typeConstraints)).then(function(path) {
                return pathValuesReq(format, path);
              }).then((function(_this) {
                return function(req) {
                  return _this.post(PATH_VALUES_PATH, req);
                };
              })(this)).then(get(wanted));
            } catch (_error) {
              e = _error;
              return error(e);
            }
          }).call(_this);
          return withCB(cb, promise);
        };
      })(this));
    };

    Service.prototype.doPagedRequest = function(q, path, page, format, cb) {
      var req, _ref2;
      if (page == null) {
        page = {};
      }
      if (cb == null) {
        cb = (function() {});
      }
      if (q.toXML != null) {
        if (utils.isFunction(page)) {
          _ref2 = [page, {}], cb = _ref2[0], page = _ref2[1];
        }
        req = merge(page, {
          query: q,
          format: format
        });
        return withCB(cb, this.post(path, req).then(get('results')));
      } else {
        return this.query(q).then((function(_this) {
          return function(query) {
            return _this.doPagedRequest(query, path, page, format, cb);
          };
        })(this));
      }
    };

    Service.prototype.table = function(q, page, cb) {
      return this.doPagedRequest(q, QUERY_RESULTS_PATH, page, 'jsontable', cb);
    };

    Service.prototype.records = function(q, page, cb) {
      return this.doPagedRequest(q, QUERY_RESULTS_PATH, page, 'jsonobjects', cb);
    };

    Service.prototype.rows = function(q, page, cb) {
      return this.doPagedRequest(q, QUERY_RESULTS_PATH, page, 'json', cb);
    };

    Service.prototype.values = function(q, opts, cb) {
      var resp, _ref2;
      if (utils.isFunction(opts)) {
        _ref2 = [opts, cb], cb = _ref2[0], opts = _ref2[1];
      }
      resp = q == null ? error("No query term supplied") : (q.descriptors != null) || typeof q === 'string' ? this.pathValues(q, opts).then(map(get('value'))) : q.toXML != null ? q.views.length !== 1 ? error("Expected one column, got " + q.views.length) : this.rows(q, opts).then(map(get(0))) : this.query(q).then((function(_this) {
        return function(query) {
          return _this.values(query, opts);
        };
      })(this));
      return withCB(cb, resp);
    };

    Service.prototype.tableRows = function(q, page, cb) {
      return this.doPagedRequest(q, TABLE_ROW_PATH, page, 'json', cb);
    };

    Service.prototype.fetchTemplates = function(cb) {
      return withCB(cb, this.get(TEMPLATES_PATH).then(get('templates')));
    };

    Service.prototype.fetchLists = function(cb) {
      return this.findLists('', cb);
    };

    Service.prototype.findLists = function(name, cb) {
      if (name == null) {
        name = '';
      }
      if (cb == null) {
        cb = (function() {});
      }
      return this.fetchVersion().then((function(_this) {
        return function(v) {
          var fn;
          return withCB(cb, name && v < 13 ? error("Finding lists by name on the server requires version 13. This is only " + v) : (fn = function(ls) {
            var data, _k, _len2, _results;
            _results = [];
            for (_k = 0, _len2 = ls.length; _k < _len2; _k++) {
              data = ls[_k];
              _results.push(new List(data, _this));
            }
            return _results;
          }, _this.get(LISTS_PATH, {
            name: name
          }).then(get('lists')).then(fn)));
        };
      })(this));
    };

    Service.prototype.fetchList = function(name, cb) {
      return this.fetchVersion().then((function(_this) {
        return function(v) {
          return withCB(cb, v < 13 ? _this.findLists().then(getListFinder(name)) : _this.findLists(name).then(get(0)));
        };
      })(this));
    };

    Service.prototype.fetchListsContaining = function(opts, cb) {
      var fn;
      fn = (function(_this) {
        return function(xs) {
          var x, _k, _len2, _results;
          _results = [];
          for (_k = 0, _len2 = xs.length; _k < _len2; _k++) {
            x = xs[_k];
            _results.push(new List(x, _this));
          }
          return _results;
        };
      })(this);
      return withCB(cb, this.get(WITH_OBJ_PATH, opts).then(get('lists')).then(fn));
    };

    Service.prototype.combineLists = function(operation, options, cb) {
      var description, lists, name, req, tags, _ref2;
      _ref2 = merge({
        lists: [],
        tags: []
      }, options), name = _ref2.name, lists = _ref2.lists, tags = _ref2.tags, description = _ref2.description;
      req = {
        name: name,
        description: description
      };
      if (req.description == null) {
        req.description = "" + operation + " of " + (lists.join(', '));
      }
      req.tags = tags.join(';');
      req.lists = lists.join(';');
      return withCB(cb, this.get(LIST_OPERATION_PATHS[operation], req).then(LIST_PIPE(this)));
    };

    Service.prototype.merge = function() {
      return this.combineLists.apply(this, ['union'].concat(__slice.call(arguments)));
    };

    Service.prototype.intersect = function() {
      return this.combineLists.apply(this, ['intersection'].concat(__slice.call(arguments)));
    };

    Service.prototype.diff = function() {
      return this.combineLists.apply(this, ['difference'].concat(__slice.call(arguments)));
    };

    Service.prototype.complement = function(options, cb) {
      var defaultDesc, description, exclude, from, lists, name, references, req, tags;
      if (options == null) {
        options = {};
      }
      if (cb == null) {
        cb = function() {};
      }
      from = options.from, exclude = options.exclude, name = options.name, description = options.description, tags = options.tags;
      defaultDesc = function() {
        return "Relative complement of " + (lists.join(' and ')) + " in " + (references.join(' and '));
      };
      references = TO_NAMES(from);
      lists = TO_NAMES(exclude);
      if (name == null) {
        name = defaultDesc();
      }
      if (description == null) {
        description = defaultDesc();
      }
      if (tags == null) {
        tags = [];
      }
      req = {
        name: name,
        description: description,
        tags: tags,
        lists: lists,
        references: references
      };
      return withCB(cb, this.post(SUBTRACT_PATH, req).then(LIST_PIPE(this)));
    };

    Service.prototype.fetchWidgets = function(cb) {
      return REQUIRES_VERSION(this, 8, (function(_this) {
        return function() {
          return _get_or_fetch.call(_this, 'widgets', WIDGETS, WIDGETS_PATH, 'widgets', cb);
        };
      })(this));
    };

    toMapByName = utils.omap(function(w) {
      return [w.name, w];
    });

    Service.prototype.fetchWidgetMap = function(cb) {
      return REQUIRES_VERSION(this, 8, (function(_this) {
        return function() {
          return withCB(cb, (_this.__wmap__ != null ? _this.__wmap__ : _this.__wmap__ = _this.fetchWidgets().then(toMapByName)));
        };
      })(this));
    };

    Service.prototype.fetchModel = function(cb) {
      var ret;
      ret = _get_or_fetch.call(this, 'model', MODELS, MODEL_PATH, 'model').then(Model.load).then(set({
        service: this
      }));
      return withCB(cb, ret);
    };

    Service.prototype.fetchSummaryFields = function(cb) {
      return _get_or_fetch.call(this, 'summaryFields', SUMMARY_FIELDS, SUMMARYFIELDS_PATH, 'classes', cb);
    };

    Service.prototype.fetchVersion = function(cb) {
      return _get_or_fetch.call(this, 'version', VERSIONS, VERSION_PATH, 'version', cb);
    };

    Service.prototype.fetchClassKeys = function(cb) {
      return _get_or_fetch.call(this, 'classkeys', CLASSKEYS, CLASSKEY_PATH, 'classes', cb);
    };

    Service.prototype.fetchRelease = function(cb) {
      return _get_or_fetch.call(this, 'release', RELEASES, RELEASE_PATH, 'version', cb);
    };

    Service.prototype.query = function(options, cb) {
      var buildQuery;
      buildQuery = (function(_this) {
        return function(_arg) {
          var model, summaryFields;
          model = _arg[0], summaryFields = _arg[1];
          return new Query(options, _this, {
            model: model,
            summaryFields: summaryFields
          });
        };
      })(this);
      return withCB(cb, utils.parallel(this.fetchModel(), this.fetchSummaryFields()).then(buildQuery));
    };

    loadQ = function(service, name) {
      return function(q) {
        if (!q) {
          return error("No query found called " + name);
        }
        return service.query(q);
      };
    };

    checkNameParam = function(name) {
      if (name) {
        if ('string' === typeof name) {
          return success();
        } else {
          return error("Name must be a string");
        }
      } else {
        return error("Name not provided");
      }
    };

    Service.prototype.savedQuery = function(name, cb) {
      return REQUIRES_VERSION(this, 16, (function(_this) {
        return function() {
          return checkNameParam(name).then(function() {
            return withCB(cb, _this.get('user/queries', {
              filter: name
            }).then(function(r) {
              return r.queries[name];
            }).then(loadQ(_this, name)));
          });
        };
      })(this));
    };

    Service.prototype.templateQuery = function(name, cb) {
      return checkNameParam(name).then((function(_this) {
        return function() {
          return withCB(cb, _this.fetchTemplates().then(get(name)).then(set('type', 'TEMPLATE')).then(loadQ(_this, name)));
        };
      })(this));
    };

    Service.prototype.manageUserPreferences = function(method, data, cb) {
      return REQUIRES_VERSION(this, 11, (function(_this) {
        return function() {
          return withCB(cb, _this.makeRequest(method, PREF_PATH, data).then(get('preferences')));
        };
      })(this));
    };

    Service.prototype.resolveIds = function(opts, cb) {
      return REQUIRES_VERSION(this, 10, (function(_this) {
        return function() {
          var req;
          req = {
            type: 'POST',
            url: _this.root + ID_RESOLUTION_PATH,
            contentType: 'application/json',
            data: JSON.stringify(opts),
            dataType: 'json'
          };
          return withCB(cb, _this.doReq(req).then(get('uid')).then(IDResolutionJob.create(_this)));
        };
      })(this));
    };

    Service.prototype.resolutionJob = function(id) {
      return IDResolutionJob.create(this)(id);
    };

    Service.prototype.createList = function(opts, ids, cb) {
      var adjust, req;
      if (opts == null) {
        opts = {};
      }
      if (ids == null) {
        ids = '';
      }
      if (cb == null) {
        cb = function() {};
      }
      adjust = (function(_this) {
        return function(x) {
          return merge(x, {
            token: _this.token,
            tags: opts.tags || []
          });
        };
      })(this);
      req = {
        data: utils.isArray(ids) ? ids.map(function(x) {
          return "\"" + x + "\"";
        }).join("\n") : ids,
        dataType: 'json',
        url: "" + this.root + "lists?" + (to_query_string(adjust(opts))),
        type: 'POST',
        contentType: 'text/plain'
      };
      return withCB(cb, this.doReq(req).then(LIST_PIPE(this)));
    };

    getNewUserToken = function(resp) {
      return resp.user.temporaryToken;
    };

    Service.prototype.connectAs = function(token) {
      return Service.connect(merge(this, {
        token: token,
        noCache: !this.useCache
      }));
    };

    Service.prototype.register = function(name, password, cb) {
      return REQUIRES_VERSION(this, 9, (function(_this) {
        return function() {
          return withCB(cb, _this.post('users', {
            name: name,
            password: password
          }).then(getNewUserToken).then(_this.connectAs));
        };
      })(this));
    };

    FIVE_MIN = 5 * 60;

    Service.prototype.getDeregistrationToken = function(validity, cb) {
      if (validity == null) {
        validity = FIVE_MIN;
      }
      return REQUIRES_VERSION(this, 16, (function(_this) {
        return function() {
          var promise;
          promise = _this.token != null ? _this.post('user/deregistration', {
            validity: validity
          }).then(get('token')) : error("Not registered");
          return withCB(cb, promise);
        };
      })(this));
    };

    Service.prototype.deregister = function(token, cb) {
      return REQUIRES_VERSION(this, 16, (function(_this) {
        return function() {
          return withCB(cb, _this.makeRequest('DELETE', 'user', {
            deregistrationToken: token,
            format: 'xml'
          }));
        };
      })(this));
    };

    Service.prototype.login = function(name, password, cb) {
      return REQUIRES_VERSION(this, 9, (function(_this) {
        return function() {
          var auth;
          auth = "" + name + ":" + password;
          return withCB(cb, _this.logout().then(function(service) {
            return service.get('user/token', {
              auth: auth
            });
          })).then(get('token')).then(_this.connectAs);
        };
      })(this));
    };

    Service.prototype.logout = function(cb) {
      return withCB(cb, success(this.connectAs()));
    };

    return Service;

  })();

  Service.prototype.rowByRow = function() {
    var args, f, q;
    q = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    f = http.iterReq('POST', QUERY_RESULTS_PATH, 'json');
    if (q.toXML != null) {
      return f.apply(this, arguments);
    } else {
      return this.query(q).then((function(_this) {
        return function(query) {
          return _this.rowByRow.apply(_this, [query].concat(__slice.call(args)));
        };
      })(this));
    }
  };

  Service.prototype.eachRow = Service.prototype.rowByRow;

  Service.prototype.recordByRecord = function() {
    var args, f, q;
    q = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    f = http.iterReq('POST', QUERY_RESULTS_PATH, 'jsonobjects');
    if (q.toXML != null) {
      return f.apply(this, arguments);
    } else {
      return this.query(q).then((function(_this) {
        return function(query) {
          return _this.recordByRecord.apply(_this, [query].concat(__slice.call(args)));
        };
      })(this));
    }
  };

  Service.prototype.eachRecord = Service.prototype.recordByRecord;

  Service.prototype.union = Service.prototype.merge;

  Service.prototype.difference = Service.prototype.diff;

  Service.prototype.symmetricDifference = Service.prototype.diff;

  Service.prototype.relativeComplement = Service.prototype.complement;

  Service.prototype.subtract = Service.prototype.complement;

  Service.flushCaches = function() {
    MODELS = {};
    VERSIONS = {};
    RELEASES = {};
    CLASSKEYS = {};
    SUMMARY_FIELDS = {};
    return WIDGETS = {};
  };

  Service.connect = function(opts) {
    if ((opts != null ? opts.root : void 0) == null) {
      throw new Error("Invalid options provided: " + (JSON.stringify(opts)));
    }
    return new Service(opts);
  };

  exports.Service = Service;

  exports.Model = Model;

  exports.Query = Query;

  exports.utils = utils;

  exports.VERSION = version.VERSION;

  exports.imjs = version;

}).call(this);

},{"./http":3,"./id-resolution-job":4,"./lists":5,"./model":6,"./promise":8,"./query":9,"./user":14,"./util":15,"./version":16}],11:[function(_dereq_,module,exports){
(function (global){
(function() {
  var FakeDomParser;

  exports.DOMParser = global.DOMParser != null ? global.DOMParser : FakeDomParser = (function() {
    function FakeDomParser() {
      throw new Error("DOMParser is not available");
    }

    return FakeDomParser;

  })();

}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],12:[function(_dereq_,module,exports){
(function() {
  var HAS_CONSOLE, HAS_JSON, NOT_ENUM, hasDontEnumBug, hasOwnProperty, head, m, script, _fn, _i, _len, _ref;

  HAS_CONSOLE = typeof console !== 'undefined';

  HAS_JSON = typeof JSON !== 'undefined';

  NOT_ENUM = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'];

  if (!HAS_JSON) {
    script = document.createElement('script');
    script.src = 'http://cdn.intermine.org/js/json3/3.2.2/json3.min.js';
    script.type = 'text/javascript';
    head = document.getElementsByTagName('head')[0];
    head.appendChild(script);
  }

  if (Object.keys == null) {
    hasOwnProperty = Object.prototype.hasOwnProperty;
    hasDontEnumBug = !{
      toString: null
    }.propertyIsEnumerable("toString");
    Object.keys = function(o) {
      var keys, name, nonEnum, _i, _len;
      if (typeof o !== "object" && typeof o !== "" || o === null) {
        throw new TypeError("Object.keys called on a non-object");
      }
      keys = (function() {
        var _results;
        _results = [];
        for (name in o) {
          if (hasOwnProperty.call(o, name)) {
            _results.push(name);
          }
        }
        return _results;
      })();
      if (hasDontEnumBug) {
        for (_i = 0, _len = NOT_ENUM.length; _i < _len; _i++) {
          nonEnum = NOT_ENUM[_i];
          if (hasOwnProperty.call(o, nonEnum)) {
            keys.push(nonEnum);
          }
        }
      }
      return keys;
    };
  }

  if (Array.prototype.map == null) {
    Array.prototype.map = function(f) {
      var x, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        x = this[_i];
        _results.push(f(x));
      }
      return _results;
    };
  }

  if (Array.prototype.filter == null) {
    Array.prototype.filter = function(f) {
      var x, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        x = this[_i];
        if (f(x)) {
          _results.push(x);
        }
      }
      return _results;
    };
  }

  if (Array.prototype.reduce == null) {
    Array.prototype.reduce = function(f, initValue) {
      var ret, x, xs, _i, _len;
      xs = this.slice();
      ret = arguments.length < 2 ? xs.pop() : initValue;
      for (_i = 0, _len = xs.length; _i < _len; _i++) {
        x = xs[_i];
        ret = f(ret, x);
      }
      return ret;
    };
  }

  if (Array.prototype.forEach == null) {
    Array.prototype.forEach = function(f, ctx) {
      var i, x, _i, _len, _results;
      if (!f) {
        throw new Error("No function provided");
      }
      _results = [];
      for (i = _i = 0, _len = this.length; _i < _len; i = ++_i) {
        x = this[i];
        _results.push(f.call(ctx != null ? ctx : this, x, i, this));
      }
      return _results;
    };
  }

  if (!HAS_CONSOLE) {
    this.console = {
      log: (function() {}),
      error: (function() {}),
      debug: (function() {})
    };
    if (typeof window !== "undefined" && window !== null) {
      window.console = this.console;
    }
  }

  if (console.log == null) {
    console.log = function() {};
  }

  if (console.error == null) {
    console.error = function() {};
  }

  if (console.debug == null) {
    console.debug = function() {};
  }

  if (console.log.apply == null) {
    console.log("Your console needs patching.");
    _ref = ['log', 'error', 'debug'];
    _fn = function(m) {
      var oldM;
      oldM = console[m];
      return console[m] = function(args) {
        return oldM(args);
      };
    };
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      m = _ref[_i];
      _fn(m);
    }
  }

}).call(this);

},{}],13:[function(_dereq_,module,exports){
(function() {
  var Promise, merge, properties,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  merge = function(src, dest) {
    var k, v, _results;
    _results = [];
    for (k in src) {
      v = src[k];
      _results.push(dest[k] = v);
    }
    return _results;
  };

  Promise = _dereq_('./promise');

  properties = ['attributes', 'references', 'collections'];

  exports.Table = (function() {
    function Table(opts, model) {
      var c, prop, _, _i, _len, _ref, _ref1;
      this.model = model;
      this.getDisplayName = __bind(this.getDisplayName, this);
      this.name = opts.name, this.tags = opts.tags, this.displayName = opts.displayName, this.attributes = opts.attributes, this.references = opts.references, this.collections = opts.collections;
      this.fields = {};
      this.__parents__ = (_ref = opts['extends']) != null ? _ref : [];
      for (_i = 0, _len = properties.length; _i < _len; _i++) {
        prop = properties[_i];
        if (this[prop] == null) {
          throw new Error("Bad model data: missing " + prop);
        }
        merge(this[prop], this.fields);
      }
      _ref1 = this.collections;
      for (_ in _ref1) {
        c = _ref1[_];
        c.isCollection = true;
      }
    }

    Table.prototype.toString = function() {
      var n, _;
      return "[Table name=" + this.name + ", fields=[" + ((function() {
        var _ref, _results;
        _ref = this.fields;
        _results = [];
        for (n in _ref) {
          _ = _ref[n];
          _results.push(n);
        }
        return _results;
      }).call(this)) + "]]";
    };

    Table.prototype.parents = function() {
      var _ref;
      return ((_ref = this.__parents__) != null ? _ref : []).slice();
    };

    Table.prototype.getDisplayName = function() {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          if (_this.model != null) {
            return resolve(_this.model.makePath(_this.name).getDisplayName());
          } else {
            return reject(new Error('model not set - cannot make path'));
          }
        };
      })(this));
    };

    return Table;

  })();

}).call(this);

},{"./promise":8}],14:[function(_dereq_,module,exports){
(function() {
  var any, do_pref_req, error, get, isFunction, withCB, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ref = _dereq_('./util'), withCB = _ref.withCB, get = _ref.get, isFunction = _ref.isFunction, any = _ref.any, error = _ref.error;

  do_pref_req = function(user, data, method, cb) {
    return user.service.manageUserPreferences(method, data, cb).then(function(prefs) {
      return user.preferences = prefs;
    });
  };

  exports.User = (function() {
    function User(service, _arg) {
      this.service = service;
      this.username = _arg.username, this.preferences = _arg.preferences;
      this.refresh = __bind(this.refresh, this);
      this.clearPreferences = __bind(this.clearPreferences, this);
      this.clearPreference = __bind(this.clearPreference, this);
      this.setPreferences = __bind(this.setPreferences, this);
      this.setPreference = __bind(this.setPreference, this);
      this.hasPreferences = this.preferences != null;
      if (this.preferences == null) {
        this.preferences = {};
      }
    }

    User.prototype.setPreference = function(key, value, cb) {
      var data, _ref1;
      if (isFunction(value)) {
        _ref1 = [null, value], value = _ref1[0], cb = _ref1[1];
      }
      if (typeof key === 'string') {
        data = {};
        data[key] = value;
      } else if (value == null) {
        data = key;
      } else {
        return withCB(cb, error("Incorrect arguments to setPreference"));
      }
      return this.setPreferences(data, cb);
    };

    User.prototype.setPreferences = function(prefs, cb) {
      return do_pref_req(this, prefs, 'POST', cb);
    };

    User.prototype.clearPreference = function(key, cb) {
      return do_pref_req(this, {
        key: key
      }, 'DELETE', cb);
    };

    User.prototype.clearPreferences = function(cb) {
      return do_pref_req(this, {}, 'DELETE', cb);
    };

    User.prototype.refresh = function(cb) {
      return do_pref_req(this, {}, 'GET', cb);
    };

    User.prototype.createToken = function(type, message, cb) {
      var _ref1, _ref2;
      if (type == null) {
        type = 'day';
      }
      if ((cb == null) && any([type, message], isFunction)) {
        if (isFunction(type)) {
          _ref1 = [null, null, type], type = _ref1[0], message = _ref1[1], cb = _ref1[2];
        } else if (isFunction(message)) {
          _ref2 = [null, message], message = _ref2[0], cb = _ref2[1];
        }
      }
      return withCB(cb, this.service.post('user/tokens', {
        type: type,
        message: message
      }).then(get('token')));
    };

    User.prototype.fetchCurrentTokens = function(cb) {
      return withCB(cb, this.service.get('user/tokens').then(get('tokens')));
    };

    User.prototype.revokeAllTokens = function(cb) {
      return withCB(cb, this.service.makeRequest('DELETE', 'user/tokens'));
    };

    User.prototype.revokeToken = function(token, cb) {
      return withCB(cb, this.service.makeRequest('DELETE', "user/tokens/" + token));
    };

    return User;

  })();

}).call(this);

},{"./util":15}],15:[function(_dereq_,module,exports){
(function() {
  var Promise, REQUIRES, comp, curry, encode, entities, error, flatten, fold, id, invoke, invokeWith, isArray, merge, pairFold, qsFromList, root, success, thenFold, _ref,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty;

  Promise = _dereq_('./promise');

  root = exports;

  root.defer = function() {
    var deferred;
    deferred = {};
    deferred.promise = new Promise(function(resolve, reject) {
      deferred.resolve = resolve;
      return deferred.reject = reject;
    });
    return deferred;
  };

  encode = function(x) {
    return encodeURIComponent(String(x));
  };

  qsFromList = function(pairs) {
    var pair;
    return ((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = pairs.length; _i < _len; _i++) {
        pair = pairs[_i];
        _results.push(pair.map(encode).join('='));
      }
      return _results;
    })()).join('&');
  };

  root.querystring = function(obj) {
    var k, p, pairs, subList, sv, v;
    if (!obj) {
      return '';
    }
    if (isArray(obj)) {
      pairs = obj.slice();
    } else {
      pairs = [];
      for (k in obj) {
        v = obj[k];
        if (isArray(v)) {
          subList = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = v.length; _i < _len; _i++) {
              sv = v[_i];
              _results.push([k, sv]);
            }
            return _results;
          })();
          pairs = pairs.concat(subList);
        } else {
          pairs.push([k, v]);
        }
      }
    }
    return qsFromList((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = pairs.length; _i < _len; _i++) {
        p = pairs[_i];
        if (p[1] != null) {
          _results.push(p);
        }
      }
      return _results;
    })());
  };

  root.curry = curry = function() {
    var args, f;
    f = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return function() {
      var rest;
      rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return f.apply(null, args.concat(rest));
    };
  };

  root.error = error = function(e) {
    return new Promise(function(_, reject) {
      return reject(new Error(e));
    });
  };

  root.success = success = function(x) {
    return new Promise(function(resolve, _) {
      return resolve(x);
    });
  };

  root.parallel = function() {
    var promises;
    promises = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (promises.length === 1 && (!promises[0].then) && promises[0].length) {
      return Promise.all(promises[0]);
    } else {
      return Promise.all(promises);
    }
  };

  root.withCB = function() {
    var f, fs, onErr, onSucc, p, _i, _j, _len;
    fs = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), p = arguments[_i++];
    for (_j = 0, _len = fs.length; _j < _len; _j++) {
      f = fs[_j];
      if (!(f != null)) {
        continue;
      }
      onSucc = curry(f, null);
      onErr = f;
      p.then(onSucc, onErr);
    }
    return p;
  };

  root.fold = fold = function(f) {
    return function(init, xs) {
      var k, ret, v;
      if (arguments.length === 1) {
        xs = (init != null ? init.slice() : void 0) || init;
        init = (xs != null ? xs.shift() : void 0) || {};
      }
      if (xs == null) {
        throw new Error("xs is null");
      }
      if (xs.reduce != null) {
        return xs.reduce(f, init);
      } else {
        ret = init;
        for (k in xs) {
          v = xs[k];
          ret = ret != null ? f(ret, k, v) : {
            k: v
          };
        }
        return ret;
      }
    };
  };

  root.take = function(n) {
    return function(xs) {
      if (n != null) {
        return xs.slice(0, +(n - 1) + 1 || 9e9);
      } else {
        return xs.slice();
      }
    };
  };

  root.filter = function(f) {
    return function(xs) {
      var x, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = xs.length; _i < _len; _i++) {
        x = xs[_i];
        if (f(x)) {
          _results.push(x);
        }
      }
      return _results;
    };
  };

  root.uniqBy = function(f, xs) {
    var k, keys, values, x, _i, _len;
    if (arguments.length === 1) {
      return curry(root.uniqBy, f);
    }
    keys = [];
    values = [];
    if (xs == null) {
      return values;
    }
    for (_i = 0, _len = xs.length; _i < _len; _i++) {
      x = xs[_i];
      k = f(x);
      if (__indexOf.call(keys, k) < 0) {
        keys.push(k);
        values.push(x);
      }
    }
    return values;
  };

  root.find = function(xs, f) {
    var x, _i, _len;
    if (arguments.length === 1) {
      f = xs;
      return function(xs) {
        return root.find(xs, f);
      };
    }
    for (_i = 0, _len = xs.length; _i < _len; _i++) {
      x = xs[_i];
      if (f(x)) {
        return x;
      }
    }
    return null;
  };

  isArray = (_ref = Array.isArray) != null ? _ref : function(xs) {
    return ((xs != null ? xs.splice : void 0) != null) && ((xs != null ? xs.push : void 0) != null) && ((xs != null ? xs.pop : void 0) != null) && ((xs != null ? xs.slice : void 0) != null);
  };

  root.isArray = isArray;

  root.isFunction = typeof /./ !== 'function' ? function(f) {
    return typeof f === 'function';
  } : function(f) {
    return (f != null) && (f.call != null) && (f.apply != null) && f.toString() === '[object Function]';
  };

  entities = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&apos;'
  };

  root.escape = function(str) {
    var code, i, ret, withEntities, _i, _ref1;
    if (str == null) {
      return '';
    }
    withEntities = String(str).replace(/[&<>"']/g, function(entity) {
      return entities[entity];
    });
    ret = [];
    for (i = _i = 0, _ref1 = withEntities.length; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
      code = withEntities.charCodeAt(i);
      if (code > 256) {
        ret.push("&#" + code + ";");
      } else {
        ret.push(withEntities.charAt(i));
      }
    }
    return ret.join('');
  };

  root.omap = function(f) {
    var merger;
    merger = fold(function(a, oldk, oldv) {
      var newk, newv, _ref1;
      _ref1 = f(oldk, oldv), newk = _ref1[0], newv = _ref1[1];
      if (isArray(newv)) {
        newv = newv.slice();
      }
      a[newk] = newv;
      return a;
    });
    return function(xs) {
      return merger({}, xs);
    };
  };

  root.copy = root.omap(function(k, v) {
    return [k, v];
  });

  root.partition = function(f) {
    return function(xs) {
      var divide;
      divide = fold(function(_arg, x) {
        var falses, trues;
        trues = _arg[0], falses = _arg[1];
        if (f(x)) {
          return [trues.concat([x]), falses];
        } else {
          return [trues, falses.concat([x])];
        }
      });
      return divide([[], []], xs);
    };
  };

  root.id = id = function(x) {
    return x;
  };

  root.concatMap = function(f) {
    return function(xs) {
      var fx, ret, x, _i, _len;
      ret = void 0;
      for (_i = 0, _len = xs.length; _i < _len; _i++) {
        x = xs[_i];
        fx = f(x);
        ret = ret === void 0 ? fx : typeof ret === 'number' ? ret + fx : ret.concat != null ? ret.concat(fx) : merge(ret, fx);
      }
      return ret;
    };
  };

  root.map = function(f) {
    return invoke('map', f);
  };

  comp = fold(function(f, g) {
    return function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return f(g.apply(null, args));
    };
  });

  root.compose = function() {
    var fs;
    fs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return comp(fs);
  };

  root.flatMap = root.concatMap;

  root.difference = function(xs, remove) {
    var x, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = xs.length; _i < _len; _i++) {
      x = xs[_i];
      if (__indexOf.call(remove, x) < 0) {
        _results.push(x);
      }
    }
    return _results;
  };

  root.stringList = function(x) {
    if (typeof x === 'string') {
      return [x];
    } else {
      return x;
    }
  };

  root.flatten = flatten = function() {
    var ret, x, xs, xx, _i, _j, _len, _len1, _ref1;
    xs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    ret = [];
    for (_i = 0, _len = xs.length; _i < _len; _i++) {
      x = xs[_i];
      if (isArray(x)) {
        _ref1 = flatten.apply(null, x);
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          xx = _ref1[_j];
          ret.push(xx);
        }
      } else {
        ret.push(x);
      }
    }
    return ret;
  };

  root.sum = root.concatMap(id);

  root.merge = merge = function() {
    var k, newObj, o, objs, v, _i, _len;
    objs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    newObj = {};
    for (_i = 0, _len = objs.length; _i < _len; _i++) {
      o = objs[_i];
      for (k in o) {
        if (!__hasProp.call(o, k)) continue;
        v = o[k];
        newObj[k] = v;
      }
    }
    return newObj;
  };

  root.any = function(xs, f) {
    var x, _i, _len;
    if (f == null) {
      f = id;
    }
    for (_i = 0, _len = xs.length; _i < _len; _i++) {
      x = xs[_i];
      if (f(x)) {
        return true;
      }
    }
    return false;
  };

  root.invoke = invoke = function() {
    var args, name;
    name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return invokeWith(name, args);
  };

  root.invokeWith = invokeWith = function(name, args, ctx) {
    if (args == null) {
      args = [];
    }
    if (ctx == null) {
      ctx = null;
    }
    return function(o) {
      if (o == null) {
        throw new Error("Cannot call method \"" + name + "\" of null");
      }
      if (!o[name]) {
        throw new Error("Cannot call undefined method \"" + name + " of " + o);
      } else {
        return o[name].apply(ctx || o, args);
      }
    };
  };

  root.get = function(name) {
    return function(obj) {
      return obj[name];
    };
  };

  root.set = function(name, value) {
    return function(obj) {
      var k, v;
      if (arguments.length === 2) {
        obj[name] = value;
      } else {
        for (k in name) {
          if (!__hasProp.call(name, k)) continue;
          v = name[k];
          obj[k] = v;
        }
      }
      return obj;
    };
  };

  REQUIRES = function(required, got) {
    return "This service requires a service at version " + required + " or above. This one is at " + got;
  };

  root.REQUIRES_VERSION = function(s, n, f) {
    return s.fetchVersion().then(function(v) {
      if (v >= n) {
        return f();
      } else {
        return error(REQUIRES(n, v));
      }
    });
  };

  root.dejoin = function(q) {
    var parts, view, _i, _len, _ref1;
    _ref1 = q.views;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      view = _ref1[_i];
      parts = view.split('.');
      if (parts.length > 2) {
        q.addJoin(parts.slice(1, -1).join('.'));
      }
    }
    return q;
  };

  thenFold = fold(function(p, f) {
    return p.then(f);
  });

  root.sequence = function() {
    var fns;
    fns = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return thenFold(success(), fns);
  };

  pairFold = fold(function(o, _arg) {
    var k, v;
    k = _arg[0], v = _arg[1];
    if (o[k] != null) {
      throw new Error("Duplicate key: " + k);
    }
    o[k] = v;
    return o;
  });

  root.pairsToObj = function(pairs) {
    return pairFold({}, pairs);
  };

}).call(this);

},{"./promise":8}],16:[function(_dereq_,module,exports){
(function() {
  exports.VERSION = '3.13.0';

}).call(this);

},{}],17:[function(_dereq_,module,exports){
(function() {
  var DOMParser, sanitize;

  DOMParser = _dereq_('xmldom').DOMParser;

  sanitize = function(xml) {
    xml = xml.replace(/^\s*/g, '');
    xml = xml.replace(/\s$/g, '');
    if (xml.length === 0) {
      return xml;
    } else if (xml[xml.length - 1] !== '>') {
      return xml + '>';
    } else {
      return xml;
    }
  };

  exports.parse = function(xml) {
    var dom, parser;
    if (typeof xml !== 'string') {
      throw new Error("Expected a string - got " + xml);
    }
    xml = sanitize(xml);
    if (!xml) {
      throw new Error("Expected content - got empty string");
    }
    dom = (function() {
      try {
        parser = new DOMParser();
        return parser.parseFromString(xml, 'text/xml');
      } catch (_error) {}
    })();
    if ((!dom) || (!dom.documentElement) || dom.getElementsByTagName('parsererror').length) {
      throw new Error("Invalid XML: " + xml);
    }
    return dom;
  };

}).call(this);

},{"xmldom":11}],18:[function(_dereq_,module,exports){
(function (process,Buffer){


var Parser = _dereq_('jsonparse')
  , through = _dereq_('through')

/*

  the value of this.stack that creationix's jsonparse has is weird.

  it makes this code ugly, but his problem is way harder that mine,
  so i'll forgive him.

*/

exports.parse = function (path, map) {

  var parser = new Parser()
  var stream = through(function (chunk) {
    if('string' === typeof chunk)
      chunk = new Buffer(chunk)
    parser.write(chunk)
  },
  function (data) {
    if(data)
      stream.write(data)
    stream.queue(null)
  })

  if('string' === typeof path)
    path = path.split('.').map(function (e) {
      if (e === '*')
        return true
      else if (e === '') // '..'.split('.') returns an empty string
        return {recurse: true}
      else
        return e
    })


  var count = 0, _key
  if(!path || !path.length)
    path = null

  parser.onValue = function (value) {
    if (!this.root)
      stream.root = value

    if(! path) return

    var i = 0 // iterates on path
    var j  = 0 // iterates on stack
    while (i < path.length) {
      var key = path[i]
      var c
      j++

      if (key && !key.recurse) {
        c = (j === this.stack.length) ? this : this.stack[j]
        if (!c) return
        if (! check(key, c.key)) return
        i++
      } else {
        i++
        var nextKey = path[i]
        if (! nextKey) return
        while (true) {
          c = (j === this.stack.length) ? this : this.stack[j]
          if (!c) return
          if (check(nextKey, c.key)) { i++; break}
          j++
        }
      }
    }
    if (j !== this.stack.length) return

    count ++
    var actualPath = this.stack.slice(1).map(function(element) { return element.key }).concat([this.key])
    var data = this.value[this.key]
    if(null != data)
      if(null != (data = map ? map(data, actualPath) : data))
        stream.queue(data)
    delete this.value[this.key]
  }
  parser._onToken = parser.onToken;

  parser.onToken = function (token, value) {
    parser._onToken(token, value);
    if (this.stack.length === 0) {
      if (stream.root) {
        if(!path)
          stream.queue(stream.root)
        stream.emit('root', stream.root, count)
        count = 0;
        stream.root = null;
      }
    }
  }

  parser.onError = function (err) {
    stream.emit('error', err)
  }


  return stream
}

function check (x, y) {
  if ('string' === typeof x)
    return y == x
  else if (x && 'function' === typeof x.exec)
    return x.exec(y)
  else if ('boolean' === typeof x)
    return x
  else if ('function' === typeof x)
    return x(y)
  return false
}

exports.stringify = function (op, sep, cl, indent) {
  indent = indent || 0
  if (op === false){
    op = ''
    sep = '\n'
    cl = ''
  } else if (op == null) {

    op = '[\n'
    sep = '\n,\n'
    cl = '\n]\n'

  }

  //else, what ever you like

  var stream
    , first = true
    , anyData = false
  stream = through(function (data) {
    anyData = true
    var json = JSON.stringify(data, null, indent)
    if(first) { first = false ; stream.queue(op + json)}
    else stream.queue(sep + json)
  },
  function (data) {
    if(!anyData)
      stream.queue(op)
    stream.queue(cl)
    stream.queue(null)
  })

  return stream
}

exports.stringifyObject = function (op, sep, cl, indent) {
  indent = indent || 0
  if (op === false){
    op = ''
    sep = '\n'
    cl = ''
  } else if (op == null) {

    op = '{\n'
    sep = '\n,\n'
    cl = '\n}\n'

  }

  //else, what ever you like

  var first = true
    , anyData = false
  stream = through(function (data) {
    anyData = true
    var json = JSON.stringify(data[0]) + ':' + JSON.stringify(data[1], null, indent)
    if(first) { first = false ; this.queue(op + json)}
    else this.queue(sep + json)
  },
  function (data) {
    if(!anyData) this.queue(op)
    this.queue(cl)

    this.queue(null)
  })

  return stream
}

if(!module.parent && process.title !== 'browser') {
  process.stdin
    .pipe(exports.parse(process.argv[2]))
    .pipe(exports.stringify('[', ',\n', ']\n', 2))
    .pipe(process.stdout)
}

}).call(this,_dereq_("/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js"),_dereq_("buffer").Buffer)
},{"/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js":55,"buffer":23,"jsonparse":19,"through":56}],19:[function(_dereq_,module,exports){
(function (Buffer){
/*global Buffer*/
// Named constants with unique integer values
var C = {};
// Tokens
var LEFT_BRACE    = C.LEFT_BRACE    = 0x1;
var RIGHT_BRACE   = C.RIGHT_BRACE   = 0x2;
var LEFT_BRACKET  = C.LEFT_BRACKET  = 0x3;
var RIGHT_BRACKET = C.RIGHT_BRACKET = 0x4;
var COLON         = C.COLON         = 0x5;
var COMMA         = C.COMMA         = 0x6;
var TRUE          = C.TRUE          = 0x7;
var FALSE         = C.FALSE         = 0x8;
var NULL          = C.NULL          = 0x9;
var STRING        = C.STRING        = 0xa;
var NUMBER        = C.NUMBER        = 0xb;
// Tokenizer States
var START   = C.START   = 0x11;
var TRUE1   = C.TRUE1   = 0x21;
var TRUE2   = C.TRUE2   = 0x22;
var TRUE3   = C.TRUE3   = 0x23;
var FALSE1  = C.FALSE1  = 0x31;
var FALSE2  = C.FALSE2  = 0x32;
var FALSE3  = C.FALSE3  = 0x33;
var FALSE4  = C.FALSE4  = 0x34;
var NULL1   = C.NULL1   = 0x41;
var NULL2   = C.NULL3   = 0x42;
var NULL3   = C.NULL2   = 0x43;
var NUMBER1 = C.NUMBER1 = 0x51;
var NUMBER2 = C.NUMBER2 = 0x52;
var NUMBER3 = C.NUMBER3 = 0x53;
var NUMBER4 = C.NUMBER4 = 0x54;
var NUMBER5 = C.NUMBER5 = 0x55;
var NUMBER6 = C.NUMBER6 = 0x56;
var NUMBER7 = C.NUMBER7 = 0x57;
var NUMBER8 = C.NUMBER8 = 0x58;
var STRING1 = C.STRING1 = 0x61;
var STRING2 = C.STRING2 = 0x62;
var STRING3 = C.STRING3 = 0x63;
var STRING4 = C.STRING4 = 0x64;
var STRING5 = C.STRING5 = 0x65;
var STRING6 = C.STRING6 = 0x66;
// Parser States
var VALUE   = C.VALUE   = 0x71;
var KEY     = C.KEY     = 0x72;
// Parser Modes
var OBJECT  = C.OBJECT  = 0x81;
var ARRAY   = C.ARRAY   = 0x82;

// Slow code to string converter (only used when throwing syntax errors)
function toknam(code) {
  var keys = Object.keys(C);
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    if (C[key] === code) { return key; }
  }
  return code && ("0x" + code.toString(16));
}


function Parser() {
  this.tState = START;
  this.value = undefined;

  this.string = undefined; // string data
  this.unicode = undefined; // unicode escapes

  // For number parsing
  this.negative = undefined;
  this.magnatude = undefined;
  this.position = undefined;
  this.exponent = undefined;
  this.negativeExponent = undefined;
  
  this.key = undefined;
  this.mode = undefined;
  this.stack = [];
  this.state = VALUE;
  this.bytes_remaining = 0; // number of bytes remaining in multi byte utf8 char to read after split boundary
  this.bytes_in_sequence = 0; // bytes in multi byte utf8 char to read
  this.temp_buffs = { "2": new Buffer(2), "3": new Buffer(3), "4": new Buffer(4) }; // for rebuilding chars split before boundary is reached
}
var proto = Parser.prototype;
proto.charError = function (buffer, i) {
  this.onError(new Error("Unexpected " + JSON.stringify(String.fromCharCode(buffer[i])) + " at position " + i + " in state " + toknam(this.tState)));
};
proto.onError = function (err) { throw err; };
proto.write = function (buffer) {
  if (typeof buffer === "string") buffer = new Buffer(buffer);
  //process.stdout.write("Input: ");
  //console.dir(buffer.toString());
  var n;
  for (var i = 0, l = buffer.length; i < l; i++) {
    if (this.tState === START){
      n = buffer[i];
      if(n === 0x7b){ this.onToken(LEFT_BRACE, "{"); // {
      }else if(n === 0x7d){ this.onToken(RIGHT_BRACE, "}"); // }
      }else if(n === 0x5b){ this.onToken(LEFT_BRACKET, "["); // [
      }else if(n === 0x5d){ this.onToken(RIGHT_BRACKET, "]"); // ]
      }else if(n === 0x3a){ this.onToken(COLON, ":");  // :
      }else if(n === 0x2c){ this.onToken(COMMA, ","); // ,
      }else if(n === 0x74){ this.tState = TRUE1;  // t
      }else if(n === 0x66){ this.tState = FALSE1;  // f
      }else if(n === 0x6e){ this.tState = NULL1; // n
      }else if(n === 0x22){ this.string = ""; this.tState = STRING1; // "
      }else if(n === 0x2d){ this.negative = true; this.tState = NUMBER1; // -
      }else if(n === 0x30){ this.magnatude = 0; this.tState = NUMBER2; // 0
      }else{
        if (n > 0x30 && n < 0x40) { // 1-9
          this.magnatude = n - 0x30; this.tState = NUMBER3;
        } else if (n === 0x20 || n === 0x09 || n === 0x0a || n === 0x0d) {
          // whitespace
        } else { this.charError(buffer, i); }
      }
    }else if (this.tState === STRING1){ // After open quote
      n = buffer[i]; // get current byte from buffer
      // check for carry over of a multi byte char split between data chunks
      // & fill temp buffer it with start of this data chunk up to the boundary limit set in the last iteration
      if (this.bytes_remaining > 0) {
        for (var j = 0; j < this.bytes_remaining; j++) {
          this.temp_buffs[this.bytes_in_sequence][this.bytes_in_sequence - this.bytes_remaining + j] = buffer[j];
        }
        this.string += this.temp_buffs[this.bytes_in_sequence].toString();
        this.bytes_in_sequence = this.bytes_remaining = 0;
        i = i + j - 1;
      } else if (this.bytes_remaining === 0 && n >= 128) { // else if no remainder bytes carried over, parse multi byte (>=128) chars one at a time
        if ((n >= 194) && (n <= 223)) this.bytes_in_sequence = 2;
        if ((n >= 224) && (n <= 239)) this.bytes_in_sequence = 3;
        if ((n >= 240) && (n <= 244)) this.bytes_in_sequence = 4;
        if ((this.bytes_in_sequence + i) > buffer.length) { // if bytes needed to complete char fall outside buffer length, we have a boundary split
          for (var k = 0; k <= (buffer.length - 1 - i); k++) {
            this.temp_buffs[this.bytes_in_sequence][k] = buffer[i + k]; // fill temp buffer of correct size with bytes available in this chunk
          }
          this.bytes_remaining = (i + this.bytes_in_sequence) - buffer.length;
          i = buffer.length - 1;
        } else {
          this.string += buffer.slice(i, (i + this.bytes_in_sequence)).toString();
          i = i + this.bytes_in_sequence - 1;
        }
      } else if (n === 0x22) { this.tState = START; this.onToken(STRING, this.string); this.string = undefined; }
      else if (n === 0x5c) { this.tState = STRING2; }
      else if (n >= 0x20) { this.string += String.fromCharCode(n); }
      else { this.charError(buffer, i); }
    }else if (this.tState === STRING2){ // After backslash
      n = buffer[i];
      if(n === 0x22){ this.string += "\""; this.tState = STRING1;
      }else if(n === 0x5c){ this.string += "\\"; this.tState = STRING1; 
      }else if(n === 0x2f){ this.string += "\/"; this.tState = STRING1; 
      }else if(n === 0x62){ this.string += "\b"; this.tState = STRING1; 
      }else if(n === 0x66){ this.string += "\f"; this.tState = STRING1; 
      }else if(n === 0x6e){ this.string += "\n"; this.tState = STRING1; 
      }else if(n === 0x72){ this.string += "\r"; this.tState = STRING1; 
      }else if(n === 0x74){ this.string += "\t"; this.tState = STRING1; 
      }else if(n === 0x75){ this.unicode = ""; this.tState = STRING3;
      }else{ 
        this.charError(buffer, i); 
      }
    }else if (this.tState === STRING3 || this.tState === STRING4 || this.tState === STRING5 || this.tState === STRING6){ // unicode hex codes
      n = buffer[i];
      // 0-9 A-F a-f
      if ((n >= 0x30 && n < 0x40) || (n > 0x40 && n <= 0x46) || (n > 0x60 && n <= 0x66)) {
        this.unicode += String.fromCharCode(n);
        if (this.tState++ === STRING6) {
          this.string += String.fromCharCode(parseInt(this.unicode, 16));
          this.unicode = undefined;
          this.tState = STRING1; 
        }
      } else {
        this.charError(buffer, i);
      }
    }else if (this.tState === NUMBER1){ // after minus
      n = buffer[i];
      if (n === 0x30) { this.magnatude = 0; this.tState = NUMBER2; }
      else if (n > 0x30 && n < 0x40) { this.magnatude = n - 0x30; this.tState = NUMBER3; }
      else { this.charError(buffer, i); }
    }else if (this.tState === NUMBER2){ // * After initial zero
      n = buffer[i];
      if(n === 0x2e){ // .
        this.position = 0.1; this.tState = NUMBER4;
      }else if(n === 0x65 ||  n === 0x45){ // e/E
        this.exponent = 0; this.tState = NUMBER6;
      }else{
        this.tState = START;
        this.onToken(NUMBER, 0);
        this.magnatude = undefined;
        this.negative = undefined;
        i--;
      }
    }else if (this.tState === NUMBER3){ // * After digit (before period)
      n = buffer[i];
      if(n === 0x2e){ // .
        this.position = 0.1; this.tState = NUMBER4;
      }else if(n === 0x65 || n === 0x45){ // e/E
        this.exponent = 0; this.tState = NUMBER6;
      }else{
        if (n >= 0x30 && n < 0x40) { this.magnatude = this.magnatude * 10 + n - 0x30; }
        else {
          this.tState = START; 
          if (this.negative) {
            this.magnatude = -this.magnatude;
            this.negative = undefined;
          }
          this.onToken(NUMBER, this.magnatude); 
          this.magnatude = undefined;
          i--;
        }
      }
    }else if (this.tState === NUMBER4){ // After period
      n = buffer[i];
      if (n >= 0x30 && n < 0x40) { // 0-9
        this.magnatude += this.position * (n - 0x30);
        this.position /= 10;
        this.tState = NUMBER5; 
      } else { this.charError(buffer, i); }
    }else if (this.tState === NUMBER5){ // * After digit (after period)
      n = buffer[i];
      if (n >= 0x30 && n < 0x40) { // 0-9
        this.magnatude += this.position * (n - 0x30);
        this.position /= 10;
      }
      else if (n === 0x65 || n === 0x45) { this.exponent = 0; this.tState = NUMBER6; } // E/e
      else {
        this.tState = START; 
        if (this.negative) {
          this.magnatude = -this.magnatude;
          this.negative = undefined;
        }
        this.onToken(NUMBER, this.negative ? -this.magnatude : this.magnatude); 
        this.magnatude = undefined;
        this.position = undefined;
        i--; 
      }
    }else if (this.tState === NUMBER6){ // After E
      n = buffer[i];
      if (n === 0x2b || n === 0x2d) { // +/-
        if (n === 0x2d) { this.negativeExponent = true; }
        this.tState = NUMBER7;
      }
      else if (n >= 0x30 && n < 0x40) {
        this.exponent = this.exponent * 10 + (n - 0x30);
        this.tState = NUMBER8;
      }
      else { this.charError(buffer, i); }  
    }else if (this.tState === NUMBER7){ // After +/-
      n = buffer[i];
      if (n >= 0x30 && n < 0x40) { // 0-9
        this.exponent = this.exponent * 10 + (n - 0x30);
        this.tState = NUMBER8;
      }
      else { this.charError(buffer, i); }  
    }else if (this.tState === NUMBER8){ // * After digit (after +/-)
      n = buffer[i];
      if (n >= 0x30 && n < 0x40) { // 0-9
        this.exponent = this.exponent * 10 + (n - 0x30);
      }
      else {
        if (this.negativeExponent) {
          this.exponent = -this.exponent;
          this.negativeExponent = undefined;
        }
        this.magnatude *= Math.pow(10, this.exponent);
        this.exponent = undefined;
        if (this.negative) { 
          this.magnatude = -this.magnatude;
          this.negative = undefined;
        }
        this.tState = START;
        this.onToken(NUMBER, this.magnatude);
        this.magnatude = undefined;
        i--; 
      } 
    }else if (this.tState === TRUE1){ // r
      if (buffer[i] === 0x72) { this.tState = TRUE2; }
      else { this.charError(buffer, i); }
    }else if (this.tState === TRUE2){ // u
      if (buffer[i] === 0x75) { this.tState = TRUE3; }
      else { this.charError(buffer, i); }
    }else if (this.tState === TRUE3){ // e
      if (buffer[i] === 0x65) { this.tState = START; this.onToken(TRUE, true); }
      else { this.charError(buffer, i); }
    }else if (this.tState === FALSE1){ // a
      if (buffer[i] === 0x61) { this.tState = FALSE2; }
      else { this.charError(buffer, i); }
    }else if (this.tState === FALSE2){ // l
      if (buffer[i] === 0x6c) { this.tState = FALSE3; }
      else { this.charError(buffer, i); }
    }else if (this.tState === FALSE3){ // s
      if (buffer[i] === 0x73) { this.tState = FALSE4; }
      else { this.charError(buffer, i); }
    }else if (this.tState === FALSE4){ // e
      if (buffer[i] === 0x65) { this.tState = START; this.onToken(FALSE, false); }
      else { this.charError(buffer, i); }
    }else if (this.tState === NULL1){ // u
      if (buffer[i] === 0x75) { this.tState = NULL2; }
      else { this.charError(buffer, i); }
    }else if (this.tState === NULL2){ // l
      if (buffer[i] === 0x6c) { this.tState = NULL3; }
      else { this.charError(buffer, i); }
    }else if (this.tState === NULL3){ // l
      if (buffer[i] === 0x6c) { this.tState = START; this.onToken(NULL, null); }
      else { this.charError(buffer, i); }
    }
  }
};
proto.onToken = function (token, value) {
  // Override this to get events
};

proto.parseError = function (token, value) {
  this.onError(new Error("Unexpected " + toknam(token) + (value ? ("(" + JSON.stringify(value) + ")") : "") + " in state " + toknam(this.state)));
};
proto.onError = function (err) { throw err; };
proto.push = function () {
  this.stack.push({value: this.value, key: this.key, mode: this.mode});
};
proto.pop = function () {
  var value = this.value;
  var parent = this.stack.pop();
  this.value = parent.value;
  this.key = parent.key;
  this.mode = parent.mode;
  this.emit(value);
  if (!this.mode) { this.state = VALUE; }
};
proto.emit = function (value) {
  if (this.mode) { this.state = COMMA; }
  this.onValue(value);
};
proto.onValue = function (value) {
  // Override me
};  
proto.onToken = function (token, value) {
  //console.log("OnToken: state=%s token=%s %s", toknam(this.state), toknam(token), value?JSON.stringify(value):"");
  if(this.state === VALUE){
    if(token === STRING || token === NUMBER || token === TRUE || token === FALSE || token === NULL){
      if (this.value) {
        this.value[this.key] = value;
      }
      this.emit(value);  
    }else if(token === LEFT_BRACE){
      this.push();
      if (this.value) {
        this.value = this.value[this.key] = {};
      } else {
        this.value = {};
      }
      this.key = undefined;
      this.state = KEY;
      this.mode = OBJECT;
    }else if(token === LEFT_BRACKET){
      this.push();
      if (this.value) {
        this.value = this.value[this.key] = [];
      } else {
        this.value = [];
      }
      this.key = 0;
      this.mode = ARRAY;
      this.state = VALUE;
    }else if(token === RIGHT_BRACE){
      if (this.mode === OBJECT) {
        this.pop();
      } else {
        this.parseError(token, value);
      }
    }else if(token === RIGHT_BRACKET){
      if (this.mode === ARRAY) {
        this.pop();
      } else {
        this.parseError(token, value);
      }
    }else{
      this.parseError(token, value);
    }
  }else if(this.state === KEY){
    if (token === STRING) {
      this.key = value;
      this.state = COLON;
    } else if (token === RIGHT_BRACE) {
      this.pop();
    } else {
      this.parseError(token, value);
    }
  }else if(this.state === COLON){
    if (token === COLON) { this.state = VALUE; }
    else { this.parseError(token, value); }
  }else if(this.state === COMMA){
    if (token === COMMA) { 
      if (this.mode === ARRAY) { this.key++; this.state = VALUE; }
      else if (this.mode === OBJECT) { this.state = KEY; }

    } else if (token === RIGHT_BRACKET && this.mode === ARRAY || token === RIGHT_BRACE && this.mode === OBJECT) {
      this.pop();
    } else {
      this.parseError(token, value);
    }
  }else{
    this.parseError(token, value);
  }
};

module.exports = Parser;

}).call(this,_dereq_("buffer").Buffer)
},{"buffer":23}],20:[function(_dereq_,module,exports){
/**
 * Standalone extraction of Backbone.Events, no external dependency required.
 * Degrades nicely when Backone/underscore are already available in the current
 * global context.
 *
 * Note that docs suggest to use underscore's `_.extend()` method to add Events
 * support to some given object. A `mixin()` method has been added to the Events
 * prototype to avoid using underscore for that sole purpose:
 *
 *     var myEventEmitter = BackboneEvents.mixin({});
 *
 * Or for a function constructor:
 *
 *     function MyConstructor(){}
 *     MyConstructor.prototype.foo = function(){}
 *     BackboneEvents.mixin(MyConstructor.prototype);
 *
 * (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.
 * (c) 2013 Nicolas Perriault
 */
/* global exports:true, define, module */
(function() {
  var root = this,
      breaker = {},
      nativeForEach = Array.prototype.forEach,
      hasOwnProperty = Object.prototype.hasOwnProperty,
      slice = Array.prototype.slice,
      idCounter = 0;

  // Returns a partial implementation matching the minimal API subset required
  // by Backbone.Events
  function miniscore() {
    return {
      keys: Object.keys || function (obj) {
        if (typeof obj !== "object" && typeof obj !== "function" || obj === null) {
          throw new TypeError("keys() called on a non-object");
        }
        var key, keys = [];
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            keys[keys.length] = key;
          }
        }
        return keys;
      },

      uniqueId: function(prefix) {
        var id = ++idCounter + '';
        return prefix ? prefix + id : id;
      },

      has: function(obj, key) {
        return hasOwnProperty.call(obj, key);
      },

      each: function(obj, iterator, context) {
        if (obj == null) return;
        if (nativeForEach && obj.forEach === nativeForEach) {
          obj.forEach(iterator, context);
        } else if (obj.length === +obj.length) {
          for (var i = 0, l = obj.length; i < l; i++) {
            if (iterator.call(context, obj[i], i, obj) === breaker) return;
          }
        } else {
          for (var key in obj) {
            if (this.has(obj, key)) {
              if (iterator.call(context, obj[key], key, obj) === breaker) return;
            }
          }
        }
      },

      once: function(func) {
        var ran = false, memo;
        return function() {
          if (ran) return memo;
          ran = true;
          memo = func.apply(this, arguments);
          func = null;
          return memo;
        };
      }
    };
  }

  var _ = miniscore(), Events;

  // Backbone.Events
  // ---------------

  // A module that can be mixed in to *any object* in order to provide it with
  // custom events. You may bind with `on` or remove with `off` callback
  // functions to an event; `trigger`-ing an event fires all callbacks in
  // succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  Events = {

    // Bind an event to a `callback` function. Passing `"all"` will bind
    // the callback to all events fired.
    on: function(name, callback, context) {
      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
      this._events || (this._events = {});
      var events = this._events[name] || (this._events[name] = []);
      events.push({callback: callback, context: context, ctx: context || this});
      return this;
    },

    // Bind an event to only be triggered a single time. After the first time
    // the callback is invoked, it will be removed.
    once: function(name, callback, context) {
      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
      var self = this;
      var once = _.once(function() {
        self.off(name, once);
        callback.apply(this, arguments);
      });
      once._callback = callback;
      return this.on(name, once, context);
    },

    // Remove one or many callbacks. If `context` is null, removes all
    // callbacks with that function. If `callback` is null, removes all
    // callbacks for the event. If `name` is null, removes all bound
    // callbacks for all events.
    off: function(name, callback, context) {
      var retain, ev, events, names, i, l, j, k;
      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
      if (!name && !callback && !context) {
        this._events = {};
        return this;
      }

      names = name ? [name] : _.keys(this._events);
      for (i = 0, l = names.length; i < l; i++) {
        name = names[i];
        if (events = this._events[name]) {
          this._events[name] = retain = [];
          if (callback || context) {
            for (j = 0, k = events.length; j < k; j++) {
              ev = events[j];
              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                  (context && context !== ev.context)) {
                retain.push(ev);
              }
            }
          }
          if (!retain.length) delete this._events[name];
        }
      }

      return this;
    },

    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    trigger: function(name) {
      if (!this._events) return this;
      var args = slice.call(arguments, 1);
      if (!eventsApi(this, 'trigger', name, args)) return this;
      var events = this._events[name];
      var allEvents = this._events.all;
      if (events) triggerEvents(events, args);
      if (allEvents) triggerEvents(allEvents, arguments);
      return this;
    },

    // Tell this object to stop listening to either specific events ... or
    // to every object it's currently listening to.
    stopListening: function(obj, name, callback) {
      var listeners = this._listeners;
      if (!listeners) return this;
      var deleteListener = !name && !callback;
      if (typeof name === 'object') callback = this;
      if (obj) (listeners = {})[obj._listenerId] = obj;
      for (var id in listeners) {
        listeners[id].off(name, callback, this);
        if (deleteListener) delete this._listeners[id];
      }
      return this;
    }

  };

  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // Implement fancy features of the Events API such as multiple event
  // names `"change blur"` and jQuery-style event maps `{change: action}`
  // in terms of the existing API.
  var eventsApi = function(obj, action, name, rest) {
    if (!name) return true;

    // Handle event maps.
    if (typeof name === 'object') {
      for (var key in name) {
        obj[action].apply(obj, [key, name[key]].concat(rest));
      }
      return false;
    }

    // Handle space separated event names.
    if (eventSplitter.test(name)) {
      var names = name.split(eventSplitter);
      for (var i = 0, l = names.length; i < l; i++) {
        obj[action].apply(obj, [names[i]].concat(rest));
      }
      return false;
    }

    return true;
  };

  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function(events, args) {
    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
    switch (args.length) {
      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);
    }
  };

  var listenMethods = {listenTo: 'on', listenToOnce: 'once'};

  // Inversion-of-control versions of `on` and `once`. Tell *this* object to
  // listen to an event in another object ... keeping track of what it's
  // listening to.
  _.each(listenMethods, function(implementation, method) {
    Events[method] = function(obj, name, callback) {
      var listeners = this._listeners || (this._listeners = {});
      var id = obj._listenerId || (obj._listenerId = _.uniqueId('l'));
      listeners[id] = obj;
      if (typeof name === 'object') callback = this;
      obj[implementation](name, callback, this);
      return this;
    };
  });

  // Aliases for backwards compatibility.
  Events.bind   = Events.on;
  Events.unbind = Events.off;

  // Mixin utility
  Events.mixin = function(proto) {
    var exports = ['on', 'once', 'off', 'trigger', 'stopListening', 'listenTo',
                   'listenToOnce', 'bind', 'unbind'];
    _.each(exports, function(name) {
      proto[name] = this[name];
    }, this);
    return proto;
  };

  // Export Events as BackboneEvents depending on current context
  if (typeof define === "function") {
    define(function() {
      return Events;
    });
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = Events;
    }
    exports.BackboneEvents = Events;
  } else {
    root.BackboneEvents = Events;
  }
})(this);

},{}],21:[function(_dereq_,module,exports){
module.exports = _dereq_('./backbone-events-standalone');

},{"./backbone-events-standalone":20}],22:[function(_dereq_,module,exports){
(function (process,global){
/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
 * @version   2.0.1
 */

(function() {
    "use strict";

    function $$utils$$objectOrFunction(x) {
      return typeof x === 'function' || (typeof x === 'object' && x !== null);
    }

    function $$utils$$isFunction(x) {
      return typeof x === 'function';
    }

    function $$utils$$isMaybeThenable(x) {
      return typeof x === 'object' && x !== null;
    }

    var $$utils$$_isArray;

    if (!Array.isArray) {
      $$utils$$_isArray = function (x) {
        return Object.prototype.toString.call(x) === '[object Array]';
      };
    } else {
      $$utils$$_isArray = Array.isArray;
    }

    var $$utils$$isArray = $$utils$$_isArray;
    var $$utils$$now = Date.now || function() { return new Date().getTime(); };
    function $$utils$$F() { }

    var $$utils$$o_create = (Object.create || function (o) {
      if (arguments.length > 1) {
        throw new Error('Second argument not supported');
      }
      if (typeof o !== 'object') {
        throw new TypeError('Argument must be an object');
      }
      $$utils$$F.prototype = o;
      return new $$utils$$F();
    });

    var $$asap$$len = 0;

    var $$asap$$default = function asap(callback, arg) {
      $$asap$$queue[$$asap$$len] = callback;
      $$asap$$queue[$$asap$$len + 1] = arg;
      $$asap$$len += 2;
      if ($$asap$$len === 2) {
        // If len is 1, that means that we need to schedule an async flush.
        // If additional callbacks are queued before the queue is flushed, they
        // will be processed by this flush that we are scheduling.
        $$asap$$scheduleFlush();
      }
    };

    var $$asap$$browserGlobal = (typeof window !== 'undefined') ? window : {};
    var $$asap$$BrowserMutationObserver = $$asap$$browserGlobal.MutationObserver || $$asap$$browserGlobal.WebKitMutationObserver;

    // test for web worker but not in IE10
    var $$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&
      typeof importScripts !== 'undefined' &&
      typeof MessageChannel !== 'undefined';

    // node
    function $$asap$$useNextTick() {
      return function() {
        process.nextTick($$asap$$flush);
      };
    }

    function $$asap$$useMutationObserver() {
      var iterations = 0;
      var observer = new $$asap$$BrowserMutationObserver($$asap$$flush);
      var node = document.createTextNode('');
      observer.observe(node, { characterData: true });

      return function() {
        node.data = (iterations = ++iterations % 2);
      };
    }

    // web worker
    function $$asap$$useMessageChannel() {
      var channel = new MessageChannel();
      channel.port1.onmessage = $$asap$$flush;
      return function () {
        channel.port2.postMessage(0);
      };
    }

    function $$asap$$useSetTimeout() {
      return function() {
        setTimeout($$asap$$flush, 1);
      };
    }

    var $$asap$$queue = new Array(1000);

    function $$asap$$flush() {
      for (var i = 0; i < $$asap$$len; i+=2) {
        var callback = $$asap$$queue[i];
        var arg = $$asap$$queue[i+1];

        callback(arg);

        $$asap$$queue[i] = undefined;
        $$asap$$queue[i+1] = undefined;
      }

      $$asap$$len = 0;
    }

    var $$asap$$scheduleFlush;

    // Decide what async method to use to triggering processing of queued callbacks:
    if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {
      $$asap$$scheduleFlush = $$asap$$useNextTick();
    } else if ($$asap$$BrowserMutationObserver) {
      $$asap$$scheduleFlush = $$asap$$useMutationObserver();
    } else if ($$asap$$isWorker) {
      $$asap$$scheduleFlush = $$asap$$useMessageChannel();
    } else {
      $$asap$$scheduleFlush = $$asap$$useSetTimeout();
    }

    function $$$internal$$noop() {}
    var $$$internal$$PENDING   = void 0;
    var $$$internal$$FULFILLED = 1;
    var $$$internal$$REJECTED  = 2;
    var $$$internal$$GET_THEN_ERROR = new $$$internal$$ErrorObject();

    function $$$internal$$selfFullfillment() {
      return new TypeError("You cannot resolve a promise with itself");
    }

    function $$$internal$$cannotReturnOwn() {
      return new TypeError('A promises callback cannot return that same promise.')
    }

    function $$$internal$$getThen(promise) {
      try {
        return promise.then;
      } catch(error) {
        $$$internal$$GET_THEN_ERROR.error = error;
        return $$$internal$$GET_THEN_ERROR;
      }
    }

    function $$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
      try {
        then.call(value, fulfillmentHandler, rejectionHandler);
      } catch(e) {
        return e;
      }
    }

    function $$$internal$$handleForeignThenable(promise, thenable, then) {
       $$asap$$default(function(promise) {
        var sealed = false;
        var error = $$$internal$$tryThen(then, thenable, function(value) {
          if (sealed) { return; }
          sealed = true;
          if (thenable !== value) {
            $$$internal$$resolve(promise, value);
          } else {
            $$$internal$$fulfill(promise, value);
          }
        }, function(reason) {
          if (sealed) { return; }
          sealed = true;

          $$$internal$$reject(promise, reason);
        }, 'Settle: ' + (promise._label || ' unknown promise'));

        if (!sealed && error) {
          sealed = true;
          $$$internal$$reject(promise, error);
        }
      }, promise);
    }

    function $$$internal$$handleOwnThenable(promise, thenable) {
      if (thenable._state === $$$internal$$FULFILLED) {
        $$$internal$$fulfill(promise, thenable._result);
      } else if (promise._state === $$$internal$$REJECTED) {
        $$$internal$$reject(promise, thenable._result);
      } else {
        $$$internal$$subscribe(thenable, undefined, function(value) {
          $$$internal$$resolve(promise, value);
        }, function(reason) {
          $$$internal$$reject(promise, reason);
        });
      }
    }

    function $$$internal$$handleMaybeThenable(promise, maybeThenable) {
      if (maybeThenable.constructor === promise.constructor) {
        $$$internal$$handleOwnThenable(promise, maybeThenable);
      } else {
        var then = $$$internal$$getThen(maybeThenable);

        if (then === $$$internal$$GET_THEN_ERROR) {
          $$$internal$$reject(promise, $$$internal$$GET_THEN_ERROR.error);
        } else if (then === undefined) {
          $$$internal$$fulfill(promise, maybeThenable);
        } else if ($$utils$$isFunction(then)) {
          $$$internal$$handleForeignThenable(promise, maybeThenable, then);
        } else {
          $$$internal$$fulfill(promise, maybeThenable);
        }
      }
    }

    function $$$internal$$resolve(promise, value) {
      if (promise === value) {
        $$$internal$$reject(promise, $$$internal$$selfFullfillment());
      } else if ($$utils$$objectOrFunction(value)) {
        $$$internal$$handleMaybeThenable(promise, value);
      } else {
        $$$internal$$fulfill(promise, value);
      }
    }

    function $$$internal$$publishRejection(promise) {
      if (promise._onerror) {
        promise._onerror(promise._result);
      }

      $$$internal$$publish(promise);
    }

    function $$$internal$$fulfill(promise, value) {
      if (promise._state !== $$$internal$$PENDING) { return; }

      promise._result = value;
      promise._state = $$$internal$$FULFILLED;

      if (promise._subscribers.length === 0) {
      } else {
        $$asap$$default($$$internal$$publish, promise);
      }
    }

    function $$$internal$$reject(promise, reason) {
      if (promise._state !== $$$internal$$PENDING) { return; }
      promise._state = $$$internal$$REJECTED;
      promise._result = reason;

      $$asap$$default($$$internal$$publishRejection, promise);
    }

    function $$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
      var subscribers = parent._subscribers;
      var length = subscribers.length;

      parent._onerror = null;

      subscribers[length] = child;
      subscribers[length + $$$internal$$FULFILLED] = onFulfillment;
      subscribers[length + $$$internal$$REJECTED]  = onRejection;

      if (length === 0 && parent._state) {
        $$asap$$default($$$internal$$publish, parent);
      }
    }

    function $$$internal$$publish(promise) {
      var subscribers = promise._subscribers;
      var settled = promise._state;

      if (subscribers.length === 0) { return; }

      var child, callback, detail = promise._result;

      for (var i = 0; i < subscribers.length; i += 3) {
        child = subscribers[i];
        callback = subscribers[i + settled];

        if (child) {
          $$$internal$$invokeCallback(settled, child, callback, detail);
        } else {
          callback(detail);
        }
      }

      promise._subscribers.length = 0;
    }

    function $$$internal$$ErrorObject() {
      this.error = null;
    }

    var $$$internal$$TRY_CATCH_ERROR = new $$$internal$$ErrorObject();

    function $$$internal$$tryCatch(callback, detail) {
      try {
        return callback(detail);
      } catch(e) {
        $$$internal$$TRY_CATCH_ERROR.error = e;
        return $$$internal$$TRY_CATCH_ERROR;
      }
    }

    function $$$internal$$invokeCallback(settled, promise, callback, detail) {
      var hasCallback = $$utils$$isFunction(callback),
          value, error, succeeded, failed;

      if (hasCallback) {
        value = $$$internal$$tryCatch(callback, detail);

        if (value === $$$internal$$TRY_CATCH_ERROR) {
          failed = true;
          error = value.error;
          value = null;
        } else {
          succeeded = true;
        }

        if (promise === value) {
          $$$internal$$reject(promise, $$$internal$$cannotReturnOwn());
          return;
        }

      } else {
        value = detail;
        succeeded = true;
      }

      if (promise._state !== $$$internal$$PENDING) {
        // noop
      } else if (hasCallback && succeeded) {
        $$$internal$$resolve(promise, value);
      } else if (failed) {
        $$$internal$$reject(promise, error);
      } else if (settled === $$$internal$$FULFILLED) {
        $$$internal$$fulfill(promise, value);
      } else if (settled === $$$internal$$REJECTED) {
        $$$internal$$reject(promise, value);
      }
    }

    function $$$internal$$initializePromise(promise, resolver) {
      try {
        resolver(function resolvePromise(value){
          $$$internal$$resolve(promise, value);
        }, function rejectPromise(reason) {
          $$$internal$$reject(promise, reason);
        });
      } catch(e) {
        $$$internal$$reject(promise, e);
      }
    }

    function $$$enumerator$$makeSettledResult(state, position, value) {
      if (state === $$$internal$$FULFILLED) {
        return {
          state: 'fulfilled',
          value: value
        };
      } else {
        return {
          state: 'rejected',
          reason: value
        };
      }
    }

    function $$$enumerator$$Enumerator(Constructor, input, abortOnReject, label) {
      this._instanceConstructor = Constructor;
      this.promise = new Constructor($$$internal$$noop, label);
      this._abortOnReject = abortOnReject;

      if (this._validateInput(input)) {
        this._input     = input;
        this.length     = input.length;
        this._remaining = input.length;

        this._init();

        if (this.length === 0) {
          $$$internal$$fulfill(this.promise, this._result);
        } else {
          this.length = this.length || 0;
          this._enumerate();
          if (this._remaining === 0) {
            $$$internal$$fulfill(this.promise, this._result);
          }
        }
      } else {
        $$$internal$$reject(this.promise, this._validationError());
      }
    }

    $$$enumerator$$Enumerator.prototype._validateInput = function(input) {
      return $$utils$$isArray(input);
    };

    $$$enumerator$$Enumerator.prototype._validationError = function() {
      return new Error('Array Methods must be provided an Array');
    };

    $$$enumerator$$Enumerator.prototype._init = function() {
      this._result = new Array(this.length);
    };

    var $$$enumerator$$default = $$$enumerator$$Enumerator;

    $$$enumerator$$Enumerator.prototype._enumerate = function() {
      var length  = this.length;
      var promise = this.promise;
      var input   = this._input;

      for (var i = 0; promise._state === $$$internal$$PENDING && i < length; i++) {
        this._eachEntry(input[i], i);
      }
    };

    $$$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
      var c = this._instanceConstructor;
      if ($$utils$$isMaybeThenable(entry)) {
        if (entry.constructor === c && entry._state !== $$$internal$$PENDING) {
          entry._onerror = null;
          this._settledAt(entry._state, i, entry._result);
        } else {
          this._willSettleAt(c.resolve(entry), i);
        }
      } else {
        this._remaining--;
        this._result[i] = this._makeResult($$$internal$$FULFILLED, i, entry);
      }
    };

    $$$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
      var promise = this.promise;

      if (promise._state === $$$internal$$PENDING) {
        this._remaining--;

        if (this._abortOnReject && state === $$$internal$$REJECTED) {
          $$$internal$$reject(promise, value);
        } else {
          this._result[i] = this._makeResult(state, i, value);
        }
      }

      if (this._remaining === 0) {
        $$$internal$$fulfill(promise, this._result);
      }
    };

    $$$enumerator$$Enumerator.prototype._makeResult = function(state, i, value) {
      return value;
    };

    $$$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
      var enumerator = this;

      $$$internal$$subscribe(promise, undefined, function(value) {
        enumerator._settledAt($$$internal$$FULFILLED, i, value);
      }, function(reason) {
        enumerator._settledAt($$$internal$$REJECTED, i, reason);
      });
    };

    var $$promise$all$$default = function all(entries, label) {
      return new $$$enumerator$$default(this, entries, true /* abort on reject */, label).promise;
    };

    var $$promise$race$$default = function race(entries, label) {
      /*jshint validthis:true */
      var Constructor = this;

      var promise = new Constructor($$$internal$$noop, label);

      if (!$$utils$$isArray(entries)) {
        $$$internal$$reject(promise, new TypeError('You must pass an array to race.'));
        return promise;
      }

      var length = entries.length;

      function onFulfillment(value) {
        $$$internal$$resolve(promise, value);
      }

      function onRejection(reason) {
        $$$internal$$reject(promise, reason);
      }

      for (var i = 0; promise._state === $$$internal$$PENDING && i < length; i++) {
        $$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);
      }

      return promise;
    };

    var $$promise$resolve$$default = function resolve(object, label) {
      /*jshint validthis:true */
      var Constructor = this;

      if (object && typeof object === 'object' && object.constructor === Constructor) {
        return object;
      }

      var promise = new Constructor($$$internal$$noop, label);
      $$$internal$$resolve(promise, object);
      return promise;
    };

    var $$promise$reject$$default = function reject(reason, label) {
      /*jshint validthis:true */
      var Constructor = this;
      var promise = new Constructor($$$internal$$noop, label);
      $$$internal$$reject(promise, reason);
      return promise;
    };

    var $$es6$promise$promise$$counter = 0;

    function $$es6$promise$promise$$needsResolver() {
      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
    }

    function $$es6$promise$promise$$needsNew() {
      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
    }

    var $$es6$promise$promise$$default = $$es6$promise$promise$$Promise;

    /**
      Promise objects represent the eventual result of an asynchronous operation. The
      primary way of interacting with a promise is through its `then` method, which
      registers callbacks to receive either a promises eventual value or the reason
      why the promise cannot be fulfilled.

      Terminology
      -----------

      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
      - `thenable` is an object or function that defines a `then` method.
      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
      - `exception` is a value that is thrown using the throw statement.
      - `reason` is a value that indicates why a promise was rejected.
      - `settled` the final resting state of a promise, fulfilled or rejected.

      A promise can be in one of three states: pending, fulfilled, or rejected.

      Promises that are fulfilled have a fulfillment value and are in the fulfilled
      state.  Promises that are rejected have a rejection reason and are in the
      rejected state.  A fulfillment value is never a thenable.

      Promises can also be said to *resolve* a value.  If this value is also a
      promise, then the original promise's settled state will match the value's
      settled state.  So a promise that *resolves* a promise that rejects will
      itself reject, and a promise that *resolves* a promise that fulfills will
      itself fulfill.


      Basic Usage:
      ------------

      ```js
      var promise = new Promise(function(resolve, reject) {
        // on success
        resolve(value);

        // on failure
        reject(reason);
      });

      promise.then(function(value) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Advanced Usage:
      ---------------

      Promises shine when abstracting away asynchronous interactions such as
      `XMLHttpRequest`s.

      ```js
      function getJSON(url) {
        return new Promise(function(resolve, reject){
          var xhr = new XMLHttpRequest();

          xhr.open('GET', url);
          xhr.onreadystatechange = handler;
          xhr.responseType = 'json';
          xhr.setRequestHeader('Accept', 'application/json');
          xhr.send();

          function handler() {
            if (this.readyState === this.DONE) {
              if (this.status === 200) {
                resolve(this.response);
              } else {
                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
              }
            }
          };
        });
      }

      getJSON('/posts.json').then(function(json) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Unlike callbacks, promises are great composable primitives.

      ```js
      Promise.all([
        getJSON('/posts'),
        getJSON('/comments')
      ]).then(function(values){
        values[0] // => postsJSON
        values[1] // => commentsJSON

        return values;
      });
      ```

      @class Promise
      @param {function} resolver
      Useful for tooling.
      @constructor
    */
    function $$es6$promise$promise$$Promise(resolver) {
      this._id = $$es6$promise$promise$$counter++;
      this._state = undefined;
      this._result = undefined;
      this._subscribers = [];

      if ($$$internal$$noop !== resolver) {
        if (!$$utils$$isFunction(resolver)) {
          $$es6$promise$promise$$needsResolver();
        }

        if (!(this instanceof $$es6$promise$promise$$Promise)) {
          $$es6$promise$promise$$needsNew();
        }

        $$$internal$$initializePromise(this, resolver);
      }
    }

    $$es6$promise$promise$$Promise.all = $$promise$all$$default;
    $$es6$promise$promise$$Promise.race = $$promise$race$$default;
    $$es6$promise$promise$$Promise.resolve = $$promise$resolve$$default;
    $$es6$promise$promise$$Promise.reject = $$promise$reject$$default;

    $$es6$promise$promise$$Promise.prototype = {
      constructor: $$es6$promise$promise$$Promise,

    /**
      The primary way of interacting with a promise is through its `then` method,
      which registers callbacks to receive either a promise's eventual value or the
      reason why the promise cannot be fulfilled.

      ```js
      findUser().then(function(user){
        // user is available
      }, function(reason){
        // user is unavailable, and you are given the reason why
      });
      ```

      Chaining
      --------

      The return value of `then` is itself a promise.  This second, 'downstream'
      promise is resolved with the return value of the first promise's fulfillment
      or rejection handler, or rejected if the handler throws an exception.

      ```js
      findUser().then(function (user) {
        return user.name;
      }, function (reason) {
        return 'default name';
      }).then(function (userName) {
        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
        // will be `'default name'`
      });

      findUser().then(function (user) {
        throw new Error('Found user, but still unhappy');
      }, function (reason) {
        throw new Error('`findUser` rejected and we're unhappy');
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
      });
      ```
      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.

      ```js
      findUser().then(function (user) {
        throw new PedagogicalException('Upstream error');
      }).then(function (value) {
        // never reached
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // The `PedgagocialException` is propagated all the way down to here
      });
      ```

      Assimilation
      ------------

      Sometimes the value you want to propagate to a downstream promise can only be
      retrieved asynchronously. This can be achieved by returning a promise in the
      fulfillment or rejection handler. The downstream promise will then be pending
      until the returned promise is settled. This is called *assimilation*.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // The user's comments are now available
      });
      ```

      If the assimliated promise rejects, then the downstream promise will also reject.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // If `findCommentsByAuthor` fulfills, we'll have the value here
      }, function (reason) {
        // If `findCommentsByAuthor` rejects, we'll have the reason here
      });
      ```

      Simple Example
      --------------

      Synchronous Example

      ```javascript
      var result;

      try {
        result = findResult();
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js
      findResult(function(result, err){
        if (err) {
          // failure
        } else {
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findResult().then(function(result){
        // success
      }, function(reason){
        // failure
      });
      ```

      Advanced Example
      --------------

      Synchronous Example

      ```javascript
      var author, books;

      try {
        author = findAuthor();
        books  = findBooksByAuthor(author);
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js

      function foundBooks(books) {

      }

      function failure(reason) {

      }

      findAuthor(function(author, err){
        if (err) {
          failure(err);
          // failure
        } else {
          try {
            findBoooksByAuthor(author, function(books, err) {
              if (err) {
                failure(err);
              } else {
                try {
                  foundBooks(books);
                } catch(reason) {
                  failure(reason);
                }
              }
            });
          } catch(error) {
            failure(err);
          }
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findAuthor().
        then(findBooksByAuthor).
        then(function(books){
          // found books
      }).catch(function(reason){
        // something went wrong
      });
      ```

      @method then
      @param {Function} onFulfilled
      @param {Function} onRejected
      Useful for tooling.
      @return {Promise}
    */
      then: function(onFulfillment, onRejection) {
        var parent = this;
        var state = parent._state;

        if (state === $$$internal$$FULFILLED && !onFulfillment || state === $$$internal$$REJECTED && !onRejection) {
          return this;
        }

        var child = new this.constructor($$$internal$$noop);
        var result = parent._result;

        if (state) {
          var callback = arguments[state - 1];
          $$asap$$default(function(){
            $$$internal$$invokeCallback(state, child, callback, result);
          });
        } else {
          $$$internal$$subscribe(parent, child, onFulfillment, onRejection);
        }

        return child;
      },

    /**
      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
      as the catch block of a try/catch statement.

      ```js
      function findAuthor(){
        throw new Error('couldn't find that author');
      }

      // synchronous
      try {
        findAuthor();
      } catch(reason) {
        // something went wrong
      }

      // async with promises
      findAuthor().catch(function(reason){
        // something went wrong
      });
      ```

      @method catch
      @param {Function} onRejection
      Useful for tooling.
      @return {Promise}
    */
      'catch': function(onRejection) {
        return this.then(null, onRejection);
      }
    };

    var $$es6$promise$polyfill$$default = function polyfill() {
      var local;

      if (typeof global !== 'undefined') {
        local = global;
      } else if (typeof window !== 'undefined' && window.document) {
        local = window;
      } else {
        local = self;
      }

      var es6PromiseSupport =
        "Promise" in local &&
        // Some of these methods are missing from
        // Firefox/Chrome experimental implementations
        "resolve" in local.Promise &&
        "reject" in local.Promise &&
        "all" in local.Promise &&
        "race" in local.Promise &&
        // Older version of the spec had a resolver object
        // as the arg rather than a function
        (function() {
          var resolve;
          new local.Promise(function(r) { resolve = r; });
          return $$utils$$isFunction(resolve);
        }());

      if (!es6PromiseSupport) {
        local.Promise = $$es6$promise$promise$$default;
      }
    };

    var es6$promise$umd$$ES6Promise = {
      'Promise': $$es6$promise$promise$$default,
      'polyfill': $$es6$promise$polyfill$$default
    };

    /* global define:true module:true window: true */
    if (typeof define === 'function' && define['amd']) {
      define(function() { return es6$promise$umd$$ES6Promise; });
    } else if (typeof module !== 'undefined' && module['exports']) {
      module['exports'] = es6$promise$umd$$ES6Promise;
    } else if (typeof this !== 'undefined') {
      this['ES6Promise'] = es6$promise$umd$$ES6Promise;
    }
}).call(this);
}).call(this,_dereq_("/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js"),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js":55}],23:[function(_dereq_,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = _dereq_('base64-js')
var ieee754 = _dereq_('ieee754')
var isArray = _dereq_('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var kMaxLength = 0x3fffffff

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Find the length
  var length
  if (type === 'number')
    length = subject > 0 ? subject >>> 0 : 0
  else if (type === 'string') {
    if (encoding === 'base64')
      subject = base64clean(subject)
    length = Buffer.byteLength(subject, encoding)
  } else if (type === 'object' && subject !== null) { // assume object is array-like
    if (subject.type === 'Buffer' && isArray(subject.data))
      subject = subject.data
    length = +subject.length > 0 ? Math.floor(+subject.length) : 0
  } else
    throw new TypeError('must start with number, buffer, array or string')

  if (this.length > kMaxLength)
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
      'size: 0x' + kMaxLength.toString(16) + ' bytes')

  var buf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer.TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    if (Buffer.isBuffer(subject)) {
      for (i = 0; i < length; i++)
        buf[i] = subject.readUInt8(i)
    } else {
      for (i = 0; i < length; i++)
        buf[i] = ((subject[i] % 256) + 256) % 256
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer.TYPED_ARRAY_SUPPORT && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

Buffer.isBuffer = function (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b))
    throw new TypeError('Arguments must be Buffers')

  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
  if (i !== len) {
    x = a[i]
    y = b[i]
  }
  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) throw new TypeError('Usage: Buffer.concat(list[, length])')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (totalLength === undefined) {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    case 'hex':
      ret = str.length >>> 1
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    default:
      ret = str.length
  }
  return ret
}

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function (encoding, start, end) {
  var loweredCase = false

  start = start >>> 0
  end = end === undefined || end === Infinity ? this.length : end >>> 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase)
          throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.equals = function (b) {
  if(!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max)
      str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b)
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(byte)) throw new Error('Invalid hex string')
    buf[offset + i] = byte
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function asciiWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function utf16leWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length, 2)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leWrite(this, string, offset, length)
      break
    default:
      throw new TypeError('Unknown encoding: ' + encoding)
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function binarySlice (buf, start, end) {
  return asciiSlice(buf, start, end)
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len;
    if (start < 0)
      start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0)
      end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start)
    end = start

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0)
    throw new RangeError('offset is not uint')
  if (offset + ext > length)
    throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80))
    return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  if (end < start) throw new TypeError('sourceEnd < sourceStart')
  if (target_start < 0 || target_start >= target.length)
    throw new TypeError('targetStart out of bounds')
  if (start < 0 || start >= source.length) throw new TypeError('sourceStart out of bounds')
  if (end < 0 || end > source.length) throw new TypeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + target_start] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new TypeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new TypeError('start out of bounds')
  if (end < 0 || end > this.length) throw new TypeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F) {
      byteArray.push(b)
    } else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++) {
        byteArray.push(parseInt(h[j], 16))
      }
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length, unitSize) {
  if (unitSize) length -= length % unitSize;
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

},{"base64-js":24,"ieee754":25,"is-array":26}],24:[function(_dereq_,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],25:[function(_dereq_,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],26:[function(_dereq_,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],27:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],28:[function(_dereq_,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],29:[function(_dereq_,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],30:[function(_dereq_,module,exports){
(function (global){
/*! http://mths.be/punycode v1.2.4 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports;
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^ -~]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /\x2E|\u3002|\uFF0E|\uFF61/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		while (length--) {
			array[length] = fn(array[length]);
		}
		return array;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings.
	 * @private
	 * @param {String} domain The domain name.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		return map(string.split(regexSeparators), fn).join('.');
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <http://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols to a Punycode string of ASCII-only
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name to Unicode. Only the
	 * Punycoded parts of the domain name will be converted, i.e. it doesn't
	 * matter if you call it on a string that has already been converted to
	 * Unicode.
	 * @memberOf punycode
	 * @param {String} domain The Punycode domain name to convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(domain) {
		return mapDomain(domain, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name to Punycode. Only the
	 * non-ASCII parts of the domain name will be converted, i.e. it doesn't
	 * matter if you call it with a domain that's already in ASCII.
	 * @memberOf punycode
	 * @param {String} domain The domain name to convert, as a Unicode string.
	 * @returns {String} The Punycode representation of the given domain name.
	 */
	function toASCII(domain) {
		return mapDomain(domain, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.2.4',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <http://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],31:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],32:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],33:[function(_dereq_,module,exports){
'use strict';

exports.decode = exports.parse = _dereq_('./decode');
exports.encode = exports.stringify = _dereq_('./encode');

},{"./decode":31,"./encode":32}],34:[function(_dereq_,module,exports){
module.exports = _dereq_("./lib/_stream_duplex.js")

},{"./lib/_stream_duplex.js":35}],35:[function(_dereq_,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

module.exports = Duplex;

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}
/*</replacement>*/


/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

var Readable = _dereq_('./_stream_readable');
var Writable = _dereq_('./_stream_writable');

util.inherits(Duplex, Readable);

forEach(objectKeys(Writable.prototype), function(method) {
  if (!Duplex.prototype[method])
    Duplex.prototype[method] = Writable.prototype[method];
});

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(this.end.bind(this));
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

}).call(this,_dereq_("/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"./_stream_readable":37,"./_stream_writable":39,"/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js":55,"core-util-is":40,"inherits":28}],36:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

module.exports = PassThrough;

var Transform = _dereq_('./_stream_transform');

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./_stream_transform":38,"core-util-is":40,"inherits":28}],37:[function(_dereq_,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;

/*<replacement>*/
var isArray = _dereq_('isarray');
/*</replacement>*/


/*<replacement>*/
var Buffer = _dereq_('buffer').Buffer;
/*</replacement>*/

Readable.ReadableState = ReadableState;

var EE = _dereq_('events').EventEmitter;

/*<replacement>*/
if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

var Stream = _dereq_('stream');

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

var StringDecoder;

util.inherits(Readable, Stream);

function ReadableState(options, stream) {
  options = options || {};

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = false;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // In streams that never have any data, and do push(null) right away,
  // the consumer can miss the 'end' event if they do some I/O before
  // consuming the stream.  So, we don't emit('end') until some reading
  // happens.
  this.calledRead = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;


  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = _dereq_('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (typeof chunk === 'string' && !state.objectMode) {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null || chunk === undefined) {
    state.reading = false;
    if (!state.ended)
      onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      // update the buffer info.
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront) {
        state.buffer.unshift(chunk);
      } else {
        state.reading = false;
        state.buffer.push(chunk);
      }

      if (state.needReadable)
        emitReadable(stream);

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = _dereq_('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (n === null || isNaN(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else
      return state.length;
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  var state = this._readableState;
  state.calledRead = true;
  var nOrig = n;
  var ret;

  if (typeof n !== 'number' || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    ret = null;

    // In cases where the decoder did not receive enough data
    // to produce a full chunk, then immediately received an
    // EOF, state.buffer will contain [<Buffer >, <Buffer 00 ...>].
    // howMuchToRead will see this and coerce the amount to
    // read to zero (because it's looking at the length of the
    // first <Buffer > in state.buffer), and we'll end up here.
    //
    // This can only happen via state.decoder -- no other venue
    // exists for pushing a zero-length chunk into state.buffer
    // and triggering this behavior. In this case, we return our
    // remaining data and end the stream, if appropriate.
    if (state.length > 0 && state.decoder) {
      ret = fromList(n, state);
      state.length -= ret.length;
    }

    if (state.length === 0)
      endReadable(this);

    return ret;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;

  // if we currently have less than the highWaterMark, then also read some
  if (state.length - n <= state.highWaterMark)
    doRead = true;

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading)
    doRead = false;

  if (doRead) {
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read called its callback synchronously, then `reading`
  // will be false, and we need to re-evaluate how much data we
  // can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we happened to read() exactly the remaining amount in the
  // buffer, and the EOF has been seen at this point, then make sure
  // that we emit 'end' on the very next tick.
  if (state.ended && !state.endEmitted && state.length === 0)
    endReadable(this);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.decoder && !state.ended) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // if we've ended and we have some data left, then emit
  // 'readable' now to make sure it gets picked up.
  if (state.length > 0)
    emitReadable(stream);
  else
    endReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (state.emittedReadable)
    return;

  state.emittedReadable = true;
  if (state.sync)
    process.nextTick(function() {
      emitReadable_(stream);
    });
  else
    emitReadable_(stream);
}

function emitReadable_(stream) {
  stream.emit('readable');
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(function() {
      maybeReadMore_(stream, state);
    });
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    process.nextTick(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    if (readable !== src) return;
    cleanup();
  }

  function onend() {
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (!dest._writableState || dest._writableState.needDrain)
      ondrain();
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    unpipe();
    dest.removeListener('error', onerror);
    if (EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS.
  if (!dest._events || !dest._events.error)
    dest.on('error', onerror);
  else if (isArray(dest._events.error))
    dest._events.error.unshift(onerror);
  else
    dest._events.error = [onerror, dest._events.error];



  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    // the handler that waits for readable events after all
    // the data gets sucked out in flow.
    // This would be easier to follow with a .once() handler
    // in flow(), but that is too slow.
    this.on('readable', pipeOnReadable);

    state.flowing = true;
    process.nextTick(function() {
      flow(src);
    });
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var dest = this;
    var state = src._readableState;
    state.awaitDrain--;
    if (state.awaitDrain === 0)
      flow(src);
  };
}

function flow(src) {
  var state = src._readableState;
  var chunk;
  state.awaitDrain = 0;

  function write(dest, i, list) {
    var written = dest.write(chunk);
    if (false === written) {
      state.awaitDrain++;
    }
  }

  while (state.pipesCount && null !== (chunk = src.read())) {

    if (state.pipesCount === 1)
      write(state.pipes, 0, null);
    else
      forEach(state.pipes, write);

    src.emit('data', chunk);

    // if anyone needs a drain, then we have to wait for that.
    if (state.awaitDrain > 0)
      return;
  }

  // if every destination was unpiped, either before entering this
  // function, or in the while loop, then stop flowing.
  //
  // NB: This is a pretty rare edge case.
  if (state.pipesCount === 0) {
    state.flowing = false;

    // if there were data event listeners added, then switch to old mode.
    if (EE.listenerCount(src, 'data') > 0)
      emitDataEvents(src);
    return;
  }

  // at this point, no one needed a drain, so we just ran out of data
  // on the next readable event, start it over again.
  state.ranOut = true;
}

function pipeOnReadable() {
  if (this._readableState.ranOut) {
    this._readableState.ranOut = false;
    flow(this);
  }
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data' && !this._readableState.flowing)
    emitDataEvents(this);

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        this.read(0);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  emitDataEvents(this);
  this.read(0);
  this.emit('resume');
};

Readable.prototype.pause = function() {
  emitDataEvents(this, true);
  this.emit('pause');
};

function emitDataEvents(stream, startPaused) {
  var state = stream._readableState;

  if (state.flowing) {
    // https://github.com/isaacs/readable-stream/issues/16
    throw new Error('Cannot switch to old mode now.');
  }

  var paused = startPaused || false;
  var readable = false;

  // convert to an old-style stream.
  stream.readable = true;
  stream.pipe = Stream.prototype.pipe;
  stream.on = stream.addListener = Stream.prototype.on;

  stream.on('readable', function() {
    readable = true;

    var c;
    while (!paused && (null !== (c = stream.read())))
      stream.emit('data', c);

    if (c === null) {
      readable = false;
      stream._readableState.needReadable = true;
    }
  });

  stream.pause = function() {
    paused = true;
    this.emit('pause');
  };

  stream.resume = function() {
    paused = false;
    if (readable)
      process.nextTick(function() {
        stream.emit('readable');
      });
    else
      this.read(0);
    this.emit('resume');
  };

  // now make it start, just in case it hadn't already.
  stream.emit('readable');
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    if (state.decoder)
      chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    //if (state.objectMode && util.isNullOrUndefined(chunk))
    if (state.objectMode && (chunk === null || chunk === undefined))
      return;
    else if (!state.objectMode && (!chunk || !chunk.length))
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (typeof stream[i] === 'function' &&
        typeof this[i] === 'undefined') {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }}(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted && state.calledRead) {
    state.ended = true;
    process.nextTick(function() {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    });
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this,_dereq_("/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js":55,"buffer":23,"core-util-is":40,"events":27,"inherits":28,"isarray":29,"stream":45,"string_decoder/":46}],38:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;

var Duplex = _dereq_('./_stream_duplex');

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);


function TransformState(options, stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined)
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  var ts = this._transformState = new TransformState(options, this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this.once('finish', function() {
    if ('function' === typeof this._flush)
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var rs = stream._readableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

},{"./_stream_duplex":35,"core-util-is":40,"inherits":28}],39:[function(_dereq_,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;

/*<replacement>*/
var Buffer = _dereq_('buffer').Buffer;
/*</replacement>*/

Writable.WritableState = WritableState;


/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

var Stream = _dereq_('stream');

util.inherits(Writable, Stream);

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream) {
  options = options || {};

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.buffer = [];

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;
}

function Writable(options) {
  var Duplex = _dereq_('./_stream_duplex');

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  process.nextTick(function() {
    cb(er);
  });
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    process.nextTick(function() {
      cb(er);
    });
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (typeof cb !== 'function')
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb))
    ret = writeOrBuffer(this, state, chunk, encoding, cb);

  return ret;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      typeof chunk === 'string') {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret)
    state.needDrain = true;

  if (state.writing)
    state.buffer.push(new WriteReq(chunk, encoding, cb));
  else
    doWrite(stream, state, len, chunk, encoding, cb);

  return ret;
}

function doWrite(stream, state, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  if (sync)
    process.nextTick(function() {
      cb(er);
    });
  else
    cb(er);

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished && !state.bufferProcessing && state.buffer.length)
      clearBuffer(stream, state);

    if (sync) {
      process.nextTick(function() {
        afterWrite(stream, state, finished, cb);
      });
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  cb();
  if (finished)
    finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;

  for (var c = 0; c < state.buffer.length; c++) {
    var entry = state.buffer[c];
    var chunk = entry.chunk;
    var encoding = entry.encoding;
    var cb = entry.callback;
    var len = state.objectMode ? 1 : chunk.length;

    doWrite(stream, state, len, chunk, encoding, cb);

    // if we didn't call the onwrite immediately, then
    // it means that we need to wait until it does.
    // also, that means that the chunk and cb are currently
    // being processed, so move the buffer counter past them.
    if (state.writing) {
      c++;
      break;
    }
  }

  state.bufferProcessing = false;
  if (c < state.buffer.length)
    state.buffer = state.buffer.slice(c);
  else
    state.buffer.length = 0;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (typeof chunk !== 'undefined' && chunk !== null)
    this.write(chunk, encoding);

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(stream, state) {
  return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing);
}

function finishMaybe(stream, state) {
  var need = needFinish(stream, state);
  if (need) {
    state.finished = true;
    stream.emit('finish');
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      process.nextTick(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

}).call(this,_dereq_("/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"./_stream_duplex":35,"/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js":55,"buffer":23,"core-util-is":40,"inherits":28,"stream":45}],40:[function(_dereq_,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

function isBuffer(arg) {
  return Buffer.isBuffer(arg);
}
exports.isBuffer = isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}
}).call(this,_dereq_("buffer").Buffer)
},{"buffer":23}],41:[function(_dereq_,module,exports){
module.exports = _dereq_("./lib/_stream_passthrough.js")

},{"./lib/_stream_passthrough.js":36}],42:[function(_dereq_,module,exports){
var Stream = _dereq_('stream'); // hack to fix a circular dependency issue when used with browserify
exports = module.exports = _dereq_('./lib/_stream_readable.js');
exports.Stream = Stream;
exports.Readable = exports;
exports.Writable = _dereq_('./lib/_stream_writable.js');
exports.Duplex = _dereq_('./lib/_stream_duplex.js');
exports.Transform = _dereq_('./lib/_stream_transform.js');
exports.PassThrough = _dereq_('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":35,"./lib/_stream_passthrough.js":36,"./lib/_stream_readable.js":37,"./lib/_stream_transform.js":38,"./lib/_stream_writable.js":39,"stream":45}],43:[function(_dereq_,module,exports){
module.exports = _dereq_("./lib/_stream_transform.js")

},{"./lib/_stream_transform.js":38}],44:[function(_dereq_,module,exports){
module.exports = _dereq_("./lib/_stream_writable.js")

},{"./lib/_stream_writable.js":39}],45:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = _dereq_('events').EventEmitter;
var inherits = _dereq_('inherits');

inherits(Stream, EE);
Stream.Readable = _dereq_('readable-stream/readable.js');
Stream.Writable = _dereq_('readable-stream/writable.js');
Stream.Duplex = _dereq_('readable-stream/duplex.js');
Stream.Transform = _dereq_('readable-stream/transform.js');
Stream.PassThrough = _dereq_('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":27,"inherits":28,"readable-stream/duplex.js":34,"readable-stream/passthrough.js":41,"readable-stream/readable.js":42,"readable-stream/transform.js":43,"readable-stream/writable.js":44}],46:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = _dereq_('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":23}],47:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var punycode = _dereq_('punycode');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = _dereq_('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a puny coded representation of "domain".
      // It only converts the part of the domain name that
      // has non ASCII characters. I.e. it dosent matter if
      // you call it with a domain that already is in ASCII.
      var domainArray = this.hostname.split('.');
      var newOut = [];
      for (var i = 0; i < domainArray.length; ++i) {
        var s = domainArray[i];
        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
            'xn--' + punycode.encode(s) : s);
      }
      this.hostname = newOut.join('.');
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  Object.keys(this).forEach(function(k) {
    result[k] = this[k];
  }, this);

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    Object.keys(relative).forEach(function(k) {
      if (k !== 'protocol')
        result[k] = relative[k];
    });

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      Object.keys(relative).forEach(function(k) {
        result[k] = relative[k];
      });
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!isNull(result.pathname) || !isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

function isString(arg) {
  return typeof arg === "string";
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return  arg == null;
}

},{"punycode":30,"querystring":33}],48:[function(_dereq_,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],49:[function(_dereq_,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = _dereq_('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = _dereq_('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,_dereq_("/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js"),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":48,"/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js":55,"inherits":28}],50:[function(_dereq_,module,exports){
var http = module.exports;
var EventEmitter = _dereq_('events').EventEmitter;
var Request = _dereq_('./lib/request');
var url = _dereq_('url')

http.request = function (params, cb) {
    if (typeof params === 'string') {
        params = url.parse(params)
    }
    if (!params) params = {};
    if (!params.host && !params.port) {
        params.port = parseInt(window.location.port, 10);
    }
    if (!params.host && params.hostname) {
        params.host = params.hostname;
    }

    if (!params.protocol) {
        if (params.scheme) {
            params.protocol = params.scheme + ':';
        } else {
            params.protocol = window.location.protocol;
        }
    }

    if (!params.host) {
        params.host = window.location.hostname || window.location.host;
    }
    if (/:/.test(params.host)) {
        if (!params.port) {
            params.port = params.host.split(':')[1];
        }
        params.host = params.host.split(':')[0];
    }
    if (!params.port) params.port = params.protocol == 'https:' ? 443 : 80;
    
    var req = new Request(new xhrHttp, params);
    if (cb) req.on('response', cb);
    return req;
};

http.get = function (params, cb) {
    params.method = 'GET';
    var req = http.request(params, cb);
    req.end();
    return req;
};

http.Agent = function () {};
http.Agent.defaultMaxSockets = 4;

var xhrHttp = (function () {
    if (typeof window === 'undefined') {
        throw new Error('no window object present');
    }
    else if (window.XMLHttpRequest) {
        return window.XMLHttpRequest;
    }
    else if (window.ActiveXObject) {
        var axs = [
            'Msxml2.XMLHTTP.6.0',
            'Msxml2.XMLHTTP.3.0',
            'Microsoft.XMLHTTP'
        ];
        for (var i = 0; i < axs.length; i++) {
            try {
                var ax = new(window.ActiveXObject)(axs[i]);
                return function () {
                    if (ax) {
                        var ax_ = ax;
                        ax = null;
                        return ax_;
                    }
                    else {
                        return new(window.ActiveXObject)(axs[i]);
                    }
                };
            }
            catch (e) {}
        }
        throw new Error('ajax not supported in this browser')
    }
    else {
        throw new Error('ajax not supported in this browser');
    }
})();

http.STATUS_CODES = {
    100 : 'Continue',
    101 : 'Switching Protocols',
    102 : 'Processing',                 // RFC 2518, obsoleted by RFC 4918
    200 : 'OK',
    201 : 'Created',
    202 : 'Accepted',
    203 : 'Non-Authoritative Information',
    204 : 'No Content',
    205 : 'Reset Content',
    206 : 'Partial Content',
    207 : 'Multi-Status',               // RFC 4918
    300 : 'Multiple Choices',
    301 : 'Moved Permanently',
    302 : 'Moved Temporarily',
    303 : 'See Other',
    304 : 'Not Modified',
    305 : 'Use Proxy',
    307 : 'Temporary Redirect',
    400 : 'Bad Request',
    401 : 'Unauthorized',
    402 : 'Payment Required',
    403 : 'Forbidden',
    404 : 'Not Found',
    405 : 'Method Not Allowed',
    406 : 'Not Acceptable',
    407 : 'Proxy Authentication Required',
    408 : 'Request Time-out',
    409 : 'Conflict',
    410 : 'Gone',
    411 : 'Length Required',
    412 : 'Precondition Failed',
    413 : 'Request Entity Too Large',
    414 : 'Request-URI Too Large',
    415 : 'Unsupported Media Type',
    416 : 'Requested Range Not Satisfiable',
    417 : 'Expectation Failed',
    418 : 'I\'m a teapot',              // RFC 2324
    422 : 'Unprocessable Entity',       // RFC 4918
    423 : 'Locked',                     // RFC 4918
    424 : 'Failed Dependency',          // RFC 4918
    425 : 'Unordered Collection',       // RFC 4918
    426 : 'Upgrade Required',           // RFC 2817
    428 : 'Precondition Required',      // RFC 6585
    429 : 'Too Many Requests',          // RFC 6585
    431 : 'Request Header Fields Too Large',// RFC 6585
    500 : 'Internal Server Error',
    501 : 'Not Implemented',
    502 : 'Bad Gateway',
    503 : 'Service Unavailable',
    504 : 'Gateway Time-out',
    505 : 'HTTP Version Not Supported',
    506 : 'Variant Also Negotiates',    // RFC 2295
    507 : 'Insufficient Storage',       // RFC 4918
    509 : 'Bandwidth Limit Exceeded',
    510 : 'Not Extended',               // RFC 2774
    511 : 'Network Authentication Required' // RFC 6585
};
},{"./lib/request":51,"events":27,"url":47}],51:[function(_dereq_,module,exports){
var Stream = _dereq_('stream');
var Response = _dereq_('./response');
var Base64 = _dereq_('Base64');
var inherits = _dereq_('inherits');

var Request = module.exports = function (xhr, params) {
    var self = this;
    self.writable = true;
    self.xhr = xhr;
    self.body = [];
    
    self.uri = (params.protocol || 'http:') + '//'
        + params.host
        + (params.port ? ':' + params.port : '')
        + (params.path || '/')
    ;
    
    if (typeof params.withCredentials === 'undefined') {
        params.withCredentials = true;
    }

    try { xhr.withCredentials = params.withCredentials }
    catch (e) {}
    
    if (params.responseType) try { xhr.responseType = params.responseType }
    catch (e) {}
    
    xhr.open(
        params.method || 'GET',
        self.uri,
        true
    );

    xhr.onerror = function(event) {
        self.emit('error', new Error('Network error'));
    };

    self._headers = {};
    
    if (params.headers) {
        var keys = objectKeys(params.headers);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (!self.isSafeRequestHeader(key)) continue;
            var value = params.headers[key];
            self.setHeader(key, value);
        }
    }
    
    if (params.auth) {
        //basic auth
        this.setHeader('Authorization', 'Basic ' + Base64.btoa(params.auth));
    }

    var res = new Response;
    res.on('close', function () {
        self.emit('close');
    });
    
    res.on('ready', function () {
        self.emit('response', res);
    });

    res.on('error', function (err) {
        self.emit('error', err);
    });
    
    xhr.onreadystatechange = function () {
        // Fix for IE9 bug
        // SCRIPT575: Could not complete the operation due to error c00c023f
        // It happens when a request is aborted, calling the success callback anyway with readyState === 4
        if (xhr.__aborted) return;
        res.handle(xhr);
    };
};

inherits(Request, Stream);

Request.prototype.setHeader = function (key, value) {
    this._headers[key.toLowerCase()] = value
};

Request.prototype.getHeader = function (key) {
    return this._headers[key.toLowerCase()]
};

Request.prototype.removeHeader = function (key) {
    delete this._headers[key.toLowerCase()]
};

Request.prototype.write = function (s) {
    this.body.push(s);
};

Request.prototype.destroy = function (s) {
    this.xhr.__aborted = true;
    this.xhr.abort();
    this.emit('close');
};

Request.prototype.end = function (s) {
    if (s !== undefined) this.body.push(s);

    var keys = objectKeys(this._headers);
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var value = this._headers[key];
        if (isArray(value)) {
            for (var j = 0; j < value.length; j++) {
                this.xhr.setRequestHeader(key, value[j]);
            }
        }
        else this.xhr.setRequestHeader(key, value)
    }

    if (this.body.length === 0) {
        this.xhr.send('');
    }
    else if (typeof this.body[0] === 'string') {
        this.xhr.send(this.body.join(''));
    }
    else if (isArray(this.body[0])) {
        var body = [];
        for (var i = 0; i < this.body.length; i++) {
            body.push.apply(body, this.body[i]);
        }
        this.xhr.send(body);
    }
    else if (/Array/.test(Object.prototype.toString.call(this.body[0]))) {
        var len = 0;
        for (var i = 0; i < this.body.length; i++) {
            len += this.body[i].length;
        }
        var body = new(this.body[0].constructor)(len);
        var k = 0;
        
        for (var i = 0; i < this.body.length; i++) {
            var b = this.body[i];
            for (var j = 0; j < b.length; j++) {
                body[k++] = b[j];
            }
        }
        this.xhr.send(body);
    }
    else if (isXHR2Compatible(this.body[0])) {
        this.xhr.send(this.body[0]);
    }
    else {
        var body = '';
        for (var i = 0; i < this.body.length; i++) {
            body += this.body[i].toString();
        }
        this.xhr.send(body);
    }
};

// Taken from http://dxr.mozilla.org/mozilla/mozilla-central/content/base/src/nsXMLHttpRequest.cpp.html
Request.unsafeHeaders = [
    "accept-charset",
    "accept-encoding",
    "access-control-request-headers",
    "access-control-request-method",
    "connection",
    "content-length",
    "cookie",
    "cookie2",
    "content-transfer-encoding",
    "date",
    "expect",
    "host",
    "keep-alive",
    "origin",
    "referer",
    "te",
    "trailer",
    "transfer-encoding",
    "upgrade",
    "user-agent",
    "via"
];

Request.prototype.isSafeRequestHeader = function (headerName) {
    if (!headerName) return false;
    return indexOf(Request.unsafeHeaders, headerName.toLowerCase()) === -1;
};

var objectKeys = Object.keys || function (obj) {
    var keys = [];
    for (var key in obj) keys.push(key);
    return keys;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

var indexOf = function (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (xs[i] === x) return i;
    }
    return -1;
};

var isXHR2Compatible = function (obj) {
    if (typeof Blob !== 'undefined' && obj instanceof Blob) return true;
    if (typeof ArrayBuffer !== 'undefined' && obj instanceof ArrayBuffer) return true;
    if (typeof FormData !== 'undefined' && obj instanceof FormData) return true;
};

},{"./response":52,"Base64":53,"inherits":54,"stream":45}],52:[function(_dereq_,module,exports){
var Stream = _dereq_('stream');
var util = _dereq_('util');

var Response = module.exports = function (res) {
    this.offset = 0;
    this.readable = true;
};

util.inherits(Response, Stream);

var capable = {
    streaming : true,
    status2 : true
};

function parseHeaders (res) {
    var lines = res.getAllResponseHeaders().split(/\r?\n/);
    var headers = {};
    for (var i = 0; i < lines.length; i++) {
        var line = lines[i];
        if (line === '') continue;
        
        var m = line.match(/^([^:]+):\s*(.*)/);
        if (m) {
            var key = m[1].toLowerCase(), value = m[2];
            
            if (headers[key] !== undefined) {
            
                if (isArray(headers[key])) {
                    headers[key].push(value);
                }
                else {
                    headers[key] = [ headers[key], value ];
                }
            }
            else {
                headers[key] = value;
            }
        }
        else {
            headers[line] = true;
        }
    }
    return headers;
}

Response.prototype.getResponse = function (xhr) {
    var respType = String(xhr.responseType).toLowerCase();
    if (respType === 'blob') return xhr.responseBlob || xhr.response;
    if (respType === 'arraybuffer') return xhr.response;
    return xhr.responseText;
}

Response.prototype.getHeader = function (key) {
    return this.headers[key.toLowerCase()];
};

Response.prototype.handle = function (res) {
    if (res.readyState === 2 && capable.status2) {
        try {
            this.statusCode = res.status;
            this.headers = parseHeaders(res);
        }
        catch (err) {
            capable.status2 = false;
        }
        
        if (capable.status2) {
            this.emit('ready');
        }
    }
    else if (capable.streaming && res.readyState === 3) {
        try {
            if (!this.statusCode) {
                this.statusCode = res.status;
                this.headers = parseHeaders(res);
                this.emit('ready');
            }
        }
        catch (err) {}
        
        try {
            this._emitData(res);
        }
        catch (err) {
            capable.streaming = false;
        }
    }
    else if (res.readyState === 4) {
        if (!this.statusCode) {
            this.statusCode = res.status;
            this.emit('ready');
        }
        this._emitData(res);
        
        if (res.error) {
            this.emit('error', this.getResponse(res));
        }
        else this.emit('end');
        
        this.emit('close');
    }
};

Response.prototype._emitData = function (res) {
    var respBody = this.getResponse(res);
    if (respBody.toString().match(/ArrayBuffer/)) {
        this.emit('data', new Uint8Array(respBody, this.offset));
        this.offset = respBody.byteLength;
        return;
    }
    if (respBody.length > this.offset) {
        this.emit('data', respBody.slice(this.offset));
        this.offset = respBody.length;
    }
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

},{"stream":45,"util":49}],53:[function(_dereq_,module,exports){
;(function () {

  var object = typeof exports != 'undefined' ? exports : this; // #8: web workers
  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

  function InvalidCharacterError(message) {
    this.message = message;
  }
  InvalidCharacterError.prototype = new Error;
  InvalidCharacterError.prototype.name = 'InvalidCharacterError';

  // encoder
  // [https://gist.github.com/999166] by [https://github.com/nignag]
  object.btoa || (
  object.btoa = function (input) {
    for (
      // initialize result and counter
      var block, charCode, idx = 0, map = chars, output = '';
      // if the next input index does not exist:
      //   change the mapping table to "="
      //   check if d has no fractional digits
      input.charAt(idx | 0) || (map = '=', idx % 1);
      // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
      output += map.charAt(63 & block >> 8 - idx % 1 * 8)
    ) {
      charCode = input.charCodeAt(idx += 3/4);
      if (charCode > 0xFF) {
        throw new InvalidCharacterError("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
      }
      block = block << 8 | charCode;
    }
    return output;
  });

  // decoder
  // [https://gist.github.com/1020396] by [https://github.com/atk]
  object.atob || (
  object.atob = function (input) {
    input = input.replace(/=+$/, '');
    if (input.length % 4 == 1) {
      throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
    }
    for (
      // initialize result and counters
      var bc = 0, bs, buffer, idx = 0, output = '';
      // get next character
      buffer = input.charAt(idx++);
      // character found in table? initialize bit storage and add its ascii value;
      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
        // and if not first of each 4 characters,
        // convert the first 8 bits to one ascii character
        bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
    ) {
      // try to find character in table (0-63, not found => -1)
      buffer = chars.indexOf(buffer);
    }
    return output;
  });

}());

},{}],54:[function(_dereq_,module,exports){
module.exports=_dereq_(28)
},{"/home/alex/projects/javascript/imjs/node_modules/grunt-browserify/node_modules/browserify/node_modules/inherits/inherits_browser.js":28}],55:[function(_dereq_,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.once = noop;
process.off = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],56:[function(_dereq_,module,exports){
(function (process){
var Stream = _dereq_('stream')

// through
//
// a stream that does nothing but re-emit the input.
// useful for aggregating a series of changing but not ending streams into one stream)

exports = module.exports = through
through.through = through

//create a readable writable stream.

function through (write, end, opts) {
  write = write || function (data) { this.queue(data) }
  end = end || function () { this.queue(null) }

  var ended = false, destroyed = false, buffer = [], _ended = false
  var stream = new Stream()
  stream.readable = stream.writable = true
  stream.paused = false

//  stream.autoPause   = !(opts && opts.autoPause   === false)
  stream.autoDestroy = !(opts && opts.autoDestroy === false)

  stream.write = function (data) {
    write.call(this, data)
    return !stream.paused
  }

  function drain() {
    while(buffer.length && !stream.paused) {
      var data = buffer.shift()
      if(null === data)
        return stream.emit('end')
      else
        stream.emit('data', data)
    }
  }

  stream.queue = stream.push = function (data) {
//    console.error(ended)
    if(_ended) return stream
    if(data == null) _ended = true
    buffer.push(data)
    drain()
    return stream
  }

  //this will be registered as the first 'end' listener
  //must call destroy next tick, to make sure we're after any
  //stream piped from here.
  //this is only a problem if end is not emitted synchronously.
  //a nicer way to do this is to make sure this is the last listener for 'end'

  stream.on('end', function () {
    stream.readable = false
    if(!stream.writable && stream.autoDestroy)
      process.nextTick(function () {
        stream.destroy()
      })
  })

  function _end () {
    stream.writable = false
    end.call(stream)
    if(!stream.readable && stream.autoDestroy)
      stream.destroy()
  }

  stream.end = function (data) {
    if(ended) return
    ended = true
    if(arguments.length) stream.write(data)
    _end() // will emit or queue
    return stream
  }

  stream.destroy = function () {
    if(destroyed) return
    destroyed = true
    ended = true
    buffer.length = 0
    stream.writable = stream.readable = false
    stream.emit('close')
    return stream
  }

  stream.pause = function () {
    if(stream.paused) return
    stream.paused = true
    return stream
  }

  stream.resume = function () {
    if(stream.paused) {
      stream.paused = false
      stream.emit('resume')
    }
    drain()
    //may have become paused again,
    //as drain emits 'data'.
    if(!stream.paused)
      stream.emit('drain')
    return stream
  }
  return stream
}


}).call(this,_dereq_("/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js":55,"stream":45}]},{},[2])(2)
});
})(window.intermine);
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],2:[function(require,module,exports){
module.exports=[{
  "selector": "node",
  "style": {
    "content": "data(label)"
  }
}, {
  "selector": ":selected",
  "style": {
    "text-outline-color": "black",
    "background-color": "gold",
    "border-color": "gold",
    "border-width": "5px",
    "border-style": "solid"
  }
}, {
  "selector": "edge",
  "style": {
    "width": "2px"
  }
}, {
  "selector": "edge[interactionType@=\"genetic\"]",
  "style": {
    "line-color": "#2c79be"
  }
}, {
  "selector": "edge[interactionType@=\"physical\"]",
  "style": {
    "line-color": "red"
  }
}, {
  "selector": "node[interactionType@=\"genetic\"]",
  "style": {
    "background-color": "#225f95"
  }
}, {
  "selector": "node[interactionType@=\"physical\"]",
  "style": {
    "background-color": "#c00"
  }
}]

},{}],3:[function(require,module,exports){
var _ = require('underscore'),
Cymine = function(records) {
  this.records = records;
  function toNodesAndEdges(records, parentNode){
    var d = {
      nodes : [],
      edges : []
    };

    for (var i in records) {
      var thisNode, row = records[i];
      thisNode = recordToNode(row);

      if(row.interactions) {
        //recursively make the interactions into nodes,
        //because node entities are nested at two levels.
        d = _.extend(d, toNodesAndEdges(row.interactions, thisNode));
      } else {
        //if it doesn't have an interaction list, it probably *is* an interaction
        //and thus needs to be an edge
        d.edges.push(interactionToEdge(parentNode, thisNode));
      }
      d.nodes.push(thisNode);
    }

    return d;
  };
  var recordToNode = function (obj) {
    var ret, data = {}, interaction;
    ret = obj.gene2 ? obj.gene2 : obj;
    interaction = getInteraction(obj);
    return {
      classes : interaction,
      data : {
        details : getDetails(obj),
        label   : nameNode(obj),
        class   : ret.class,
        interactionType : interaction,
        symbol  : ret.symbol,
        id : ret.primaryIdentifier //cytoscape needs strings, not ints
      }
    }
  };
  var getDetails = function(obj) {
    var details = obj.details ? obj.details[0] : {};
    details = collapseArrays(details);
    return details;
  },
  /**
   * While it's usefuly to see array indices if there are multiple elements,
   * There's not much point showing an index for just one array element.
   * This function collapses arrays with only one member and returns the member instead.
   * @param  {object} obj an object with arrays in its properties. Can be nested.
   * @return {object} the same object, just with 1-length arrays collapsed.
   */
  collapseArrays = function(obj){
    var ret = obj;
    for (var detail in ret){
      var theProp = ret[detail];
      if(Array.isArray(theProp)) {
        ret[detail] = (theProp.length === 1) ? theProp[0] : theProp;
      } else if(typeof theProp === "object") {
        theProp = collapseArrays(theProp);
      } // no need for a final else. Just leave string/int values as is.
    }
    return ret;
  },
  getInteraction = function(obj){
    var ret = "master";
    if (obj.details) {
      ret = obj.details[0].type;
    }
    return ret;
  },
  nameNode = function(obj) {
    if (obj.gene2 && obj.gene2.symbol) {
      return obj.gene2.symbol;
    } else if (obj.symbol) {
      return obj.symbol;
    } else if (obj.details) {
      return obj.details[0].name;
    } else {
      return "NAME MISSING";
    }
  },
  interactionToEdge = function(node, node2) {
    return {
      classes : node2.data.details.type,
      data : {
        source : node.data.id,
        target : node2.data.id,
        interactionType : node2.data.details.type
      }
    };
  }
  return toNodesAndEdges(records);

};

module.exports = Cymine;

},{"underscore":14}],4:[function(require,module,exports){
var cymineDataFormatter = require('./dataFormatter'),
imjs          = require('./../bower_components/imjs/js/im.js'),
cytoscape     = require('cytoscape'),
_             = require('underscore'),
strings       = require('./strings'),
query         = require('./query'),
cymineDisplay = require('./ui');
ES6Promise    = require('es6-promise')

function Cymine(args) {

  var ui,
  graph = _.extend({},args);
  return init()

/**
 * Checks if there is indeed an element to attach to, and failing that tries a default.
 * @return {boolean} whether or not we've found an element to attach to. Allows you to cancel the xhr
 *                          since there's nowhere to render it to.
 */
  function validateParent() {
    if(!graph.parentElem){
      var defaultElem = document.getElementById('cymine');
      if(defaultElem) {
        graph.parentElem = defaultElem;
        console.info(strings.dev.noParent.usingDefault);
      } else {
        console.error(strings.dev.noParent.noDefault);
        return false;
      }
    }
    return true;
  }

  function validateServiceRoot(){
    if(graph.service){
      return new imjs.Service({
        token: graph.service.token,
        root: graph.service.root,
        errorHandler: badServiceError
      });
    } else {
      throw new initError('noServiceUrl');
      return false;
    }
  }

  function prepQuery() {
    if(graph.queryOn) {
      _.extend(query.where[0],graph.queryOn);
      return true;
    } else {
      throw new initError('noQueryData');
      return false;
    }
  }

  function init(){
    return new ES6Promise.Promise(function(resolve, reject) {
      if(validateParent()) {
      ui = new cymineDisplay(graph);
      var mine = validateServiceRoot();
        if(prepQuery() && mine) {
          mine.records(query).then(function(response) {
            if (response.length > 0) {
              graph.data = new cymineDataFormatter(response);
              ui.init();
              console.debug('response:', response, 'graphdata:', graph);
              resolve(true);
            } else {
              ui.init(strings.user.noResults);
              resolve(false);
            }
          });
        }
      }
    });
  }
  /**
   * throw this error to console.error and display a user-facing error too
   * @param  {string} devMessage  this should be the key to a string in the strings.dev object.
   * @param  {[type]} userMessage optional - this should be the key to a string in the strings.user object. If not set, it will use the generic strings.user.noQuery message.
   */
  function initError(devMessage, userMessage){
    var um = userMessage ? userMessage : "noQueryData";
    ui.init(strings.user[um]);
    console.error(strings.dev[devMessage]);
  }
}
/**
 * helper method for calling services from imjs. Useful because we can only pass a reference to a functtion (without args) to imjs, so passing initError wouldn't allow us to set the dev error message.
 * @return {[type]} [description]
 */
function badServiceError(err){
    console.log("error thrown", err);
    throw new initError('badServiceUrl');
}

module.exports = Cymine;

},{"./../bower_components/imjs/js/im.js":1,"./dataFormatter":3,"./query":5,"./strings":6,"./ui":7,"cytoscape":12,"es6-promise":13,"underscore":14}],5:[function(require,module,exports){
module.exports={
  "name": "Gene_Interactions",
  "title": "Gene --> Interactions",
  "description": "Show all interactions for a given gene.",
  "constraintLogic": "A and B",
  "from": "Gene",
  "select": [
    "primaryIdentifier",
    "symbol",
    "interactions.gene2.symbol",
    "interactions.gene2.primaryIdentifier",
    "interactions.details.name",
    "interactions.details.role1",
    "interactions.details.role2",
    "interactions.details.type",
    "interactions.details.experiment.interactionDetectionMethods.name",
    "interactions.details.experiment.publication.pubMedId",
    "interactions.details.relationshipType.name",
    "interactions.details.dataSets.name"
  ],
  "orderBy": [
    {
      "path": "symbol",
      "direction": "ASC"
    }
  ],
  "where": [
    {
      "path": "Gene",
      "op": "LOOKUP",
      "code": "A",
      "editable": true,
      "switched": "LOCKED",
      "switchable": false,
    }
  ]
}

},{}],6:[function(require,module,exports){
module.exports={
  "user" : {
    "noResults" : "No interaction results for this query",
    "noQueryData" : "Problem loading query results"
  },
  "dev" : {
    "noParent" : {
      usingDefault : "Cymine: No parent element specified for Cymine. Using default '#cymine",
      noDefault : "Cymine: No parent element specified, and default '#cymine' not available."
    },
    "noQueryData" : "Cymine: No queryOn values supplied!",
    "noServiceUrl" : "Cymine: No serviceUrl defined, unable to query for interactions.",
    "badServiceUrl" : "Cymine: bad serviceUrl. Please check for typos and check this host is up."
  }
}

},{}],7:[function(require,module,exports){
var cymineHtml = require('./../template/cytomine.html'),
cyStyle = require('./cytoscapeStyle');
ui = function (graph) {
  this.graph = graph;
  var cy,
  display = function(node) {
    targetElem = graph.parentElem.querySelector('nodeDetails'),
    setTitle(node);
    listProperties(node);
  },
  setTitle = function (node) {
    var title = graph.parentElem.querySelector('.nodeTitle');
    title.innerHTML = node.label;
  },
  listProperties = function(node) {
    var display = expandPropertyVals(node),
    oldNodeInfo = graph.parentElem.querySelector('.nodeInfo');
    display.setAttribute('class', 'nodeInfo');
    oldNodeInfo.parentElement.replaceChild(display, oldNodeInfo);
  },
  getTemplate = function(){
    return cymineHtml;
  },
  expandPropertyVals = function(obj) {
    var display = document.createElement('dl'),
    dtTemp, ddTemp;
    for (var prop in obj) {
      dtTemp = document.createElement("dt");
      dtTemp.appendChild(document.createTextNode(prop));
      ddTemp = document.createElement("dd");
      if(typeof obj[prop] === "object") {
        ddTemp.setAttribute("class","child");
        ddTemp.appendChild(expandPropertyVals(obj[prop]));
      } else {
        ddTemp.appendChild(document.createTextNode(obj[prop]));
      }
      display.appendChild(dtTemp);
      display.appendChild(ddTemp);
    }
    return display;
  },
  init = function(errorMessage) {
    initHtml();
    if(!errorMessage) {
      initGraph();
    } else {
      noResults(errorMessage);
    }
  },
  controls = function() {
    var hiddenElems,
    getControls = function() {
      return graph.parentElem.querySelector('.controls');
    },
    selectInteractionType = function(e){
      var elem = e.target;
      if((elem !== e.currentTarget) && (elem.nodeName.toLowerCase() === "button")) {
        //visual button response
        removeAllButtonSelections();
        var elemClass = elem.className;//at this point we've stripped selected off. Should only be the type.
        addClass(elem, 'selected');

        //affect the graph:
        //old ones back:
        if(hiddenElems) {
          hiddenElems.restore();
        }
        //new ones gone:
        hiddenElems = cy.elements('[interactionType="' + elemClass + '"]').remove();
      }
    },
    listen = function() {
      getControls().addEventListener('click', selectInteractionType, false);
    },
    addClass = function(elem, classToAdd) {
      if (!hasClass(elem, classToAdd)) {
        elem.className += " " + classToAdd;
      }
    },
    removeClass = function(elem, classToRemove) {
      elem.className = elem.className.replace(classToRemove, "");
    },
    removeAllButtonSelections = function() {
      var theButtons = getControls().querySelectorAll('button');
      for (var i = 0; i < theButtons.length; i++) {
        removeClass(theButtons[i], ' selected');
        removeClass(theButtons[i], 'selected');
      }
    }
    hasClass = function(elem, classToCheckFor) {
      var classes = elem.className.split(" ");
      return (classes.indexOf(classToCheckFor) >= 0);
    }
    return {listen : listen};
  },
  initHtml = function () {
    graph.parentElem.innerHTML = getTemplate();
    graph.parentElem.className += " cymine";
    graph.statusBar = graph.parentElem.querySelector('.status');
  },
  initGraph = function() {
    graph.targetElem = graph.parentElem.querySelector('.cy');
    try{
      var interactionControls = controls();
      interactionControls.listen();
    } catch(e) {
      console.error(e);
    }
    //make the graph
    cy = cytoscape({
      container: graph.targetElem,
      layout: { name: 'cose'},
      elements: graph.data,
      style: cyStyle,

      ready: function(){
        window.cy = this;
        graph.statusBar.remove();
      }
    });

    //event listener for node taps
    cy.on('tap', 'node', function(){
      display(this.data());
    });

    cy.on('tap', 'edge', function(){
      display(this.data());
    });


  },
  noResults = function (message) {
    graph.statusBar.className = "status no-results";
    graph.statusBar.innerHTML = message;
  }

  return {
    init:init,
    noResults:noResults
  }

};

module.exports = ui;

},{"./../template/cytomine.html":15,"./cytoscapeStyle":2}],8:[function(require,module,exports){

},{}],9:[function(require,module,exports){
exports.endianness = function () { return 'LE' };

exports.hostname = function () {
    if (typeof location !== 'undefined') {
        return location.hostname
    }
    else return '';
};

exports.loadavg = function () { return [] };

exports.uptime = function () { return 0 };

exports.freemem = function () {
    return Number.MAX_VALUE;
};

exports.totalmem = function () {
    return Number.MAX_VALUE;
};

exports.cpus = function () { return [] };

exports.type = function () { return 'Browser' };

exports.release = function () {
    if (typeof navigator !== 'undefined') {
        return navigator.appVersion;
    }
    return '';
};

exports.networkInterfaces
= exports.getNetworkInterfaces
= function () { return {} };

exports.arch = function () { return 'javascript' };

exports.platform = function () { return 'browser' };

exports.tmpdir = exports.tmpDir = function () {
    return '/tmp';
};

exports.EOL = '\n';

},{}],10:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":11}],11:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            currentQueue[queueIndex].run();
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],12:[function(require,module,exports){
(function (process,__dirname){
/*!
 * This file is part of Cytoscape.js 2.4.5.
 * 
 * Cytoscape.js is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 * 
 * Cytoscape.js is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Lesser General Public License along with
 * Cytoscape.js. If not, see <http://www.gnu.org/licenses/>.
 */
 

// this is put as a global var in the browser
// or it's just a global to this module if commonjs

var cytoscape;

(function(window){ 'use strict';

  // the object iteself is a function that init's an instance of cytoscape

  var $$ = cytoscape = function(){ // jshint ignore:line
    return cytoscape.init.apply(cytoscape, arguments);
  };

  $$.version = '2.4.5';
  
  // allow functional access to cytoscape.js
  // e.g. var cyto = $.cytoscape({ selector: "#foo", ... });
  //      var nodes = cyto.nodes();
  $$.init = function( options ){
    
    // if no options specified, use default
    if( options === undefined ){
      options = {};
    }

    // create instance
    if( $$.is.plainObject( options ) ){
      return new $$.Core( options );
    } 
    
    // allow for registration of extensions
    // e.g. $.cytoscape('renderer', 'svg', SvgRenderer);
    // e.g. $.cytoscape('renderer', 'svg', 'nodeshape', 'ellipse', SvgEllipseNodeShape);
    // e.g. $.cytoscape('core', 'doSomething', function(){ /* doSomething code */ });
    // e.g. $.cytoscape('collection', 'doSomething', function(){ /* doSomething code */ });
    else if( $$.is.string( options ) ) {
      return $$.extension.apply($$.extension, arguments);
    }
  };

  // define the function namespace here, since it has members in many places
  $$.fn = {};

  if( typeof module !== 'undefined' && module.exports ){ // expose as a commonjs module
    module.exports = cytoscape;
  }

  if( typeof define !== 'undefined' && define.amd ){ // expose as an amd/requirejs module
    define('cytoscape', function(){
      return cytoscape;
    });
  }

  // make sure we always register in the window just in case (e.g. w/ derbyjs)
  if( window ){
    window.cytoscape = cytoscape;
  }
  
})( typeof window === 'undefined' ? null : window );

// extra set to `this` is necessary for meteor
this.cytoscape = cytoscape;

// internal, minimal Promise impl s.t. apis can return promises in old envs
// based on thenable (http://github.com/rse/thenable)

// NB: you must use `new $$.Promise`, because you may have native promises that don't autonew for you

;(function($$){ 'use strict';
  
  /*  promise states [Promises/A+ 2.1]  */
  var STATE_PENDING   = 0;                                         /*  [Promises/A+ 2.1.1]  */
  var STATE_FULFILLED = 1;                                         /*  [Promises/A+ 2.1.2]  */
  var STATE_REJECTED  = 2;                                         /*  [Promises/A+ 2.1.3]  */

  /*  promise object constructor  */
  var api = function (executor) {
    /*  optionally support non-constructor/plain-function call  */
    if (!(this instanceof api))
      return new api(executor);

    /*  initialize object  */
    this.id           = "Thenable/1.0.7";
    this.state        = STATE_PENDING; /*  initial state  */
    this.fulfillValue = undefined;     /*  initial value  */     /*  [Promises/A+ 1.3, 2.1.2.2]  */
    this.rejectReason = undefined;     /*  initial reason */     /*  [Promises/A+ 1.5, 2.1.3.2]  */
    this.onFulfilled  = [];            /*  initial handlers  */
    this.onRejected   = [];            /*  initial handlers  */

    /*  provide optional information-hiding proxy  */
    this.proxy = {
      then: this.then.bind(this)
    };

    /*  support optional executor function  */
    if (typeof executor === "function")
      executor.call(this, this.fulfill.bind(this), this.reject.bind(this));
  };

  /*  promise API methods  */
  api.prototype = {
    /*  promise resolving methods  */
    fulfill: function (value) { return deliver(this, STATE_FULFILLED, "fulfillValue", value); },
    reject:  function (value) { return deliver(this, STATE_REJECTED,  "rejectReason", value); },

    /*  "The then Method" [Promises/A+ 1.1, 1.2, 2.2]  */
    then: function (onFulfilled, onRejected) {
      var curr = this;
      var next = new api();                                    /*  [Promises/A+ 2.2.7]  */
      curr.onFulfilled.push(
        resolver(onFulfilled, next, "fulfill"));             /*  [Promises/A+ 2.2.2/2.2.6]  */
      curr.onRejected.push(
        resolver(onRejected,  next, "reject" ));             /*  [Promises/A+ 2.2.3/2.2.6]  */
      execute(curr);
      return next.proxy;                                       /*  [Promises/A+ 2.2.7, 3.3]  */
    }
  };

  /*  deliver an action  */
  var deliver = function (curr, state, name, value) {
    if (curr.state === STATE_PENDING) {
      curr.state = state;                                      /*  [Promises/A+ 2.1.2.1, 2.1.3.1]  */
      curr[name] = value;                                      /*  [Promises/A+ 2.1.2.2, 2.1.3.2]  */
      execute(curr);
    }
    return curr;
  };

  /*  execute all handlers  */
  var execute = function (curr) {
    if (curr.state === STATE_FULFILLED)
      execute_handlers(curr, "onFulfilled", curr.fulfillValue);
    else if (curr.state === STATE_REJECTED)
      execute_handlers(curr, "onRejected",  curr.rejectReason);
  };

  /*  execute particular set of handlers  */
  var execute_handlers = function (curr, name, value) {
    /* global process: true */
    /* global setImmediate: true */
    /* global setTimeout: true */

    /*  short-circuit processing  */
    if (curr[name].length === 0)
      return;

    /*  iterate over all handlers, exactly once  */
    var handlers = curr[name];
    curr[name] = [];                                             /*  [Promises/A+ 2.2.2.3, 2.2.3.3]  */
    var func = function () {
      for (var i = 0; i < handlers.length; i++)
        handlers[i](value);                                  /*  [Promises/A+ 2.2.5]  */
    };

    /*  execute procedure asynchronously  */                     /*  [Promises/A+ 2.2.4, 3.1]  */
    if (typeof process === "object" && typeof process.nextTick === "function")
      process.nextTick(func);
    else if (typeof setImmediate === "function")
      setImmediate(func);
    else
      setTimeout(func, 0);
  };

  /*  generate a resolver function  */
  var resolver = function (cb, next, method) {
    return function (value) {
      if (typeof cb !== "function")                            /*  [Promises/A+ 2.2.1, 2.2.7.3, 2.2.7.4]  */
        next[method].call(next, value);                      /*  [Promises/A+ 2.2.7.3, 2.2.7.4]  */
      else {
        var result;
        try { result = cb(value); }                          /*  [Promises/A+ 2.2.2.1, 2.2.3.1, 2.2.5, 3.2]  */
        catch (e) {
          next.reject(e);                                  /*  [Promises/A+ 2.2.7.2]  */
          return;
        }
        resolve(next, result);                               /*  [Promises/A+ 2.2.7.1]  */
      }
    };
  };

  /*  "Promise Resolution Procedure"  */                           /*  [Promises/A+ 2.3]  */
  var resolve = function (promise, x) {
    /*  sanity check arguments  */                               /*  [Promises/A+ 2.3.1]  */
    if (promise === x || promise.proxy === x) {
      promise.reject(new TypeError("cannot resolve promise with itself"));
      return;
    }

    /*  surgically check for a "then" method
      (mainly to just call the "getter" of "then" only once)  */
    var then;
    if ((typeof x === "object" && x !== null) || typeof x === "function") {
      try { then = x.then; }                                   /*  [Promises/A+ 2.3.3.1, 3.5]  */
      catch (e) {
        promise.reject(e);                                   /*  [Promises/A+ 2.3.3.2]  */
        return;
      }
    }

    /*  handle own Thenables    [Promises/A+ 2.3.2]
      and similar "thenables" [Promises/A+ 2.3.3]  */
    if (typeof then === "function") {
      var resolved = false;
      try {
        /*  call retrieved "then" method */                  /*  [Promises/A+ 2.3.3.3]  */
        then.call(x,
          /*  resolvePromise  */                           /*  [Promises/A+ 2.3.3.3.1]  */
          function (y) {
            if (resolved) return; resolved = true;       /*  [Promises/A+ 2.3.3.3.3]  */
            if (y === x)                                 /*  [Promises/A+ 3.6]  */
              promise.reject(new TypeError("circular thenable chain"));
            else
              resolve(promise, y);
          },

          /*  rejectPromise  */                            /*  [Promises/A+ 2.3.3.3.2]  */
          function (r) {
            if (resolved) return; resolved = true;       /*  [Promises/A+ 2.3.3.3.3]  */
            promise.reject(r);
          }
        );
      }
      catch (e) {
        if (!resolved)                                       /*  [Promises/A+ 2.3.3.3.3]  */
          promise.reject(e);                               /*  [Promises/A+ 2.3.3.3.4]  */
      }
      return;
    }

    /*  handle other values  */
    promise.fulfill(x);                                          /*  [Promises/A+ 2.3.4, 2.3.3.4]  */
  };

  // use native promises where possible
  $$.Promise = typeof Promise === 'undefined' ? api : Promise;

  // so we always have Promise.all()
  $$.Promise.all = $$.Promise.all || function( ps ){
    return new $$.Promise(function( resolveAll, rejectAll ){
      var vals = new Array( ps.length );
      var doneCount = 0;

      var fulfill = function( i, val ){
        vals[i] = val;
        doneCount++;

        if( doneCount === ps.length ){
          resolveAll( vals );
        }
      };

      for( var i = 0; i < ps.length; i++ ){
        (function( i ){
          var p = ps[i];
          var isPromise = p.then != null;

          if( isPromise ){
            p.then(function( val ){
              fulfill( i, val );
            }, function( err ){
              rejectAll( err );
            });
          } else {
            var val = p;
            fulfill( i, val );
          }
        })( i );
      }

    });
  };

})( cytoscape );
// type testing utility functions

;(function($$, window){ 'use strict';

  var typeofstr = typeof '';
  var typeofobj = typeof {};
  var typeoffn = typeof function(){};

  $$.is = {
    defined: function(obj){
      return obj != null; // not undefined or null
    },

    string: function(obj){
      return obj != null && typeof obj == typeofstr;
    },
    
    fn: function(obj){
      return obj != null && typeof obj === typeoffn;
    },
    
    array: function(obj){
      return Array.isArray ? Array.isArray(obj) : obj != null && obj instanceof Array;
    },
    
    plainObject: function(obj){
      return obj != null && typeof obj === typeofobj && !$$.is.array(obj) && obj.constructor === Object;
    },

    object: function(obj){
      return obj != null && typeof obj === typeofobj;
    },
    
    number: function(obj){
      return obj != null && typeof obj === typeof 1 && !isNaN(obj);
    },

    integer: function( obj ){
      return $$.is.number(obj) && Math.floor(obj) === obj;
    },
    
    color: function(obj){
      return obj != null && typeof obj === typeof '' && $.Color(obj).toString() !== '';
    },
    
    bool: function(obj){
      return obj != null && typeof obj === typeof true;
    },
    
    elementOrCollection: function(obj){
      return $$.is.element(obj) || $$.is.collection(obj);
    },
    
    element: function(obj){
      return obj instanceof $$.Element && obj._private.single;
    },
    
    collection: function(obj){
      return obj instanceof $$.Collection && !obj._private.single;
    },
    
    core: function(obj){
      return obj instanceof $$.Core;
    },

    style: function(obj){
      return obj instanceof $$.Style;
    },

    stylesheet: function(obj){
      return obj instanceof $$.Stylesheet;
    },

    event: function(obj){
      return obj instanceof $$.Event;
    },

    thread: function(obj){
      return obj instanceof $$.Thread;
    },

    fabric: function(obj){
      return obj instanceof $$.Fabric;
    },

    emptyString: function(obj){
      if( !obj ){ // null is empty
        return true; 
      } else if( $$.is.string(obj) ){
        if( obj === '' || obj.match(/^\s+$/) ){
          return true; // empty string is empty
        }
      }
      
      return false; // otherwise, we don't know what we've got
    },
    
    nonemptyString: function(obj){
      if( obj && $$.is.string(obj) && obj !== '' && !obj.match(/^\s+$/) ){
        return true;
      }

      return false;
    },

    domElement: function(obj){
      if( typeof HTMLElement === 'undefined' ){
        return false; // we're not in a browser so it doesn't matter
      } else {
        return obj instanceof HTMLElement;
      }
    },

    boundingBox: function(obj){
      return $$.is.plainObject(obj) && 
        $$.is.number(obj.x1) && $$.is.number(obj.x2) &&
        $$.is.number(obj.y1) && $$.is.number(obj.y2)
      ;
    },

    promise: function(obj){
      return $$.is.object(obj) && $$.is.fn(obj.then);
    },

    touch: function(){
      return window && ( ('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch );
    },

    gecko: function(){
      return typeof InstallTrigger !== 'undefined' || ('MozAppearance' in document.documentElement.style);
    },

    webkit: function(){
      return typeof webkitURL !== 'undefined' || ('WebkitAppearance' in document.documentElement.style);
    },

    chromium: function(){
      return typeof chrome !== 'undefined';
    },

    khtml: function(){
      return navigator.vendor.match(/kde/i); // TODO probably a better way to detect this...
    },

    khtmlEtc: function(){
      return $$.is.khtml() || $$.is.webkit() || $$.is.chromium();
    },

    trident: function(){
       return typeof ActiveXObject !== 'undefined' || /*@cc_on!@*/false;
    },

    windows: function(){
      return typeof navigator !== 'undefined' && navigator.appVersion.match(/Win/i);
    },

    mac: function(){
      return typeof navigator !== 'undefined' && navigator.appVersion.match(/Mac/i);
    },

    linux: function(){
      return typeof navigator !== 'undefined' && navigator.appVersion.match(/Linux/i);
    },

    unix: function(){
      return typeof navigator !== 'undefined' && navigator.appVersion.match(/X11/i);
    }
  };  
  
})( cytoscape, typeof window === 'undefined' ? null : window );

;(function($$, window){ 'use strict';
  
  // utility functions only for internal use

  $$.util = {

    // the jquery extend() function
    // NB: modified to use $$.is etc since we can't use jquery functions
    extend: function() {
      var options, name, src, copy, copyIsArray, clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;

      // Handle a deep copy situation
      if ( typeof target === 'boolean' ) {
        deep = target;
        target = arguments[1] || {};
        // skip the boolean and the target
        i = 2;
      }

      // Handle case when target is a string or something (possible in deep copy)
      if ( typeof target !== 'object' && !$$.is.fn(target) ) {
        target = {};
      }

      // extend jQuery itself if only one argument is passed
      if ( length === i ) {
        target = this;
        --i;
      }

      for ( ; i < length; i++ ) {
        // Only deal with non-null/undefined values
        if ( (options = arguments[ i ]) != null ) {
          // Extend the base object
          for ( name in options ) {
            src = target[ name ];
            copy = options[ name ];

            // Prevent never-ending loop
            if ( target === copy ) {
              continue;
            }

            // Recurse if we're merging plain objects or arrays
            if ( deep && copy && ( $$.is.plainObject(copy) || (copyIsArray = $$.is.array(copy)) ) ) {
              if ( copyIsArray ) {
                copyIsArray = false;
                clone = src && $$.is.array(src) ? src : [];

              } else {
                clone = src && $$.is.plainObject(src) ? src : {};
              }

              // Never move original objects, clone them
              target[ name ] = $$.util.extend( deep, clone, copy );

            // Don't bring in undefined values
            } else if ( copy !== undefined ) {
              target[ name ] = copy;
            }
          }
        }
      }

      // Return the modified object
      return target;
    },

    // require that pulls in module from commonjs, amd, or window (falling back until found)
    require: function( name, callback, options ){
      var ret;
      options = $$.util.extend({
        msgIfNotFound: true
      }, options);

      var done = false;
      var fulfil = function( ret ){
        done = true;
        callback( ret );
      };

      var checkWindow = function( next ){
        if( window ){ // detected browser/window env
          ret = window[ name ];
        }

        if( ret !== undefined ){ fulfil(ret); }
        if( next ){ next(); }
      };
      var onCheckWindowDone = function(){
        if( !done ){
          checkCommonJs( onCheckCommonJsDone );
        }
      };

      var checkCommonJs = function( next ){
        if( typeof module !== 'undefined' && module.exports && require ){ // detected commonjs env
          ret = require( name ); // regular require
        }

        if( ret !== undefined ){ fulfil(ret); }
        if( next ){ next(); }
      };
      var onCheckCommonJsDone = function(){
        if( !done ){
          checkAmd( onCheckAmdDone );
        }
      };

      var checkAmd = function( next ){
        if( typeof define !== 'undefined' && define.amd && require ){ // detected amd env w/ defined module
          require([ name ], function( nameImpl ){
            ret = nameImpl;
            
            if( ret !== undefined ){ fulfil(ret); }
            if( next ){ next(); }
          });
        }
      };
      var onCheckAmdDone = function(){
        if( !done && options.msgIfNotFound ){
          $$.util.error('Cytoscape.js tried to pull in dependency `' + name + '` but no module (i.e. CommonJS, AMD, or window) was found');
        }
      };

      // kick off 1st check: window
      checkWindow( onCheckWindowDone );

    },

    // multiple requires in one callback
    requires: function( names, callback ){
      var impls = [];
      var gotImpl = [];

      var checkDone = function(){
        for( var i = 0; i < names.length; i++ ){ // check have all impls
          if( !gotImpl[i] ){ return; }
        }

        // otherwise, all got all impls => done
        callback.apply( callback, impls ); 
      };

      for( var i = 0; i < names.length; i++ ){ (function(){ // w/scope
        var name = names[i];
        var index = i;

        $$.util.require(name, function(impl){
          impls[index] = impl;
          gotImpl[index] = true;

          checkDone();
        });
      })(); }
    },

    // ported lodash throttle function
    throttle: function(func, wait, options) {
      var leading = true,
          trailing = true;

      if (options === false) {
        leading = false;
      } else if ($$.is.plainObject(options)) {
        leading = 'leading' in options ? options.leading : leading;
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      options = options || {};
      options.leading = leading;
      options.maxWait = wait;
      options.trailing = trailing;

      return $$.util.debounce(func, wait, options);
    },

    now: function(){
      return +new Date();
    },

    // ported lodash debounce function
    debounce: function(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (!$$.is.fn(func)) {
        return;
      }
      wait = Math.max(0, wait) || 0;
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if ($$.is.plainObject(options)) {
        leading = options.leading;
        maxWait = 'maxWait' in options && (Math.max(wait, options.maxWait) || 0);
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      var delayed = function() {
        var remaining = wait - ($$.util.now() - stamp);
        if (remaining <= 0) {
          if (maxTimeoutId) {
            clearTimeout(maxTimeoutId);
          }
          var isCalled = trailingCall;
          maxTimeoutId = timeoutId = trailingCall = undefined;
          if (isCalled) {
            lastCalled = $$.util.now();
            result = func.apply(thisArg, args);
            if (!timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
          }
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      };

      var maxDelayed = function() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (trailing || (maxWait !== wait)) {
          lastCalled = $$.util.now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = null;
          }
        }
      };

      return function() {
        args = arguments;
        stamp = $$.util.now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }
        return result;
      };
    },

    error: function( msg ){
      if( console ){
        if( console.error ){
          console.error.apply( console, arguments );
        } else if( console.log ){
          console.log.apply( console, arguments );
        } else {
          throw msg;
        }
      } else {
        throw msg;
      }
    },    

    clone: function( obj ){
      var target = {};
      for (var i in obj) {
        if ( obj.hasOwnProperty(i) ) { // TODO is this hasOwnProperty() call necessary for our use?
          target[i] = obj[i];
        }
      }
      return target;
    },

    // gets a shallow copy of the argument
    copy: function( obj ){
      if( obj == null ){
        return obj;
      } if( $$.is.array(obj) ){
        return obj.slice();
      } else if( $$.is.plainObject(obj) ){
        return $$.util.clone( obj );
      } else {
        return obj;
      }
    },
    
    // makes a full bb (x1, y1, x2, y2, w, h) from implicit params
    makeBoundingBox: function( bb ){
      if( bb.x1 != null && bb.y1 != null ){
        if( bb.x2 != null && bb.y2 != null && bb.x2 >= bb.x1 && bb.y2 >= bb.y1 ){
          return {
            x1: bb.x1,
            y1: bb.y1,
            x2: bb.x2,
            y2: bb.y2,
            w: bb.x2 - bb.x1,
            h: bb.y2 - bb.y1
          };
        } else if( bb.w != null && bb.h != null && bb.w >= 0 && bb.h >= 0 ){
          return {
            x1: bb.x1,
            y1: bb.y1,
            x2: bb.x1 + bb.w,
            y2: bb.y1 + bb.h,
            w: bb.w,
            h: bb.h
          };
        }
      } 
    },

    // has anything been set in the map
    mapEmpty: function( map ){
      var empty = true;

      if( map != null ){
        for(var i in map){ // jshint ignore:line
          empty = false;
          break;
        }
      }

      return empty;
    },

    // pushes to the array at the end of a map (map may not be built)
    pushMap: function( options ){
      var array = $$.util.getMap(options);

      if( array == null ){ // if empty, put initial array
        $$.util.setMap( $.extend({}, options, {
          value: [ options.value ]
        }) );
      } else {
        array.push( options.value );
      }
    },

    // sets the value in a map (map may not be built)
    setMap: function( options ){
      var obj = options.map;
      var key;
      var keys = options.keys;
      var l = keys.length;

      for(var i = 0; i < l; i++){
        var key = keys[i];

        if( $$.is.plainObject( key ) ){
          $$.util.error('Tried to set map with object key');
        }

        if( i < keys.length - 1 ){
          
          // extend the map if necessary
          if( obj[key] == null ){
            obj[key] = {};
          }
          
          obj = obj[key];
        } else {
          // set the value
          obj[key] = options.value;
        }
      }
    },
    
    // gets the value in a map even if it's not built in places
    getMap: function( options ){
      var obj = options.map;
      var keys = options.keys;
      var l = keys.length;
      
      for(var i = 0; i < l; i++){
        var key = keys[i];

        if( $$.is.plainObject( key ) ){
          $$.util.error('Tried to get map with object key');
        }

        obj = obj[key];
        
        if( obj == null ){
          return obj;
        }
      }
      
      return obj;
    },

    // deletes the entry in the map
    deleteMap: function( options ){
      var obj = options.map;
      var keys = options.keys;
      var l = keys.length;
      var keepChildren = options.keepChildren;
      
      for(var i = 0; i < l; i++){
        var key = keys[i];

        if( $$.is.plainObject( key ) ){
          $$.util.error('Tried to delete map with object key');
        }

        var lastKey = i === options.keys.length - 1;
        if( lastKey ){
          
          if( keepChildren ){ // then only delete child fields not in keepChildren
            for( var child in obj ){
              if( !keepChildren[child] ){
                obj[child] = undefined;
              }
            }
          } else {
            obj[key] = undefined;
          }

        } else {
          obj = obj[key];
        }
      }
    },
    
    capitalize: function(str){
      if( $$.is.emptyString(str) ){
        return str;
      }
      
      return str.charAt(0).toUpperCase() + str.substring(1);
    },

    camel2dash: function( str ){
      var ret = [];

      for( var i = 0; i < str.length; i++ ){
        var ch = str[i];
        var chLowerCase = ch.toLowerCase();
        var isUpperCase = ch !== chLowerCase;

        if( isUpperCase ){
          ret.push( '-' );
          ret.push( chLowerCase );
        } else {
          ret.push( ch );
        }
      }

      var noUpperCases = ret.length === str.length;
      if( noUpperCases ){ return str; } // cheaper than .join()

      return ret.join('');
    },

    dash2camel: function( str ){
      var ret = [];
      var nextIsUpper = false;

      for( var i = 0; i < str.length; i++ ){
        var ch = str[i];
        var isDash = ch === '-';

        if( isDash ){
          nextIsUpper = true;
        } else {
          if( nextIsUpper ){
            ret.push( ch.toUpperCase() );
          } else {
            ret.push( ch );
          }

          nextIsUpper = false;
        }
      }

      return ret.join('');
    },

    // strip spaces from beginning of string and end of string
    trim: function( str ){
      var first, last;

      // find first non-space char
      for( first = 0; first < str.length && str[first] === ' '; first++ ){}

      // find last non-space char
      for( last = str.length - 1; last > first && str[last] === ' '; last-- ){}

      return str.substring(first, last + 1);
    },

    // get [r, g, b] from #abc or #aabbcc
    hex2tuple: function( hex ){
      if( !(hex.length === 4 || hex.length === 7) || hex[0] !== "#" ){ return; }

      var shortHex = hex.length === 4;
      var r, g, b;
      var base = 16;

      if( shortHex ){
        r = parseInt( hex[1] + hex[1], base );
        g = parseInt( hex[2] + hex[2], base );
        b = parseInt( hex[3] + hex[3], base );
      } else {
        r = parseInt( hex[1] + hex[2], base );
        g = parseInt( hex[3] + hex[4], base );
        b = parseInt( hex[5] + hex[6], base );
      }

      return [r, g, b];
    },

    // get [r, g, b, a] from hsl(0, 0, 0) or hsla(0, 0, 0, 0)
    hsl2tuple: function( hsl ){
      var ret;
      var h, s, l, a, r, g, b;
      function hue2rgb(p, q, t){
        if(t < 0) t += 1;
        if(t > 1) t -= 1;
        if(t < 1/6) return p + (q - p) * 6 * t;
        if(t < 1/2) return q;
        if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
      }

      var m = new RegExp("^" + $$.util.regex.hsla + "$").exec(hsl);
      if( m ){

        // get hue
        h = parseInt( m[1] ); 
        if( h < 0 ){
          h = ( 360 - (-1*h % 360) ) % 360;
        } else if( h > 360 ){
          h = h % 360;
        }
        h /= 360; // normalise on [0, 1]

        s = parseFloat( m[2] );
        if( s < 0 || s > 100 ){ return; } // saturation is [0, 100]
        s = s/100; // normalise on [0, 1]

        l = parseFloat( m[3] );
        if( l < 0 || l > 100 ){ return; } // lightness is [0, 100]
        l = l/100; // normalise on [0, 1]

        a = m[4];
        if( a !== undefined ){
          a = parseFloat( a );

          if( a < 0 || a > 1 ){ return; } // alpha is [0, 1]
        }

        // now, convert to rgb
        // code from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript
        if( s === 0 ){
          r = g = b = Math.round(l * 255); // achromatic
        } else {
          var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          var p = 2 * l - q;
          r = Math.round( 255 * hue2rgb(p, q, h + 1/3) );
          g = Math.round( 255 * hue2rgb(p, q, h) );
          b = Math.round( 255 * hue2rgb(p, q, h - 1/3) );
        }

        ret = [r, g, b, a];
      }

      return ret;
    },

    // get [r, g, b, a] from rgb(0, 0, 0) or rgba(0, 0, 0, 0)
    rgb2tuple: function( rgb ){
      var ret;

      var m = new RegExp("^" + $$.util.regex.rgba + "$").exec(rgb);
      if( m ){
        ret = [];

        var isPct = [];
        for( var i = 1; i <= 3; i++ ){
          var channel = m[i];

          if( channel[ channel.length - 1 ] === "%" ){
            isPct[i] = true;
          }
          channel = parseFloat( channel );

          if( isPct[i] ){
            channel = channel/100 * 255; // normalise to [0, 255]
          }

          if( channel < 0 || channel > 255 ){ return; } // invalid channel value

          ret.push( Math.floor(channel) );
        }

        var atLeastOneIsPct = isPct[1] || isPct[2] || isPct[3];
        var allArePct = isPct[1] && isPct[2] && isPct[3];
        if( atLeastOneIsPct && !allArePct ){ return; } // must all be percent values if one is

        var alpha = m[4];
        if( alpha !== undefined ){
          alpha = parseFloat( alpha );

          if( alpha < 0 || alpha > 1 ){ return; } // invalid alpha value

          ret.push( alpha );
        }
      }

      return ret;
    },

    colorname2tuple: function( color ){
      return $$.util.colors[ color.toLowerCase() ];
    },

    color2tuple: function( color ){
      return ( $$.is.array(color) ? color : null ) 
        || $$.util.colorname2tuple(color)
        || $$.util.hex2tuple(color)
        || $$.util.rgb2tuple(color)
        || $$.util.hsl2tuple(color);
    },

    tuple2hex: function( tuple ){
      var r = tuple[0];
      var g = tuple[1];
      var b = tuple[2];

      function ch2hex( ch ){
        var hex = ch.toString(16);

        if( hex.length === 1 ){
          hex = '0' + hex;
        }

        return hex;
      }

      return '#' + ch2hex(r) + ch2hex(g) + ch2hex(b);
    },

    colors: {
      // special colour names
      transparent:      [0,0,0,0], // NB alpha === 0

      // regular colours
      aliceblue:        [240,248,255],
      antiquewhite:      [250,235,215],
      aqua:          [0,255,255],
      aquamarine:        [127,255,212],
      azure:          [240,255,255],
      beige:          [245,245,220],
      bisque:          [255,228,196],
      black:          [0,0,0],
      blanchedalmond:      [255,235,205],
      blue:          [0,0,255],
      blueviolet:        [138,43,226],
      brown:          [165,42,42],
      burlywood:        [222,184,135],
      cadetblue:        [95,158,160],
      chartreuse:        [127,255,0],
      chocolate:        [210,105,30],
      coral:          [255,127,80],
      cornflowerblue:      [100,149,237],
      cornsilk:        [255,248,220],
      crimson:        [220,20,60],
      cyan:          [0,255,255],
      darkblue:        [0,0,139],
      darkcyan:        [0,139,139],
      darkgoldenrod:      [184,134,11],
      darkgray:        [169,169,169],
      darkgreen:        [0,100,0],
      darkgrey:        [169,169,169],
      darkkhaki:        [189,183,107],
      darkmagenta:      [139,0,139],
      darkolivegreen:      [85,107,47],
      darkorange:        [255,140,0],
      darkorchid:        [153,50,204],
      darkred:        [139,0,0],
      darksalmon:        [233,150,122],
      darkseagreen:      [143,188,143],
      darkslateblue:      [72,61,139],
      darkslategray:      [47,79,79],
      darkslategrey:      [47,79,79],
      darkturquoise:      [0,206,209],
      darkviolet:        [148,0,211],
      deeppink:        [255,20,147],
      deepskyblue:      [0,191,255],
      dimgray:        [105,105,105],
      dimgrey:        [105,105,105],
      dodgerblue:        [30,144,255],
      firebrick:        [178,34,34],
      floralwhite:      [255,250,240],
      forestgreen:      [34,139,34],
      fuchsia:        [255,0,255],
      gainsboro:        [220,220,220],
      ghostwhite:        [248,248,255],
      gold:          [255,215,0],
      goldenrod:        [218,165,32],
      gray:          [128,128,128],
      grey:          [128,128,128],
      green:          [0,128,0],
      greenyellow:      [173,255,47],
      honeydew:        [240,255,240],
      hotpink:        [255,105,180],
      indianred:        [205,92,92],
      indigo:          [75,0,130],
      ivory:          [255,255,240],
      khaki:          [240,230,140],
      lavender:        [230,230,250],
      lavenderblush:      [255,240,245],
      lawngreen:        [124,252,0],
      lemonchiffon:      [255,250,205],
      lightblue:        [173,216,230],
      lightcoral:        [240,128,128],
      lightcyan:        [224,255,255],
      lightgoldenrodyellow:  [250,250,210],
      lightgray:        [211,211,211],
      lightgreen:        [144,238,144],
      lightgrey:        [211,211,211],
      lightpink:        [255,182,193],
      lightsalmon:      [255,160,122],
      lightseagreen:      [32,178,170],
      lightskyblue:      [135,206,250],
      lightslategray:      [119,136,153],
      lightslategrey:      [119,136,153],
      lightsteelblue:      [176,196,222],
      lightyellow:      [255,255,224],
      lime:          [0,255,0],
      limegreen:        [50,205,50],
      linen:          [250,240,230],
      magenta:        [255,0,255],
      maroon:          [128,0,0],
      mediumaquamarine:    [102,205,170],
      mediumblue:        [0,0,205],
      mediumorchid:      [186,85,211],
      mediumpurple:      [147,112,219],
      mediumseagreen:      [60,179,113],
      mediumslateblue:    [123,104,238],
      mediumspringgreen:    [0,250,154],
      mediumturquoise:    [72,209,204],
      mediumvioletred:    [199,21,133],
      midnightblue:      [25,25,112],
      mintcream:        [245,255,250],
      mistyrose:        [255,228,225],
      moccasin:        [255,228,181],
      navajowhite:      [255,222,173],
      navy:          [0,0,128],
      oldlace:        [253,245,230],
      olive:          [128,128,0],
      olivedrab:        [107,142,35],
      orange:          [255,165,0],
      orangered:        [255,69,0],
      orchid:          [218,112,214],
      palegoldenrod:      [238,232,170],
      palegreen:        [152,251,152],
      paleturquoise:      [175,238,238],
      palevioletred:      [219,112,147],
      papayawhip:        [255,239,213],
      peachpuff:        [255,218,185],
      peru:          [205,133,63],
      pink:          [255,192,203],
      plum:          [221,160,221],
      powderblue:        [176,224,230],
      purple:          [128,0,128],
      red:          [255,0,0],
      rosybrown:        [188,143,143],
      royalblue:        [65,105,225],
      saddlebrown:      [139,69,19],
      salmon:          [250,128,114],
      sandybrown:        [244,164,96],
      seagreen:        [46,139,87],
      seashell:        [255,245,238],
      sienna:          [160,82,45],
      silver:          [192,192,192],
      skyblue:        [135,206,235],
      slateblue:        [106,90,205],
      slategray:        [112,128,144],
      slategrey:        [112,128,144],
      snow:          [255,250,250],
      springgreen:      [0,255,127],
      steelblue:        [70,130,180],
      tan:          [210,180,140],
      teal:          [0,128,128],
      thistle:        [216,191,216],
      tomato:          [255,99,71],
      turquoise:        [64,224,208],
      violet:          [238,130,238],
      wheat:          [245,222,179],
      white:          [255,255,255],
      whitesmoke:        [245,245,245],
      yellow:          [255,255,0],
      yellowgreen:      [154,205,50]
    }
      
  };

  $$.util.regex = {};
  
  $$.util.regex.number = "(?:[-]?\\d*\\.\\d+|[-]?\\d+|[-]?\\d*\\.\\d+[eE]\\d+)";
  
  $$.util.regex.rgba = "rgb[a]?\\(("+ $$.util.regex.number +"[%]?)\\s*,\\s*("+ $$.util.regex.number +"[%]?)\\s*,\\s*("+ $$.util.regex.number +"[%]?)(?:\\s*,\\s*("+ $$.util.regex.number +"))?\\)";
  $$.util.regex.rgbaNoBackRefs = "rgb[a]?\\((?:"+ $$.util.regex.number +"[%]?)\\s*,\\s*(?:"+ $$.util.regex.number +"[%]?)\\s*,\\s*(?:"+ $$.util.regex.number +"[%]?)(?:\\s*,\\s*(?:"+ $$.util.regex.number +"))?\\)";
  
  $$.util.regex.hsla = "hsl[a]?\\(("+ $$.util.regex.number +")\\s*,\\s*("+ $$.util.regex.number +"[%])\\s*,\\s*("+ $$.util.regex.number +"[%])(?:\\s*,\\s*("+ $$.util.regex.number +"))?\\)";
  $$.util.regex.hslaNoBackRefs = "hsl[a]?\\((?:"+ $$.util.regex.number +")\\s*,\\s*(?:"+ $$.util.regex.number +"[%])\\s*,\\s*(?:"+ $$.util.regex.number +"[%])(?:\\s*,\\s*(?:"+ $$.util.regex.number +"))?\\)";
  
  $$.util.regex.hex3 = "\\#[0-9a-fA-F]{3}";
  $$.util.regex.hex6 = "\\#[0-9a-fA-F]{6}";

  var raf = !window ? null : ( window.requestAnimationFrame || window.mozRequestAnimationFrame ||  
        window.webkitRequestAnimationFrame || window.msRequestAnimationFrame );

  raf = raf || function(fn){ if(fn){ setTimeout(fn, 1000/60); } };

  $$.util.requestAnimationFrame = function(fn){
    raf( fn );
  };

})( cytoscape, typeof window === 'undefined' ? null : window  );

;(function($$){ 'use strict';
  
  $$.math = {};
  
  $$.math.signum = function(x){
    if( x > 0 ){
      return 1;
    } else if( x < 0 ){
      return -1;
    } else {
      return 0;
    }
  };

  $$.math.distance = function( p1, p2 ){
    var dx = p2.x - p1.x;
    var dy = p2.y - p1.y;

    return Math.sqrt( dx*dx + dy*dy );
  };

  // from http://en.wikipedia.org/wiki/Bzier_curve#Quadratic_curves
  $$.math.qbezierAt = function(p0, p1, p2, t){
    return (1 - t)*(1 - t)*p0 + 2*(1 - t)*t*p1 + t*t*p2;
  };

  $$.math.qbezierPtAt = function(p0, p1, p2, t){
    return {
      x: $$.math.qbezierAt( p0.x, p1.x, p2.x, t ),
      y: $$.math.qbezierAt( p0.y, p1.y, p2.y, t )
    };
  };

  $$.math.boundingBoxesIntersect = function( bb1, bb2 ){
    // case: one bb to right of other
    if( bb1.x1 > bb2.x2 ){ return false; }
    if( bb2.x1 > bb1.x2 ){ return false; }

    // case: one bb to left of other
    if( bb1.x2 < bb2.x1 ){ return false; }
    if( bb2.x2 < bb1.x1 ){ return false; }

    // case: one bb above other
    if( bb1.y2 < bb2.y1 ){ return false; }
    if( bb2.y2 < bb1.y1 ){ return false; }

    // case: one bb below other
    if( bb1.y1 > bb2.y2 ){ return false; }
    if( bb2.y1 > bb1.y2 ){ return false; }

    // otherwise, must have some overlap
    return true;
  };

  $$.math.inBoundingBox = function( bb, x, y ){
    return bb.x1 <= x && x <= bb.x2 && bb.y1 <= y && y <= bb.y2;
  };

  $$.math.pointInBoundingBox = function( bb, pt ){
    return this.inBoundingBox( bb, pt.x, pt.y );
  };

  $$.math.roundRectangleIntersectLine = function(
    x, y, nodeX, nodeY, width, height, padding) {
    
    var cornerRadius = this.getRoundRectangleRadius(width, height);
    
    var halfWidth = width / 2;
    var halfHeight = height / 2;
    
    // Check intersections with straight line segments
    var straightLineIntersections;
    
    // Top segment, left to right
    {
      var topStartX = nodeX - halfWidth + cornerRadius - padding;
      var topStartY = nodeY - halfHeight - padding;
      var topEndX = nodeX + halfWidth - cornerRadius + padding;
      var topEndY = topStartY;
      
      straightLineIntersections = this.finiteLinesIntersect(
        x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);
      
      if (straightLineIntersections.length > 0) {
        return straightLineIntersections;
      }
    }
    
    // Right segment, top to bottom
    {
      var rightStartX = nodeX + halfWidth + padding;
      var rightStartY = nodeY - halfHeight + cornerRadius - padding;
      var rightEndX = rightStartX;
      var rightEndY = nodeY + halfHeight - cornerRadius + padding;
      
      straightLineIntersections = this.finiteLinesIntersect(
        x, y, nodeX, nodeY, rightStartX, rightStartY, rightEndX, rightEndY, false);
      
      if (straightLineIntersections.length > 0) {
        return straightLineIntersections;
      }
    }
    
    // Bottom segment, left to right
    {
      var bottomStartX = nodeX - halfWidth + cornerRadius - padding;
      var bottomStartY = nodeY + halfHeight + padding;
      var bottomEndX = nodeX + halfWidth - cornerRadius + padding;
      var bottomEndY = bottomStartY;
      
      straightLineIntersections = this.finiteLinesIntersect(
        x, y, nodeX, nodeY, bottomStartX, bottomStartY, bottomEndX, bottomEndY, false);
      
      if (straightLineIntersections.length > 0) {
        return straightLineIntersections;
      }
    }
    
    // Left segment, top to bottom
    {
      var leftStartX = nodeX - halfWidth - padding;
      var leftStartY = nodeY - halfHeight + cornerRadius - padding;
      var leftEndX = leftStartX;
      var leftEndY = nodeY + halfHeight - cornerRadius + padding;
      
      straightLineIntersections = this.finiteLinesIntersect(
        x, y, nodeX, nodeY, leftStartX, leftStartY, leftEndX, leftEndY, false);
      
      if (straightLineIntersections.length > 0) {
        return straightLineIntersections;
      }
    }
    
    // Check intersections with arc segments
    var arcIntersections;
    
    // Top Left
    {
      var topLeftCenterX = nodeX - halfWidth + cornerRadius;
      var topLeftCenterY = nodeY - halfHeight + cornerRadius;
      arcIntersections = this.intersectLineCircle(
        x, y, nodeX, nodeY, 
        topLeftCenterX, topLeftCenterY, cornerRadius + padding);
      
      // Ensure the intersection is on the desired quarter of the circle
      if (arcIntersections.length > 0
        && arcIntersections[0] <= topLeftCenterX
        && arcIntersections[1] <= topLeftCenterY) {
        return [arcIntersections[0], arcIntersections[1]];
      }
    }
    
    // Top Right
    {
      var topRightCenterX = nodeX + halfWidth - cornerRadius;
      var topRightCenterY = nodeY - halfHeight + cornerRadius;
      arcIntersections = this.intersectLineCircle(
        x, y, nodeX, nodeY, 
        topRightCenterX, topRightCenterY, cornerRadius + padding);
      
      // Ensure the intersection is on the desired quarter of the circle
      if (arcIntersections.length > 0
        && arcIntersections[0] >= topRightCenterX
        && arcIntersections[1] <= topRightCenterY) {
        return [arcIntersections[0], arcIntersections[1]];
      }
    }
    
    // Bottom Right
    {
      var bottomRightCenterX = nodeX + halfWidth - cornerRadius;
      var bottomRightCenterY = nodeY + halfHeight - cornerRadius;
      arcIntersections = this.intersectLineCircle(
        x, y, nodeX, nodeY, 
        bottomRightCenterX, bottomRightCenterY, cornerRadius + padding);
      
      // Ensure the intersection is on the desired quarter of the circle
      if (arcIntersections.length > 0
        && arcIntersections[0] >= bottomRightCenterX
        && arcIntersections[1] >= bottomRightCenterY) {
        return [arcIntersections[0], arcIntersections[1]];
      }
    }
    
    // Bottom Left
    {
      var bottomLeftCenterX = nodeX - halfWidth + cornerRadius;
      var bottomLeftCenterY = nodeY + halfHeight - cornerRadius;
      arcIntersections = this.intersectLineCircle(
        x, y, nodeX, nodeY, 
        bottomLeftCenterX, bottomLeftCenterY, cornerRadius + padding);
      
      // Ensure the intersection is on the desired quarter of the circle
      if (arcIntersections.length > 0
        && arcIntersections[0] <= bottomLeftCenterX
        && arcIntersections[1] >= bottomLeftCenterY) {
        return [arcIntersections[0], arcIntersections[1]];
      }
    }

    return []; // if nothing
  };
  
  $$.math.roundRectangleIntersectBox = function(
    boxX1, boxY1, boxX2, boxY2, width, height, centerX, centerY, padding) {
    
    // We have the following shpae
    
    //    _____
    //  _|     |_
    // |         |
    // |_       _|
    //   |_____|
    //
    // With a quarter circle at each corner.
    
    var cornerRadius = this.getRoundRectangleRadius(width, height);
    
    var hBoxTopLeftX = centerX - width / 2 - padding;
    var hBoxTopLeftY = centerY - height / 2 + cornerRadius - padding;
    var hBoxBottomRightX = centerX + width / 2 + padding;
    var hBoxBottomRightY = centerY + height / 2 - cornerRadius + padding;
    
    var vBoxTopLeftX = centerX - width / 2 + cornerRadius - padding;
    var vBoxTopLeftY = centerY - height / 2 - padding;
    var vBoxBottomRightX = centerX + width / 2 - cornerRadius + padding;
    var vBoxBottomRightY = centerY + height / 2 + padding;
    
    // Check if the box is out of bounds
    var boxMinX = Math.min(boxX1, boxX2);
    var boxMaxX = Math.max(boxX1, boxX2);
    var boxMinY = Math.min(boxY1, boxY2);
    var boxMaxY = Math.max(boxY1, boxY2);
    
    if (boxMaxX < hBoxTopLeftX) {
      return false;
    } else if (boxMinX > hBoxBottomRightX) {
      return false;
    }
    
    if (boxMaxY < vBoxTopLeftY) {
      return false;
    } else if (boxMinY > vBoxBottomRightY) {
      return false;
    }
    
    // Check if an hBox point is in given box
    if (hBoxTopLeftX >= boxMinX && hBoxTopLeftX <= boxMaxX
        && hBoxTopLeftY >= boxMinY && hBoxTopLeftY <= boxMaxY) {
      return true;
    }
    
    if (hBoxBottomRightX >= boxMinX && hBoxBottomRightX <= boxMaxX
        && hBoxTopLeftY >= boxMinY && hBoxTopLeftY <= boxMaxY) {
      return true;
    }
    
    if (hBoxBottomRightX >= boxMinX && hBoxBottomRightX <= boxMaxX
        && hBoxBottomRightY >= boxMinY && hBoxBottomRightY <= boxMaxY) {
      return true;
    }
    
    if (hBoxTopLeftX >= boxMinX && hBoxTopLeftX <= boxMaxX
        && hBoxBottomRightY >= boxMinY && hBoxBottomRightY <= boxMaxY) {
      return true;
    }
    
    // Check if a given point box is in the hBox
    if (boxMinX >= hBoxTopLeftX && boxMinX <= hBoxBottomRightX
      && boxMinY >= hBoxTopLeftY && boxMinY <= hBoxBottomRightY) {
      return true;
    }
    
    if (boxMaxX >= hBoxTopLeftX && boxMaxX <= hBoxBottomRightX
      && boxMinY >= hBoxTopLeftY && boxMinY <= hBoxBottomRightY) {
      return true;
    }
    
    if (boxMaxX >= hBoxTopLeftX && boxMaxX <= hBoxBottomRightX
      && boxMaxY >= hBoxTopLeftY && boxMaxY <= hBoxBottomRightY) {
      return true;
    }
    
    if (boxMinX >= hBoxTopLeftX && boxMinX <= hBoxBottomRightX
      && boxMaxY >= hBoxTopLeftY && boxMaxY <= hBoxBottomRightY) {
      return true;
    }
    
    // Check if an vBox point is in given box
    if (vBoxTopLeftX >= boxMinX && vBoxTopLeftX <= boxMaxX
        && vBoxTopLeftY >= boxMinY && vBoxTopLeftY <= boxMaxY) {
      return true;
    }
    
    if (vBoxBottomRightX >= boxMinX && vBoxBottomRightX <= boxMaxX
        && vBoxTopLeftY >= boxMinY && vBoxTopLeftY <= boxMaxY) {
      return true;
    }
    
    if (vBoxBottomRightX >= boxMinX && vBoxBottomRightX <= boxMaxX
        && vBoxBottomRightY >= boxMinY && vBoxBottomRightY <= boxMaxY) {
      return true;
    }
    
    if (vBoxTopLeftX >= boxMinX && vBoxTopLeftX <= boxMaxX
        && vBoxBottomRightY >= boxMinY && vBoxBottomRightY <= boxMaxY) {
      return true;
    }
    
    // Check if a given point box is in the vBox
    if (boxMinX >= vBoxTopLeftX && boxMinX <= vBoxBottomRightX
      && boxMinY >= vBoxTopLeftY && boxMinY <= vBoxBottomRightY) {
      return true;
    }
    
    if (boxMaxX >= vBoxTopLeftX && boxMaxX <= vBoxBottomRightX
      && boxMinY >= vBoxTopLeftY && boxMinY <= vBoxBottomRightY) {
      return true;
    }
    
    if (boxMaxX >= vBoxTopLeftX && boxMaxX <= vBoxBottomRightX
      && boxMaxY >= vBoxTopLeftY && boxMaxY <= vBoxBottomRightY) {
      return true;
    }
    
    if (boxMinX >= vBoxTopLeftX && boxMinX <= vBoxBottomRightX
      && boxMaxY >= vBoxTopLeftY && boxMaxY <= vBoxBottomRightY) {
      return true;
    }
    
    // Lastly, check if one of the ellipses coincide with the box
    
    if (this.boxIntersectEllipse(boxMinX, boxMinY, boxMaxX, boxMaxY, padding,
        cornerRadius * 2, cornerRadius * 2, vBoxTopLeftX + padding, hBoxTopLeftY + padding)) {
      return true;
    }
    
    if (this.boxIntersectEllipse(boxMinX, boxMinY, boxMaxX, boxMaxY, padding,
        cornerRadius * 2, cornerRadius * 2, vBoxBottomRightX - padding, hBoxTopLeftY + padding)) {
      return true;
    }
    
    if (this.boxIntersectEllipse(boxMinX, boxMinY, boxMaxX, boxMaxY, padding,
        cornerRadius * 2, cornerRadius * 2, vBoxBottomRightX - padding, hBoxBottomRightY - padding)) {
      return true;
    }
    
    if (this.boxIntersectEllipse(boxMinX, boxMinY, boxMaxX, boxMaxY, padding,
        cornerRadius * 2, cornerRadius * 2, vBoxTopLeftX + padding, hBoxBottomRightY - padding)) {
      return true;
    }
    
    return false;
  };
  
  // @O Approximate collision functions
  $$.math.checkInBoundingCircle = function(
    x, y, farthestPointSqDistance, padding, width, height, centerX, centerY) {
    
    x = (x - centerX) / (width + padding);
    y = (y - centerY) / (height + padding);
    
    return (x * x + y * y) <= farthestPointSqDistance;
  };
  
  $$.math.boxInBezierVicinity = function(
    x1box, y1box, x2box, y2box, x1, y1, x2, y2, x3, y3, tolerance) {
    
    // Return values:
    // 0 - curve is not in box
    // 1 - curve may be in box; needs precise check
    // 2 - curve is in box
    
    // midpoint
    var midX = 0.25 * x1 + 0.5 * x2 + 0.25 * x3;
    var midY = 0.25 * y1 + 0.5 * y2 + 0.25 * y3;

    var boxMinX = Math.min(x1box, x2box) - tolerance;
    var boxMinY = Math.min(y1box, y2box) - tolerance;
    var boxMaxX = Math.max(x1box, x2box) + tolerance;
    var boxMaxY = Math.max(y1box, y2box) + tolerance;
    
    if (x1 >= boxMinX && x1 <= boxMaxX && y1 >= boxMinY && y1 <= boxMaxY) { // (x1, y1) in box
      return 1;
    } else if (x3 >= boxMinX && x3 <= boxMaxX && y3 >= boxMinY && y3 <= boxMaxY) { // (x3, y3) in box
      return 1;
    } else if (midX >= boxMinX && midX <= boxMaxX && midY >= boxMinY && midY <= boxMaxY) { // (midX, midY) in box
      return 1;
    } else if (x2 >= boxMinX && x2 <= boxMaxX && y2 >= boxMinY && y2 <= boxMaxY) { // ctrl pt in box
      return 1;
    }
    
    var curveMinX = Math.min(x1, midX, x3);
    var curveMinY = Math.min(y1, midY, y3);
    var curveMaxX = Math.max(x1, midX, x3);
    var curveMaxY = Math.max(y1, midY, y3);
    
    /*
    console.log(curveMinX + ", " + curveMinY + ", " + curveMaxX 
      + ", " + curveMaxY);
    if (curveMinX == undefined) {
      console.log("undefined curveMinX: " + x1 + ", " + x2 + ", " + x3);
    }
    */
    
    if (curveMinX > boxMaxX
      || curveMaxX < boxMinX
      || curveMinY > boxMaxY
      || curveMaxY < boxMinY) {
      
      return 0;  
    }
    
    return 1;
  };

  $$.math.checkBezierInBox = function(
    x1box, y1box, x2box, y2box, x1, y1, x2, y2, x3, y3, tolerance) {

    function sampleInBox(t){
      var x = $$.math.qbezierAt(x1, x2, x3, t);
      var y = $$.math.qbezierAt(y1, y2, y3, t);

      return x1box <= x && x <= x2box
        && y1box <= y && y <= y2box
      ;
    }

    for( var t = 0; t <= 1; t += 0.25 ){
      if( !sampleInBox(t) ){
        return false;
      }
    }

    return true;
  };
  
  $$.math.checkStraightEdgeInBox = function(
    x1box, y1box, x2box, y2box, x1, y1, x2, y2, tolerance) {

    return x1box <= x1 && x1 <= x2box
      && x1box <= x2 && x2 <= x2box
      && y1box <= y1 && y1 <= y2box
      && y1box <= y2 && y2 <= y2box
    ;
  };

  $$.math.checkStraightEdgeCrossesBox = function(
    x1box, y1box, x2box, y2box, x1, y1, x2, y2, tolerance) {
    
   //console.log(arguments);
    
    var boxMinX = Math.min(x1box, x2box) - tolerance;
    var boxMinY = Math.min(y1box, y2box) - tolerance;
    var boxMaxX = Math.max(x1box, x2box) + tolerance;
    var boxMaxY = Math.max(y1box, y2box) + tolerance;
    
    // Check left + right bounds
    var aX = x2 - x1;
    var bX = x1;
    var yValue;
    
    // Top and bottom
    var aY = y2 - y1;
    var bY = y1;
    var xValue;
    
    if (Math.abs(aX) < 0.0001) {
      return (x1 >= boxMinX && x1 <= boxMaxX
        && Math.min(y1, y2) <= boxMinY
        && Math.max(y1, y2) >= boxMaxY);  
    }
    
    var tLeft = (boxMinX - bX) / aX;
    if (tLeft > 0 && tLeft <= 1) {
      yValue = aY * tLeft + bY;
      if (yValue >= boxMinY && yValue <= boxMaxY) {
        return true;
      } 
    }
    
    var tRight = (boxMaxX - bX) / aX;
    if (tRight > 0 && tRight <= 1) {
      yValue = aY * tRight + bY;
      if (yValue >= boxMinY && yValue <= boxMaxY) {
        return true;
      } 
    }
    
    var tTop = (boxMinY - bY) / aY;
    if (tTop > 0 && tTop <= 1) {
      xValue = aX * tTop + bX;
      if (xValue >= boxMinX && xValue <= boxMaxX) {
        return true;
      } 
    }
    
    var tBottom = (boxMaxY - bY) / aY;
    if (tBottom > 0 && tBottom <= 1) {
      xValue = aX * tBottom + bX;
      if (xValue >= boxMinX && xValue <= boxMaxX) {
        return true;
      } 
    }
    
    return false;
  };
  
  $$.math.checkBezierCrossesBox = function(
    x1box, y1box, x2box, y2box, x1, y1, x2, y2, x3, y3, tolerance) {
    
    var boxMinX = Math.min(x1box, x2box) - tolerance;
    var boxMinY = Math.min(y1box, y2box) - tolerance;
    var boxMaxX = Math.max(x1box, x2box) + tolerance;
    var boxMaxY = Math.max(y1box, y2box) + tolerance;
    
    if (x1 >= boxMinX && x1 <= boxMaxX && y1 >= boxMinY && y1 <= boxMaxY) {
      return true;
    } else if (x3 >= boxMinX && x3 <= boxMaxX && y3 >= boxMinY && y3 <= boxMaxY) {
      return true;
    }
    
    var aX = x1 - 2 * x2 + x3;
    var bX = -2 * x1 + 2 * x2;
    var cX = x1;

    var xIntervals = [];
    
    if (Math.abs(aX) < 0.0001) {
      var leftParam = (boxMinX - x1) / bX;
      var rightParam = (boxMaxX - x1) / bX;
      
      xIntervals.push(leftParam, rightParam);
    } else {
      // Find when x coordinate of the curve crosses the left side of the box
      var discriminantX1 = bX * bX - 4 * aX * (cX - boxMinX);
      var tX1, tX2;
      if (discriminantX1 > 0) {
        var sqrt = Math.sqrt(discriminantX1);
        tX1 = (-bX + sqrt) / (2 * aX);
        tX2 = (-bX - sqrt) / (2 * aX);
        
        xIntervals.push(tX1, tX2);
      }
      
      var discriminantX2 = bX * bX - 4 * aX * (cX - boxMaxX);
      var tX3, tX4;
      if (discriminantX2 > 0) {
        var sqrt = Math.sqrt(discriminantX2);
        tX3 = (-bX + sqrt) / (2 * aX);
        tX4 = (-bX - sqrt) / (2 * aX);
        
        xIntervals.push(tX3, tX4);
      }
    }
    
    xIntervals.sort(function(a, b) { return a - b; });
    
    var aY = y1 - 2 * y2 + y3;
    var bY = -2 * y1 + 2 * y2;
    var cY = y1;
    
    var yIntervals = [];
    
    if (Math.abs(aY) < 0.0001) {
      var topParam = (boxMinY - y1) / bY;
      var bottomParam = (boxMaxY - y1) / bY;
      
      yIntervals.push(topParam, bottomParam);
    } else {
      var discriminantY1 = bY * bY - 4 * aY * (cY - boxMinY);
      
      var tY1, tY2;
      if (discriminantY1 > 0) {
        var sqrt = Math.sqrt(discriminantY1);
        tY1 = (-bY + sqrt) / (2 * aY);
        tY2 = (-bY - sqrt) / (2 * aY);
        
        yIntervals.push(tY1, tY2);
      }
  
      var discriminantY2 = bY * bY - 4 * aY * (cY - boxMaxY);
      
      var tY3, tY4;
      if (discriminantY2 > 0) {
        var sqrt = Math.sqrt(discriminantY2);
        tY3 = (-bY + sqrt) / (2 * aY);
        tY4 = (-bY - sqrt) / (2 * aY);
        
        yIntervals.push(tY3, tY4);
      }
    }
        
    yIntervals.sort(function(a, b) { return a - b; });

    for (var index = 0; index < xIntervals.length; index += 2) {
      for (var yIndex = 1; yIndex < yIntervals.length; yIndex += 2) {
        
        // Check if there exists values for the Bezier curve
        // parameter between 0 and 1 where both the curve's
        // x and y coordinates are within the bounds specified by the box
        if (xIntervals[index] < yIntervals[yIndex]
          && yIntervals[yIndex] >= 0.0
          && xIntervals[index] <= 1.0
          && xIntervals[index + 1] > yIntervals[yIndex - 1]
          && yIntervals[yIndex - 1] <= 1.0
          && xIntervals[index + 1] >= 0.0) {
          
          return true;
        }
      }
    }
    
    return false;
  };
  
  $$.math.inLineVicinity = function(x, y, lx1, ly1, lx2, ly2, tolerance){
    var t = tolerance;

    var x1 = Math.min(lx1, lx2);
    var x2 = Math.max(lx1, lx2);
    var y1 = Math.min(ly1, ly2);
    var y2 = Math.max(ly1, ly2);

    return x1 - t <= x && x <= x2 + t
      && y1 - t <= y && y <= y2 + t;
  };

  $$.math.inBezierVicinity = function(
    x, y, x1, y1, x2, y2, x3, y3, toleranceSquared) {

    var bb = {
      x1: Math.min( x1, x3, x2 ),
      x2: Math.max( x1, x3, x2 ),
      y1: Math.min( y1, y3, y2 ),
      y2: Math.max( y1, y3, y2 )
    };

    // if outside the rough bounding box for the bezier, then it can't be a hit
    if( x < bb.x1 || x > bb.x2 || y < bb.y1 || y > bb.y2 ){
      // console.log('bezier out of rough bb')
      return false;
    } else {
      // console.log('do more expensive check');
      return true;
    }

  };
  
  $$.math.solveCubic = function(a, b, c, d, result) {
    
    // Solves a cubic function, returns root in form [r1, i1, r2, i2, r3, i3], where
    // r is the real component, i is the imaginary component

    // An implementation of the Cardano method from the year 1545
    // http://en.wikipedia.org/wiki/Cubic_function#The_nature_of_the_roots

    b /= a;
    c /= a;
    d /= a;
    
    var discriminant, q, r, dum1, s, t, term1, r13;

    q = (3.0 * c - (b * b)) / 9.0;
    r = -(27.0 * d) + b * (9.0 * c - 2.0 * (b * b));
    r /= 54.0;
    
    discriminant = q * q * q + r * r;
    result[1] = 0;
    term1 = (b / 3.0);
    
    if (discriminant > 0) {
      s = r + Math.sqrt(discriminant);
      s = ((s < 0) ? -Math.pow(-s, (1.0 / 3.0)) : Math.pow(s, (1.0 / 3.0)));
      t = r - Math.sqrt(discriminant);
      t = ((t < 0) ? -Math.pow(-t, (1.0 / 3.0)) : Math.pow(t, (1.0 / 3.0)));
      result[0] = -term1 + s + t;
      term1 += (s + t) / 2.0;
      result[4] = result[2] = -term1;
      term1 = Math.sqrt(3.0) * (-t + s) / 2;
      result[3] = term1;
      result[5] = -term1;
      return;
    }
    
    result[5] = result[3] = 0;
    
    if (discriminant === 0) {
      r13 = ((r < 0) ? -Math.pow(-r, (1.0 / 3.0)) : Math.pow(r, (1.0 / 3.0)));
      result[0] = -term1 + 2.0 * r13;
      result[4] = result[2] = -(r13 + term1);
      return;
    }
    
    q = -q;
    dum1 = q * q * q;
    dum1 = Math.acos(r / Math.sqrt(dum1));
    r13 = 2.0 * Math.sqrt(q);
    result[0] = -term1 + r13 * Math.cos(dum1 / 3.0);
    result[2] = -term1 + r13 * Math.cos((dum1 + 2.0 * Math.PI) / 3.0);
    result[4] = -term1 + r13 * Math.cos((dum1 + 4.0 * Math.PI) / 3.0);
    
    return;
  };

  $$.math.sqDistanceToQuadraticBezier = function(
    x, y, x1, y1, x2, y2, x3, y3) {
    
    // Find minimum distance by using the minimum of the distance 
    // function between the given point and the curve
    
    // This gives the coefficients of the resulting cubic equation
    // whose roots tell us where a possible minimum is
    // (Coefficients are divided by 4)
    
    var a = 1.0 * x1*x1 - 4*x1*x2 + 2*x1*x3 + 4*x2*x2 - 4*x2*x3 + x3*x3
      + y1*y1 - 4*y1*y2 + 2*y1*y3 + 4*y2*y2 - 4*y2*y3 + y3*y3;
    
    var b = 1.0 * 9*x1*x2 - 3*x1*x1 - 3*x1*x3 - 6*x2*x2 + 3*x2*x3
      + 9*y1*y2 - 3*y1*y1 - 3*y1*y3 - 6*y2*y2 + 3*y2*y3;
    
    var c = 1.0 * 3*x1*x1 - 6*x1*x2 + x1*x3 - x1*x + 2*x2*x2 + 2*x2*x - x3*x
      + 3*y1*y1 - 6*y1*y2 + y1*y3 - y1*y + 2*y2*y2 + 2*y2*y - y3*y;
      
    var d = 1.0 * x1*x2 - x1*x1 + x1*x - x2*x
      + y1*y2 - y1*y1 + y1*y - y2*y;
    
    // debug("coefficients: " + a / a + ", " + b / a + ", " + c / a + ", " + d / a);
    
    var roots = [];
    
    // Use the cubic solving algorithm
    this.solveCubic(a, b, c, d, roots);
    
    var zeroThreshold = 0.0000001;
    
    var params = [];
    
    for (var index = 0; index < 6; index += 2) {
      if (Math.abs(roots[index + 1]) < zeroThreshold
          && roots[index] >= 0
          && roots[index] <= 1.0) {
        params.push(roots[index]);
      }
    }
    
    params.push(1.0);
    params.push(0.0);
    
    var minDistanceSquared = -1;
    var closestParam;
    
    var curX, curY, distSquared;
    for (var i = 0; i < params.length; i++) {
      curX = Math.pow(1.0 - params[i], 2.0) * x1
        + 2.0 * (1 - params[i]) * params[i] * x2
        + params[i] * params[i] * x3;
        
      curY = Math.pow(1 - params[i], 2.0) * y1
        + 2 * (1.0 - params[i]) * params[i] * y2
        + params[i] * params[i] * y3;
        
      distSquared = Math.pow(curX - x, 2) + Math.pow(curY - y, 2);
      // debug('distance for param ' + params[i] + ": " + Math.sqrt(distSquared));
      if (minDistanceSquared >= 0) {
        if (distSquared < minDistanceSquared) {
          minDistanceSquared = distSquared;
          closestParam = params[i];
        }
      } else {
        minDistanceSquared = distSquared;
        closestParam = params[i];
      }
    }
    
    /*
    debugStats.clickX = x;
    debugStats.clickY = y;
    
    debugStats.closestX = Math.pow(1.0 - closestParam, 2.0) * x1
        + 2.0 * (1.0 - closestParam) * closestParam * x2
        + closestParam * closestParam * x3;
        
    debugStats.closestY = Math.pow(1.0 - closestParam, 2.0) * y1
        + 2.0 * (1.0 - closestParam) * closestParam * y2
        + closestParam * closestParam * y3;
    */
    
    // debug("given: " 
    //   + "( " + x + ", " + y + "), " 
    //   + "( " + x1 + ", " + y1 + "), " 
    //   + "( " + x2 + ", " + y2 + "), "
    //   + "( " + x3 + ", " + y3 + ")");
    
    
    // debug("roots: " + roots);
    // debug("params: " + params);
    // debug("closest param: " + closestParam);
    return minDistanceSquared;
  };
  
  $$.math.sqDistanceToFiniteLine = function(x, y, x1, y1, x2, y2) {
    var offset = [x - x1, y - y1];
    var line = [x2 - x1, y2 - y1];
    
    var lineSq = line[0] * line[0] + line[1] * line[1];
    var hypSq = offset[0] * offset[0] + offset[1] * offset[1];
    
    var dotProduct = offset[0] * line[0] + offset[1] * line[1];
    var adjSq = dotProduct * dotProduct / lineSq;
    
    if (dotProduct < 0) {
      return hypSq;
    }
    
    if (adjSq > lineSq) {
      return (x - x2) * (x - x2) + (y - y2) * (y - y2);
    }
    
    return hypSq - adjSq;
  };

  $$.math.pointInsidePolygon = function(
    x, y, basePoints, centerX, centerY, width, height, direction, padding) {

    //var direction = arguments[6];
    var transformedPoints = new Array(basePoints.length);

    // Gives negative angle
    var angle = Math.asin(direction[1] / (Math.sqrt(direction[0] * direction[0] 
      + direction[1] * direction[1])));
    
    if (direction[0] < 0) {
      angle = angle + Math.PI / 2;
    } else {
      angle = -angle - Math.PI / 2;
    }
        
    var cos = Math.cos(-angle);
    var sin = Math.sin(-angle);
    
//    console.log("base: " + basePoints);
    for (var i = 0; i < transformedPoints.length / 2; i++) {
      transformedPoints[i * 2] = 
        width / 2 * (basePoints[i * 2] * cos
          - basePoints[i * 2 + 1] * sin);
      
      transformedPoints[i * 2 + 1] = 
        height / 2 * (basePoints[i * 2 + 1] * cos 
          + basePoints[i * 2] * sin);

      transformedPoints[i * 2] += centerX;
      transformedPoints[i * 2 + 1] += centerY;
    }
    
    var points;
    
    if (padding > 0) {
      var expandedLineSet = this.expandPolygon(
        transformedPoints,
        -padding);
      
      points = this.joinLines(expandedLineSet);
    } else {
      points = transformedPoints;
    }
    
    var x1, y1, x2, y2;
    var y3;
    
    // Intersect with vertical line through (x, y)
    var up = 0;
    var down = 0;
    for (var i = 0; i < points.length / 2; i++) {
      
      x1 = points[i * 2];
      y1 = points[i * 2 + 1];
      
      if (i + 1 < points.length / 2) {
        x2 = points[(i + 1) * 2];
        y2 = points[(i + 1) * 2 + 1];
      } else {
        x2 = points[(i + 1 - points.length / 2) * 2];
        y2 = points[(i + 1 - points.length / 2) * 2 + 1];
      }
      
//*      console.log("line from (" + x1 + ", " + y1 + ") to (" + x2 + ", " + y2 + ")");

//&      console.log(x1, x, x2);

      if (x1 == x && x2 == x) {
        
      } else if ((x1 >= x && x >= x2)
        || (x1 <= x && x <= x2)) {
        
        y3 = (x - x1) / (x2 - x1) * (y2 - y1) + y1;
        
        if (y3 > y) {
          up++;
        }
        
        if (y3 < y) {
          down++;
        }
        
//*        console.log(y3, y);
        
      } else {
//*        console.log('22');
        continue;
      }
      
    }
    
//*    console.log("up: " + up + ", down: " + down);
    
    if (up % 2 === 0) {
      return false;
    } else {
      return true;
    }
  };

  $$.math.joinLines = function(lineSet) {
    
    var vertices = new Array(lineSet.length / 2);
    
    var currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY;
    var nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY;
    
    for (var i = 0; i < lineSet.length / 4; i++) {
      currentLineStartX = lineSet[i * 4];
      currentLineStartY = lineSet[i * 4 + 1];
      currentLineEndX = lineSet[i * 4 + 2];
      currentLineEndY = lineSet[i * 4 + 3];
      
      if (i < lineSet.length / 4 - 1) {
        nextLineStartX = lineSet[(i + 1) * 4];
        nextLineStartY = lineSet[(i + 1) * 4 + 1];
        nextLineEndX = lineSet[(i + 1) * 4 + 2];
        nextLineEndY = lineSet[(i + 1) * 4 + 3];
      } else {
        nextLineStartX = lineSet[0];
        nextLineStartY = lineSet[1];
        nextLineEndX = lineSet[2];
        nextLineEndY = lineSet[3];
      }
      
      var intersection = this.finiteLinesIntersect(
        currentLineStartX, currentLineStartY,
        currentLineEndX, currentLineEndY,
        nextLineStartX, nextLineStartY,
        nextLineEndX, nextLineEndY,
        true);
      
      vertices[i * 2] = intersection[0];
      vertices[i * 2 + 1] = intersection[1];
    }
    
    return vertices;
  };

  $$.math.expandPolygon = function(points, pad) {
    
    var expandedLineSet = new Array(points.length * 2);
    
    var currentPointX, currentPointY, nextPointX, nextPointY;
    
    for (var i = 0; i < points.length / 2; i++) {
      currentPointX = points[i * 2];
      currentPointY = points[i * 2 + 1];
      
      if (i < points.length / 2 - 1) {
        nextPointX = points[(i + 1) * 2];
        nextPointY = points[(i + 1) * 2 + 1];
      } else {
        nextPointX = points[0];
        nextPointY = points[1];
      }
      
      // Current line: [currentPointX, currentPointY] to [nextPointX, nextPointY]
      
      // Assume CCW polygon winding
      
      var offsetX = (nextPointY - currentPointY);
      var offsetY = -(nextPointX - currentPointX);
      
      // Normalize
      var offsetLength = Math.sqrt(offsetX * offsetX + offsetY * offsetY);
      var normalizedOffsetX = offsetX / offsetLength;
      var normalizedOffsetY = offsetY / offsetLength;
      
      expandedLineSet[i * 4] = currentPointX + normalizedOffsetX * pad;
      expandedLineSet[i * 4 + 1] = currentPointY + normalizedOffsetY * pad;
      expandedLineSet[i * 4 + 2] = nextPointX + normalizedOffsetX * pad;
      expandedLineSet[i * 4 + 3] = nextPointY + normalizedOffsetY * pad;
    }
    
    return expandedLineSet;
  };

  $$.math.intersectLineEllipse = function(
    x, y, centerX, centerY, ellipseWradius, ellipseHradius) {
    
    var dispX = centerX - x;
    var dispY = centerY - y;
    
    dispX /= ellipseWradius;
    dispY /= ellipseHradius;
    
    var len = Math.sqrt(dispX * dispX + dispY * dispY);
    
    var newLength = len - 1;
    
    if (newLength < 0) {
      return [];
    }
    
    var lenProportion = newLength / len;
    
    return [(centerX - x) * lenProportion + x, (centerY - y) * lenProportion + y];
  };
  
  $$.math.dotProduct = function(
    vec1, vec2) {
    
    if (vec1.length != 2 || vec2.length != 2) {
      throw 'dot product: arguments are not vectors';
    }
    
    return (vec1[0] * vec2[0] + vec1[1] * vec2[1]);
  };
  
  // Returns intersections of increasing distance from line's start point
  $$.math.intersectLineCircle = function(
    x1, y1, x2, y2, centerX, centerY, radius) {
    
    // Calculate d, direction vector of line
    var d = [x2 - x1, y2 - y1]; // Direction vector of line
    var c = [centerX, centerY]; // Center of circle
    var f = [x1 - centerX, y1 - centerY];
    
    var a = d[0] * d[0] + d[1] * d[1];
    var b = 2 * (f[0] * d[0] + f[1] * d[1]);
    var c = (f[0] * f[0] + f[1] * f[1]) - radius * radius ;
    
    var discriminant = b*b-4*a*c;
    
    if (discriminant < 0) {
      return [];
    }
    
    var t1 = (-b + Math.sqrt(discriminant)) / (2 * a);
    var t2 = (-b - Math.sqrt(discriminant)) / (2 * a);
    
    var tMin = Math.min(t1, t2);
    var tMax = Math.max(t1, t2);
    var inRangeParams = [];
    
    if (tMin >= 0 && tMin <= 1) {
      inRangeParams.push(tMin);
    }
    
    if (tMax >= 0 && tMax <= 1) {
      inRangeParams.push(tMax);
    }
    
    if (inRangeParams.length === 0) {
      return [];
    }
    
    var nearIntersectionX = inRangeParams[0] * d[0] + x1;
    var nearIntersectionY = inRangeParams[0] * d[1] + y1;
    
    if (inRangeParams.length > 1) {
    
      if (inRangeParams[0] == inRangeParams[1]) {
        return [nearIntersectionX, nearIntersectionY];
      } else {
        
        var farIntersectionX = inRangeParams[1] * d[0] + x1;
        var farIntersectionY = inRangeParams[1] * d[1] + y1;
      
        return [nearIntersectionX, nearIntersectionY, farIntersectionX, farIntersectionY];
      }
      
    } else {
      return [nearIntersectionX, nearIntersectionY];
    }
    
  };
  
  $$.math.findCircleNearPoint = function(centerX, centerY, 
    radius, farX, farY) {
    
    var displacementX = farX - centerX;
    var displacementY = farY - centerY;
    var distance = Math.sqrt(displacementX * displacementX 
      + displacementY * displacementY);
    
    var unitDisplacementX = displacementX / distance;
    var unitDisplacementY = displacementY / distance;
    
    return [centerX + unitDisplacementX * radius, 
      centerY + unitDisplacementY * radius];
  };
  
  $$.math.findMaxSqDistanceToOrigin = function(points) {
    var maxSqDistance = 0.000001;
    var sqDistance;
    
    for (var i = 0; i < points.length / 2; i++) {
      
      sqDistance = points[i * 2] * points[i * 2] 
        + points[i * 2 + 1] * points[i * 2 + 1];
      
      if (sqDistance > maxSqDistance) {
        maxSqDistance = sqDistance;
      }
    }
    
    return maxSqDistance;
  };
  
  $$.math.finiteLinesIntersect = function(
    x1, y1, x2, y2, x3, y3, x4, y4, infiniteLines) {
    
    var ua_t = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
    var ub_t = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
    var u_b = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);

    if (u_b !== 0) {
      var ua = ua_t / u_b;
      var ub = ub_t / u_b;
      
      if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {  
        return [x1 + ua * (x2 - x1), y1 + ua * (y2 - y1)];
        
      } else {
        if (!infiniteLines) {
          return [];
        } else {
          return [x1 + ua * (x2 - x1), y1 + ua * (y2 - y1)];
        }
      }
    } else {
      if (ua_t === 0 || ub_t === 0) {

        // Parallel, coincident lines. Check if overlap

        // Check endpoint of second line
        if ([x1, x2, x4].sort()[1] === x4) {
          return [x4, y4];
        }
        
        // Check start point of second line
        if ([x1, x2, x3].sort()[1] === x3) {
          return [x3, y3];
        }
        
        // Endpoint of first line
        if ([x3, x4, x2].sort()[1] === x2) {
          return [x2, y2];
        }
        
        return [];
      } else {
      
        // Parallel, non-coincident
        return [];
      }
    }
  };
  
  // (boxMinX, boxMinY, boxMaxX, boxMaxY, padding,
  //      cornerRadius * 2, cornerRadius * 2, vBoxTopLeftX + padding, hBoxTopLeftY + padding)) {
  
  $$.math.boxIntersectEllipse = function(
    x1, y1, x2, y2, padding, width, height, centerX, centerY) {
    
    if (x2 < x1) {
      var oldX1 = x1;
      x1 = x2;
      x2 = oldX1;
    }
    
    if (y2 < y1) {
      var oldY1 = y1;
      y1 = y2;
      y2 = oldY1;
    }
    
    // 4 ortho extreme points
    var west = [centerX - width / 2 - padding, centerY];
    var east = [centerX + width / 2 + padding, centerY];
    var north = [centerX, centerY - height / 2 - padding];
    var south = [centerX, centerY + height / 2 + padding];
    
    // out of bounds: return false
    if (x2 < west[0]) {
      return false;
    }
    
    if (x1 > east[0]) {
      return false;
    }
    
    if (y1 > south[1]) {
      return false;
    }
    
    if (y2 < north[1]) {
      return false;
    }
    
    // 1 of 4 ortho extreme points in box: return true
    if (x1 <= east[0] && east[0] <= x2
        && y1 <= east[1] && east[1] <= y2) {
      return true;
    }
    
    if (x1 <= west[0] && west[0] <= x2
        && y1 <= west[1] && west[1] <= y2) {
      return true;
    }
    
    if (x1 <= north[0] && north[0] <= x2
        && y1 <= north[1] && north[1] <= y2) {
      return true;
    }
    
    if (x1 <= south[0] && south[0] <= x2
        && y1 <= south[1] && south[1] <= y2) {
      return true;
    }
    
    // box corner in ellipse: return true    
    x1 = (x1 - centerX) / (width / 2 + padding);
    x2 = (x2 - centerX) / (width / 2 + padding);
    
    y1 = (y1 - centerY) / (height / 2 + padding);
    y2 = (y2 - centerY) / (height / 2 + padding);
    
    if (x1 * x1 + y1 * y1 <= 1) {
      return true;
    }
    
    if (x2 * x2 + y1 * y1 <= 1) {
      return true;
    }
    
    if (x2 * x2 + y2 * y2 <= 1) {
      return true;
    }
    
    if (x1 * x1 + y2 * y2 <= 1) {
      return true;
    }
    
    return false;
  };
  
  $$.math.boxIntersectPolygon = function(
    x1, y1, x2, y2, basePoints, width, height, centerX, centerY, direction, padding) {
    
//    console.log(arguments);
    
    if (x2 < x1) {
      var oldX1 = x1;
      x1 = x2;
      x2 = oldX1;
    }
    
    if (y2 < y1) {
      var oldY1 = y1;
      y1 = y2;
      y2 = oldY1;
    }
    
    var transformedPoints = new Array(basePoints.length);
    
    // Gives negative of angle
    var angle = Math.asin(direction[1] / (Math.sqrt(direction[0] * direction[0] 
      + direction[1] * direction[1])));
    
    if (direction[0] < 0) {
      angle = angle + Math.PI / 2;
    } else {
      angle = -angle - Math.PI / 2;
    }
    
    var cos = Math.cos(-angle);
    var sin = Math.sin(-angle);
    
    for (var i = 0; i < transformedPoints.length / 2; i++) {
      transformedPoints[i * 2] = 
        width / 2 * (basePoints[i * 2] * cos
          - basePoints[i * 2 + 1] * sin);
      
      transformedPoints[i * 2 + 1] = 
        height / 2 * (basePoints[i * 2 + 1] * cos 
          + basePoints[i * 2] * sin);
      
      transformedPoints[i * 2] += centerX;
      transformedPoints[i * 2 + 1] += centerY;
    }
    
    // Assume transformedPoints.length > 0, and check if intersection is possible
    var minTransformedX = transformedPoints[0];
    var maxTransformedX = transformedPoints[0];
    var minTransformedY = transformedPoints[1];
    var maxTransformedY = transformedPoints[1];
    
    for (var i = 1; i < transformedPoints.length / 2; i++) {
      if (transformedPoints[i * 2] > maxTransformedX) {
        maxTransformedX = transformedPoints[i * 2];
      }
      
      if (transformedPoints[i * 2] < minTransformedX) {
        minTransformedX = transformedPoints[i * 2];
      }
      
      if (transformedPoints[i * 2 + 1] > maxTransformedY) {
        maxTransformedY = transformedPoints[i * 2 + 1];
      }
      
      if (transformedPoints[i * 2 + 1] < minTransformedY) {
        minTransformedY = transformedPoints[i * 2 + 1];
      }
    }
    
    if (x2 < minTransformedX - padding) {
      return false;
    }
    
    if (x1 > maxTransformedX + padding) {
      return false;
    }
    
    if (y2 < minTransformedY - padding) {
      return false;
    }
    
    if (y1 > maxTransformedY + padding) {
      return false;
    }
    
    // Continue checking with padding-corrected points
    var points;
    
    if (padding > 0) {
      var expandedLineSet = $$.math.expandPolygon(
        transformedPoints,
        -padding);
      
      points = $$.math.joinLines(expandedLineSet);
    } else {
      points = transformedPoints;
    }
    
    // Check if a point is in box
    for (var i = 0; i < transformedPoints.length / 2; i++) {
      if (x1 <= transformedPoints[i * 2]
          && transformedPoints[i * 2] <= x2) {
        
        if (y1 <= transformedPoints[i * 2 + 1]
            && transformedPoints[i * 2 + 1] <= y2) {
          
          return true;
        }
      }
    }
    
    
    // Check for intersections with the selection box
    for (var i = 0; i < points.length / 2; i++) {
      
      var currentX = points[i * 2];
      var currentY = points[i * 2 + 1];
      var nextX;
      var nextY;
      
      if (i < points.length / 2 - 1) {
        nextX = points[(i + 1) * 2];
        nextY = points[(i + 1) * 2 + 1];
      } else {
        nextX = points[0];
        nextY = points[1];
      }
      
      // Intersection with top of selection box
      if ($$.math.finiteLinesIntersect(currentX, currentY, nextX, nextY, x1, y1, x2, y1, false).length > 0) {
        return true;
      }
      
      // Intersection with bottom of selection box
      if ($$.math.finiteLinesIntersect(currentX, currentY, nextX, nextY, x1, y2, x2, y2, false).length > 0) {
        return true;
      }
      
      // Intersection with left side of selection box
      if ($$.math.finiteLinesIntersect(currentX, currentY, nextX, nextY, x1, y1, x1, y2, false).length > 0) {
        return true;
      }
      
      // Intersection with right side of selection box
      if ($$.math.finiteLinesIntersect(currentX, currentY, nextX, nextY, x2, y1, x2, y2, false).length > 0) {
        return true;
      }
    }

    /*
    // Check if box corner in the polygon
    if ($$.math.pointInsidePolygon(
      x1, y1, points, 0, 0, 1, 1, 0, direction)) {
      
      return true;
    } else if ($$.math.pointInsidePolygon(
      x1, y2, points, 0, 0, 1, 1, 0, direction)) {
      
      return true;
    } else if ($$.math.pointInsidePolygon(
      x2, y2, points, 0, 0, 1, 1, 0, direction)) {
       
      return true; 
    } else if ($$.math.pointInsidePolygon(
      x2, y1, points, 0, 0, 1, 1, 0, direction)) {
      
      return true;
    }
    */
    return false;
  };
  
  $$.math.polygonIntersectLine = function(
    x, y, basePoints, centerX, centerY, width, height, padding) {
    
    var intersections = [];
    var intersection;
    
    var transformedPoints = new Array(basePoints.length);
    
    for (var i = 0; i < transformedPoints.length / 2; i++) {
      transformedPoints[i * 2] = basePoints[i * 2] * width + centerX;
      transformedPoints[i * 2 + 1] = basePoints[i * 2 + 1] * height + centerY;
    }
    
    var points;
    
    if (padding > 0) {
      var expandedLineSet = $$.math.expandPolygon(
        transformedPoints,
        -padding);
      
      points = $$.math.joinLines(expandedLineSet);
    } else {
      points = transformedPoints;
    }
    // var points = transformedPoints;
    
    var currentX, currentY, nextX, nextY;
    
    for (var i = 0; i < points.length / 2; i++) {
    
      currentX = points[i * 2];
      currentY = points[i * 2 + 1];

      if (i < points.length / 2 - 1) {
        nextX = points[(i + 1) * 2]; 
        nextY = points[(i + 1) * 2 + 1];
      } else {
        nextX = points[0]; 
        nextY = points[1];
      }
      
      intersection = this.finiteLinesIntersect(
        x, y, centerX, centerY,
        currentX, currentY,
        nextX, nextY);
      
      if (intersection.length !== 0) {
        intersections.push(intersection[0], intersection[1]);
      }
    }
    
    return intersections;
  };
  
  $$.math.shortenIntersection = function(
    intersection, offset, amount) {
    
    var disp = [intersection[0] - offset[0], intersection[1] - offset[1]];
    
    var length = Math.sqrt(disp[0] * disp[0] + disp[1] * disp[1]);
    
    var lenRatio = (length - amount) / length;
    
    if (lenRatio < 0) {
      lenRatio = 0.00001;
    }

    return [offset[0] + lenRatio * disp[0], offset[1] + lenRatio * disp[1]];
  };

  $$.math.generateUnitNgonPointsFitToSquare = function(sides, rotationRadians) {
    var points = $$.math.generateUnitNgonPoints(sides, rotationRadians);
    points = $$.math.fitPolygonToSquare(points);

    return points;
  };

  $$.math.fitPolygonToSquare = function(points){
    var x, y;
    var sides = points.length/2;
    var minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

    for (var i = 0; i < sides; i++) {
      x = points[2 * i];
      y = points[2 * i + 1];

      minX = Math.min( minX, x );
      maxX = Math.max( maxX, x );
      minY = Math.min( minY, y );
      maxY = Math.max( maxY, y );
    }
    
    // stretch factors
    var sx = 2 / (maxX - minX);
    var sy = 2 / (maxY - minY);

    for (var i = 0; i < sides; i++){
      x = points[2 * i] = points[2 * i] * sx;
      y = points[2 * i + 1] = points[2 * i + 1] * sy;

      minX = Math.min( minX, x );
      maxX = Math.max( maxX, x );
      minY = Math.min( minY, y );
      maxY = Math.max( maxY, y );
    }

    if( minY < -1 ){
      for (var i = 0; i < sides; i++){
        y = points[2 * i + 1] = points[2 * i + 1] + (-1 -minY);
      }
    }
    
    return points;
  };

  $$.math.generateUnitNgonPoints = function(sides, rotationRadians) {
    
    var increment = 1.0 / sides * 2 * Math.PI;
    var startAngle = sides % 2 === 0 ? 
      Math.PI / 2.0 + increment / 2.0 : Math.PI / 2.0;
//    console.log(nodeShapes['square']);
    startAngle += rotationRadians;
    
    var points = new Array(sides * 2);

    var currentAngle, x, y;
    for (var i = 0; i < sides; i++) {
      currentAngle = i * increment + startAngle;
      
      x = points[2 * i] = Math.cos(currentAngle);// * (1 + i/2);
      y = points[2 * i + 1] = Math.sin(-currentAngle);//  * (1 + i/2);
    }
    
    return points;
  };

  $$.math.getRoundRectangleRadius = function(width, height) {
    
    // Set the default radius, unless half of width or height is smaller than default
    return Math.min(width / 4, height / 4, 8);
  };
  
})( cytoscape );

;(function($$){ 'use strict';
  
  // registered extensions to cytoscape, indexed by name
  var extensions = {};
  $$.extensions = extensions;
  
  // registered modules for extensions, indexed by name
  var modules = {};
  $$.modules = modules;
  
  function setExtension(type, name, registrant){
    var impl = {};
    impl[name] = registrant;
    
    switch( type ){
    case 'core':
    case 'collection':
      $$.fn[type]( impl );
    }
    
    // fill in missing layout functions in the prototype
    if( type === 'layout' ){
      var layoutProto = registrant.prototype;
      var optLayoutFns = [];

      for( var i = 0; i < optLayoutFns.length; i++ ){
        var fnName = optLayoutFns[i];

        layoutProto[fnName] = layoutProto[fnName] || function(){ return this; };
      }

      // either .start() or .run() is defined, so autogen the other
      if( layoutProto.start && !layoutProto.run ){
        layoutProto.run = function(){ this.start(); return this; };
      } else if( !layoutProto.start && layoutProto.run ){
        layoutProto.start = function(){ this.run(); return this; };
      }
      
      if( !layoutProto.stop ){
        layoutProto.stop = function(){
          var opts = this.options;
          
          if( opts && opts.animate ){
            opts.eles.stop();
          }
          
          return this;
        };
      }

      layoutProto.on = $$.define.on({ layout: true });
      layoutProto.one = $$.define.on({ layout: true, unbindSelfOnTrigger: true });
      layoutProto.once = $$.define.on({ layout: true, unbindAllBindersOnTrigger: true });
      layoutProto.off = $$.define.off({ layout: true });
      layoutProto.trigger = $$.define.trigger({ layout: true });

      $$.define.eventAliasesOn( layoutProto );
    }

    return $$.util.setMap({
      map: extensions,
      keys: [ type, name ],
      value: registrant
    });
  }
  
  function getExtension(type, name){
    return $$.util.getMap({
      map: extensions,
      keys: [ type, name ]
    });
  }
  
  function setModule(type, name, moduleType, moduleName, registrant){
    return $$.util.setMap({
      map: modules,
      keys: [ type, name, moduleType, moduleName ],
      value: registrant
    });
  }
  
  function getModule(type, name, moduleType, moduleName){
    return $$.util.getMap({
      map: modules,
      keys: [ type, name, moduleType, moduleName ]
    });
  }
  
  $$.extension = function(){
    // e.g. $$.extension('renderer', 'svg')
    if( arguments.length == 2 ){
      return getExtension.apply(this, arguments);
    }
    
    // e.g. $$.extension('renderer', 'svg', { ... })
    else if( arguments.length == 3 ){
      return setExtension.apply(this, arguments);
    }
    
    // e.g. $$.extension('renderer', 'svg', 'nodeShape', 'ellipse')
    else if( arguments.length == 4 ){
      return getModule.apply(this, arguments);
    }
    
    // e.g. $$.extension('renderer', 'svg', 'nodeShape', 'ellipse', { ... })
    else if( arguments.length == 5 ){
      return setModule.apply(this, arguments);
    }
    
    else {
      $$.util.error('Invalid extension access syntax');
    }
  
  };
  
})( cytoscape );

;(function($, $$){ 'use strict';
  
  if( !$ ){ return; } // no jquery => don't need this

  var cyReg = function( $ele ){
    var d = $ele[0]._cyreg = $ele[0]._cyreg || {};

    return d;
  };

  // allow calls on a jQuery selector by proxying calls to $.cytoscape
  // e.g. $("#foo").cytoscape(options) => $.cytoscape(options) on #foo
  $.fn.cytoscape = function(opts){
    var $this = $(this);

    // get object
    if( opts === 'get' ){
      return cyReg( $this ).cy;
    }
    
    // bind to ready
    else if( $$.is.fn(opts) ){

      var ready = opts;
      var cy = cyReg( $this ).cy;
      
      if( cy && cy.isReady() ){ // already ready so just trigger now
        cy.trigger('ready', [], ready);

      } else { // not yet ready, so add to readies list
        var data = cyReg( $this );
        var readies = data.readies = data.readies || [];

        readies.push( ready );
      } 
      
    }
    
    // proxy to create instance
    else if( $$.is.plainObject(opts) ){
      return $this.each(function(){
        var options = $.extend({}, opts, {
          container: $(this)[0]
        });
      
        cytoscape(options);
      });
    }
  };
  
  // allow access to the global cytoscape object under jquery for legacy reasons
  $.cytoscape = cytoscape;
  
  // use short alias (cy) if not already defined
  if( $.fn.cy == null && $.cy == null ){
    $.fn.cy = $.fn.cytoscape;
    $.cy = $.cytoscape;
  }
  
})(typeof jQuery !== 'undefined' ? jQuery : null , cytoscape);

;(function($$){ 'use strict';
  
  // shamelessly taken from jQuery
  // https://github.com/jquery/jquery/blob/master/src/event.js

  $$.Event = function( src, props ) {
    // Allow instantiation without the 'new' keyword
    if ( !(this instanceof $$.Event) ) {
      return new $$.Event( src, props );
    }

    // Event object
    if ( src && src.type ) {
      this.originalEvent = src;
      this.type = src.type;

      // Events bubbling up the document may have been marked as prevented
      // by a handler lower down the tree; reflect the correct value.
      this.isDefaultPrevented = ( src.defaultPrevented ) ? returnTrue : returnFalse;

    // Event type
    } else {
      this.type = src;
    }

    // Put explicitly provided properties onto the event object
    if ( props ) {
      // $$.util.extend( this, props );

      // more efficient to manually copy fields we use
      this.type = props.type !== undefined ? props.type : this.type;
      this.cy = props.cy;
      this.cyTarget = props.cyTarget;
      this.cyPosition = props.cyPosition;
      this.cyRenderedPosition = props.cyRenderedPosition;
      this.namespace = props.namespace;
      this.layout = props.layout;
      this.data = props.data;
      this.message = props.message;
    }

    // Create a timestamp if incoming event doesn't have one
    this.timeStamp = src && src.timeStamp || +new Date();
  };

  function returnFalse() {
    return false;
  }
  function returnTrue() {
    return true;
  }

  // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
  // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
  $$.Event.prototype = {
    preventDefault: function() {
      this.isDefaultPrevented = returnTrue;

      var e = this.originalEvent;
      if ( !e ) {
        return;
      }

      // if preventDefault exists run it on the original event
      if ( e.preventDefault ) {
        e.preventDefault();
      }
    },
    stopPropagation: function() {
      this.isPropagationStopped = returnTrue;

      var e = this.originalEvent;
      if ( !e ) {
        return;
      }
      // if stopPropagation exists run it on the original event
      if ( e.stopPropagation ) {
        e.stopPropagation();
      }
    },
    stopImmediatePropagation: function() {
      this.isImmediatePropagationStopped = returnTrue;
      this.stopPropagation();
    },
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse
  };
  
  
})( cytoscape );

;(function($$){ 'use strict';

  // use this module to cherry pick functions into your prototype
  // (useful for functions shared between the core and collections, for example)

  // e.g.
  // $$.fn.collection({
  //   foo: $$.define.foo({ /* params... */ })
  // });

  $$.define = {

    // access data field
    data: function( params ){
      var defaults = { 
        field: 'data',
        bindingEvent: 'data',
        allowBinding: false,
        allowSetting: false,
        allowGetting: false,
        settingEvent: 'data',
        settingTriggersEvent: false,
        triggerFnName: 'trigger',
        immutableKeys: {}, // key => true if immutable
        updateStyle: false,
        onSet: function( self ){},
        canSet: function( self ){ return true; }
      };
      params = $$.util.extend({}, defaults, params);

      return function dataImpl( name, value ){
        var p = params;
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        var single = selfIsArrayLike ? self[0] : self;

        // .data('foo', ...)
        if( $$.is.string(name) ){ // set or get property

          // .data('foo')
          if( p.allowGetting && value === undefined ){ // get

            var ret;
            if( single ){
              ret = single._private[ p.field ][ name ];
            }
            return ret;
          
          // .data('foo', 'bar')
          } else if( p.allowSetting && value !== undefined ) { // set
            var valid = !p.immutableKeys[name];
            if( valid ){
              for( var i = 0, l = all.length; i < l; i++ ){
                if( p.canSet( all[i] ) ){
                  all[i]._private[ p.field ][ name ] = value;
                }
              }

              // update mappers if asked
              if( p.updateStyle ){ self.updateStyle(); }

              // call onSet callback
              p.onSet( self );

              if( p.settingTriggersEvent ){
                self[ p.triggerFnName ]( p.settingEvent );
              }
            }
          }

        // .data({ 'foo': 'bar' })
        } else if( p.allowSetting && $$.is.plainObject(name) ){ // extend
          var obj = name;
          var k, v;

          for( k in obj ){
            v = obj[ k ];

            var valid = !p.immutableKeys[k];
            if( valid ){
              for( var i = 0, l = all.length; i < l; i++ ){
                if( p.canSet( all[i] ) ){
                  all[i]._private[ p.field ][ k ] = v;
                }
              }
            }
          }
          
          // update mappers if asked
          if( p.updateStyle ){ self.updateStyle(); }

          // call onSet callback
          p.onSet( self );

          if( p.settingTriggersEvent ){
            self[ p.triggerFnName ]( p.settingEvent );
          }
        
        // .data(function(){ ... })
        } else if( p.allowBinding && $$.is.fn(name) ){ // bind to event
          var fn = name;
          self.bind( p.bindingEvent, fn );
        
        // .data()
        } else if( p.allowGetting && name === undefined ){ // get whole object
          var ret;
          if( single ){
            ret = single._private[ p.field ];
          }
          return ret;
        }

        return self; // maintain chainability
      }; // function
    }, // data

    // remove data field
    removeData: function( params ){
      var defaults = { 
        field: 'data',
        event: 'data',
        triggerFnName: 'trigger',
        triggerEvent: false,
        immutableKeys: {} // key => true if immutable
      };
      params = $$.util.extend({}, defaults, params);

      return function removeDataImpl( names ){
        var p = params;
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        
        // .removeData('foo bar')
        if( $$.is.string(names) ){ // then get the list of keys, and delete them
          var keys = names.split(/\s+/);
          var l = keys.length;

          for( var i = 0; i < l; i++ ){ // delete each non-empty key
            var key = keys[i];
            if( $$.is.emptyString(key) ){ continue; }

            var valid = !p.immutableKeys[ key ]; // not valid if immutable
            if( valid ){
              for( var i_a = 0, l_a = all.length; i_a < l_a; i_a++ ){
                all[ i_a ]._private[ p.field ][ key ] = undefined;
              }
            }
          }

          if( p.triggerEvent ){
            self[ p.triggerFnName ]( p.event );
          }

        // .removeData()
        } else if( names === undefined ){ // then delete all keys

          for( var i_a = 0, l_a = all.length; i_a < l_a; i_a++ ){
            var _privateFields = all[ i_a ]._private[ p.field ];
            
            for( var key in _privateFields ){
              var validKeyToDelete = !p.immutableKeys[ key ];

              if( validKeyToDelete ){
                _privateFields[ key ] = undefined;
              }
            }
          }

          if( p.triggerEvent ){
            self[ p.triggerFnName ]( p.event );
          }
        }

        return self; // maintain chaining
      }; // function
    }, // removeData

    // event function reusable stuff
    event: {
      regex: /(\w+)(\.\w+)?/, // regex for matching event strings (e.g. "click.namespace")
      optionalTypeRegex: /(\w+)?(\.\w+)?/,
      falseCallback: function(){ return false; }
    },

    // event binding
    on: function( params ){
      var defaults = {
        unbindSelfOnTrigger: false,
        unbindAllBindersOnTrigger: false
      };
      params = $$.util.extend({}, defaults, params);
      
      return function onImpl(events, selector, data, callback){
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        var eventsIsString = $$.is.string(events);
        var p = params;

        if( $$.is.plainObject(selector) ){ // selector is actually data
          callback = data;
          data = selector;
          selector = undefined;
        } else if( $$.is.fn(selector) || selector === false ){ // selector is actually callback
          callback = selector;
          data = undefined;
          selector = undefined;
        }

        if( $$.is.fn(data) || data === false ){ // data is actually callback
          callback = data;
          data = undefined;
        }

        // if there isn't a callback, we can't really do anything
        // (can't speak for mapped events arg version)
        if( !($$.is.fn(callback) || callback === false) && eventsIsString ){
          return self; // maintain chaining
        }

        if( eventsIsString ){ // then convert to map
          var map = {};
          map[ events ] = callback;
          events = map;
        }

        for( var evts in events ){
          callback = events[evts];
          if( callback === false ){
            callback = $$.define.event.falseCallback;
          }

          if( !$$.is.fn(callback) ){ continue; }

          evts = evts.split(/\s+/);
          for( var i = 0; i < evts.length; i++ ){
            var evt = evts[i];
            if( $$.is.emptyString(evt) ){ continue; }

            var match = evt.match( $$.define.event.regex ); // type[.namespace]

            if( match ){
              var type = match[1];
              var namespace = match[2] ? match[2] : undefined;

              var listener = {
                callback: callback, // callback to run
                data: data, // extra data in eventObj.data
                delegated: selector ? true : false, // whether the evt is delegated
                selector: selector, // the selector to match for delegated events
                selObj: new $$.Selector(selector), // cached selector object to save rebuilding
                type: type, // the event type (e.g. 'click')
                namespace: namespace, // the event namespace (e.g. ".foo")
                unbindSelfOnTrigger: p.unbindSelfOnTrigger,
                unbindAllBindersOnTrigger: p.unbindAllBindersOnTrigger,
                binders: all // who bound together
              };

              for( var j = 0; j < all.length; j++ ){
                var _p = all[j]._private;

                _p.listeners = _p.listeners || [];
                _p.listeners.push( listener );
              }
            }
          } // for events array
        } // for events map
        
        return self; // maintain chaining
      }; // function
    }, // on

    eventAliasesOn: function( proto ){
      var p = proto;

      p.addListener = p.listen = p.bind = p.on;
      p.removeListener = p.unlisten = p.unbind = p.off;
      p.emit = p.trigger;

      // this is just a wrapper alias of .on()
      p.pon = p.promiseOn = function( events, selector ){
        var self = this;
        var args = Array.prototype.slice.call( arguments, 0 );

        return new $$.Promise(function( resolve, reject ){
          var callback = function( e ){
            self.off.apply( self, offArgs );

            resolve( e );
          };

          var onArgs = args.concat([ callback ]);
          var offArgs = onArgs.concat([]);

          self.on.apply( self, onArgs );
        });
      };
    },

    off: function offImpl( params ){
      var defaults = {
      };
      params = $$.util.extend({}, defaults, params);
      
      return function(events, selector, callback){
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        var eventsIsString = $$.is.string(events);

        if( arguments.length === 0 ){ // then unbind all

          for( var i = 0; i < all.length; i++ ){
            all[i]._private.listeners = [];
          }

          return self; // maintain chaining
        }

        if( $$.is.fn(selector) || selector === false ){ // selector is actually callback
          callback = selector;
          selector = undefined;
        }

        if( eventsIsString ){ // then convert to map
          var map = {};
          map[ events ] = callback;
          events = map;
        }

        for( var evts in events ){
          callback = events[evts];

          if( callback === false ){
            callback = $$.define.event.falseCallback;
          }

          evts = evts.split(/\s+/);
          for( var h = 0; h < evts.length; h++ ){
            var evt = evts[h];
            if( $$.is.emptyString(evt) ){ continue; }

            var match = evt.match( $$.define.event.optionalTypeRegex ); // [type][.namespace]
            if( match ){
              var type = match[1] ? match[1] : undefined;
              var namespace = match[2] ? match[2] : undefined;

              for( var i = 0; i < all.length; i++ ){ //
                var listeners = all[i]._private.listeners = all[i]._private.listeners || [];

                for( var j = 0; j < listeners.length; j++ ){
                  var listener = listeners[j];
                  var nsMatches = !namespace || namespace === listener.namespace;
                  var typeMatches = !type || listener.type === type;
                  var cbMatches = !callback || callback === listener.callback;
                  var listenerMatches = nsMatches && typeMatches && cbMatches;

                  // delete listener if it matches
                  if( listenerMatches ){
                    listeners.splice(j, 1);
                    j--;
                  }
                } // for listeners
              } // for all
            } // if match
          } // for events array

        } // for events map
        
        return self; // maintain chaining
      }; // function
    }, // off

    trigger: function( params ){
      var defaults = {};
      params = $$.util.extend({}, defaults, params);
      
      return function triggerImpl(events, extraParams, fnToTrigger){
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        var eventsIsString = $$.is.string(events);
        var eventsIsObject = $$.is.plainObject(events);
        var eventsIsEvent = $$.is.event(events);
        var cy = this._private.cy || ( $$.is.core(this) ? this : null );
        var hasCompounds = cy ? cy.hasCompoundNodes() : false;

        if( eventsIsString ){ // then make a plain event object for each event name
          var evts = events.split(/\s+/);
          events = [];

          for( var i = 0; i < evts.length; i++ ){
            var evt = evts[i];
            if( $$.is.emptyString(evt) ){ continue; }

            var match = evt.match( $$.define.event.regex ); // type[.namespace]
            var type = match[1];
            var namespace = match[2] ? match[2] : undefined;

            events.push( {
              type: type,
              namespace: namespace
            } );
          }
        } else if( eventsIsObject ){ // put in length 1 array
          var eventArgObj = events;

          events = [ eventArgObj ];
        }

        if( extraParams ){
          if( !$$.is.array(extraParams) ){ // make sure extra params are in an array if specified
            extraParams = [ extraParams ];
          }
        } else { // otherwise, we've got nothing
          extraParams = [];
        }

        for( var i = 0; i < events.length; i++ ){ // trigger each event in order
          var evtObj = events[i];
          
          for( var j = 0; j < all.length; j++ ){ // for each
            var triggerer = all[j];
            var listeners = triggerer._private.listeners = triggerer._private.listeners || [];
            var triggererIsElement = $$.is.element(triggerer);
            var bubbleUp = triggererIsElement || params.layout;

            // create the event for this element from the event object
            var evt;

            if( eventsIsEvent ){ // then just get the object
              evt = evtObj;
              
              evt.cyTarget = evt.cyTarget || triggerer;
              evt.cy = evt.cy || cy;

            } else { // then we have to make one
              evt = new $$.Event( evtObj, {
                cyTarget: triggerer,
                cy: cy,
                namespace: evtObj.namespace
              } );
            }

            // if a layout was specified, then put it in the typed event
            if( evtObj.layout ){
              evt.layout = evtObj.layout;
            }

            // if triggered by layout, put in event
            if( params.layout ){
              evt.layout = triggerer;
            }

            // create a rendered position based on the passed position
            if( evt.cyPosition ){
              var pos = evt.cyPosition;
              var zoom = cy.zoom();
              var pan = cy.pan();

              evt.cyRenderedPosition = {
                x: pos.x * zoom + pan.x,
                y: pos.y * zoom + pan.y
              };
            }

            if( fnToTrigger ){ // then override the listeners list with just the one we specified
              listeners = [{
                namespace: evt.namespace,
                type: evt.type,
                callback: fnToTrigger
              }];
            }

            for( var k = 0; k < listeners.length; k++ ){ // check each listener
              var lis = listeners[k];
              var nsMatches = !lis.namespace || lis.namespace === evt.namespace;
              var typeMatches = lis.type === evt.type;
              var targetMatches = lis.delegated ? ( triggerer !== evt.cyTarget && $$.is.element(evt.cyTarget) && lis.selObj.matches(evt.cyTarget) ) : (true); // we're not going to validate the hierarchy; that's too expensive
              var listenerMatches = nsMatches && typeMatches && targetMatches;

              if( listenerMatches ){ // then trigger it
                var args = [ evt ];
                args = args.concat( extraParams ); // add extra params to args list

                if( lis.data ){ // add on data plugged into binding
                  evt.data = lis.data;
                } else { // or clear it in case the event obj is reused
                  evt.data = undefined;
                }

                if( lis.unbindSelfOnTrigger || lis.unbindAllBindersOnTrigger ){ // then remove listener
                  listeners.splice(k, 1);
                  k--;
                }

                if( lis.unbindAllBindersOnTrigger ){ // then delete the listener for all binders
                  var binders = lis.binders;
                  for( var l = 0; l < binders.length; l++ ){
                    var binder = binders[l];
                    if( !binder || binder === triggerer ){ continue; } // already handled triggerer or we can't handle it

                    var binderListeners = binder._private.listeners;
                    for( var m = 0; m < binderListeners.length; m++ ){
                      var binderListener = binderListeners[m];

                      if( binderListener === lis ){ // delete listener from list
                        binderListeners.splice(m, 1);
                        m--;
                      }
                    }
                  }
                }

                // run the callback
                var context = lis.delegated ? evt.cyTarget : triggerer;
                var ret = lis.callback.apply( context, args );

                if( ret === false || evt.isPropagationStopped() ){
                  // then don't bubble
                  bubbleUp = false;

                  if( ret === false ){
                    // returning false is a shorthand for stopping propagation and preventing the def. action
                    evt.stopPropagation();
                    evt.preventDefault();
                  }
                }
              } // if listener matches
            } // for each listener

            // bubble up event for elements
            if( bubbleUp ){
              var parent = hasCompounds ? triggerer._private.parent : null;
              var hasParent = parent != null && parent.length !== 0;

              if( hasParent ){ // then bubble up to parent
                parent = parent[0];
                parent.trigger(evt);
              } else { // otherwise, bubble up to the core
                cy.trigger(evt);
              }
            }

          } // for each of all
        } // for each event
        
        return self; // maintain chaining
      }; // function
    }, // trigger


    animated: function( fnParams ){
      var defaults = {};
      fnParams = $$.util.extend({}, defaults, fnParams);

      return function animatedImpl(){
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        var cy = this._private.cy || this;

        if( !cy.styleEnabled() ){ return false; }

        var ele = all[0];

        if( ele ){
          return ele._private.animation.current.length > 0;
        }
      };
    }, // animated

    clearQueue: function( fnParams ){
      var defaults = {};
      fnParams = $$.util.extend({}, defaults, fnParams);

      return function clearQueueImpl(){
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        var cy = this._private.cy || this;

        if( !cy.styleEnabled() ){ return this; }

        for( var i = 0; i < all.length; i++ ){
          var ele = all[i];
          ele._private.animation.queue = [];
        }

        return this;
      };
    }, // clearQueue

    delay: function( fnParams ){
      var defaults = {};
      fnParams = $$.util.extend({}, defaults, fnParams);

      return function delayImpl( time, complete ){
        var cy = this._private.cy || this;

        if( !cy.styleEnabled() ){ return this; }

        this.animate({
          delay: time
        }, {
          duration: time,
          complete: complete
        });

        return this;
      };
    }, // delay

    animate: function( fnParams ){
      var defaults = {};
      fnParams = $$.util.extend({}, defaults, fnParams);

      return function animateImpl( properties, params ){
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        var cy = this._private.cy || this;
        var isCore = !selfIsArrayLike;
        var isEles = !isCore;

        if( !cy.styleEnabled() ){ return this; }

        var callTime = +new Date();
        var style = cy.style();
        var q;
        
        if( params === undefined ){
          params = {};
        }

        if( params.duration === undefined ){
          params.duration = 400;
        }
        
        switch( params.duration ){
        case 'slow':
          params.duration = 600;
          break;
        case 'fast':
          params.duration = 200;
          break;
        }
        
        var propertiesEmpty = true;
        if( properties ){ for( var i in properties ){
          propertiesEmpty = false;
          break;
        } }

        if( propertiesEmpty ){
          return this; // nothing to animate
        }

        if( properties.css && isEles ){
          properties.css = style.getValueStyle( properties.css, { array: true } );
        }

        if( properties.renderedPosition && isEles ){
          var rpos = properties.renderedPosition;
          var pan = cy.pan();
          var zoom = cy.zoom();

          properties.position = {
            x: ( rpos.x - pan.x ) /zoom,
            y: ( rpos.y - pan.y ) /zoom
          };
        }

        // override pan w/ panBy if set
        if( properties.panBy && isCore ){
          var panBy = properties.panBy;
          var cyPan = cy.pan();

          properties.pan = {
            x: cyPan.x + panBy.x,
            y: cyPan.y + panBy.y
          };
        }

        // override pan w/ center if set
        var center = properties.center || properties.centre;
        if( center && isCore ){
          var centerPan = cy.getCenterPan( center.eles, properties.zoom );

          if( centerPan ){
            properties.pan = centerPan;
          }
        }

        // override pan & zoom w/ fit if set
        if( properties.fit && isCore ){
          var fit = properties.fit;
          var fitVp = cy.getFitViewport( fit.eles || fit.boundingBox, fit.padding );

          if( fitVp ){
            properties.pan = fitVp.pan; //{ x: fitVp.pan.x, y: fitVp.pan.y };
            properties.zoom = fitVp.zoom;
          }
        }

        for( var i = 0; i < all.length; i++ ){
          var ele = all[i];
         
          if( ele.animated() && (params.queue === undefined || params.queue) ){
            q = ele._private.animation.queue;
          } else {
            q = ele._private.animation.current;
          }

          q.push({
            properties: properties,
            duration: params.duration,
            params: params,
            callTime: callTime
          });
        }

        if( isEles ){
          cy.addToAnimationPool( this );
        }

        return this; // chaining
      };
    }, // animate

    stop: function( fnParams ){
      var defaults = {};
      fnParams = $$.util.extend({}, defaults, fnParams);

      return function stopImpl( clearQueue, jumpToEnd ){
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        var cy = this._private.cy || this;

        if( !cy.styleEnabled() ){ return this; }

        for( var i = 0; i < all.length; i++ ){
          var ele = all[i];
          var anis = ele._private.animation.current;

          for( var j = 0; j < anis.length; j++ ){
            var animation = anis[j];    
            if( jumpToEnd ){
              // next iteration of the animation loop, the animation
              // will go straight to the end and be removed
              animation.duration = 0; 
            }
          }
          
          // clear the queue of future animations
          if( clearQueue ){
            ele._private.animation.queue = [];
          }

          if( !jumpToEnd ){
            ele._private.animation.current = [];
          }
        }
        
        // we have to notify (the animation loop doesn't do it for us on `stop`)
        cy.notify({
          collection: this,
          type: 'draw'
        });
        
        return this;
      };
    } // stop

  }; // define

  
})( cytoscape );

;(function($$){ 'use strict';

  $$.fn.selector = function(map, options){
    for( var name in map ){
      var fn = map[name];
      $$.Selector.prototype[ name ] = fn;
    }
  };

  $$.Selector = function(onlyThisGroup, selector){
    
    if( !(this instanceof $$.Selector) ){
      return new $$.Selector(onlyThisGroup, selector);
    }
  
    if( selector === undefined && onlyThisGroup !== undefined ){
      selector = onlyThisGroup;
      onlyThisGroup = undefined;
    }
    
    var self = this;
    
    self._private = {
      selectorText: null,
      invalid: true
    };
    
    if( !selector || ( $$.is.string(selector) && selector.match(/^\s*$/) ) ){
      
      if( onlyThisGroup == null ){
        // ignore
        self.length = 0;
      } else {
        self[0] = newQuery();
        self[0].group = onlyThisGroup;
        self.length = 1;
      }
              
    } else if( $$.is.element( selector ) ){
      var collection = new $$.Collection(self.cy(), [ selector ]);
      
      self[0] = newQuery();
      self[0].collection = collection;
      self.length = 1;
      
    } else if( $$.is.collection( selector ) ){
      self[0] = newQuery();
      self[0].collection = selector;
      self.length = 1;
      
    } else if( $$.is.fn( selector ) ) {
      self[0] = newQuery();
      self[0].filter = selector;
      self.length = 1;
      
    } else if( $$.is.string( selector ) ){

      // the current subject in the query
      var currentSubject = null;
      
      // storage for parsed queries
      var newQuery = function(){
        return {
          classes: [], 
          colonSelectors: [],
          data: [],
          group: null,
          ids: [],
          meta: [],

          // fake selectors
          collection: null, // a collection to match against
          filter: null, // filter function

          // these are defined in the upward direction rather than down (e.g. child)
          // because we need to go up in Selector.filter()
          parent: null, // parent query obj
          ancestor: null, // ancestor query obj
          subject: null, // defines subject in compound query (subject query obj; points to self if subject)

          // use these only when subject has been defined
          child: null,
          descendant: null
        };
      };

      // tokens in the query language
      var tokens = {
        metaChar: '[\\!\\"\\#\\$\\%\\&\\\'\\(\\)\\*\\+\\,\\.\\/\\:\\;\\<\\=\\>\\?\\@\\[\\]\\^\\`\\{\\|\\}\\~]', // chars we need to escape in var names, etc
        comparatorOp: '=|\\!=|>|>=|<|<=|\\$=|\\^=|\\*=', // binary comparison op (used in data selectors)
        boolOp: '\\?|\\!|\\^', // boolean (unary) operators (used in data selectors)
        string: '"(?:\\\\"|[^"])+"' + '|' + "'(?:\\\\'|[^'])+'", // string literals (used in data selectors) -- doublequotes | singlequotes
        number: $$.util.regex.number, // number literal (used in data selectors) --- e.g. 0.1234, 1234, 12e123
        meta: 'degree|indegree|outdegree', // allowed metadata fields (i.e. allowed functions to use from $$.Collection)
        separator: '\\s*,\\s*', // queries are separated by commas, e.g. edge[foo = 'bar'], node.someClass
        descendant: '\\s+',
        child: '\\s+>\\s+',
        subject: '\\$'
      };
      tokens.variable = '(?:[\\w-]|(?:\\\\'+ tokens.metaChar +'))+'; // a variable name
      tokens.value = tokens.string + '|' + tokens.number; // a value literal, either a string or number
      tokens.className = tokens.variable; // a class name (follows variable conventions)
      tokens.id = tokens.variable; // an element id (follows variable conventions)

      // when a token like a variable has escaped meta characters, we need to clean the backslashes out
      // so that values get compared properly in Selector.filter()
      var cleanMetaChars = function(str){
        return str.replace(new RegExp('\\\\(' + tokens.metaChar + ')', 'g'), function(match, $1, offset, original){
          return $1;
        });
      };
      
      // add @ variants to comparatorOp
      var ops = tokens.comparatorOp.split('|');
      for( var i = 0; i < ops.length; i++ ){
        var op = ops[i];
        tokens.comparatorOp += '|@' + op;
      }

      // add ! variants to comparatorOp
      var ops = tokens.comparatorOp.split('|');
      for( var i = 0; i < ops.length; i++ ){
        var op = ops[i];

        if( op.indexOf('!') >= 0 ){ continue; } // skip ops that explicitly contain !
        if( op === '=' ){ continue; } // skip = b/c != is explicitly defined

        tokens.comparatorOp += '|\\!' + op;
      }

      // NOTE: add new expression syntax here to have it recognised by the parser;
      // - a query contains all adjacent (i.e. no separator in between) expressions;
      // - the current query is stored in self[i] --- you can use the reference to `this` in the populate function;
      // - you need to check the query objects in Selector.filter() for it actually filter properly, but that's pretty straight forward
      // - when you add something here, also add to Selector.toString()
      var exprs = {
        group: {
          query: true,
          regex: '(node|edge|\\*)',
          populate: function( group ){
            this.group = group == "*" ? group : group + 's';
          }
        },
        
        state: {
          query: true,
          // NB: if one colon selector is a substring of another from its start, place the longer one first
          // e.g. :foobar|:foo
          regex: '(:selected|:unselected|:locked|:unlocked|:visible|:hidden|:transparent|:grabbed|:free|:removed|:inside|:grabbable|:ungrabbable|:animated|:unanimated|:selectable|:unselectable|:orphan|:nonorphan|:parent|:child|:loop|:simple|:active|:inactive|:touch|:backgrounding|:nonbackgrounding)',
          populate: function( state ){
            this.colonSelectors.push( state );
          }
        },
        
        id: {
          query: true,
          regex: '\\#('+ tokens.id +')',
          populate: function( id ){
            this.ids.push( cleanMetaChars(id) );
          }
        },
        
        className: {
          query: true,
          regex: '\\.('+ tokens.className +')',
          populate: function( className ){
            this.classes.push( cleanMetaChars(className) );
          }
        },
        
        dataExists: {
          query: true,
          regex: '\\[\\s*('+ tokens.variable +')\\s*\\]',
          populate: function( variable ){
            this.data.push({
              field: cleanMetaChars(variable)
            });
          }
        },
        
        dataCompare: {
          query: true,
          regex: '\\[\\s*('+ tokens.variable +')\\s*('+ tokens.comparatorOp +')\\s*('+ tokens.value +')\\s*\\]',
          populate: function( variable, comparatorOp, value ){ 
            var valueIsString = new RegExp('^' + tokens.string + '$').exec(value) != null;

            if( valueIsString ){
              value = value.substring(1, value.length - 1);
            } else {
              value = parseFloat(value);
            }

            this.data.push({
              field: cleanMetaChars(variable),
              operator: comparatorOp,
              value: value
            });
          }
        },
        
        dataBool: {
          query: true,
          regex: '\\[\\s*('+ tokens.boolOp +')\\s*('+ tokens.variable +')\\s*\\]',
          populate: function( boolOp, variable ){
            this.data.push({
              field: cleanMetaChars(variable),
              operator: boolOp
            });
          }
        },
        
        metaCompare: {
          query: true,
          regex: '\\[\\[\\s*('+ tokens.meta +')\\s*('+ tokens.comparatorOp +')\\s*('+ tokens.number +')\\s*\\]\\]',
          populate: function( meta, comparatorOp, number ){
            this.meta.push({
              field: cleanMetaChars(meta),
              operator: comparatorOp,
              value: parseFloat(number)
            });
          }
        },

        nextQuery: {
          separator: true,
          regex: tokens.separator,
          populate: function(){
            // go on to next query
            self[++i] = newQuery();
            currentSubject = null;
          }
        },

        child: {
          separator: true,
          regex: tokens.child,
          populate: function(){
            // this query is the parent of the following query
            var childQuery = newQuery();
            childQuery.parent = this;
            childQuery.subject = currentSubject;

            // we're now populating the child query with expressions that follow
            self[i] = childQuery;
          }
        },

        descendant: {
          separator: true,
          regex: tokens.descendant,
          populate: function(){
            // this query is the ancestor of the following query
            var descendantQuery = newQuery();
            descendantQuery.ancestor = this;
            descendantQuery.subject = currentSubject;

            // we're now populating the descendant query with expressions that follow
            self[i] = descendantQuery;
          }
        },

        subject: {
          modifier: true,
          regex: tokens.subject,
          populate: function(){
            if( currentSubject != null && this.subject != this ){
              $$.util.error('Redefinition of subject in selector `' + selector + '`');
              return false;
            }

            currentSubject = this;
            this.subject = this;
          }

        }
      };

      var j = 0;
      for( var name in exprs ){
        exprs[j] = exprs[name];
        exprs[j].name = name;

        j++;
      }
      exprs.length = j;

      self._private.selectorText = selector;
      var remaining = selector;
      var i = 0;
      
      // of all the expressions, find the first match in the remaining text
      var consumeExpr = function( expectation ){
        var expr;
        var match;
        var name;
        
        for( var j = 0; j < exprs.length; j++ ){
          var e = exprs[j];
          var n = e.name;

          // ignore this expression if it doesn't meet the expectation function
          if( $$.is.fn( expectation ) && !expectation(n, e) ){ continue; }

          var m = remaining.match(new RegExp( '^' + e.regex ));
          
          if( m != null ){
            match = m;
            expr = e;
            name = n;
            
            var consumed = m[0];
            remaining = remaining.substring( consumed.length );                
            
            break; // we've consumed one expr, so we can return now
          }
        }
        
        return {
          expr: expr,
          match: match,
          name: name
        };
      };
      
      // consume all leading whitespace
      var consumeWhitespace = function(){
        var match = remaining.match(/^\s+/);
        
        if( match ){
          var consumed = match[0];
          remaining = remaining.substring( consumed.length );
        }
      };
      
      self[0] = newQuery(); // get started

      consumeWhitespace(); // get rid of leading whitespace
      for(;;){        
        var check = consumeExpr();
        
        if( check.expr == null ){
          $$.util.error('The selector `'+ selector +'`is invalid');
          return;
        } else {
          var args = [];
          for(var j = 1; j < check.match.length; j++){
            args.push( check.match[j] );
          }
          
          // let the token populate the selector object (i.e. in self[i])
          var ret = check.expr.populate.apply( self[i], args );

          if( ret === false ){ return; } // exit if population failed
        }
        
        // we're done when there's nothing left to parse
        if( remaining.match(/^\s*$/) ){
          break;
        }
      }
      
      self.length = i + 1;

      // adjust references for subject
      for(j = 0; j < self.length; j++){
        var query = self[j];

        if( query.subject != null ){
          // go up the tree until we reach the subject
          for(;;){
            if( query.subject == query ){ break; } // done if subject is self

            if( query.parent != null ){ // swap parent/child reference
              var parent = query.parent;
              var child = query;

              child.parent = null;
              parent.child = child;

              query = parent; // go up the tree
            } else if( query.ancestor != null ){ // swap ancestor/descendant
              var ancestor = query.ancestor;
              var descendant = query;

              descendant.ancestor = null;
              ancestor.descendant = descendant;

              query = ancestor; // go up the tree
            } else {
              $$.util.error('When adjusting references for the selector `'+ query +'`, neither parent nor ancestor was found');
              break;
            }
          } // for

          self[j] = query.subject; // subject should be the root query
        } // if
      } // for

      // make sure for each query that the subject group matches the implicit group if any
      if( onlyThisGroup != null ){
        for(var j = 0; j < self.length; j++){
          if( self[j].group != null && self[j].group != onlyThisGroup ){
            $$.util.error('Group `'+ self[j].group +'` conflicts with implicit group `'+ onlyThisGroup +'` in selector `'+ selector +'`');
            return;
          }

          self[j].group = onlyThisGroup; // set to implicit group
        }
      }
      
    } else {
      $$.util.error('A selector must be created from a string; found ' + selector);
      return;
    }

    self._private.invalid = false;
    
  };

  $$.selfn = $$.Selector.prototype;
  
  $$.selfn.size = function(){
    return this.length;
  };
  
  $$.selfn.eq = function(i){
    return this[i];
  };
  
  // get elements from the core and then filter them
  $$.selfn.find = function(){
    // TODO impl if we decide to use a DB for storing elements
  };
  
  var queryMatches = function(query, element){
    // check group
    if( query.group != null && query.group != '*' && query.group != element._private.group ){
      return false;
    }

    var cy = element.cy();
    
    // check colon selectors
    var allColonSelectorsMatch = true;
    for(var k = 0; k < query.colonSelectors.length; k++){
      var sel = query.colonSelectors[k];
      
      switch(sel){
      case ':selected':
        allColonSelectorsMatch = element.selected();
        break;
      case ':unselected':
        allColonSelectorsMatch = !element.selected();
        break;
      case ':selectable':
        allColonSelectorsMatch = element.selectable();
        break;
      case ':unselectable':
        allColonSelectorsMatch = !element.selectable();
        break;
      case ':locked':
        allColonSelectorsMatch = element.locked();
        break;
      case ':unlocked':
        allColonSelectorsMatch = !element.locked();
        break;
      case ':visible':
        allColonSelectorsMatch = element.visible();
        break;
      case ':hidden':
        allColonSelectorsMatch = !element.visible();
        break;
      case ':transparent':
        allColonSelectorsMatch = element.transparent();
        break;
      case ':grabbed':
        allColonSelectorsMatch = element.grabbed();
        break;
      case ':free':
        allColonSelectorsMatch = !element.grabbed();
        break;
      case ':removed':
        allColonSelectorsMatch = element.removed();
        break;
      case ':inside':
        allColonSelectorsMatch = !element.removed();
        break;
      case ':grabbable':
        allColonSelectorsMatch = element.grabbable();
        break;
      case ':ungrabbable':
        allColonSelectorsMatch = !element.grabbable();
        break;
      case ':animated':
        allColonSelectorsMatch = element.animated();
        break;
      case ':unanimated':
        allColonSelectorsMatch = !element.animated();
        break;
      case ':parent':
        allColonSelectorsMatch = element.isNode() && element.children().nonempty();
        break;
      case ':child':
      case ':nonorphan':
        allColonSelectorsMatch = element.isNode() && element.parent().nonempty();
        break;
      case ':orphan':
        allColonSelectorsMatch = element.isNode() && element.parent().empty();
        break;
      case ':loop':
        allColonSelectorsMatch = element.isEdge() && element.data('source') === element.data('target');
        break;
      case ':simple':
        allColonSelectorsMatch = element.isEdge() && element.data('source') !== element.data('target');
        break;
      case ':active':
        allColonSelectorsMatch = element.active();
        break;
      case ':inactive':
        allColonSelectorsMatch = !element.active();
        break;
      case ':touch':
        allColonSelectorsMatch = $$.is.touch();
        break;
      case ':backgrounding':
        allColonSelectorsMatch = element.backgrounding();
        break;
      case ':nonbackgrounding':
        allColonSelectorsMatch = !element.backgrounding();
        break;
      }
      
      if( !allColonSelectorsMatch ) break;
    }
    if( !allColonSelectorsMatch ) return false;
    
    // check id
    var allIdsMatch = true;
    for(var k = 0; k < query.ids.length; k++){
      var id = query.ids[k];
      var actualId = element._private.data.id;
      
      allIdsMatch = allIdsMatch && (id == actualId);
      
      if( !allIdsMatch ) break;
    }
    if( !allIdsMatch ) return false;
    
    // check classes
    var allClassesMatch = true;
    for(var k = 0; k < query.classes.length; k++){
      var cls = query.classes[k];
      
      allClassesMatch = allClassesMatch && element.hasClass(cls);
      
      if( !allClassesMatch ) break;
    }
    if( !allClassesMatch ) return false;
    
    // generic checking for data/metadata
    var operandsMatch = function(params){
      var allDataMatches = true;
      for(var k = 0; k < query[params.name].length; k++){
        var data = query[params.name][k];
        var operator = data.operator;
        var value = data.value;
        var field = data.field;
        var matches;
        
        if( operator != null && value != null ){
          
          var fieldVal = params.fieldValue(field);
          var fieldStr = !$$.is.string(fieldVal) && !$$.is.number(fieldVal) ? '' : '' + fieldVal;
          var valStr = '' + value;
          
          var caseInsensitive = false;
          if( operator.indexOf('@') >= 0 ){
            fieldStr = fieldStr.toLowerCase();
            valStr = valStr.toLowerCase();
            
            operator = operator.replace('@', '');
            caseInsensitive = true;
          }

          var notExpr = false;
          var handledNotExpr = false;
          if( operator.indexOf('!') >= 0 ){
            operator = operator.replace('!', '');
            notExpr = true;
          }
          
          // if we're doing a case insensitive comparison, then we're using a STRING comparison
          // even if we're comparing numbers
          if( caseInsensitive ){
            value = valStr.toLowerCase();
            fieldVal = fieldStr.toLowerCase();
          }

          switch(operator){
          case '*=':
            matches = fieldStr.search(valStr) >= 0;
            break;
          case '$=':
            matches = new RegExp(valStr + '$').exec(fieldStr) != null;
            break;
          case '^=':
            matches = new RegExp('^' + valStr).exec(fieldStr) != null;
            break;
          case '=':
            matches = fieldVal === value;
            break;
          case '!=':
            matches = fieldVal !== value;
            break;
          case '>':
            matches = !notExpr ? fieldVal > value : fieldVal <= value;
            handledNotExpr = true;
            break;
          case '>=':
            matches = !notExpr ? fieldVal >= value : fieldVal < value;
            handledNotExpr = true;
            break;
          case '<':
            matches = !notExpr ? fieldVal < value : fieldVal >= value;
            handledNotExpr = true;
            break;
          case '<=':
            matches = !notExpr ? fieldVal <= value : fieldVal > value;
            handledNotExpr = true;
            break;
          default:
            matches = false;
            break;
            
          }
        } else if( operator != null ){
          switch(operator){
          case '?':
            matches = params.fieldTruthy(field);
            break;
          case '!':
            matches = !params.fieldTruthy(field);
            break;
          case '^':
            matches = params.fieldUndefined(field);
            break;
          }
        } else {   
          matches = !params.fieldUndefined(field);
        }

        if( notExpr && !handledNotExpr ){
          matches = !matches;
          handledNotExpr = true;
        }
        
        if( !matches ){
          allDataMatches = false;
          break;
        }
      } // for
      
      return allDataMatches;
    }; // operandsMatch
    
    // check data matches
    var allDataMatches = operandsMatch({
      name: 'data',
      fieldValue: function(field){
        return element._private.data[field];
      },
      fieldRef: function(field){
        return 'element._private.data.' + field;
      },
      fieldUndefined: function(field){
        return element._private.data[field] === undefined;
      },
      fieldTruthy: function(field){
        if( element._private.data[field] ){
          return true;
        }
        return false;
      }
    });
    
    if( !allDataMatches ){
      return false;
    }
    
    // check metadata matches
    var allMetaMatches = operandsMatch({
      name: 'meta',
      fieldValue: function(field){
        return element[field]();
      },
      fieldRef: function(field){
        return 'element.' + field + '()';
      },
      fieldUndefined: function(field){
        return element[field]() == null;
      },
      fieldTruthy: function(field){
        if( element[field]() ){
          return true;
        }
        return false;
      }
    });
    
    if( !allMetaMatches ){
      return false;
    }
    
    // check collection
    if( query.collection != null ){
      var matchesAny = query.collection._private.ids[ element.id() ] != null;
      
      if( !matchesAny ){
        return false;
      }
    }
    
    // check filter function
    if( query.filter != null && element.collection().filter( query.filter ).size() === 0 ){
      return false;
    }
    

    // check parent/child relations
    var confirmRelations = function( query, elements ){
      if( query != null ){
        var matches = false;

        if( !cy.hasCompoundNodes() ){
          return false;
        }

        elements = elements(); // make elements functional so we save cycles if query == null

        // query must match for at least one element (may be recursive)
        for(var i = 0; i < elements.length; i++){
          if( queryMatches( query, elements[i] ) ){
            matches = true;
            break;
          }
        }

        return matches;
      } else {
        return true;
      }
    };

    if (! confirmRelations(query.parent, function(){
      return element.parent();
    }) ){ return false; }

    if (! confirmRelations(query.ancestor, function(){
      return element.parents();
    }) ){ return false; }

    if (! confirmRelations(query.child, function(){
      return element.children();
    }) ){ return false; }

    if (! confirmRelations(query.descendant, function(){
      return element.descendants();
    }) ){ return false; }

    // we've reached the end, so we've matched everything for this query
    return true;
  }; // queryMatches

  // filter an existing collection
  $$.selfn.filter = function(collection){
    var self = this;
    var cy = collection.cy();
    
    // don't bother trying if it's invalid
    if( self._private.invalid ){
      return new $$.Collection( cy );
    }
  
    var selectorFunction = function(i, element){
      for(var j = 0; j < self.length; j++){
        var query = self[j];
        
        if( queryMatches(query, element) ){
          return true;
        }
      }
      
      return false;
    };
    
    if( self._private.selectorText == null ){
      selectorFunction = function(){ return true; };
    }
    
    var filteredCollection = collection.filter( selectorFunction );
    
    return filteredCollection;
  }; // filter

  // does selector match a single element?
  $$.selfn.matches = function(ele){
    var self = this;
    
    // don't bother trying if it's invalid
    if( self._private.invalid ){
      return false;
    }
  
    for(var j = 0; j < self.length; j++){
      var query = self[j];
      
      if( queryMatches(query, ele) ){
        return true;
      }
    }
    
    return false;
  }; // filter
  
  // ith query to string
  $$.selfn.toString = $$.selfn.selector = function(){
    
    var str = '';
    
    var clean = function(obj, isValue){
      if( $$.is.string(obj) ){
        return isValue ? '"' + obj + '"' : obj;
      } 
      return '';
    };
    
    var queryToString = function(query){
      var str = '';

      if( query.subject === query ){
        str += '$';
      }

      var group = clean(query.group);
      str += group.substring(0, group.length - 1);
      
      for(var j = 0; j < query.data.length; j++){
        var data = query.data[j];
        
        if( data.value ){
          str += '[' + data.field + clean(data.operator) + clean(data.value, true) + ']';
        } else {
          str += '[' + clean(data.operator) + data.field + ']';
        }
      }

      for(var j = 0; j < query.meta.length; j++){
        var meta = query.meta[j];
        str += '[[' + meta.field + clean(meta.operator) + clean(meta.value, true) + ']]';
      }
      
      for(var j = 0; j < query.colonSelectors.length; j++){
        var sel = query.colonSelectors[i];
        str += sel;
      }
      
      for(var j = 0; j < query.ids.length; j++){
        var sel = '#' + query.ids[i];
        str += sel;
      }
      
      for(var j = 0; j < query.classes.length; j++){
        var sel = '.' + query.classes[i];
        str += sel;
      }

      if( query.parent != null ){
        str = queryToString( query.parent ) + ' > ' + str; 
      }

      if( query.ancestor != null ){
        str = queryToString( query.ancestor ) + ' ' + str; 
      }

      if( query.child != null ){
        str += ' > ' + queryToString( query.child ); 
      }

      if( query.descendant != null ){
        str += ' ' + queryToString( query.descendant ); 
      }

      return str;
    };

    for(var i = 0; i < this.length; i++){
      var query = this[i];
      
      str += queryToString( query );
      
      if( this.length > 1 && i < this.length - 1 ){
        str += ', ';
      }
    }
    
    return str;
  };
  
})( cytoscape );

;(function($$){ 'use strict';

  $$.Style = function( cy ){

    if( !(this instanceof $$.Style) ){
      return new $$.Style(cy);
    }

    if( !$$.is.core(cy) ){
      $$.util.error('A style must have a core reference');
      return;
    }

    this._private = {
      cy: cy,
      coreStyle: {},
      newStyle: true
    };

    this.length = 0;

    this.addDefaultStylesheet();
  };

  // nice-to-have aliases
  $$.style = $$.Style;
  $$.styfn = $$.Style.prototype;

  // define functions in the Style prototype
  $$.fn.style = function( fnMap, options ){
    for( var fnName in fnMap ){
      var fn = fnMap[ fnName ];
      $$.Style.prototype = fn;
    }
  };

  (function(){
    var number = $$.util.regex.number;
    var rgba = $$.util.regex.rgbaNoBackRefs;
    var hsla = $$.util.regex.hslaNoBackRefs;
    var hex3 = $$.util.regex.hex3;
    var hex6 = $$.util.regex.hex6;
    var data = function( prefix ){ return '^' + prefix + '\\s*\\(\\s*([\\w\\.]+)\\s*\\)$'; };
    var mapData = function( prefix ){ return '^' + prefix + '\\s*\\(([\\w\\.]+)\\s*\\,\\s*(' + number + ')\\s*\\,\\s*(' + number + ')\\s*,\\s*(' + number + '|\\w+|' + rgba + '|' + hsla + '|' + hex3 + '|' + hex6 + ')\\s*\\,\\s*(' + number + '|\\w+|' + rgba + '|' + hsla + '|' + hex3 + '|' + hex6 + ')\\)$'; };

    // each visual style property has a type and needs to be validated according to it
    $$.style.types = {
      time: { number: true, min: 0, units: 's|ms', implicitUnits: 'ms' },
      percent: { number: true, min: 0, max: 100, units: '%' },
      zeroOneNumber: { number: true, min: 0, max: 1, unitless: true },
      nOneOneNumber: { number: true, min: -1, max: 1, unitless: true },
      nonNegativeInt: { number: true, min: 0, integer: true, unitless: true },
      position: { enums: ['parent', 'origin'] },
      autoSize: { number: true, min: 0, enums: ['auto'] },
      number: { number: true },
      size: { number: true, min: 0 },
      bgSize: { number: true, min: 0, allowPercent: true },
      bgWH: { number: true, min: 0, allowPercent: true, enums: ['auto'] },
      bgPos: { number: true, allowPercent: true },
      bgRepeat: { enums: ['repeat', 'repeat-x', 'repeat-y', 'no-repeat'] },
      bgFit: { enums: ['none', 'contain', 'cover'] },
      bgClip: { enums: ['none', 'node'] },
      color: { color: true },
      lineStyle: { enums: ['solid', 'dotted', 'dashed'] },
      borderStyle: { enums: ['solid', 'dotted', 'dashed', 'double'] },
      curveStyle: { enums: ['bezier', 'unbundled-bezier', 'haystack'] },
      fontFamily: { regex: '^([\\w- \\"]+(?:\\s*,\\s*[\\w- \\"]+)*)$' },
      fontVariant: { enums: ['small-caps', 'normal'] },
      fontStyle: { enums: ['italic', 'normal', 'oblique'] },
      fontWeight: { enums: ['normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '800', '900', 100, 200, 300, 400, 500, 600, 700, 800, 900] },
      textDecoration: { enums: ['none', 'underline', 'overline', 'line-through'] },
      textTransform: { enums: ['none', 'uppercase', 'lowercase'] },
      textWrap: { enums: ['none', 'wrap'] },
      textBackgroundShape: { enums: ['rectangle', 'roundrectangle']},
      nodeShape: { enums: ['rectangle', 'roundrectangle', 'ellipse', 'triangle', 'square', 'pentagon', 'hexagon', 'heptagon', 'octagon', 'star', 'diamond', 'vee', 'rhomboid'] },
      compoundIncludeLabels: { enums: ['include', 'exclude'] },
      arrowShape: { enums: ['tee', 'triangle', 'triangle-tee', 'triangle-backcurve', 'half-triangle-overshot', 'square', 'circle', 'diamond', 'none'] },
      arrowFill: { enums: ['filled', 'hollow'] },
      display: { enums: ['element', 'none'] },
      visibility: { enums: ['hidden', 'visible'] },
      valign: { enums: ['top', 'center', 'bottom'] },
      halign: { enums: ['left', 'center', 'right'] },
      text: { string: true },
      data: { mapping: true, regex: data('data') },
      layoutData: { mapping: true, regex: data('layoutData') },
      scratch: { mapping: true, regex: data('scratch') },
      mapData: { mapping: true, regex: mapData('mapData') },
      mapLayoutData: { mapping: true, regex: mapData('mapLayoutData') },
      mapScratch: { mapping: true, regex: mapData('mapScratch') },
      fn: { mapping: true, fn: true },
      url: { regex: '^url\\s*\\(\\s*([^\\s]+)\\s*\\s*\\)|none|(.+)$' },
      propList: { propList: true },
      angle: { number: true, units: 'deg|rad' },
      textRotation: { enums: ['none', 'autorotate'] }
    };

    // define visual style properties
    var t = $$.style.types;
    var props = $$.style.properties = [
      // labels
      { name: 'text-valign', type: t.valign },
      { name: 'text-halign', type: t.halign },
      { name: 'color', type: t.color },
      { name: 'content', type: t.text },
      { name: 'text-outline-color', type: t.color },
      { name: 'text-outline-width', type: t.size },
      { name: 'text-outline-opacity', type: t.zeroOneNumber },
      { name: 'text-opacity', type: t.zeroOneNumber },
      { name: 'text-background-color', type: t.color },
      { name: 'text-background-opacity', type: t.zeroOneNumber },
      { name: 'text-border-opacity', type: t.zeroOneNumber },
      { name: 'text-border-color', type: t.color },
      { name: 'text-border-width', type: t.size },
      { name: 'text-border-style', type: t.borderStyle },
      { name: 'text-background-shape', type: t.textBackgroundShape},
      // { name: 'text-decoration', type: t.textDecoration }, // not supported in canvas
      { name: 'text-transform', type: t.textTransform },
      { name: 'text-wrap', type: t.textWrap },
      { name: 'text-max-width', type: t.size },

      // { name: 'text-rotation', type: t.angle }, // TODO disabled b/c rotation breaks bounding boxes
      { name: 'font-family', type: t.fontFamily },
      { name: 'font-style', type: t.fontStyle },
      // { name: 'font-variant', type: t.fontVariant }, // not useful
      { name: 'font-weight', type: t.fontWeight },
      { name: 'font-size', type: t.size },
      { name: 'min-zoomed-font-size', type: t.size },
      { name: 'edge-text-rotation', type: t.textRotation },

      // visibility
      { name: 'display', type: t.display },
      { name: 'visibility', type: t.visibility },
      { name: 'opacity', type: t.zeroOneNumber },
      { name: 'z-index', type: t.nonNegativeInt },

      // overlays
      { name: 'overlay-padding', type: t.size },
      { name: 'overlay-color', type: t.color },
      { name: 'overlay-opacity', type: t.zeroOneNumber },

      // shadows
      { name: 'shadow-blur', type: t.size },
      { name: 'shadow-color', type: t.color },
      { name: 'shadow-opacity', type: t.zeroOneNumber },
      { name: 'shadow-offset-x', type: t.number },
      { name: 'shadow-offset-y', type: t.number },

      // label shadows
      { name: 'text-shadow-blur', type: t.size },
      { name: 'text-shadow-color', type: t.color },
      { name: 'text-shadow-opacity', type: t.zeroOneNumber },
      { name: 'text-shadow-offset-x', type: t.number },
      { name: 'text-shadow-offset-y', type: t.number },

      // transition anis
      { name: 'transition-property', type: t.propList },
      { name: 'transition-duration', type: t.time },
      { name: 'transition-delay', type: t.time },

      // node body
      { name: 'height', type: t.autoSize },
      { name: 'width', type: t.autoSize },
      { name: 'shape', type: t.nodeShape },
      { name: 'background-color', type: t.color },
      { name: 'background-opacity', type: t.zeroOneNumber },
      { name: 'background-blacken', type: t.nOneOneNumber },

      // node border
      { name: 'border-color', type: t.color },
      { name: 'border-opacity', type: t.zeroOneNumber },
      { name: 'border-width', type: t.size },
      { name: 'border-style', type: t.borderStyle },

      // node background images
      { name: 'background-image', type: t.url },
      { name: 'background-image-opacity', type: t.zeroOneNumber },
      { name: 'background-position-x', type: t.bgPos },
      { name: 'background-position-y', type: t.bgPos },
      { name: 'background-repeat', type: t.bgRepeat },
      { name: 'background-fit', type: t.bgFit },
      { name: 'background-clip', type: t.bgClip },
      { name: 'background-width', type: t.bgWH },
      { name: 'background-height', type: t.bgWH },

      // compound props
      { name: 'padding-left', type: t.size },
      { name: 'padding-right', type: t.size },
      { name: 'padding-top', type: t.size },
      { name: 'padding-bottom', type: t.size },
      { name: 'position', type: t.position },
      { name: 'compound-sizing-wrt-labels', type: t.compoundIncludeLabels },

      // edge line
      { name: 'line-style', type: t.lineStyle },
      { name: 'line-color', type: t.color },
      { name: 'control-point-step-size', type: t.size },
      { name: 'control-point-distance', type: t.number },
      { name: 'control-point-weight', type: t.zeroOneNumber },
      { name: 'curve-style', type: t.curveStyle },
      { name: 'haystack-radius', type: t.zeroOneNumber },

      // edge arrows
      { name: 'source-arrow-shape', type: t.arrowShape },
      { name: 'target-arrow-shape', type: t.arrowShape },
      { name: 'mid-source-arrow-shape', type: t.arrowShape },
      { name: 'mid-target-arrow-shape', type: t.arrowShape },
      { name: 'source-arrow-color', type: t.color },
      { name: 'target-arrow-color', type: t.color },
      { name: 'mid-source-arrow-color', type: t.color },
      { name: 'mid-target-arrow-color', type: t.color },
      { name: 'source-arrow-fill', type: t.arrowFill },
      { name: 'target-arrow-fill', type: t.arrowFill },
      { name: 'mid-source-arrow-fill', type: t.arrowFill },
      { name: 'mid-target-arrow-fill', type: t.arrowFill },

      // these are just for the core
      { name: 'selection-box-color', type: t.color },
      { name: 'selection-box-opacity', type: t.zeroOneNumber },
      { name: 'selection-box-border-color', type: t.color },
      { name: 'selection-box-border-width', type: t.size },
      { name: 'active-bg-color', type: t.color },
      { name: 'active-bg-opacity', type: t.zeroOneNumber },
      { name: 'active-bg-size', type: t.size },
      { name: 'outside-texture-bg-color', type: t.color },
      { name: 'outside-texture-bg-opacity', type: t.zeroOneNumber }
    ];

    // pie backgrounds for nodes
    $$.style.pieBackgroundN = 16; // because the pie properties are numbered, give access to a constant N (for renderer use)
    props.push({ name: 'pie-size', type: t.bgSize });
    for( var i = 1; i <= $$.style.pieBackgroundN; i++ ){
      props.push({ name: 'pie-'+i+'-background-color', type: t.color });
      props.push({ name: 'pie-'+i+'-background-size', type: t.percent });
      props.push({ name: 'pie-'+i+'-background-opacity', type: t.zeroOneNumber });
    }

    // allow access of properties by name ( e.g. $$.style.properties.height )
    for( var i = 0; i < props.length; i++ ){
      var prop = props[i];

      props[ prop.name ] = prop; // allow lookup by name
    }
  })();

  // adds the default stylesheet to the current style
  $$.styfn.addDefaultStylesheet = function(){
    // to be nice, we build font related style properties from the core container
    // so that cytoscape matches the style of its container by default
    //
    // unfortunately, this doesn't seem work consistently and can grab the default stylesheet values
    // instead of the developer's values so let's just make it explicit for the dev for now
    //
    // delaying the read of these val's is not an opt'n: that would delay init'l load time
    var fontFamily = 'Helvetica' || this.containerPropertyAsString('font-family') || 'sans-serif';
    var fontStyle = 'normal' || this.containerPropertyAsString('font-style') || 'normal';
    // var fontVariant = 'normal' || this.containerPropertyAsString('font-variant') || 'normal';
    var fontWeight = 'normal' || this.containerPropertyAsString('font-weight') || 'normal';
    var color = '#000' || this.containerPropertyAsString('color') || '#000';
    var textTransform = 'none' || this.containerPropertyAsString('text-transform') || 'none';
    var fontSize = 16 || this.containerPropertyAsString('font-size') || 16;
    var textMaxWidth = 9999 || this.containerPropertyAsString('text-max-width') || 9999;

    // fill the style with the default stylesheet
    this
      .selector('node, edge') // common properties
        .css({
          'text-valign': 'top',
          'text-halign': 'center',
          'color': color,
          'text-outline-color': '#000',
          'text-outline-width': 0,
          'text-outline-opacity': 1,
          'text-opacity': 1,
          'text-decoration': 'none',
          'text-transform': textTransform,
          'text-wrap': 'none',
          'text-max-width': textMaxWidth,
          'text-background-color': '#000',
          'text-background-opacity': 0,
          'text-border-opacity': 0,
          'text-border-width': 0,
          'text-border-style': 'solid',
          'text-border-color':'#000',
          'text-background-shape':'rectangle',
          'font-family': fontFamily,
          'font-style': fontStyle,
          // 'font-variant': fontVariant,
          'font-weight': fontWeight,
          'font-size': fontSize,
          'min-zoomed-font-size': 0,
          'edge-text-rotation': 'none',
          'visibility': 'visible',
          'display': 'element',
          'opacity': 1,
          'z-index': 0,
          'content': '',
          'overlay-opacity': 0,
          'overlay-color': '#000',
          'overlay-padding': 10,
          'shadow-opacity': 0,
          'shadow-color': '#000',
          'shadow-blur': 10,
          'shadow-offset-x': 0,
          'shadow-offset-y': 0,
          'text-shadow-opacity': 0,
          'text-shadow-color': '#000',
          'text-shadow-blur': 5,
          'text-shadow-offset-x': 0,
          'text-shadow-offset-y': 0,
          'transition-property': 'none',
          'transition-duration': 0,
          'transition-delay': 0,

          // node props
          'background-blacken': 0,
          'background-color': '#888',
          'background-opacity': 1,
          'background-image': 'none',
          'background-image-opacity': 1,
          'background-position-x': '50%',
          'background-position-y': '50%',
          'background-repeat': 'no-repeat',
          'background-fit': 'none',
          'background-clip': 'node',
          'background-width': 'auto',
          'background-height': 'auto',
          'border-color': '#000',
          'border-opacity': 1,
          'border-width': 0,
          'border-style': 'solid',
          'height': 30,
          'width': 30,
          'shape': 'ellipse',

          // compound props
          'padding-top': 0,
          'padding-bottom': 0,
          'padding-left': 0,
          'padding-right': 0,
          'position': 'origin',
          'compound-sizing-wrt-labels': 'include',


          // node pie bg
          'pie-size': '100%',
          'pie-1-background-color': 'black',
          'pie-2-background-color': 'black',
          'pie-3-background-color': 'black',
          'pie-4-background-color': 'black',
          'pie-5-background-color': 'black',
          'pie-6-background-color': 'black',
          'pie-7-background-color': 'black',
          'pie-8-background-color': 'black',
          'pie-9-background-color': 'black',
          'pie-10-background-color': 'black',
          'pie-11-background-color': 'black',
          'pie-12-background-color': 'black',
          'pie-13-background-color': 'black',
          'pie-14-background-color': 'black',
          'pie-15-background-color': 'black',
          'pie-16-background-color': 'black',
          'pie-1-background-size': '0%',
          'pie-2-background-size': '0%',
          'pie-3-background-size': '0%',
          'pie-4-background-size': '0%',
          'pie-5-background-size': '0%',
          'pie-6-background-size': '0%',
          'pie-7-background-size': '0%',
          'pie-8-background-size': '0%',
          'pie-9-background-size': '0%',
          'pie-10-background-size': '0%',
          'pie-11-background-size': '0%',
          'pie-12-background-size': '0%',
          'pie-13-background-size': '0%',
          'pie-14-background-size': '0%',
          'pie-15-background-size': '0%',
          'pie-16-background-size': '0%',
          'pie-1-background-opacity': 1,
          'pie-2-background-opacity': 1,
          'pie-3-background-opacity': 1,
          'pie-4-background-opacity': 1,
          'pie-5-background-opacity': 1,
          'pie-6-background-opacity': 1,
          'pie-7-background-opacity': 1,
          'pie-8-background-opacity': 1,
          'pie-9-background-opacity': 1,
          'pie-10-background-opacity': 1,
          'pie-11-background-opacity': 1,
          'pie-12-background-opacity': 1,
          'pie-13-background-opacity': 1,
          'pie-14-background-opacity': 1,
          'pie-15-background-opacity': 1,
          'pie-16-background-opacity': 1,

          // edge props
          'source-arrow-shape': 'none',
          'mid-source-arrow-shape': 'none',
          'target-arrow-shape': 'none',
          'mid-target-arrow-shape': 'none',
          'source-arrow-color': '#ddd',
          'mid-source-arrow-color': '#ddd',
          'target-arrow-color': '#ddd',
          'mid-target-arrow-color': '#ddd',
          'source-arrow-fill': 'filled',
          'mid-source-arrow-fill': 'filled',
          'target-arrow-fill': 'filled',
          'mid-target-arrow-fill': 'filled',
          'line-style': 'solid',
          'line-color': '#ddd',
          'control-point-step-size': 40,
          'control-point-weight': 0.5,
          'curve-style': 'bezier',
          'haystack-radius': 0.8
        })
      .selector('$node > node') // compound (parent) node properties
        .css({
          'width': 'auto',
          'height': 'auto',
          'shape': 'rectangle',
          'background-opacity': 0.5,
          'padding-top': 10,
          'padding-right': 10,
          'padding-left': 10,
          'padding-bottom': 10
        })
      .selector('edge') // just edge properties
        .css({
          'width': 1
        })
      .selector(':active')
        .css({
          'overlay-color': 'black',
          'overlay-padding': 10,
          'overlay-opacity': 0.25
        })
      .selector('core') // just core properties
        .css({
          'selection-box-color': '#ddd',
          'selection-box-opacity': 0.65,
          'selection-box-border-color': '#aaa',
          'selection-box-border-width': 1,
          'active-bg-color': 'black',
          'active-bg-opacity': 0.15,
          'active-bg-size': 30,
          'outside-texture-bg-color': '#000',
          'outside-texture-bg-opacity': 0.125
        })
    ;

    this.defaultLength = this.length;
  };

  // remove all contexts
  $$.styfn.clear = function(){
    for( var i = 0; i < this.length; i++ ){
      this[i] = undefined;
    }
    this.length = 0;
    this._private.newStyle = true;

    return this; // chaining
  };

  $$.styfn.resetToDefault = function(){
    this.clear();
    this.addDefaultStylesheet();

    return this;
  };

  // builds a style object for the 'core' selector
  $$.styfn.core = function(){
    return this._private.coreStyle;
  };

  // parse a property; return null on invalid; return parsed property otherwise
  // fields :
  // - name : the name of the property
  // - value : the parsed, native-typed value of the property
  // - strValue : a string value that represents the property value in valid css
  // - bypass : true iff the property is a bypass property
  $$.styfn.parse = function( name, value, propIsBypass, propIsFlat ){

    name = $$.util.camel2dash( name ); // make sure the property name is in dash form (e.g. 'property-name' not 'propertyName')
    var property = $$.style.properties[ name ];
    var passedValue = value;
    var types = $$.style.types;

    if( !property ){ return null; } // return null on property of unknown name
    if( value === undefined || value === null ){ return null; } // can't assign null

    var valueIsString = $$.is.string(value);
    if( valueIsString ){ // trim the value to make parsing easier
      value = $$.util.trim( value );
    }

    var type = property.type;
    if( !type ){ return null; } // no type, no luck

    // check if bypass is null or empty string (i.e. indication to delete bypass property)
    if( propIsBypass && (value === '' || value === null) ){
      return {
        name: name,
        value: value,
        bypass: true,
        deleteBypass: true
      };
    }

    var hasPie = name.match(/pie-(\d+)-background-size/);

    // check if value is a function used as a mapper
    if( $$.is.fn(value) ){
      return {
        name: name,
        value: value,
        strValue: 'fn',
        mapped: types.fn,
        bypass: propIsBypass,
        hasPie: hasPie
      };
    }

    // check if value is mapped
    var data, mapData, layoutData, mapLayoutData, scratch, mapScratch;
    if( !valueIsString || propIsFlat ){
      // then don't bother to do the expensive regex checks

    } else if(
      ( data = new RegExp( types.data.regex ).exec( value ) ) ||
      ( layoutData = new RegExp( types.layoutData.regex ).exec( value ) ) ||
      ( scratch = new RegExp( types.scratch.regex ).exec( value ) )
    ){
      if( propIsBypass ){ return false; } // mappers not allowed in bypass

      var mapped;
      if( data ){
        mapped = types.data;
      } else if( layoutData ){
        mapped = types.layoutData;
      } else {
        mapped = types.scratch;
      }

      data = data || layoutData || scratch;

      return {
        name: name,
        value: data,
        strValue: '' + value,
        mapped: mapped,
        field: data[1],
        bypass: propIsBypass,
        hasPie: hasPie
      };

    } else if(
      ( mapData = new RegExp( types.mapData.regex ).exec( value ) ) ||
      ( mapLayoutData = new RegExp( types.mapLayoutData.regex ).exec( value ) ) ||
      ( mapScratch = new RegExp( types.mapScratch.regex ).exec( value ) )
    ){
      if( propIsBypass ){ return false; } // mappers not allowed in bypass

      var mapped;
      if( mapData ){
        mapped = types.mapData;
      } else if( mapLayoutData ){
        mapped = types.mapLayoutData;
      } else {
        mapped = types.mapScratch;
      }

      mapData = mapData || mapLayoutData || mapScratch;

      // we can map only if the type is a colour or a number
      if( !(type.color || type.number) ){ return false; }

      var valueMin = this.parse( name, mapData[4]); // parse to validate
      if( !valueMin || valueMin.mapped ){ return false; } // can't be invalid or mapped

      var valueMax = this.parse( name, mapData[5]); // parse to validate
      if( !valueMax || valueMax.mapped ){ return false; } // can't be invalid or mapped

      // check if valueMin and valueMax are the same
      if( valueMin.value === valueMax.value ){
        return false; // can't make much of a mapper without a range

      } else if( type.color ){
        var c1 = valueMin.value;
        var c2 = valueMax.value;

        var same = c1[0] === c2[0] // red
          && c1[1] === c2[1] // green
          && c1[2] === c2[2] // blue
          && ( // optional alpha
            c1[3] === c2[3] // same alpha outright
            || (
              (c1[3] == null || c1[3] === 1) // full opacity for colour 1?
              &&
              (c2[3] == null || c2[3] === 1) // full opacity for colour 2?
            )
          )
        ;

        if( same ){ return false; } // can't make a mapper without a range
      }

      return {
        name: name,
        value: mapData,
        strValue: '' + value,
        mapped: mapped,
        field: mapData[1],
        fieldMin: parseFloat( mapData[2] ), // min & max are numeric
        fieldMax: parseFloat( mapData[3] ),
        valueMin: valueMin.value,
        valueMax: valueMax.value,
        bypass: propIsBypass,
        hasPie: hasPie
      };
    }

    // check the type and return the appropriate object
    if( type.number ){
      var units;
      var implicitUnits = 'px'; // not set => px

      if( type.units ){ // use specified units if set
        units = type.units;
      }

      if( type.implicitUnits ){
        implicitUnits = type.implicitUnits;
      }

      if( !type.unitless ){
        if( valueIsString ){
          var unitsRegex = 'px|em' + (type.allowPercent ? '|\\%' : '');
          if( units ){ unitsRegex = units; } // only allow explicit units if so set
          var match = value.match( '^(' + $$.util.regex.number + ')(' + unitsRegex + ')?' + '$' );

          if( match ){
            value = match[1];
            units = match[2] || implicitUnits;
          }

        } else if( !units || type.implicitUnits ) {
          units = implicitUnits; // implicitly px if unspecified
        }
      }

      value = parseFloat( value );

      // if not a number and enums not allowed, then the value is invalid
      if( isNaN(value) && type.enums === undefined ){
        return null;
      }

      // check if this number type also accepts special keywords in place of numbers
      // (i.e. `left`, `auto`, etc)
      if( isNaN(value) && type.enums !== undefined ){
        value = passedValue;

        for( var i = 0; i < type.enums.length; i++ ){
          var en = type.enums[i];

          if( en === value ){
            return {
              name: name,
              value: value,
              strValue: '' + value,
              bypass: propIsBypass
            };
          }
        }

        return null; // failed on enum after failing on number
      }

      // check if value must be an integer
      if( type.integer && !$$.is.integer(value) ){
        return null;
      }

      // check value is within range
      if( (type.min !== undefined && value < type.min)
      || (type.max !== undefined && value > type.max)
      ){
        return null;
      }

      var ret = {
        name: name,
        value: value,
        strValue: '' + value + (units ? units : ''),
        units: units,
        bypass: propIsBypass,
        hasPie: hasPie && value != null && value !== 0 && value !== ''
      };

      // normalise value in pixels
      if( type.unitless || (units !== 'px' && units !== 'em') ){
        // then pxValue does not apply
      } else {
        ret.pxValue = ( units === 'px' || !units ? (value) : (this.getEmSizeInPixels() * value) );
      }

      // normalise value in ms
      if( units === 'ms' || units === 's' ){
        ret.msValue = units === 'ms' ? value : 1000 * value;
      }

      return ret;

    } else if( type.propList ) {

      var props = [];
      var propsStr = '' + value;

      if( propsStr === 'none' ){
        // leave empty

      } else { // go over each prop

        var propsSplit = propsStr.split(',');
        for( var i = 0; i < propsSplit.length; i++ ){
          var propName = $$.util.trim( propsSplit[i] );

          if( $$.style.properties[propName] ){
            props.push( propName );
          }
        }

        if( props.length === 0 ){ return null; }

      }

      return {
        name: name,
        value: props,
        strValue: props.length === 0 ? 'none' : props.join(', '),
        bypass: propIsBypass
      };

    } else if( type.color ){
      var tuple = $$.util.color2tuple( value );

      if( !tuple ){ return null; }

      return {
        name: name,
        value: tuple,
        strValue: '' + value,
        bypass: propIsBypass
      };

    } else if( type.enums ){
      for( var i = 0; i < type.enums.length; i++ ){
        var en = type.enums[i];

        if( en === value ){
          return {
            name: name,
            value: value,
            strValue: '' + value,
            bypass: propIsBypass
          };
        }
      }

      return null;

    } else if( type.regex ){
      var regex = new RegExp( type.regex ); // make a regex from the type
      var m = regex.exec( value );

      if( m ){ // regex matches
        return {
          name: name,
          value: m,
          strValue: '' + value,
          bypass: propIsBypass
        };
      } else { // regex doesn't match
        return null; // didn't match the regex so the value is bogus
      }

    } else if( type.string ){
      // just return
      return {
        name: name,
        value: value,
        strValue: '' + value,
        bypass: propIsBypass
      };

    } else {
      return null; // not a type we can handle
    }

  };

  // create a new context from the specified selector string and switch to that context
  $$.styfn.selector = function( selectorStr ){
    // 'core' is a special case and does not need a selector
    var selector = selectorStr === 'core' ? null : new $$.Selector( selectorStr );

    var i = this.length++; // new context means new index
    this[i] = {
      selector: selector,
      properties: [],
      mappedProperties: [],
      index: i
    };

    return this; // chaining
  };

  // add one or many css rules to the current context
  $$.styfn.css = function(){
    var args = arguments;

    switch( args.length ){
    case 1:
      var map = args[0];

      for( var i = 0; i < $$.style.properties.length; i++ ){
        var prop = $$.style.properties[i];
        var mapVal = map[ prop.name ];

        if( mapVal === undefined ){
          mapVal = map[ $$.util.dash2camel(prop.name) ];
        }

        if( mapVal !== undefined ){
          this.cssRule( prop.name, mapVal );
        }
      }

      break;

    case 2:
      this.cssRule( args[0], args[1] );
      break;

    default:
      break; // do nothing if args are invalid
    }

    return this; // chaining
  };
  $$.styfn.style = $$.styfn.css;

  // add a single css rule to the current context
  $$.styfn.cssRule = function( name, value ){
    // name-value pair
    var property = this.parse( name, value );

    // add property to current context if valid
    if( property ){
      var i = this.length - 1;
      this[i].properties.push( property );
      this[i].properties[ property.name ] = property; // allow access by name as well

      if( property.hasPie ){
        this._private.hasPie = true;
      }

      if( property.mapped ){
        this[i].mappedProperties.push( property );
      }

      // add to core style if necessary
      var currentSelectorIsCore = !this[i].selector;
      if( currentSelectorIsCore ){
        this._private.coreStyle[ property.name ] = property;
      }
    }

    return this; // chaining
  };

})( cytoscape );

;(function($$){ 'use strict';

  // (potentially expensive calculation)
  // apply the style to the element based on
  // - its bypass
  // - what selectors match it
  $$.styfn.apply = function( eles ){
    var self = this;

    if( self._private.newStyle ){ // clear style caches
      this._private.contextStyles = {};
      this._private.propDiffs = {};
    }

    for( var ie = 0; ie < eles.length; ie++ ){
      var ele = eles[ie];
      var cxtMeta = self.getContextMeta( ele );
      var cxtStyle = self.getContextStyle( cxtMeta );
      var app = self.applyContextStyle( cxtMeta, cxtStyle, ele );

      self.updateTransitions( ele, app.diffProps );
      self.updateStyleHints( ele );

    } // for elements

    self._private.newStyle = false;
  };

  $$.styfn.getPropertiesDiff = function( oldCxtKey, newCxtKey ){
    var self = this;
    var cache = self._private.propDiffs = self._private.propDiffs || {};
    var dualCxtKey = oldCxtKey + '-' + newCxtKey;
    var cachedVal = cache[dualCxtKey];

    if( cachedVal ){
      return cachedVal;
    }

    var diffProps = [];
    var addedProp = {};

    for( var i = 0; i < self.length; i++ ){
      var cxt = self[i];
      var oldHasCxt = oldCxtKey[i] === 't';
      var newHasCxt = newCxtKey[i] === 't';
      var cxtHasDiffed = oldHasCxt !== newHasCxt;
      var cxtHasMappedProps = cxt.mappedProperties.length > 0;

      if( cxtHasDiffed || cxtHasMappedProps ){
        var props;

        if( cxtHasDiffed && cxtHasMappedProps ){
          props = cxt.properties; // suffices b/c mappedProperties is a subset of properties
        } else if( cxtHasDiffed ){
          props = cxt.properties; // need to check them all
        } else if( cxtHasMappedProps ){
          props = cxt.mappedProperties; // only need to check mapped
        }

        for( var j = 0; j < props.length; j++ ){
          var prop = props[j];
          var name = prop.name;

          // if a later context overrides this property, then the fact that this context has switched/diffed doesn't matter
          // (semi expensive check since it makes this function O(n^2) on context length, but worth it since overall result
          // is cached)
          var laterCxtOverrides = false;
          for( var k = i + 1; k < self.length; k++ ){
            var laterCxt = self[k];
            var hasLaterCxt = newCxtKey[k] === 't';

            if( !hasLaterCxt ){ continue; } // can't override unless the context is active

            laterCxtOverrides = laterCxt.properties[ prop.name ] != null;

            if( laterCxtOverrides ){ break; } // exit early as long as one later context overrides
          }

          if( !addedProp[name] && !laterCxtOverrides ){
            addedProp[name] = true;
            diffProps.push( name );
          }
        } // for props
      } // if

    } // for contexts

    cache[ dualCxtKey ] = diffProps;
    return diffProps;
  };

  $$.styfn.getContextMeta = function( ele ){
    var self = this;
    var cxtKey = '';
    var diffProps;
    var prevKey = ele._private.styleCxtKey || '';

    if( self._private.newStyle ){
      prevKey = ''; // since we need to apply all style if a fresh stylesheet
    }

    // get the cxt key
    for( var i = 0; i < self.length; i++ ){
      var context = self[i];
      var contextSelectorMatches = context.selector && context.selector.matches( ele ); // NB: context.selector may be null for 'core'

      if( contextSelectorMatches ){
        cxtKey += 't';
      } else {
        cxtKey += 'f';
      }
    } // for context

    diffProps = self.getPropertiesDiff( prevKey, cxtKey );

    ele._private.styleCxtKey = cxtKey;

    return {
      key: cxtKey,
      diffPropNames: diffProps
    };
  };

  // gets a computed ele style object based on matched contexts
  $$.styfn.getContextStyle = function( cxtMeta ){
    var cxtKey = cxtMeta.key;
    var self = this;
    var cxtStyles = this._private.contextStyles = this._private.contextStyles || {};

    // if already computed style, returned cached copy
    if( cxtStyles[cxtKey] ){ return cxtStyles[cxtKey]; }

    var style = {
      _private: {
        key: cxtKey
      }
    };

    for( var i = 0; i < self.length; i++ ){
      var cxt = self[i];
      var hasCxt = cxtKey[i] === 't';

      if( !hasCxt ){ continue; }

      for( var j = 0; j < cxt.properties.length; j++ ){
        var prop = cxt.properties[j];
        var styProp = style[ prop.name ] = prop;

        styProp.context = cxt;
      }
    }

    cxtStyles[cxtKey] = style;
    return style;
  };

  $$.styfn.applyContextStyle = function( cxtMeta, cxtStyle, ele ){
    var self = this;
    var diffProps = cxtMeta.diffPropNames;
    var retDiffProps = {};

    for( var i = 0; i < diffProps.length; i++ ){
      var diffPropName = diffProps[i];
      var cxtProp = cxtStyle[ diffPropName ];
      var eleProp = ele._private.style[ diffPropName ];

      // save cycles when the context prop doesn't need to be applied
      if( !cxtProp || eleProp === cxtProp ){ continue; }

      var retDiffProp = retDiffProps[ diffPropName ] = {
        prev: eleProp
      };

      self.applyParsedProperty( ele, cxtProp );

      retDiffProp.next = ele._private.style[ diffPropName ];

      if( retDiffProp.next && retDiffProp.next.bypass ){
        retDiffProp.next = retDiffProp.next.bypassed;
      }
    }

    return {
      diffProps: retDiffProps
    };
  };

  $$.styfn.updateStyleHints = function(ele){
    var _p = ele._private;
    var self = this;
    var style = _p.style;

    // set whether has pie or not; for greater efficiency
    var hasPie = false;
    if( _p.group === 'nodes' && self._private.hasPie ){
      for( var i = 1; i <= $$.style.pieBackgroundN; i++ ){ // 1..N
        var size = _p.style['pie-' + i + '-background-size'].value;

        if( size > 0 ){
          hasPie = true;
          break;
        }
      }
    }

    _p.hasPie = hasPie;

    var transform = style['text-transform'].strValue;
    var content = style['content'].strValue;
    var fStyle = style['font-style'].strValue;
    var size = style['font-size'].pxValue + 'px';
    var family = style['font-family'].strValue;
    // var variant = style['font-variant'].strValue;
    var weight = style['font-weight'].strValue;
    var valign = style['text-valign'].strValue;
    var halign = style['text-valign'].strValue;
    var oWidth = style['text-outline-width'].pxValue;
    var wrap = style['text-wrap'].strValue;
    var wrapW = style['text-max-width'].pxValue;
    _p.labelKey = fStyle +'$'+ size +'$'+ family +'$'+ weight +'$'+ content +'$'+ transform +'$'+ valign +'$'+ halign +'$'+ oWidth + '$' + wrap + '$' + wrapW;
    _p.fontKey = fStyle +'$'+ weight +'$'+ size +'$'+ family;

    var width = style['width'].pxValue;
    var height = style['height'].pxValue;
    var borderW = style['border-width'].pxValue;
    _p.boundingBoxKey = width +'$'+ height +'$'+ borderW;

    if( ele._private.group === 'edges' ){
      var cpss = style['control-point-step-size'].pxValue;
      var cpd = style['control-point-distance'] ? style['control-point-distance'].pxValue : undefined;
      var cpw = style['control-point-weight'].value;
      var curve = style['curve-style'].strValue;

      _p.boundingBoxKey += '$'+ cpss +'$'+ cpd +'$'+ cpw +'$'+ curve;
    }

    _p.styleKey = Date.now(); // probably safe to use applied time and much faster
    // for( var i = 0; i < $$.style.properties.length; i++ ){
    //   var prop = $$.style.properties[i];
    //   var eleProp = _p.style[ prop.name ];
    //   var val = eleProp && eleProp.strValue ? eleProp.strValue : 'undefined';

    //   _p.styleKey += '$' + val;
    // }
  };

  // apply a property to the style (for internal use)
  // returns whether application was successful
  //
  // now, this function flattens the property, and here's how:
  //
  // for parsedProp:{ bypass: true, deleteBypass: true }
  // no property is generated, instead the bypass property in the
  // element's style is replaced by what's pointed to by the `bypassed`
  // field in the bypass property (i.e. restoring the property the
  // bypass was overriding)
  //
  // for parsedProp:{ mapped: truthy }
  // the generated flattenedProp:{ mapping: prop }
  //
  // for parsedProp:{ bypass: true }
  // the generated flattenedProp:{ bypassed: parsedProp }
  $$.styfn.applyParsedProperty = function( ele, parsedProp ){
    var prop = parsedProp;
    var style = ele._private.style;
    var fieldVal, flatProp;
    var types = $$.style.types;
    var type = $$.style.properties[ prop.name ].type;
    var propIsBypass = prop.bypass;
    var origProp = style[ prop.name ];
    var origPropIsBypass = origProp && origProp.bypass;
    var _p = ele._private;

    // can't apply auto to width or height unless it's a parent node
    if( (parsedProp.name === 'height' || parsedProp.name === 'width') && ele.isNode() ){
      if( parsedProp.value === 'auto' && !ele.isParent() ){
        return false;
      } else if( parsedProp.value !== 'auto' && ele.isParent() ){
        prop = parsedProp = this.parse( parsedProp.name, 'auto', propIsBypass );
      }
    }

    // check if we need to delete the current bypass
    if( propIsBypass && prop.deleteBypass ){ // then this property is just here to indicate we need to delete
      var currentProp = style[ prop.name ];

      // can only delete if the current prop is a bypass and it points to the property it was overriding
      if( !currentProp ){
        return true; // property is already not defined
      } else if( currentProp.bypass && currentProp.bypassed ){ // then replace the bypass property with the original

        // because the bypassed property was already applied (and therefore parsed), we can just replace it (no reapplying necessary)
        style[ prop.name ] = currentProp.bypassed;
        return true;

      } else {
        return false; // we're unsuccessful deleting the bypass
      }
    }

    var printMappingErr = function(){
      $$.util.error('Do not assign mappings to elements without corresponding data (e.g. ele `'+ ele.id() +'` for property `'+ prop.name +'` with data field `'+ prop.field +'`); try a `['+ prop.field +']` selector to limit scope to elements with `'+ prop.field +'` defined');
    };

    // put the property in the style objects
    switch( prop.mapped ){ // flatten the property if mapped
    case types.mapData:
    case types.mapLayoutData:
    case types.mapScratch:

      var isLayout = prop.mapped === types.mapLayoutData;
      var isScratch = prop.mapped === types.mapScratch;

      // flatten the field (e.g. data.foo.bar)
      var fields = prop.field.split(".");
      var fieldVal;

      if( isScratch || isLayout ){
        fieldVal = _p.scratch;
      } else {
        fieldVal = _p.data;
      }

      for( var i = 0; i < fields.length && fieldVal; i++ ){
        var field = fields[i];
        fieldVal = fieldVal[ field ];
      }

      var percent;
      if( !$$.is.number(fieldVal) ){ // then keep the mapping but assume 0% for now
        percent = 0;
      } else {
        percent = (fieldVal - prop.fieldMin) / (prop.fieldMax - prop.fieldMin);
      }

      // make sure to bound percent value
      if( percent < 0 ){
        percent = 0;
      } else if( percent > 1 ){
        percent = 1;
      }

      if( type.color ){
        var r1 = prop.valueMin[0];
        var r2 = prop.valueMax[0];
        var g1 = prop.valueMin[1];
        var g2 = prop.valueMax[1];
        var b1 = prop.valueMin[2];
        var b2 = prop.valueMax[2];
        var a1 = prop.valueMin[3] == null ? 1 : prop.valueMin[3];
        var a2 = prop.valueMax[3] == null ? 1 : prop.valueMax[3];

        var clr = [
          Math.round( r1 + (r2 - r1)*percent ),
          Math.round( g1 + (g2 - g1)*percent ),
          Math.round( b1 + (b2 - b1)*percent ),
          Math.round( a1 + (a2 - a1)*percent )
        ];

        flatProp = { // colours are simple, so just create the flat property instead of expensive string parsing
          bypass: prop.bypass, // we're a bypass if the mapping property is a bypass
          name: prop.name,
          value: clr,
          strValue: 'rgb(' + clr[0] + ', ' + clr[1] + ', ' + clr[2] + ')'
        };

      } else if( type.number ){
        var calcValue = prop.valueMin + (prop.valueMax - prop.valueMin) * percent;
        flatProp = this.parse( prop.name, calcValue, prop.bypass, true );

      } else {
        return false; // can only map to colours and numbers
      }

      if( !flatProp ){ // if we can't flatten the property, then use the origProp so we still keep the mapping itself
        flatProp = this.parse( prop.name, origProp.strValue, prop.bypass, true );
      }

      if( !flatProp ){ printMappingErr(); }
      flatProp.mapping = prop; // keep a reference to the mapping
      prop = flatProp; // the flattened (mapped) property is the one we want

      break;

    // direct mapping
    case types.data:
    case types.layoutData:
    case types.scratch:
      var isLayout = prop.mapped === types.layoutData;
      var isScratch = prop.mapped === types.scratch;

      // flatten the field (e.g. data.foo.bar)
      var fields = prop.field.split(".");
      var fieldVal;

      if( isScratch || isLayout ){
        fieldVal = _p.scratch;
      } else {
        fieldVal = _p.data;
      }

      if( fieldVal ){ for( var i = 0; i < fields.length; i++ ){
        var field = fields[i];
        fieldVal = fieldVal[ field ];
      } }

      flatProp = this.parse( prop.name, fieldVal, prop.bypass, true );

      if( !flatProp ){ // if we can't flatten the property, then use the origProp so we still keep the mapping itself
        var flatPropVal = origProp ? origProp.strValue : '';

        flatProp = this.parse( prop.name, flatPropVal, prop.bypass, true );
      }

      if( !flatProp ){ printMappingErr(); }
      flatProp.mapping = prop; // keep a reference to the mapping
      prop = flatProp; // the flattened (mapped) property is the one we want

      break;

    case types.fn:
      var fn = prop.value;
      var fnRetVal = fn( ele );

      flatProp = this.parse( prop.name, fnRetVal, prop.bypass, true );
      flatProp.mapping = prop; // keep a reference to the mapping
      prop = flatProp; // the flattened (mapped) property is the one we want

      break;

    case undefined:
      break; // just set the property

    default:
      return false; // not a valid mapping
    }

    // if the property is a bypass property, then link the resultant property to the original one
    if( propIsBypass ){
      if( origPropIsBypass ){ // then this bypass overrides the existing one
        prop.bypassed = origProp.bypassed; // steal bypassed prop from old bypass
      } else { // then link the orig prop to the new bypass
        prop.bypassed = origProp;
      }

      style[ prop.name ] = prop; // and set

    } else { // prop is not bypass
      if( origPropIsBypass ){ // then keep the orig prop (since it's a bypass) and link to the new prop
        origProp.bypassed = prop;
      } else { // then just replace the old prop with the new one
        style[ prop.name ] = prop;
      }
    }

    return true;
  };

  // updates the visual style for all elements (useful for manual style modification after init)
  $$.styfn.update = function(){
    var cy = this._private.cy;
    var eles = cy.elements();

    eles.updateStyle();
  };

  // just update the functional properties (i.e. mappings) in the elements'
  // styles (less expensive than recalculation)
  $$.styfn.updateMappers = function( eles ){
    for( var i = 0; i < eles.length; i++ ){ // for each ele
      var ele = eles[i];
      var style = ele._private.style;

      for( var j = 0; j < $$.style.properties.length; j++ ){ // for each prop
        var prop = $$.style.properties[j];
        var propInStyle = style[ prop.name ];

        if( propInStyle && propInStyle.mapping ){
          var mapping = propInStyle.mapping;
          this.applyParsedProperty( ele, mapping ); // reapply the mapping property
        }
      }

      this.updateStyleHints( ele );
    }
  };

  // diffProps : { name => { prev, next } }
  $$.styfn.updateTransitions = function( ele, diffProps, isBypass ){
    var self = this;
    var style = ele._private.style;

    var props = style['transition-property'].value;
    var duration = style['transition-duration'].msValue;
    var delay = style['transition-delay'].msValue;
    var css = {};

    if( props.length > 0 && duration > 0 ){

      // build up the style to animate towards
      var anyPrev = false;
      for( var i = 0; i < props.length; i++ ){
        var prop = props[i];
        var styProp = style[ prop ];
        var diffProp = diffProps[ prop ];

        if( !diffProp ){ continue; }

        var prevProp = diffProp.prev;
        var fromProp = prevProp;
        var toProp = diffProp.next != null ? diffProp.next : styProp;
        var diff = false;

        if( !fromProp ){ continue; }

        // consider px values
        if( $$.is.number( fromProp.pxValue ) && $$.is.number( toProp.pxValue ) ){
          diff = fromProp.pxValue !== toProp.pxValue;

        // consider numerical values
        } else if( $$.is.number( fromProp.value ) && $$.is.number( toProp.value ) ){
          diff = fromProp.value !== toProp.value;

        // consider colour values
        } else if( $$.is.array( fromProp.value ) && $$.is.array( toProp.value ) ){
          diff = fromProp.value[0] !== toProp.value[0]
            || fromProp.value[1] !== toProp.value[1]
            || fromProp.value[2] !== toProp.value[2]
          ;
        }

        // the previous value is good for an animation only if it's different
        if( diff ){
          css[ prop ] = toProp.strValue; // to val
          this.applyBypass(ele, prop, fromProp.strValue); // from val
          anyPrev = true;
        }

      } // end if props allow ani

      // can't transition if there's nothing previous to transition from
      if( !anyPrev ){ return; }

      ele._private.transitioning = true;

      ele.stop();

      if( delay > 0 ){
        ele.delay( delay );
      }

      ele.animate({
        css: css
      }, {
        duration: duration,
        queue: false,
        complete: function(){
          if( !isBypass ){
            self.removeBypasses( ele, props );
          }

          ele._private.transitioning = false;
        }
      });

    } else if( ele._private.transitioning ){
      ele.stop();

      this.removeBypasses( ele, props );

      ele._private.transitioning = false;
    }
  };

})( cytoscape );

;(function($$){ 'use strict';

  // bypasses are applied to an existing style on an element, and just tacked on temporarily
  // returns true iff application was successful for at least 1 specified property
  $$.styfn.applyBypass = function( eles, name, value, updateTransitions ){
    var props = [];
    var isBypass = true;
    
    // put all the properties (can specify one or many) in an array after parsing them
    if( name === "*" || name === "**" ){ // apply to all property names

      if( value !== undefined ){
        for( var i = 0; i < $$.style.properties.length; i++ ){
          var prop = $$.style.properties[i];
          var name = prop.name;

          var parsedProp = this.parse(name, value, true);
          
          if( parsedProp ){
            props.push( parsedProp );
          }
        }
      }

    } else if( $$.is.string(name) ){ // then parse the single property
      var parsedProp = this.parse(name, value, true);

      if( parsedProp ){
        props.push( parsedProp );
      }
    } else if( $$.is.plainObject(name) ){ // then parse each property
      var specifiedProps = name;
      updateTransitions = value;

      for( var i = 0; i < $$.style.properties.length; i++ ){
        var prop = $$.style.properties[i];
        var name = prop.name;
        var value = specifiedProps[ name ];

        if( value === undefined ){ // try camel case name too
          value = specifiedProps[ $$.util.dash2camel(name) ];
        }

        if( value !== undefined ){
          var parsedProp = this.parse(name, value, true);
          
          if( parsedProp ){
            props.push( parsedProp );
          }
        }
      }
    } else { // can't do anything without well defined properties
      return false;
    }

    // we've failed if there are no valid properties
    if( props.length === 0 ){ return false; }

    // now, apply the bypass properties on the elements
    var ret = false; // return true if at least one succesful bypass applied
    for( var i = 0; i < eles.length; i++ ){ // for each ele
      var ele = eles[i];
      var style = ele._private.style;
      var diffProps = {};
      var diffProp;

      for( var j = 0; j < props.length; j++ ){ // for each prop
        var prop = props[j];

        if( updateTransitions ){
          var prevProp = style[ prop.name ];
          diffProp = diffProps[ prop.name ] = { prev: prevProp };
        }

        ret = this.applyParsedProperty( ele, prop ) || ret;

        if( updateTransitions ){
          diffProp.next = style[ prop.name ];
        }

      } // for props

      if( updateTransitions ){
        this.updateTransitions( ele, diffProps, isBypass );
      }
    } // for eles

    return ret;
  };

  // only useful in specific cases like animation
  $$.styfn.overrideBypass = function( eles, name, value ){
    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[i];
      var prop = ele._private.style[ $$.util.camel2dash(name) ];

      if( !prop.bypass ){ // need a bypass if one doesn't exist
        this.applyBypass( ele, name, value );
        continue;
      }

      prop.value = value;
      prop.pxValue = value;
    }
  };

  $$.styfn.removeAllBypasses = function( eles, updateTransitions ){
    var isBypass = true;

    for( var j = 0; j < eles.length; j++ ){
      var ele = eles[j];
      var diffProps = {};
      var style = ele._private.style;

      for( var i = 0; i < $$.style.properties.length; i++ ){
        var prop = $$.style.properties[i];
        var name = prop.name;
        var value = ''; // empty => remove bypass
        var parsedProp = this.parse(name, value, true);
        var prevProp = style[ prop.name ];
        var diffProp = diffProps[ prop.name ] = { prev: prevProp };

        this.applyParsedProperty(ele, parsedProp);

        diffProp.next = style[ prop.name ];
      } // for props

      if( updateTransitions ){
        this.updateTransitions( ele, diffProps, isBypass );
      }
    } // for eles
  };

  $$.styfn.removeBypasses = function( eles, props, updateTransitions ){
    var isBypass = true;

    for( var j = 0; j < eles.length; j++ ){
      var ele = eles[j];
      var diffProps = {};
      var style = ele._private.style;

      for( var i = 0; i < props.length; i++ ){
        var name = props[i];
        var prop = $$.style.properties[ name ];
        var value = ''; // empty => remove bypass
        var parsedProp = this.parse(name, value, true);
        var prevProp = style[ prop.name ];
        var diffProp = diffProps[ prop.name ] = { prev: prevProp };

        this.applyParsedProperty(ele, parsedProp);

        diffProp.next = style[ prop.name ];
      } // for props

      if( updateTransitions ){
        this.updateTransitions( ele, diffProps, isBypass );
      }
    } // for eles
  };

})( cytoscape );
;(function($$, window){ 'use strict';

  // gets what an em size corresponds to in pixels relative to a dom element
  $$.styfn.getEmSizeInPixels = function(){
    var cy = this._private.cy;
    var domElement = cy.container();

    if( window && domElement && window.getComputedStyle ){
      var pxAsStr = window.getComputedStyle(domElement).getPropertyValue('font-size');
      var px = parseFloat( pxAsStr );
      return px;
    } else {
      return 1; // in case we're running outside of the browser
    }
  };

  // gets css property from the core container
  $$.styfn.containerCss = function( propName ){
    var cy = this._private.cy;
    var domElement = cy.container();

    if( window && domElement && window.getComputedStyle ){
      return window.getComputedStyle(domElement).getPropertyValue( propName );
    }
  };

  $$.styfn.containerProperty = function( propName ){
    var propStr = this.containerCss( propName );
    var prop = this.parse( propName, propStr );
    return prop;
  };

  $$.styfn.containerPropertyAsString = function( propName ){
    var prop = this.containerProperty( propName );

    if( prop ){
      return prop.strValue;
    }
  };

})( cytoscape, typeof window === 'undefined' ? null : window );
;(function($$){ 'use strict';

  // gets the rendered style for an element
  $$.styfn.getRenderedStyle = function( ele ){
    var ele = ele[0]; // insure it's an element

    if( ele ){
      var rstyle = {};
      var style = ele._private.style;
      var cy = this._private.cy;
      var zoom = cy.zoom();

      for( var i = 0; i < $$.style.properties.length; i++ ){
        var prop = $$.style.properties[i];
        var styleProp = style[ prop.name ];

        if( styleProp ){
          var val = styleProp.unitless ? styleProp.strValue : (styleProp.pxValue * zoom) + 'px';
          rstyle[ prop.name ] = val;
          rstyle[ $$.util.dash2camel(prop.name) ] = val;
        }
      }

      return rstyle;
    }
  };

  // gets the raw style for an element
  $$.styfn.getRawStyle = function( ele ){
    var ele = ele[0]; // insure it's an element

    if( ele ){
      var rstyle = {};
      var style = ele._private.style;

      for( var i = 0; i < $$.style.properties.length; i++ ){
        var prop = $$.style.properties[i];
        var styleProp = style[ prop.name ];

        if( styleProp ){
          rstyle[ prop.name ] = styleProp.strValue;
          rstyle[ $$.util.dash2camel(prop.name) ] = styleProp.strValue;
        }
      }

      return rstyle;
    }
  };

  // gets the value style for an element (useful for things like animations)
  $$.styfn.getValueStyle = function( ele, opts ){
    opts = opts || {};

    var rstyle = opts.array ? [] : {}; 
    var style;

    if( $$.is.element(ele) ){
      style = ele._private.style;    
    } else {
      style = ele; // just passed the style itself
    }

    if( style ){
      for( var i = 0; i < $$.style.properties.length; i++ ){
        var prop = $$.style.properties[i];
        var styleProp = style[ prop.name ] || style[ $$.util.dash2camel(prop.name) ];

        if( styleProp !== undefined && !$$.is.plainObject( styleProp ) ){ // then make a prop of it
          styleProp = this.parse(prop.name, styleProp);
        }

        if( styleProp ){
          if( opts.array ){
            rstyle.push( styleProp );
          } else {
            rstyle[ prop.name ] = styleProp;
            rstyle[ $$.util.dash2camel(prop.name) ] = styleProp;
          }
        }
      }
    }

    return rstyle;
  };

})( cytoscape );
;(function($$){ 'use strict';

  $$.style.applyFromJson = function( style, json ){
    for( var i = 0; i < json.length; i++ ){
      var context = json[i];
      var selector = context.selector;
      var props = context.style || context.css;

      style.selector( selector ); // apply selector

      for( var name in props ){
        var value = props[name];

        style.css( name, value ); // apply property
      }
    }

    return style;
  };

  // static function
  $$.style.fromJson = function( cy, json ){
    var style = new $$.Style(cy);

    $$.style.applyFromJson( style, json );

    return style;
  };

  // accessible cy.style() function
  $$.styfn.fromJson = function( json ){
    var style = this;

    style.resetToDefault();

    $$.style.applyFromJson( style, json );

    return style;
  };

  // get json from cy.style() api
  $$.styfn.json = function(){
    var json = [];

    for( var i = this.defaultLength; i < this.length; i++ ){
      var cxt = this[i];
      var selector = cxt.selector;
      var props = cxt.properties;
      var css = {};

      for( var j = 0; j < props.length; j++ ){
        var prop = props[j];
        css[ prop.name ] = prop.strValue;
      }

      json.push({
        selector: !selector ? 'core' : selector.toString(),
        style: css
      });
    }

    return json;
  };

})( cytoscape );
;(function($$){ 'use strict';

  $$.style.applyFromString = function( style, string ){
    var remaining = '' + string;
    var selAndBlockStr;
    var blockRem;
    var propAndValStr;

    // remove comments from the style string
    remaining = remaining.replace(/[/][*](\s|.)+?[*][/]/g, '');

    function removeSelAndBlockFromRemaining(){
      // remove the parsed selector and block from the remaining text to parse
      if( remaining.length > selAndBlockStr.length ){
        remaining = remaining.substr( selAndBlockStr.length );
      } else {
        remaining = '';
      }
    }

    function removePropAndValFromRem(){
      // remove the parsed property and value from the remaining block text to parse
      if( blockRem.length > propAndValStr.length ){
        blockRem = blockRem.substr( propAndValStr.length );
      } else {
        blockRem = '';
      }
    }

    while(true){
      var nothingLeftToParse = remaining.match(/^\s*$/);
      if( nothingLeftToParse ){ break; }

      var selAndBlock = remaining.match(/^\s*((?:.|\s)+?)\s*\{((?:.|\s)+?)\}/);

      if( !selAndBlock ){
        $$.util.error('Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: ' + remaining);
        break;
      }

      selAndBlockStr = selAndBlock[0];

      // parse the selector
      var selectorStr = selAndBlock[1];
      if( selectorStr !== 'core' ){
        var selector = new $$.Selector( selectorStr );
        if( selector._private.invalid ){
          $$.util.error('Skipping parsing of block: Invalid selector found in string stylesheet: ' + selectorStr);

          // skip this selector and block
          removeSelAndBlockFromRemaining();
          continue; 
        }
      }

      // parse the block of properties and values
      var blockStr = selAndBlock[2];
      var invalidBlock = false;
      blockRem = blockStr;
      var props = [];

      while(true){
        var nothingLeftToParse = blockRem.match(/^\s*$/);
        if( nothingLeftToParse ){ break; }

        var propAndVal = blockRem.match(/^\s*(.+?)\s*:\s*(.+?)\s*;/);

        if( !propAndVal ){
          $$.util.error('Skipping parsing of block: Invalid formatting of style property and value definitions found in:' + blockStr);
          invalidBlock = true;
          break;
        }

        propAndValStr = propAndVal[0];
        var propStr = propAndVal[1];
        var valStr = propAndVal[2];

        var prop = $$.style.properties[ propStr ];
        if( !prop ){
          $$.util.error('Skipping property: Invalid property name in: ' + propAndValStr);

          // skip this property in the block
          removePropAndValFromRem();
          continue;
        }

        var parsedProp = style.parse( propStr, valStr );

        if( !parsedProp ){
          $$.util.error('Skipping property: Invalid property definition in: ' + propAndValStr);

          // skip this property in the block
          removePropAndValFromRem();
          continue;
        }

        props.push({
          name: propStr,
          val: valStr
        });
        removePropAndValFromRem();
      }

      if( invalidBlock ){
        removeSelAndBlockFromRemaining();
        break;
      }

      // put the parsed block in the style
      style.selector( selectorStr );
      for( var i = 0; i < props.length; i++ ){
        var prop = props[i];
        style.css( prop.name, prop.val );
      }

      removeSelAndBlockFromRemaining();
    }

    return style;
  };

  $$.style.fromString = function( cy, string ){
    var style = new $$.Style(cy);
    
    $$.style.applyFromString( style, string );

    return style;
  };

  $$.styfn.fromString = function( string ){
    var style = this;

    style.resetToDefault();

    $$.style.applyFromString( style, string );

    return style;
  };

})( cytoscape );

;(function($$){ 'use strict';

  // a dummy stylesheet object that doesn't need a reference to the core
  // (useful for init)
  $$.stylesheet = $$.Stylesheet = function(){
    if( !(this instanceof $$.Stylesheet) ){
      return new $$.Stylesheet();
    }

    this.length = 0;
  };

  $$.sheetfn = $$.Stylesheet.prototype;

  // just store the selector to be parsed later
  $$.sheetfn.selector = function( selector ){
    var i = this.length++;

    this[i] = {
      selector: selector,
      properties: []
    };

    return this; // chaining
  };

  // just store the property to be parsed later
  $$.sheetfn.css = function( name, value ){
    var i = this.length - 1;

    if( $$.is.string(name) ){
      this[i].properties.push({
        name: name,
        value: value
      });
    } else if( $$.is.plainObject(name) ){
      var map = name;

      for( var j = 0; j < $$.style.properties.length; j++ ){
        var prop = $$.style.properties[j];
        var mapVal = map[ prop.name ];

        if( mapVal === undefined ){ // also try camel case name
          mapVal = map[ $$.util.dash2camel(prop.name) ];
        }

        if( mapVal !== undefined ){
          var name = prop.name;
          var value = mapVal;

          this[i].properties.push({
            name: name,
            value: value
          });
        }
      }
    }

    return this; // chaining
  };

  $$.sheetfn.style = $$.sheetfn.css;

  // generate a real style object from the dummy stylesheet
  $$.sheetfn.generateStyle = function( cy ){
    var style = new $$.Style(cy);

    for( var i = 0; i < this.length; i++ ){
      var context = this[i];
      var selector = context.selector;
      var props = context.properties;

      style.selector(selector); // apply selector

      for( var j = 0; j < props.length; j++ ){
        var prop = props[j];

        style.css( prop.name, prop.value ); // apply property
      }
    }

    return style;
  };

})( cytoscape );
// cross-env thread/worker
// NB : uses (heavyweight) processes on nodejs so best not to create too many threads

;(function($$, window){ 'use strict';

  $$.Thread = function( fn ){
    if( !(this instanceof $$.Thread) ){
      return new $$.Thread( fn );
    }

    this._private = {
      requires: [],
      files: [],
      queue: null,
      pass: []
    };

    if( fn ){
      this.run( fn );
    }

  };

  $$.thread = $$.Thread;
  $$.thdfn = $$.Thread.prototype; // short alias

  $$.fn.thread = function( fnMap, options ){
    for( var name in fnMap ){
      var fn = fnMap[name];
      $$.Thread.prototype[ name ] = fn;
    }
  };

  var stringifyFieldVal = function( val ){
    var valStr = $$.is.fn( val ) ? val.toString() : 'JSON.parse("' + JSON.stringify(val) + '")';

    return valStr;
  };

  // allows for requires with prototypes and subobjs etc
  var fnAsRequire = function( fn ){
    var req;
    var fnName;

    if( $$.is.object(fn) && fn.fn ){ // manual fn
      req = fnAs( fn.fn, fn.name );
      fnName = fn.name;
      fn = fn.fn;
    } else if( $$.is.fn(fn) ){ // auto fn
      req = fn.toString();
      fnName = fn.name;
    } else if( $$.is.string(fn) ){ // stringified fn
      req = fn;
    } else if( $$.is.object(fn) ){ // plain object
      if( fn.proto ){
        req = '';
      } else {
        req = fn.name + ' = {};';
      }

      fnName = fn.name;
      fn = fn.obj;
    }

    req += '\n';

    var protoreq = function( val, subname ){
      if( val.prototype ){
        var protoNonempty = false;
        for( var prop in val.prototype ){ protoNonempty = true; break; }

        if( protoNonempty ){
          req += fnAsRequire( {
            name: subname,
            obj: val,
            proto: true
          }, val );
        }
      }
    };

    // pull in prototype
    if( fn.prototype && fnName != null ){

      for( var name in fn.prototype ){
        var protoStr = '';

        var val = fn.prototype[ name ];
        var valStr = stringifyFieldVal( val );
        var subname = fnName + '.prototype.' + name;

        protoStr += subname + ' = ' + valStr + ';\n';

        if( protoStr ){
          req += protoStr;
        }

        protoreq( val, subname ); // subobject with prototype
      }
  
    }

    // pull in properties for obj/fns
    if( !$$.is.string(fn) ){ for( var name in fn ){
      var propsStr = '';

      if( fn.hasOwnProperty(name) ){
        var val = fn[ name ];
        var valStr = stringifyFieldVal( val );
        var subname = fnName + '["' + name + '"]';

        propsStr += subname + ' = ' + valStr + ';\n';
      }

      if( propsStr ){
        req += propsStr;
      }

      protoreq( val, subname ); // subobject with prototype
    } }

    return req;
  };
  
  var isPathStr = function( str ){
    return $$.is.string(str) && str.match(/\.js$/);
  };

  $$.fn.thread({

    require: function( fn, as ){
      if( isPathStr(fn) ){
        this._private.files.push( fn );
        
        return this;
      }
        
      if( as ){
        if( $$.is.fn(fn) ){
          // disabled b/c doesn't work with forced names on functions w/ prototypes
          //fn = fnAs( fn, as );

          as = as || fn.name;

          fn = { name: as, fn: fn };
        } else {
          fn = { name: as, obj: fn };
        }
      }

      this._private.requires.push( fn );

      return this; // chaining
    },

    pass: function( data ){
      this._private.pass.push( data );

      return this; // chaining
    },

    run: function( fn, pass ){ // fn used like main()
      var self = this;
      var _p = this._private;
      pass = pass || _p.pass.shift();

      if( _p.stopped ){
        $$.util.error('Attempted to run a stopped thread!  Start a new thread or do not stop the existing thread and reuse it.');
        return;
      }

      if( _p.running ){
        return _p.queue = _p.queue.then(function(){ // inductive step
          return self.run( fn, pass );
        });
      }
      
      var useWW = window != null;
      var useNode = typeof module !== 'undefined';

      self.trigger('run');

      var runP = new $$.Promise(function( resolve, reject ){

        _p.running = true;

        var threadTechAlreadyExists = _p.ran;

        var fnImplStr = $$.is.string( fn ) ? fn : fn.toString();

        // worker code to exec
        var fnStr = '\n' + ( _p.requires.map(function( r ){
          return fnAsRequire( r );
        }) ).concat( _p.files.map(function( f ){
          if( useWW ){
            var wwifyFile = function( file ){
              if( file.match(/^\.\//) || file.match(/^\.\./) ){
                return window.location.origin + window.location.pathname + file;
              } else if( file.match(/^\//) ){
                return window.location.origin + '/' + file;
              }
              return file;
            };
            
            return 'importScripts("' + wwifyFile(f) + '");';
          } else if( useNode ) {
            return 'eval( require("fs").readFileSync("' + f + '", { encoding: "utf8" }) );';
          }
        }) ).concat([
          '( function(){',
            'var ret = (' + fnImplStr + ')(' + JSON.stringify(pass) + ');',
            'if( ret !== undefined ){ resolve(ret); }', // assume if ran fn returns defined value (incl. null), that we want to resolve to it
          '} )()\n'
        ]).join('\n');

        // because we've now consumed the requires, empty the list so we don't dupe on next run()
        _p.requires = [];
        _p.files = [];

        if( useWW ){
          var fnBlob, fnUrl;

          // add normalised thread api functions
          if( !threadTechAlreadyExists ){
            var fnPre = fnStr + '';

            fnStr = [
              'function broadcast(m){ return message(m); };', // alias
              'function message(m){ postMessage(m); };',
              'function listen(fn){',
              '  self.addEventListener("message", function(m){ ',
              '    if( typeof m === "object" && (m.data.$$eval || m.data === "$$start") ){',
              '    } else { ',
              '      fn( m.data );',
              '    }',
              '  });',
              '};', 
              'self.addEventListener("message", function(m){  if( m.data.$$eval ){ eval( m.data.$$eval ); }  });',
              'function resolve(v){ postMessage({ $$resolve: v }); };', 
              'function reject(v){ postMessage({ $$reject: v }); };'
            ].join('\n');
          
            fnStr += fnPre;

            fnBlob = new Blob([ fnStr ], {
              type: 'application/javascript'
            });
            fnUrl = window.URL.createObjectURL( fnBlob );
          }
          // create webworker and let it exec the serialised code
          var ww = _p.webworker = _p.webworker || new Worker( fnUrl );

          if( threadTechAlreadyExists ){ // then just exec new run() code
            ww.postMessage({
              $$eval: fnStr
            });
          }

          // worker messages => events
          var cb;
          ww.addEventListener('message', cb = function( m ){
            var isObject = $$.is.object(m) && $$.is.object( m.data );
            
            if( isObject && ('$$resolve' in m.data) ){
              ww.removeEventListener('message', cb); // done listening b/c resolve()

              resolve( m.data.$$resolve );
            } else if( isObject && ('$$reject' in m.data) ){
              ww.removeEventListener('message', cb); // done listening b/c reject()

              reject( m.data.$$reject );
            } else {
              self.trigger( new $$.Event(m, { type: 'message', message: m.data }) );
            }
          }, false);

          if( !threadTechAlreadyExists ){
            ww.postMessage('$$start'); // start up the worker
          }

        } else if( useNode ){
          // create a new process
          var path = require('path');
          var child_process = require('child_process');
          var child = _p.child = _p.child || child_process.fork( path.join(__dirname, 'thread-node-fork') );

          // child process messages => events
          var cb;
          child.on('message', cb = function( m ){
            if( $$.is.object(m) && ('$$resolve' in m) ){
              child.removeListener('message', cb); // done listening b/c resolve()

              resolve( m.$$resolve );
            } else if( $$.is.object(m) && ('$$reject' in m) ){
              child.removeListener('message', cb); // done listening b/c reject()

              reject( m.$$reject );
            } else {
              self.trigger( new $$.Event({}, { type: 'message', message: m }) );
            }
          });

          // ask the child process to eval the worker code
          child.send({
            $$eval: fnStr
          });
        } else {
          $$.error('Tried to create thread but no underlying tech found!');
          // TODO fallback on main JS thread?
        }

      }).then(function( v ){
        _p.running = false;
        _p.ran = true;

        self.trigger('ran');

        return v;
      });

      if( _p.queue == null ){
        _p.queue = runP; // i.e. first step of inductive promise chain (for queue)
      }

      return runP;
    },

    // send the thread a message
    message: function( m ){
      var _p = this._private;

      if( _p.webworker ){
        _p.webworker.postMessage( m );
      }

      if( _p.child ){
        _p.child.send( m );
      } 

      return this; // chaining
    },

    stop: function(){
      var _p = this._private;

      if( _p.webworker ){
        _p.webworker.terminate();
      }

      if( _p.child ){
        _p.child.kill();
      } 

      _p.stopped = true;

      return this.trigger('stop'); // chaining
    },

    stopped: function(){
      return this._private.stopped;
    }

  });

  var fnAs = function( fn, name ){
    var fnStr = fn.toString();
    fnStr = fnStr.replace(/function.*\(/, 'function ' + name + '(');

    return fnStr;
  };

  var defineFnal = function( opts ){
    opts = opts || {};

    return function fnalImpl( fn, arg1 ){
      var fnStr = fnAs( fn, '_$_$_' + opts.name );

      this.require( fnStr );

      return this.run( [ 
        'function( data ){',
        '  var origResolve = resolve;',
        '  var res = [];',
        '  ',
        '  resolve = function( val ){',
        '    res.push( val );',
        '  };',
        '  ',
        '  var ret = data.' + opts.name + '( _$_$_' + opts.name + ( arguments.length > 1 ? ', ' + JSON.stringify(arg1) : '' ) + ' );',
        '  ',
        '  resolve = origResolve;',
        '  resolve( res.length > 0 ? res : ret );',
        '}'
      ].join('\n') );
    };
  };

  $$.fn.thread({
    reduce: defineFnal({ name: 'reduce' }),

    reduceRight: defineFnal({ name: 'reduceRight' }),

    map: defineFnal({ name: 'map' })
  });

  // aliases
  var fn = $$.thdfn;
  fn.promise = fn.run;
  fn.terminate = fn.halt = fn.stop;
  fn.include = fn.require;

  // higher level alias (in case you like the worker metaphor)
  $$.worker = $$.Worker = $$.Thread;

  // pull in event apis
  $$.fn.thread({
    on: $$.define.on(),
    one: $$.define.on({ unbindSelfOnTrigger: true }),
    off: $$.define.off(), 
    trigger: $$.define.trigger()
  });

  $$.define.eventAliasesOn( $$.thdfn );
  
})( cytoscape, typeof window === 'undefined' ? null : window );

;(function($$, window){ 'use strict';

  $$.Fabric = function( N ){
    if( !(this instanceof $$.Fabric) ){
      return new $$.Fabric( N );
    }

    this._private = {
      pass: []
    };

    var defN = 4;

    if( $$.is.number(N) ){
      // then use the specified number of threads
    } if( typeof navigator !== 'undefined' && navigator.hardwareConcurrency != null ){
      N = navigator.hardwareConcurrency;
    } else if( typeof module !== 'undefined' ){
      N = require('os').cpus().length;
    } else { // TODO could use an estimation here but would the additional expense be worth it?
      N = defN;
    }

    for( var i = 0; i < N; i++ ){
      this[i] = $$.Thread();
    }

    this.length = N;
  };

  $$.fabric = $$.Fabric;
  $$.fabfn = $$.Fabric.prototype; // short alias

  $$.fn.fabric = function( fnMap, options ){
    for( var name in fnMap ){
      var fn = fnMap[name];
      $$.Fabric.prototype[ name ] = fn;
    }
  };

  $$.fn.fabric({

    // require fn in all threads
    require: function( fn, as ){
      for( var i = 0; i < this.length; i++ ){
        var thread = this[i];

        thread.require( fn, as );
      }

      return this;
    },

    // get a random thread
    random: function(){
      var i = Math.round( (this.length - 1) * Math.random() );
      var thread = this[i];

      return thread;
    },

    // run on random thread
    run: function( fn ){
      var pass = this._private.pass.shift();

      return this.random().pass( pass ).run( fn );
    },

    // sends a random thread a message
    message: function( m ){
      return this.random().message( m );
    },

    // send all threads a message
    broadcast: function( m ){
      for( var i = 0; i < this.length; i++ ){
        var thread = this[i];

        thread.message( m );
      }

      return this; // chaining
    },

    // stop all threads
    stop: function(){
      for( var i = 0; i < this.length; i++ ){
        var thread = this[i];

        thread.stop();
      }

      return this; // chaining
    },

    // pass data to be used with .spread() etc.
    pass: function( data ){
      var pass = this._private.pass;

      if( $$.is.array(data) ){
        pass.push( data );
      } else {
        $$.util.error('Only arrays or collections may be used with fabric.pass()');
      }

      return this; // chaining
    },

    spreadSize: function(){
      var subsize =  Math.ceil( this._private.pass[0].length / this.length );

      subsize = Math.max( 1, subsize ); // don't pass less than one ele to each thread

      return subsize;
    },

    // split the data into slices to spread the data equally among threads
    spread: function( fn ){
      var self = this;
      var _p = self._private;
      var subsize = self.spreadSize(); // number of pass eles to handle in each thread
      var pass = _p.pass.shift().concat([]); // keep a copy
      var runPs = [];

      for( var i = 0; i < this.length; i++ ){
        var thread = this[i];
        var slice = pass.splice( 0, subsize );

        var runP = thread.pass( slice ).run( fn );

        runPs.push( runP );

        var doneEarly = pass.length === 0;
        if( doneEarly ){ break; }
      }

      return $$.Promise.all( runPs ).then(function( thens ){
        var postpass = [];
        var p = 0;

        // fill postpass with the total result joined from all threads
        for( var i = 0; i < thens.length; i++ ){
          var then = thens[i]; // array result from thread i

          for( var j = 0; j < then.length; j++ ){
            var t = then[j]; // array element

            postpass[ p++ ] = t;
          }
        }

        return postpass;
      });
    },

    // parallel version of array.map()
    map: function( fn ){
      var self = this;

      self.require( fn, '_$_$_fabmap' );

      return self.spread(function( split ){
        var mapped = [];
        var origResolve = resolve;

        resolve = function( val ){
          mapped.push( val );
        };

        for( var i = 0; i < split.length; i++ ){
          var oldLen = mapped.length;
          var ret = _$_$_fabmap( split[i] );
          var nothingInsdByResolve = oldLen === mapped.length;

          if( nothingInsdByResolve ){
            mapped.push( ret );
          }
        }

        resolve = origResolve;

        return mapped;
      });

    },

    // parallel version of array.filter()
    filter: function( fn ){
      var _p = this._private;
      var pass = _p.pass[0];

      return this.map( fn ).then(function( include ){
        var ret = [];

        for( var i = 0; i < pass.length; i++ ){
          var datum = pass[i];
          var incDatum = include[i];

          if( incDatum ){
            ret.push( datum );
          }
        }

        return ret;
      });
    },

    // sorts the passed array using a divide and conquer strategy
    sort: function( cmp ){
      var self = this;
      var P = this._private.pass[0].length;
      var subsize = this.spreadSize();

      cmp = cmp || function( a, b ){ // default comparison function
        if( a < b ){
          return -1;
        } else if( a > b ){
          return 1;
        }

        return 0;
      };

      self.require( cmp, '_$_$_cmp' );

      return self.spread(function( split ){ // sort each split normally
        var sortedSplit = split.sort( _$_$_cmp );
        resolve( sortedSplit );

      }).then(function( joined ){
        // do all the merging in the main thread to minimise data transfer

        // TODO could do merging in separate threads but would incur add'l cost of data transfer
        // for each level of the merge

        var merge = function( i, j, max ){
          // don't overflow array
          j = Math.min( j, P );
          max = Math.min( max, P );

          // left and right sides of merge
          var l = i;
          var r = j;

          var sorted = [];

          for( var k = l; k < max; k++ ){

            var eleI = joined[i];
            var eleJ = joined[j];

            if( i < r && ( j >= max || cmp(eleI, eleJ) <= 0 ) ){
              sorted.push( eleI );
              i++;
            } else {
              sorted.push( eleJ );
              j++;
            }

          }

          // in the array proper, put the sorted values
          for( var k = 0; k < sorted.length; k++ ){ // kth sorted item
            var index = l + k;

            joined[ index ] = sorted[k];
          }
        };

        for( var splitL = subsize; splitL < P; splitL *= 2 ){ // merge until array is "split" as 1

          for( var i = 0; i < P; i += 2*splitL ){
            merge( i, i + splitL, i + 2*splitL );
          }

        }

        return joined;
      });
    }


  });

  var defineRandomPasser = function( opts ){
    opts = opts || {};

    return function( fn, arg1 ){
      var pass = this._private.pass.shift();

      return this.random().pass( pass )[ opts.threadFn ]( fn, arg1 );
    };
  };

  $$.fn.fabric({
    randomMap: defineRandomPasser({ threadFn: 'map' }),

    reduce: defineRandomPasser({ threadFn: 'reduce' }),

    reduceRight: defineRandomPasser({ threadFn: 'reduceRight' })
  });

  // aliases
  var fn = $$.fabfn;
  fn.promise = fn.run;
  fn.terminate = fn.halt = fn.stop;
  fn.include = fn.require;

  // pull in event apis
  $$.fn.fabric({
    on: $$.define.on(),
    one: $$.define.on({ unbindSelfOnTrigger: true }),
    off: $$.define.off(),
    trigger: $$.define.trigger()
  });

  $$.define.eventAliasesOn( $$.fabfn );

})( cytoscape, typeof window === 'undefined' ? null : window );

;(function($$, window){ 'use strict';

  var defaults = {
  };
  
  var origDefaults = $$.util.copy( defaults );

  $$.defaults = function( opts ){
    defaults = $$.util.extend({}, origDefaults, opts);
  };

  $$.fn.core = function( fnMap, options ){
    for( var name in fnMap ){
      var fn = fnMap[name];
      $$.Core.prototype[ name ] = fn;
    }
  };
  
  $$.Core = function( opts ){
    if( !(this instanceof $$.Core) ){
      return new $$.Core(opts);
    }
    var cy = this;

    opts = $$.util.extend({}, defaults, opts);

    var container = opts.container;
    var reg = container ? container._cyreg : null; // e.g. already registered some info (e.g. readies) via jquery
    reg = reg || {};

    if( reg && reg.cy ){ 
      if( container ){
        while( container.firstChild ){ // clean the container
          container.removeChild( container.firstChild );
        }
      }
      
      reg.cy.notify({ type: 'destroy' }); // destroy the renderer

      reg = {}; // old instance => replace reg completely
    }

    var readies = reg.readies = reg.readies || [];
    
    if( container ){ container._cyreg = reg; } // make sure container assoc'd reg points to this cy
    reg.cy = cy;

    var head = window !== undefined && container !== undefined && !opts.headless;
    var options = opts;
    options.layout = $$.util.extend( { name: head ? 'grid' : 'null' }, options.layout );
    options.renderer = $$.util.extend( { name: head ? 'canvas' : 'null' }, options.renderer );
    
    var defVal = function( def, val, altVal ){
      if( val !== undefined ){
        return val;
      } else if( altVal !== undefined ){
        return altVal;
      } else {
        return def;
      }
    };

    var _p = this._private = {
      container: options.container, // html dom ele container
      ready: false, // whether ready has been triggered
      initrender: false, // has initrender has been triggered
      options: options, // cached options
      elements: [], // array of elements
      id2index: {}, // element id => index in elements array
      listeners: [], // list of listeners
      onRenders: [], // rendering listeners
      aniEles: $$.Collection(this), // elements being animated
      scratch: {}, // scratch object for core
      layout: null,
      renderer: null,
      notificationsEnabled: true, // whether notifications are sent to the renderer
      minZoom: 1e-50,
      maxZoom: 1e50,
      zoomingEnabled: defVal(true, options.zoomingEnabled),
      userZoomingEnabled: defVal(true, options.userZoomingEnabled),
      panningEnabled: defVal(true, options.panningEnabled),
      userPanningEnabled: defVal(true, options.userPanningEnabled),
      boxSelectionEnabled: defVal(false, options.boxSelectionEnabled),
      autolock: defVal(false, options.autolock, options.autolockNodes),
      autoungrabify: defVal(false, options.autoungrabify, options.autoungrabifyNodes),
      autounselectify: defVal(false, options.autounselectify),
      styleEnabled: options.styleEnabled === undefined ? head : options.styleEnabled,
      zoom: $$.is.number(options.zoom) ? options.zoom : 1,
      pan: {
        x: $$.is.plainObject(options.pan) && $$.is.number(options.pan.x) ? options.pan.x : 0,
        y: $$.is.plainObject(options.pan) && $$.is.number(options.pan.y) ? options.pan.y : 0
      },
      animation: { // object for currently-running animations
        current: [],
        queue: []
      },
      hasCompoundNodes: false,
      deferredExecQueue: []
    };

    // set selection type
    var selType = options.selectionType;
    if( selType === undefined || (selType !== 'additive' && selType !== 'single') ){
      // then set default

      _p.selectionType = 'single';
    } else {
      _p.selectionType = selType;
    }

    // init zoom bounds
    if( $$.is.number(options.minZoom) && $$.is.number(options.maxZoom) && options.minZoom < options.maxZoom ){
      _p.minZoom = options.minZoom;
      _p.maxZoom = options.maxZoom;
    } else if( $$.is.number(options.minZoom) && options.maxZoom === undefined ){
      _p.minZoom = options.minZoom;
    } else if( $$.is.number(options.maxZoom) && options.minZoom === undefined ){
      _p.maxZoom = options.maxZoom;
    }

    var loadExtData = function( next ){
      var anyIsPromise = false;

      for( var i = 0; i < extData.length; i++ ){
        var datum = extData[i];

        if( $$.is.promise(datum) ){
          anyIsPromise = true;
          break;
        }
      }

      if( anyIsPromise ){
        return $$.Promise.all( extData ).then( next ); // load all data asynchronously, then exec rest of init
      } else {
        next( extData ); // exec synchronously for convenience
      }
    };

    var extData = [ options.style, options.elements ];
    loadExtData(function( thens ){
      var initStyle = thens[0];
      var initEles = thens[1];
   
      // init style
      if( _p.styleEnabled ){
        cy.setStyle( initStyle );
      }

      // create the renderer
      cy.initRenderer( $$.util.extend({
        hideEdgesOnViewport: options.hideEdgesOnViewport,
        hideLabelsOnViewport: options.hideLabelsOnViewport,
        textureOnViewport: options.textureOnViewport,
        wheelSensitivity: $$.is.number(options.wheelSensitivity) && options.wheelSensitivity > 0 ? options.wheelSensitivity : 1,
        motionBlur: options.motionBlur === undefined ? true : options.motionBlur, // on by default
        motionBlurOpacity: options.motionBlurOpacity === undefined ? 0.05 : options.motionBlurOpacity,
        pixelRatio: $$.is.number(options.pixelRatio) && options.pixelRatio > 0 ? options.pixelRatio : (options.pixelRatio === 'auto' ? undefined : 1),
        desktopTapThreshold: options.desktopTapThreshold === undefined ? 4 : options.desktopTapThreshold,
        touchTapThreshold: options.touchTapThreshold === undefined ? 8 : options.touchTapThreshold
      }, options.renderer) );

      // trigger the passed function for the `initrender` event
      if( options.initrender ){
        cy.on('initrender', options.initrender);
        cy.on('initrender', function(){
          cy._private.initrender = true;
        });
      }

      // initial load
      cy.load(initEles, function(){ // onready
        cy.startAnimationLoop();
        cy._private.ready = true;

        // if a ready callback is specified as an option, the bind it
        if( $$.is.fn( options.ready ) ){
          cy.on('ready', options.ready);
        }

        // bind all the ready handlers registered before creating this instance
        for( var i = 0; i < readies.length; i++ ){
          var fn = readies[i];
          cy.on('ready', fn);
        }
        if( reg ){ reg.readies = []; } // clear b/c we've bound them all and don't want to keep it around in case a new core uses the same div etc
        
        cy.trigger('ready');
      }, options.done);

    });
  };

  $$.corefn = $$.Core.prototype; // short alias
  

  $$.fn.core({
    isReady: function(){
      return this._private.ready;
    },

    ready: function( fn ){
      if( this.isReady() ){
        this.trigger('ready', [], fn); // just calls fn as though triggered via ready event
      } else {
        this.on('ready', fn);
      }
    },

    initrender: function(){
      return this._private.initrender;
    },

    destroy: function(){
      this.notify({ type: 'destroy' }); // destroy the renderer

      var domEle = this.container();
      var parEle = domEle.parentNode;
      if( parEle ){
        try{
          parEle.removeChild( domEle );
        } catch(e){
          // ie10 issue #1014
        }
      }

      return this;
    },

    getElementById: function( id ){
      var index = this._private.id2index[ id ];
      if( index !== undefined ){
        return this._private.elements[ index ];
      }

      // worst case, return an empty collection
      return new $$.Collection( this );
    },

    selectionType: function(){
      return this._private.selectionType;
    },

    hasCompoundNodes: function(){
      return this._private.hasCompoundNodes;
    },

    styleEnabled: function(){
      return this._private.styleEnabled;
    },

    addToPool: function( eles ){
      var elements = this._private.elements;
      var id2index = this._private.id2index;

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];

        var id = ele._private.data.id;
        var index = id2index[ id ];
        var alreadyInPool = index !== undefined;

        if( !alreadyInPool ){
          index = elements.length;
          elements.push( ele );
          id2index[ id ] = index;
          ele._private.index = index;
        }
      }

      return this; // chaining
    },

    removeFromPool: function( eles ){
      var elements = this._private.elements;
      var id2index = this._private.id2index;

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];

        var id = ele._private.data.id;
        var index = id2index[ id ];
        var inPool = index !== undefined;

        if( inPool ){
          this._private.id2index[ id ] = undefined;
          elements.splice(index, 1);

          // adjust the index of all elements past this index
          for( var j = index; j < elements.length; j++ ){
            var jid = elements[j]._private.data.id;
            id2index[ jid ]--;
            elements[j]._private.index--;
          }
        }
      }
    },

    container: function(){
      return this._private.container;
    },

    options: function(){
      return $$.util.copy( this._private.options );
    },
    
    json: function(params){
      var json = {};
      var cy = this;
      
      json.elements = {};
      cy.elements().each(function(i, ele){
        var group = ele.group();
        
        if( !json.elements[group] ){
          json.elements[group] = [];
        }
        
        json.elements[group].push( ele.json() );
      });

      if( this._private.styleEnabled ){
        json.style = cy.style().json();
      }

      json.zoomingEnabled = cy._private.zoomingEnabled;
      json.userZoomingEnabled = cy._private.userZoomingEnabled;
      json.zoom = cy._private.zoom;
      json.minZoom = cy._private.minZoom;
      json.maxZoom = cy._private.maxZoom;
      json.panningEnabled = cy._private.panningEnabled;
      json.userPanningEnabled = cy._private.userPanningEnabled;
      json.pan = cy._private.pan;
      json.boxSelectionEnabled = cy._private.boxSelectionEnabled;
      json.layout = cy._private.options.layout;
      json.renderer = cy._private.options.renderer;
      json.hideEdgesOnViewport = cy._private.options.hideEdgesOnViewport;
      json.hideLabelsOnViewport = cy._private.options.hideLabelsOnViewport;
      json.textureOnViewport = cy._private.options.textureOnViewport;
      json.wheelSensitivity = cy._private.options.wheelSensitivity;
      json.motionBlur = cy._private.options.motionBlur;
      
      return json;
    },

    // defer execution until not busy and guarantee relative execution order of deferred functions
    defer: function( fn ){
      var cy = this;
      var _p = cy._private;
      var q = _p.deferredExecQueue;

      q.push( fn );

      if( !_p.deferredTimeout ){
        _p.deferredTimeout = setTimeout(function(){
          while( q.length > 0 ){
            ( q.shift() )();
          }

          _p.deferredTimeout = null;
        }, 0);
      }
    }
    
  });  
  
})( cytoscape, typeof window === 'undefined' ? null : window );

(function($$, window){ 'use strict';

  function ready(f) {
    var fn = ( document && (document.readyState === 'interactive' || document.readyState === 'complete') )  ? f : ready;

    setTimeout(fn, 9, f);
  }

  $$.fn.core({
    add: function(opts){
      
      var elements;
      var cy = this;
      
      // add the elements
      if( $$.is.elementOrCollection(opts) ){
        var eles = opts;

        if( eles._private.cy === cy ){ // same instance => just restore
          elements = eles.restore();

        } else { // otherwise, copy from json
          var jsons = [];

          for( var i = 0; i < eles.length; i++ ){
            var ele = eles[i];
            jsons.push( ele.json() );
          }

          elements = new $$.Collection( cy, jsons );
        }
      }
      
      // specify an array of options
      else if( $$.is.array(opts) ){
        var jsons = opts;

        elements = new $$.Collection(cy, jsons);
      }
      
      // specify via opts.nodes and opts.edges
      else if( $$.is.plainObject(opts) && ($$.is.array(opts.nodes) || $$.is.array(opts.edges)) ){
        var elesByGroup = opts;
        var jsons = [];

        var grs = ['nodes', 'edges'];
        for( var i = 0, il = grs.length; i < il; i++ ){
          var group = grs[i];
          var elesArray = elesByGroup[group];

          if( $$.is.array(elesArray) ){

            for( var j = 0, jl = elesArray.length; j < jl; j++ ){
              var json = elesArray[j];
              json.group = group;

              jsons.push( json );
            }
          } 
        }

        elements = new $$.Collection(cy, jsons);
      }
      
      // specify options for one element
      else {
        var json = opts;
        elements = (new $$.Element( cy, json )).collection();
      }
      
      return elements;
    },
    
    remove: function(collection){
      if( $$.is.elementOrCollection(collection) ){
        collection = collection;
      } else if( $$.is.string(collection) ){
        var selector = collection;
        collection = this.$( selector );
      }
      
      return collection.remove();
    },
    
    load: function(elements, onload, ondone){
      var cy = this;
      
      cy.notifications(false);

      // remove old elements
      var oldEles = cy.elements();
      if( oldEles.length > 0 ){
        oldEles.remove();
      }
      
      if( elements != null ){
        if( $$.is.plainObject(elements) || $$.is.array(elements) ){
          cy.add( elements );
        } 
      }
      
      function callback(){        
        cy.one('layoutready', function(e){
          cy.notifications(true);
          cy.trigger(e); // we missed this event by turning notifications off, so pass it on

          cy.notify({
            type: 'load',
            collection: cy.elements()
          });

          cy.one('load', onload);
          cy.trigger('load');
        }).one('layoutstop', function(){
          cy.one('done', ondone);
          cy.trigger('done');
        });
        
        var layoutOpts = $$.util.extend({}, cy._private.options.layout);
        layoutOpts.eles = cy.$();

        cy.layout( layoutOpts );

      }

      if( window ){
        ready( callback );
      } else {
        callback();
      }

      return this;
    }
  });
  
})( cytoscape, typeof window === 'undefined' ? null : window );

;(function($$, window){ 'use strict';
  
  $$.fn.core({
    
    // pull in animation functions
    animated: $$.define.animated(),
    clearQueue: $$.define.clearQueue(),
    delay: $$.define.delay(),
    animate: $$.define.animate(),
    stop: $$.define.stop(),

    addToAnimationPool: function( eles ){
      var cy = this;

      if( !cy.styleEnabled() ){ return; } // save cycles when no style used
      
      cy._private.aniEles.merge( eles );
    },

    startAnimationLoop: function(){
      var cy = this;

      if( !cy.styleEnabled() ){ return; } // save cycles when no style used

      // don't execute the animation loop in headless environments
      if( !window ){
        return;
      }
      
      function globalAnimationStep(){
        $$.util.requestAnimationFrame(function(now){
          handleElements(now);
          globalAnimationStep();
        });
      }
      
      globalAnimationStep(); // first call
      
      function handleElements(now){
        now = +new Date();

        var eles = cy._private.aniEles;
        var doneEles = [];

        function handleElement( ele, isCore ){
          var current = ele._private.animation.current;
          var queue = ele._private.animation.queue;
          var ranAnis = false;
          
          // if nothing currently animating, get something from the queue
          if( current.length === 0 ){
            var next = queue.length > 0 ? queue.shift() : null;
            
            if( next ){
              next.callTime = now; // was queued, so update call time
              current.push( next );
            }
          }
          
          // step and remove if done
          var completes = [];
          for(var i = current.length - 1; i >= 0; i--){
            var ani = current[i];

            // start if need be
            if( !ani.started ){ startAnimation( ele, ani ); }
            
            step( ele, ani, now, isCore );

            if( ani.done ){
              completes.push( ani );
              
              // remove current[i]
              current.splice(i, 1);
            }

            ranAnis = true;
          }
          
          // call complete callbacks
          for( var i = 0; i < completes.length; i++ ){
            var ani = completes[i];
            var complete = ani.params.complete;

            if( $$.is.fn(complete) ){
              complete.apply( ele, [ now ] );
            }
          }

          if( !isCore && current.length === 0 && queue.length === 0 ){
            doneEles.push( ele );
          }

          return ranAnis;
        } // handleElements

        // handle all eles
        for( var e = 0; e < eles.length; e++ ){
          var ele = eles[e];
          
          handleElement( ele );
        } // each element

        var ranCoreAni = handleElement( cy, true );
        
        // notify renderer
        if( eles.length > 0 || ranCoreAni ){
          var toNotify;

          if( eles.length > 0 ){
            var updatedEles = eles.updateCompoundBounds();
            toNotify = updatedEles.length > 0 ? eles.add( updatedEles ) : eles;
          }

          cy.notify({
            type: 'draw',
            collection: toNotify
          });
        }

        // remove elements from list of currently animating if its queues are empty
        eles.unmerge( doneEles );

      } // handleElements
      
      function startAnimation( self, ani ){
        var isCore = $$.is.core( self );
        var isEles = !isCore;
        var ele = self;
        var style = cy._private.style;

        if( isEles ){
          var pos = ele._private.position;
          var startPosition = {
            x: pos.x,
            y: pos.y
          };
          var startStyle = style.getValueStyle( ele );
        }

        if( isCore ){
          var pan = cy._private.pan;
          var startPan = {
            x: pan.x,
            y: pan.y
          };

          var startZoom = cy._private.zoom;
        }

        ani.started = true;
        ani.startTime = Date.now();
        ani.startPosition = startPosition;
        ani.startStyle = startStyle;
        ani.startPan = startPan;
        ani.startZoom = startZoom;
      }

      function step( self, animation, now, isCore ){
        var style = cy._private.style;
        var properties = animation.properties;
        var params = animation.params;
        var startTime = animation.startTime;
        var percent;
        var isEles = !isCore;
        
        if( animation.duration === 0 ){
          percent = 1;
        } else {
          percent = Math.min(1, (now - startTime)/animation.duration);
        }

        if( percent < 0 ){
          percent = 0;
        } else if( percent > 1 ){
          percent = 1;
        }
        
        if( properties.delay == null ){ // then update

          var startPos = animation.startPosition;
          var endPos = properties.position;
          var pos = self._private.position;
          if( endPos && isEles ){
            if( valid( startPos.x, endPos.x ) ){
              pos.x = ease( startPos.x, endPos.x, percent );
            }

            if( valid( startPos.y, endPos.y ) ){
              pos.y = ease( startPos.y, endPos.y, percent );
            }
          }

          var startPan = animation.startPan;
          var endPan = properties.pan;
          var pan = self._private.pan;
          var animatingPan = endPan != null && isCore;
          if( animatingPan ){
            if( valid( startPan.x, endPan.x ) ){
              pan.x = ease( startPan.x, endPan.x, percent );
            }

            if( valid( startPan.y, endPan.y ) ){
              pan.y = ease( startPan.y, endPan.y, percent );
            }

            self.trigger('pan');
          }

          var startZoom = animation.startZoom;
          var endZoom = properties.zoom;
          var animatingZoom = endZoom != null && isCore;
          if( animatingZoom ){
            if( valid( startZoom, endZoom ) ){
              self._private.zoom = ease( startZoom, endZoom, percent );
            }

            self.trigger('zoom');
          }

          if( animatingPan || animatingZoom ){
            self.trigger('viewport');
          }

          var props = properties.style || properties.css;
          if( props && isEles ){

            for( var i = 0; i < props.length; i++ ){
              var name = props[i].name;
              var prop = props[i];
              var end = prop;

              var start = animation.startStyle[ name ];
              var easedVal = ease( start, end, percent );
              
              style.overrideBypass( self, name, easedVal );
            } // for props
            
          } // if 

        }
        
        if( $$.is.fn(params.step) ){
          params.step.apply( self, [ now ] );
        }
        
        if( percent >= 1 ){
          animation.done = true;
        }
        
        return percent;
      }
      
      function valid(start, end){
        if( start == null || end == null ){
          return false;
        }
        
        if( $$.is.number(start) && $$.is.number(end) ){
          return true;
        } else if( (start) && (end) ){
          return true;
        }
        
        return false;
      }
      
      function ease(startProp, endProp, percent){
        if( percent < 0 ){
          percent = 0;
        } else if( percent > 1 ){
          percent = 1;
        }

        var start, end;

        if( startProp.pxValue != null || startProp.value != null ){
          start = startProp.pxValue != null ? startProp.pxValue : startProp.value;
        } else {
          start = startProp;
        }

        if( endProp.pxValue != null || endProp.value != null ){
          end = endProp.pxValue != null ? endProp.pxValue : endProp.value;
        } else {
          end = endProp;
        }

        if( $$.is.number(start) && $$.is.number(end) ){
          return start + (end - start) * percent;

        } else if( $$.is.number(start[0]) && $$.is.number(end[0]) ){ // then assume a colour
          var c1 = start;
          var c2 = end;

          var ch = function(ch1, ch2){
            var diff = ch2 - ch1;
            var min = ch1;
            return Math.round( percent * diff + min );
          };
          
          var r = ch( c1[0], c2[0] );
          var g = ch( c1[1], c2[1] );
          var b = ch( c1[2], c2[2] );
          
          return [r, g, b];
        }
        
        return undefined;
      }
      
    }
    
  });
  
})( cytoscape, typeof window === 'undefined' ? null : window );


  
    
;(function($$){ 'use strict';
  
  $$.fn.core({
    data: $$.define.data({
      field: 'data',
      bindingEvent: 'data',
      allowBinding: true,
      allowSetting: true,
      settingEvent: 'data',
      settingTriggersEvent: true,
      triggerFnName: 'trigger',
      allowGetting: true
    }),

    removeData: $$.define.removeData({
      field: 'data',
      event: 'data',
      triggerFnName: 'trigger',
      triggerEvent: true
    }),

    scratch: $$.define.data({
      field: 'scratch',
      allowBinding: false,
      allowSetting: true,
      settingTriggersEvent: false,
      allowGetting: true
    }),

    removeScratch: $$.define.removeData({
      field: 'scratch',
      triggerEvent: false
    })
  });
  
})( cytoscape );

;(function($$){ 'use strict';

  $$.fn.core({
    on: $$.define.on(), // .on( events [, selector] [, data], handler)
    one: $$.define.on({ unbindSelfOnTrigger: true }),
    once: $$.define.on({ unbindAllBindersOnTrigger: true }),
    off: $$.define.off(), // .off( events [, selector] [, handler] )
    trigger: $$.define.trigger() // .trigger( events [, extraParams] )
  });

  $$.define.eventAliasesOn( $$.corefn );

})( cytoscape );

;(function($$){ 'use strict';
  
  $$.fn.core({
    
    png: function( options ){
      var renderer = this._private.renderer;
      options = options || {};

      return renderer.png( options );      
    },
    
    jpg: function( options ){
      var renderer = this._private.renderer;
      options = options || {};
      
      options.bg = options.bg || '#fff';

      return renderer.jpg( options );      
    }
    
  });
  
  $$.corefn.jpeg = $$.corefn.jpg;
  
})( cytoscape );

;(function($$){ 'use strict';
  
  $$.fn.core({
    
    layout: function( params ){
      var layout;

      // always use a new layout w/ init opts; slightly different backwards compatibility
      // but fixes layout reuse issues like dagre #819 
      if( params == null ){ 
        params = $$.util.extend({}, this._private.options.layout);
        params.eles = this.$();
      }

      layout = this.initLayout( params );
      layout.run();

      return this; // chaining
    },

    makeLayout: function( params ){
      return this.initLayout( params );
    },
    
    initLayout: function( options ){
      if( options == null ){
        $$.util.error('Layout options must be specified to make a layout');
        return;
      }
      
      if( options.name == null ){
        $$.util.error('A `name` must be specified to make a layout');
        return;
      }
      
      var name = options.name;
      var LayoutProto = $$.extension('layout', name);
      
      if( LayoutProto == null ){
        $$.util.error('Can not apply layout: No such layout `' + name + '` found; did you include its JS file?');
        return;
      }

      options.eles = options.eles != null ? options.eles : this.$();

      if( $$.is.string( options.eles ) ){
        options.eles = this.$( options.eles );
      }
      
      var layout = new LayoutProto( $$.util.extend({}, options, {
        cy: this
      }) );

      // make sure layout has _private for use w/ std apis like .on()
      if( !$$.is.plainObject(layout._private) ){
        layout._private = {};
      }

      layout._private.cy = this;
      layout._private.listeners = [];
      
      return layout;
    }
    
  });

  $$.corefn.createLayout = $$.corefn.makeLayout;
  
})( cytoscape );
(function($$){ 'use strict';
  
  $$.fn.core({
    notify: function( params ){
      if( this._private.batchingNotify ){
        var bEles = this._private.batchNotifyEles;
        var bTypes = this._private.batchNotifyTypes;

        if( params.collection ){ for( var i = 0; i < params.collection.length; i++ ){
          var ele = params.collection[i];

          if( !bEles.ids[ ele._private.id ] ){
            bEles.push( ele );
          }
        } }

        if( !bTypes.ids[ params.type ] ){
          bTypes.push( params.type );
        }

        return; // notifications are disabled during batching
      }

      if( !this._private.notificationsEnabled ){ return; } // exit on disabled

      var renderer = this.renderer();
      
      renderer.notify(params);
    },
    
    notifications: function( bool ){
      var p = this._private;
      
      if( bool === undefined ){
        return p.notificationsEnabled;
      } else {
        p.notificationsEnabled = bool ? true : false;
      }
    },
    
    noNotifications: function( callback ){
      this.notifications(false);
      callback();
      this.notifications(true);
    },

    startBatch: function(){
      var _p = this._private;

      _p.batchingStyle = _p.batchingNotify = true;
      _p.batchStyleEles = [];
      _p.batchNotifyEles = [];
      _p.batchNotifyTypes = [];

      _p.batchStyleEles.ids = {};
      _p.batchNotifyEles.ids = {};
      _p.batchNotifyTypes.ids = {};

      return this;
    },

    endBatch: function(){
      var _p = this._private;

      // update style for dirty eles
      _p.batchingStyle = false;
      new $$.Collection(this, _p.batchStyleEles).updateStyle();

      // notify the renderer of queued eles and event types
      _p.batchingNotify = false;
      this.notify({
        type: _p.batchNotifyTypes,
        collection: _p.batchNotifyEles
      });

      return this;
    },

    batch: function( callback ){
      this.startBatch();
      callback();
      this.endBatch();

      return this;
    },

    // for backwards compatibility
    batchData: function( map ){
      var cy = this;

      return this.batch(function(){
        for( var id in map ){
          var data = map[id];
          var ele = cy.getElementById( id );
          
          ele.data( data );
        }
      });
    }
  });
  
})( cytoscape );

;(function($$){ 'use strict';
  
  $$.fn.core({
    
    renderTo: function( context, zoom, pan, pxRatio ){
      var r = this._private.renderer;

      r.renderTo( context, zoom, pan, pxRatio );
      return this;
    },

    renderer: function(){
      return this._private.renderer;
    },

    forceRender: function(){
      this.notify({
        type: 'draw'
      });

      return this;
    },

    resize: function(){
      this.notify({
        type: 'resize'
      });

      this.trigger('resize');

      return this;
    },
    
    initRenderer: function( options ){
      var cy = this;

      var RendererProto = $$.extension('renderer', options.name);
      if( RendererProto == null ){
        $$.util.error('Can not initialise: No such renderer `%s` found; did you include its JS file?', options.name);
        return;
      }
      
      this._private.renderer = new RendererProto(
        $$.util.extend({}, options, {
          cy: cy,
          style: cy._private.style
        })
      );
       
    },

    triggerOnRender: function(){
      var cbs = this._private.onRenders;

      for( var i = 0; i < cbs.length; i++ ){
        var cb = cbs[i];

        cb();
      }

      return this;
    },

    onRender: function( cb ){
      this._private.onRenders.push( cb );

      return this;
    },

    offRender: function( fn ){
      var cbs = this._private.onRenders;

      if( fn == null ){ // unbind all
        this._private.onRenders = [];
        return this;
      }

      for( var i = 0; i < cbs.length; i++ ){ // unbind specified
        var cb = cbs[i];

        if( fn === cb ){
          cbs.splice( i, 1 );
          break;
        }
      }

      return this;
    }
    
  });  
  
})( cytoscape );
;(function($$){ 'use strict';
  
  $$.fn.core({

    // get a collection
    // - empty collection on no args
    // - collection of elements in the graph on selector arg
    // - guarantee a returned collection when elements or collection specified
    collection: function( eles ){

      if( $$.is.string( eles ) ){
        return this.$( eles );

      } else if( $$.is.elementOrCollection( eles ) ){
        return eles.collection();

      } else if( $$.is.array( eles ) ){
        return new $$.Collection( this, eles );
      }

      return new $$.Collection( this );
    },
    
    nodes: function( selector ){
      var nodes = this.$(function(){
        return this.isNode();
      });

      if( selector ){
        return nodes.filter( selector );
      } 

      return nodes;
    },
    
    edges: function( selector ){
      var edges = this.$(function(){
        return this.isEdge();
      });

      if( selector ){
        return edges.filter( selector );
      }

      return edges;
    },
      
    // search the graph like jQuery
    $: function( selector ){
      var eles = new $$.Collection( this, this._private.elements );

      if( selector ){
        return eles.filter( selector );
      }

      return eles;
    }
    
  });  

  // aliases
  $$.corefn.elements = $$.corefn.filter = $$.corefn.$;  
  
})( cytoscape );

;(function($$){ 'use strict';
  
  $$.fn.core({
    
    style: function( newStyle ){
      if( newStyle ){
        var s = this.setStyle( newStyle );

        s.update();
      }

      return this._private.style;
    },

    setStyle: function( style ){
      var _p = this._private;

      if( $$.is.stylesheet(style) ){
        _p.style = style.generateStyle(this);
      
      } else if( $$.is.array(style) ) {
        _p.style = $$.style.fromJson(this, style);
      
      } else if( $$.is.string(style) ){
        _p.style = $$.style.fromString(this, style);
      
      } else {
        _p.style = new $$.Style( this );
      }

      return _p.style;
    }
  });
  
})( cytoscape );


;(function($$){ 'use strict';
  
  $$.fn.core({

    autolock: function(bool){
      if( bool !== undefined ){
        this._private.autolock = bool ? true : false;
      } else {
        return this._private.autolock;
      }
      
      return this; // chaining
    },

    autoungrabify: function(bool){
      if( bool !== undefined ){
        this._private.autoungrabify = bool ? true : false;
      } else {
        return this._private.autoungrabify;
      }
      
      return this; // chaining
    },

    autounselectify: function(bool){
      if( bool !== undefined ){
        this._private.autounselectify = bool ? true : false;
      } else {
        return this._private.autounselectify;
      }
      
      return this; // chaining
    },

    panningEnabled: function( bool ){
      if( bool !== undefined ){
        this._private.panningEnabled = bool ? true : false;
      } else {
        return this._private.panningEnabled;
      }
      
      return this; // chaining
    },

    userPanningEnabled: function( bool ){
      if( bool !== undefined ){
        this._private.userPanningEnabled = bool ? true : false;
      } else {
        return this._private.userPanningEnabled;
      }
      
      return this; // chaining
    },
    
    zoomingEnabled: function( bool ){
      if( bool !== undefined ){
        this._private.zoomingEnabled = bool ? true : false;
      } else {
        return this._private.zoomingEnabled;
      }
      
      return this; // chaining
    },

    userZoomingEnabled: function( bool ){
      if( bool !== undefined ){
        this._private.userZoomingEnabled = bool ? true : false;
      } else {
        return this._private.userZoomingEnabled;
      }
      
      return this; // chaining
    },

    boxSelectionEnabled: function( bool ){
      if( bool !== undefined ){
        this._private.boxSelectionEnabled = bool ? true : false;
      } else {
        return this._private.boxSelectionEnabled;
      }
      
      return this; // chaining
    },
    
    pan: function(){
      var args = arguments;
      var pan = this._private.pan;
      var dim, val, dims, x, y;

      switch( args.length ){
      case 0: // .pan()
        return pan;

      case 1: 

        if( $$.is.string( args[0] ) ){ // .pan('x')
          dim = args[0];
          return pan[ dim ];

        } else if( $$.is.plainObject( args[0] ) ) { // .pan({ x: 0, y: 100 })
          if( !this._private.panningEnabled ){
            return this;
          }

          dims = args[0];
          x = dims.x;
          y = dims.y;

          if( $$.is.number(x) ){
            pan.x = x;
          }

          if( $$.is.number(y) ){
            pan.y = y;
          }

          this.trigger('pan viewport');
        }
        break;

      case 2: // .pan('x', 100)
        if( !this._private.panningEnabled ){
          return this;
        }

        dim = args[0];
        val = args[1];

        if( (dim === 'x' || dim === 'y') && $$.is.number(val) ){
          pan[dim] = val;
        }

        this.trigger('pan viewport');
        break;

      default:
        break; // invalid
      }

      this.notify({ // notify the renderer that the viewport changed
        type: 'viewport'
      });

      return this; // chaining
    },
    
    panBy: function(params){
      var args = arguments;
      var pan = this._private.pan;
      var dim, val, dims, x, y;

      if( !this._private.panningEnabled ){
        return this;
      }

      switch( args.length ){
      case 1: 

        if( $$.is.plainObject( args[0] ) ) { // .panBy({ x: 0, y: 100 })
          dims = args[0];
          x = dims.x;
          y = dims.y;

          if( $$.is.number(x) ){
            pan.x += x;
          }

          if( $$.is.number(y) ){
            pan.y += y;
          }

          this.trigger('pan viewport');
        }
        break;

      case 2: // .panBy('x', 100)
        dim = args[0];
        val = args[1];

        if( (dim === 'x' || dim === 'y') && $$.is.number(val) ){
          pan[dim] += val;
        }

        this.trigger('pan viewport');
        break;

      default:
        break; // invalid
      }

      this.notify({ // notify the renderer that the viewport changed
        type: 'viewport'
      });

      return this; // chaining
    },
    
    fit: function( elements, padding ){
      var viewportState = this.getFitViewport( elements, padding );

      if( viewportState ){
        var _p = this._private;
        _p.zoom = viewportState.zoom;
        _p.pan = viewportState.pan;

        this.trigger('pan zoom viewport');

        this.notify({ // notify the renderer that the viewport changed
          type: 'viewport'
        });
      }

      return this; // chaining
    },

    getFitViewport: function( elements, padding ){
      if( $$.is.number(elements) && padding === undefined ){ // elements is optional
        padding = elements;
        elements = undefined;
      }

      if( !this._private.panningEnabled || !this._private.zoomingEnabled ){
        return;
      }

      var bb;

      if( $$.is.string(elements) ){
        var sel = elements;
        elements = this.$( sel );

      } else if( $$.is.boundingBox(elements) ){ // assume bb
        var bbe = elements;
        bb = {
          x1: bbe.x1,
          y1: bbe.y1,
          x2: bbe.x2,
          y2: bbe.y2
        };

        bb.w = bb.x2 - bb.x1;
        bb.h = bb.y2 - bb.y1;

      } else if( !$$.is.elementOrCollection(elements) ){
        elements = this.elements();
      }

      bb = bb || elements.boundingBox();

      var w = this.width();
      var h = this.height();
      var zoom;
      padding = $$.is.number(padding) ? padding : 0;

      if( !isNaN(w) && !isNaN(h) && w > 0 && h > 0 && !isNaN(bb.w) && !isNaN(bb.h) &&  bb.w > 0 && bb.h > 0 ){
        zoom = Math.min( (w - 2*padding)/bb.w, (h - 2*padding)/bb.h );

        // crop zoom
        zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;
        zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;

        var pan = { // now pan to middle
          x: (w - zoom*( bb.x1 + bb.x2 ))/2,
          y: (h - zoom*( bb.y1 + bb.y2 ))/2
        };

        return {
          zoom: zoom, 
          pan: pan
        };
      }

      return;
    },
    
    minZoom: function( zoom ){
      if( zoom === undefined ){
        return this._private.minZoom;
      } else if( $$.is.number(zoom) ){
        this._private.minZoom = zoom;
      }

      return this;
    },

    maxZoom: function( zoom ){
      if( zoom === undefined ){
        return this._private.maxZoom;
      } else if( $$.is.number(zoom) ){
        this._private.maxZoom = zoom;
      }

      return this;
    },

    zoom: function( params ){
      var pos; // in rendered px
      var zoom;

      if( params === undefined ){ // then get the zoom
        return this._private.zoom;

      } else if( $$.is.number(params) ){ // then set the zoom
        zoom = params;

      } else if( $$.is.plainObject(params) ){ // then zoom about a point
        zoom = params.level;

        if( params.position ){
          var p = params.position;
          var pan = this._private.pan;
          var z = this._private.zoom;

          pos = { // convert to rendered px
            x: p.x * z + pan.x,
            y: p.y * z + pan.y
          };
        } else if( params.renderedPosition ){
          pos = params.renderedPosition;
        }

        if( pos && !this._private.panningEnabled ){
          return this; // panning disabled
        }
      }

      if( !this._private.zoomingEnabled ){
        return this; // zooming disabled
      }

      if( !$$.is.number(zoom) || ( pos && (!$$.is.number(pos.x) || !$$.is.number(pos.y)) ) ){
        return this; // can't zoom with invalid params
      }

      // crop zoom
      zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;
      zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;

      if( pos ){ // set zoom about position
        var pan1 = this._private.pan;
        var zoom1 = this._private.zoom;
        var zoom2 = zoom;
        
        var pan2 = {
          x: -zoom2/zoom1 * (pos.x - pan1.x) + pos.x,
          y: -zoom2/zoom1 * (pos.y - pan1.y) + pos.y
        };

        this._private.zoom = zoom;
        this._private.pan = pan2;

        var posChanged = pan1.x !== pan2.x || pan1.y !== pan2.y;
        this.trigger(' zoom ' + (posChanged ? ' pan ' : '') + ' viewport ' );
      
      } else { // just set the zoom
        this._private.zoom = zoom;
        this.trigger('zoom viewport');
      }

      this.notify({ // notify the renderer that the viewport changed
        type: 'viewport'
      });

      return this; // chaining
    },

    viewport: function( opts ){ 
      var _p = this._private;
      var zoomDefd = true;
      var panDefd = true;
      var events = []; // to trigger
      var zoomFailed = false;
      var panFailed = false;

      if( !opts ){ return this; }
      if( !$$.is.number(opts.zoom) ){ zoomDefd = false; }
      if( !$$.is.plainObject(opts.pan) ){ panDefd = false; }
      if( !zoomDefd && !panDefd ){ return this; }

      if( zoomDefd ){
        var z = opts.zoom;

        if( z < _p.minZoom || z > _p.maxZoom || !_p.zoomingEnabled ){
          zoomFailed = true;

        } else {
          _p.zoom = z;

          events.push('zoom');
        }
      }

      if( panDefd && (!zoomFailed || !opts.cancelOnFailedZoom) && _p.panningEnabled ){
        var p = opts.pan;

        if( $$.is.number(p.x) ){
          _p.pan.x = p.x;
          panFailed = false;
        }

        if( $$.is.number(p.y) ){
          _p.pan.y = p.y;
          panFailed = false;
        }

        if( !panFailed ){
          events.push('pan');
        }
      }

      if( events.length > 0 ){
        events.push('viewport');
        this.trigger( events.join(' ') );

        this.notify({
          type: 'viewport'
        });
      }

      return this; // chaining
    },
    
    center: function( elements ){
      var pan = this.getCenterPan( elements );

      if( pan ){
        this._private.pan = pan;

        this.trigger('pan viewport');

        this.notify({ // notify the renderer that the viewport changed
          type: 'viewport'
        });
      }

      return this; // chaining
    },

    getCenterPan: function( elements, zoom ){
      if( !this._private.panningEnabled ){
        return;
      }

      if( $$.is.string(elements) ){
        var selector = elements;
        elements = this.elements( selector );
      } else if( !$$.is.elementOrCollection(elements) ){
        elements = this.elements();
      }

      var bb = elements.boundingBox();
      var w = this.width();
      var h = this.height();
      zoom = zoom === undefined ? this._private.zoom : zoom;

      var pan = { // middle
        x: (w - zoom*( bb.x1 + bb.x2 ))/2,
        y: (h - zoom*( bb.y1 + bb.y2 ))/2
      };
      
      return pan;
    },
    
    reset: function(){
      if( !this._private.panningEnabled || !this._private.zoomingEnabled ){
        return this;
      }

      this.viewport({
        pan: { x: 0, y: 0 },
        zoom: 1
      });
      
      return this; // chaining
    },

    width: function(){
      var container = this._private.container;

      if( container ){
        return container.clientWidth;
      }

      return 1; // fallback if no container (not 0 b/c can be used for dividing etc)
    },

    height: function(){
      var container = this._private.container;

      if( container ){
        return container.clientHeight;
      }

      return 1; // fallback if no container (not 0 b/c can be used for dividing etc)
    },

    extent: function(){
      var pan = this._private.pan;
      var zoom = this._private.zoom;
      var rb = this.renderedExtent();

      var b = {
        x1: ( rb.x1 - pan.x )/zoom,
        x2: ( rb.x2 - pan.x )/zoom,
        y1: ( rb.y1 - pan.y )/zoom,
        y2: ( rb.y2 - pan.y )/zoom,
      };

      b.w = b.x2 - b.x1;
      b.h = b.y2 - b.y1;

      return b;
    },

    renderedExtent: function(){
      var width = this.width();
      var height = this.height();

      return {
        x1: 0,
        y1: 0,
        x2: width,
        y2: height,
        w: width,
        h: height
      };
    }
  });

  // aliases
  $$.corefn.centre = $$.corefn.center;

  // backwards compatibility
  $$.corefn.autolockNodes = $$.corefn.autolock;
  $$.corefn.autoungrabifyNodes = $$.corefn.autoungrabify;

})( cytoscape );

;(function($$){ 'use strict';
  
  // Use this interface to define functions for collections/elements.
  // This interface is good, because it forces you to think in terms
  // of the collections case (more than 1 element), so we don't need
  // notification blocking nonsense everywhere.
  //
  // Other collection-*.js files depend on this being defined first.
  // It's a trade off: It simplifies the code for Collection and 
  // Element integration so much that it's worth it to create the
  // JS dependency.
  //
  // Having this integration guarantees that we can call any
  // collection function on an element and vice versa.

  // e.g. $$.fn.collection({ someFunc: function(){ /* ... */ } })
  $$.fn.collection = $$.fn.eles = function( fnMap, options ){
    for( var name in fnMap ){
      var fn = fnMap[name];

      $$.Collection.prototype[ name ] = fn;
    }
  };
  
  // factory for generating edge ids when no id is specified for a new element
  var idFactory = {
    prefix: {
      nodes: 'n',
      edges: 'e'
    },
    id: {
      nodes: 0,
      edges: 0
    },
    generate: function(cy, element, tryThisId){
      var json = $$.is.element( element ) ? element._private : element;
      var group = json.group;
      var id = tryThisId != null ? tryThisId : this.prefix[group] + this.id[group];
      
      if( cy.getElementById(id).empty() ){
        this.id[group]++; // we've used the current id, so move it up
      } else { // otherwise keep trying successive unused ids
        while( !cy.getElementById(id).empty() ){
          id = this.prefix[group] + ( ++this.id[group] );
        }
      }
      
      return id;
    }
  };
  
  // Element
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  // represents a node or an edge
  $$.Element = function(cy, params, restore){
    if( !(this instanceof $$.Element) ){
      return new $$.Element(cy, params, restore);
    }

    var self = this;
    restore = (restore === undefined || restore ? true : false);
    
    if( cy === undefined || params === undefined || !$$.is.core(cy) ){
      $$.util.error('An element must have a core reference and parameters set');
      return;
    }
    
    // validate group
    if( params.group !== 'nodes' && params.group !== 'edges' ){
      $$.util.error('An element must be of type `nodes` or `edges`; you specified `' + params.group + '`');
      return;
    }
    
    // make the element array-like, just like a collection
    this.length = 1;
    this[0] = this;
    
    // NOTE: when something is added here, add also to ele.json()
    this._private = {
      cy: cy,
      single: true, // indicates this is an element
      data: params.data || {}, // data object
      position: params.position || {}, // (x, y) position pair
      autoWidth: undefined, // width and height of nodes calculated by the renderer when set to special 'auto' value
      autoHeight: undefined, 
      listeners: [], // array of bound listeners
      group: params.group, // string; 'nodes' or 'edges'
      style: {}, // properties as set by the style
      rstyle: {}, // properties for style sent from the renderer to the core
      styleCxts: [], // applied style contexts from the styler
      removed: true, // whether it's inside the vis; true if removed (set true here since we call restore)
      selected: params.selected ? true : false, // whether it's selected
      selectable: params.selectable === undefined ? true : ( params.selectable ? true : false ), // whether it's selectable
      locked: params.locked ? true : false, // whether the element is locked (cannot be moved)
      grabbed: false, // whether the element is grabbed by the mouse; renderer sets this privately
      grabbable: params.grabbable === undefined ? true : ( params.grabbable ? true : false ), // whether the element can be grabbed
      active: false, // whether the element is active from user interaction
      classes: {}, // map ( className => true )
      animation: { // object for currently-running animations
        current: [],
        queue: []
      },
      rscratch: {}, // object in which the renderer can store information
      scratch: params.scratch || {}, // scratch objects
      edges: [], // array of connected edges
      children: [] // array of children
    };
    
    // renderedPosition overrides if specified
    if( params.renderedPosition ){
      var rpos = params.renderedPosition;
      var pan = cy.pan();
      var zoom = cy.zoom();

      this._private.position = {
        x: (rpos.x - pan.x)/zoom,
        y: (rpos.y - pan.y)/zoom
      };
    }
    
    if( $$.is.string(params.classes) ){
      var classes = params.classes.split(/\s+/);
      for( var i = 0, l = classes.length; i < l; i++ ){
        var cls = classes[i];
        if( !cls || cls === '' ){ continue; }

        self._private.classes[cls] = true;
      }
    }

    if( params.css ){
      cy.style().applyBypass( this, params.css );
    }
    
    if( restore === undefined || restore ){
      this.restore();
    }
    
  };

  
  // Collection
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  // represents a set of nodes, edges, or both together
  $$.Collection = function(cy, elements, options){
    if( !(this instanceof $$.Collection) ){
      return new $$.Collection(cy, elements);
    }

    if( cy === undefined || !$$.is.core(cy) ){
      $$.util.error('A collection must have a reference to the core');
      return;
    }
    
    var ids = {};
    var indexes = {};
    var createdElements = false;
    
    if( !elements ){
      elements = [];
    } else if( elements.length > 0 && $$.is.plainObject( elements[0] ) && !$$.is.element( elements[0] ) ){
      createdElements = true;

      // make elements from json and restore all at once later
      var eles = [];
      var elesIds = {};

      for( var i = 0, l = elements.length; i < l; i++ ){
        var json = elements[i];

        if( json.data == null ){
          json.data = {};
        }
        
        var data = json.data;

        // make sure newly created elements have valid ids
        if( data.id == null ){
          data.id = idFactory.generate( cy, json );
        } else if( cy.getElementById( data.id ).length !== 0 || elesIds[ data.id ] ){
          continue; // can't create element if prior id already exists
        }

        var ele = new $$.Element( cy, json, false );
        eles.push( ele );
        elesIds[ data.id ] = true;
      }

      elements = eles;
    }
    
    this.length = 0;

    for( var i = 0, l = elements.length; i < l; i++ ){
      var element = elements[i];
      if( !element ){  continue; }
      
      var id = element._private.data.id;
      
      if( !options || (options.unique && !ids[ id ] ) ){
        ids[ id ] = element;
        indexes[ id ] = this.length;

        this[ this.length ] = element;
        this.length++;
      }
    }
    
    this._private = {
      cy: cy,
      ids: ids,
      indexes: indexes
    };

    // restore the elements if we created them from json
    if( createdElements ){
      this.restore();
    }
  };
  
  
  // Functions
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  // keep the prototypes in sync (an element has the same functions as a collection)
  // and use $$.elefn and $$.elesfn as shorthands to the prototypes
  $$.elefn = $$.elesfn = $$.Element.prototype = $$.Collection.prototype;

  $$.elesfn.cy = function(){
    return this._private.cy;
  };
  
  $$.elesfn.element = function(){
    return this[0];
  };
  
  $$.elesfn.collection = function(){
    if( $$.is.collection(this) ){
      return this;
    } else { // an element
      return new $$.Collection( this._private.cy, [this] );
    }
  };

  $$.elesfn.unique = function(){
    return new $$.Collection( this._private.cy, this, { unique: true } );
  };

  $$.elesfn.getElementById = function( id ){
    var cy = this._private.cy;
    var ele = this._private.ids[ id ];

    return ele ? ele : $$.Collection(cy); // get ele or empty collection
  };

  $$.elesfn.json = function(){
    var ele = this.element();
    if( ele == null ){ return undefined; }

    var p = ele._private;
    
    var json = $$.util.copy({
      data: p.data,
      position: p.position,
      group: p.group,
      bypass: p.bypass,
      removed: p.removed,
      selected: p.selected,
      selectable: p.selectable,
      locked: p.locked,
      grabbed: p.grabbed,
      grabbable: p.grabbable,
      classes: ''
    });
    
    var classes = [];
    for( var cls in p.classes ){
      if( p.classes[cls] ){
        classes.push(cls);
      }
    }
    
    for( var i = 0; i < classes.length; i++ ){
      var cls = classes[i];
      json.classes += cls + ( i < classes.length - 1 ? ' ' : '' );
    }
    
    return json;
  };

  $$.elesfn.jsons = function(){
    var jsons = [];

    for( var i = 0; i < this.length; i++ ){
      var ele = this[i];
      var json = ele.json();

      jsons.push( json );
    }

    return jsons;
  };

  $$.elesfn.clone = function(){
    var cy = this.cy();
    var elesArr = [];

    for( var i = 0; i < this.length; i++ ){
      var ele = this[i];
      var json = ele.json();
      var clone = new $$.Element(cy, json, false); // NB no restore

      elesArr.push( clone );
    }

    return new $$.Collection( cy, elesArr );
  };
  $$.elesfn.copy = $$.elesfn.clone;

  $$.elesfn.restore = function( notifyRenderer ){
    var self = this;
    var restored = [];
    var cy = self.cy();
    
    if( notifyRenderer === undefined ){
      notifyRenderer = true;
    }

    // create arrays of nodes and edges, since we need to
    // restore the nodes first
    var elements = [];
    var nodes = [], edges = [];
    var numNodes = 0;
    var numEdges = 0;
    for( var i = 0, l = self.length; i < l; i++ ){
      var ele = self[i];
      
      // keep nodes first in the array and edges after
      if( ele.isNode() ){ // put to front of array if node
        nodes.push( ele );
        numNodes++;
      } else { // put to end of array if edge
        edges.push( ele );
        numEdges++;
      }
    }

    elements = nodes.concat( edges );

    // now, restore each element
    for( var i = 0, l = elements.length; i < l; i++ ){
      var ele = elements[i];

      if( !ele.removed() ){
        // don't need to do anything
        continue;
      }
      
      var _private = ele._private;
      var data = _private.data;
      
      // set id and validate
      if( data.id === undefined ){
        data.id = idFactory.generate( cy, ele );
      } else if( $$.is.emptyString(data.id) || !$$.is.string(data.id) ){
        $$.util.error('Can not create element with invalid string ID `' + data.id + '`');
        
        // can't create element if it has empty string as id or non-string id
        continue;
      } else if( cy.getElementById( data.id ).length !== 0 ){
        $$.util.error('Can not create second element with ID `' + data.id + '`');
        
        // can't create element if one already has that id
        continue;
      }

      var id = data.id; // id is finalised, now let's keep a ref
      
      if( ele.isEdge() ){ // extra checks for edges
        
        var edge = ele;
        var fields = ['source', 'target'];
        var fieldsLength = fields.length;
        var badSourceOrTarget = false;
        for(var j = 0; j < fieldsLength; j++){
          
          var field = fields[j];
          var val = data[field];
          
          if( val == null || val === '' ){
            // can't create if source or target is not defined properly
            $$.util.error('Can not create edge `' + id + '` with unspecified ' + field);
            badSourceOrTarget = true;
          } else if( cy.getElementById(val).empty() ){ 
            // can't create edge if one of its nodes doesn't exist
            $$.util.error('Can not create edge `' + id + '` with nonexistant ' + field + ' `' + val + '`');
            badSourceOrTarget = true;
          }
        }

        if( badSourceOrTarget ){ continue; } // can't create this
        
        var src = cy.getElementById( data.source );
        var tgt = cy.getElementById( data.target );

        src._private.edges.push( edge );
        tgt._private.edges.push( edge );

        edge._private.source = src;
        edge._private.target = tgt;

      } // if is edge
       
      // create mock ids map for element so it can be used like collections
      _private.ids = {};
      _private.ids[ id ] = ele;

      _private.removed = false;
      cy.addToPool( ele );
      
      restored.push( ele );
    } // for each element

    // do compound node sanity checks
    for( var i = 0; i < numNodes; i++ ){ // each node 
      var node = elements[i];
      var data = node._private.data;

      var parentId = node._private.data.parent;
      var specifiedParent = parentId != null;

      if( specifiedParent ){
        var parent = cy.getElementById( parentId );

        if( parent.empty() ){
          // non-existant parent; just remove it
          data.parent = undefined;
        } else {
          var selfAsParent = false;
          var ancestor = parent;
          while( !ancestor.empty() ){
            if( node.same(ancestor) ){
              // mark self as parent and remove from data
              selfAsParent = true;
              data.parent = undefined; // remove parent reference

              // exit or we loop forever
              break;
            }

            ancestor = ancestor.parent();
          }

          if( !selfAsParent ){
            // connect with children
            parent[0]._private.children.push( node );
            node._private.parent = parent[0];

            // let the core know we have a compound graph
            cy._private.hasCompoundNodes = true;
          }
        } // else
      } // if specified parent
    } // for each node
    
    restored = new $$.Collection( cy, restored );
    if( restored.length > 0 ){

      var toUpdateStyle = restored.add( restored.connectedNodes() ).add( restored.parent() );
      toUpdateStyle.updateStyle( notifyRenderer );

      if( notifyRenderer ){
        restored.rtrigger('add');
      } else {
        restored.trigger('add');
      }
    }
    
    return self; // chainability
  };
  
  $$.elesfn.removed = function(){
    var ele = this[0];
    return ele && ele._private.removed;
  };

  $$.elesfn.inside = function(){
    var ele = this[0];
    return ele && !ele._private.removed;
  };

  $$.elesfn.remove = function( notifyRenderer ){
    var self = this;
    var removed = [];
    var elesToRemove = [];
    var elesToRemoveIds = {};
    var cy = self._private.cy;
    
    if( notifyRenderer === undefined ){
      notifyRenderer = true;
    }
    
    // add connected edges
    function addConnectedEdges(node){
      var edges = node._private.edges; 
      for( var i = 0; i < edges.length; i++ ){
        add( edges[i] );
      }
    }
    

    // add descendant nodes
    function addChildren(node){
      var children = node._private.children;
      
      for( var i = 0; i < children.length; i++ ){
        add( children[i] );
      }
    }

    function add( ele ){
      var alreadyAdded =  elesToRemoveIds[ ele.id() ];
      if( alreadyAdded ){
        return;
      } else {
        elesToRemoveIds[ ele.id() ] = true;
      }

      if( ele.isNode() ){
        elesToRemove.push( ele ); // nodes are removed last

        addConnectedEdges( ele );
        addChildren( ele );
      } else {
        elesToRemove.unshift( ele ); // edges are removed first
      }
    }

    // make the list of elements to remove
    // (may be removing more than specified due to connected edges etc)

    for( var i = 0, l = self.length; i < l; i++ ){
      var ele = self[i];

      add( ele );
    }
    
    function removeEdgeRef(node, edge){
      var connectedEdges = node._private.edges;
      for( var j = 0; j < connectedEdges.length; j++ ){
        var connectedEdge = connectedEdges[j];
        
        if( edge === connectedEdge ){
          connectedEdges.splice( j, 1 );
          break;
        }
      }
    }

    function removeChildRef(parent, ele){
      ele = ele[0];
      parent = parent[0];
      var children = parent._private.children;

      for( var j = 0; j < children.length; j++ ){
        if( children[j][0] === ele[0] ){
          children.splice(j, 1);
          break;
        }
      }
    }

    for( var i = 0; i < elesToRemove.length; i++ ){
      var ele = elesToRemove[i];

      // mark as removed
      ele._private.removed = true;

      // remove from core pool
      cy.removeFromPool( ele );

      // add to list of removed elements
      removed.push( ele );

      if( ele.isEdge() ){ // remove references to this edge in its connected nodes
        var src = ele.source()[0];
        var tgt = ele.target()[0];

        removeEdgeRef( src, ele );
        removeEdgeRef( tgt, ele );

      } else { // remove reference to parent 
        var parent = ele.parent();

        if( parent.length !== 0 ){
          removeChildRef(parent, ele);
        }
      }
    }

    // check to see if we have a compound graph or not
    var elesStillInside = cy._private.elements;
    cy._private.hasCompoundNodes = false;
    for( var i = 0; i < elesStillInside.length; i++ ){
      var ele = elesStillInside[i];

      if( ele.isParent() ){
        cy._private.hasCompoundNodes = true;
        break;
      }
    }

    var removedElements = new $$.Collection( this.cy(), removed );
    if( removedElements.size() > 0 ){
      // must manually notify since trigger won't do this automatically once removed
      
      if( notifyRenderer ){
        this.cy().notify({
          type: 'remove',
          collection: removedElements
        });
      }
      
      removedElements.trigger('remove');
    }

    // check for empty remaining parent nodes
    var checkedParentId = {};
    for( var i = 0; i < elesToRemove.length; i++ ){
      var ele = elesToRemove[i];
      var isNode = ele._private.group === 'nodes';
      var parentId = ele._private.data.parent;

      if( isNode && parentId !== undefined && !checkedParentId[ parentId ] ){
        checkedParentId[ parentId ] = true;
        var parent = cy.getElementById( parentId );

        if( parent && parent.length !== 0 && !parent._private.removed && parent.children().length === 0 ){
          parent.updateStyle();
        }
      }
    }

    return this;
  };

  $$.elesfn.move = function( struct ){
    var cy = this._private.cy;

    if( struct.source !== undefined || struct.target !== undefined ){
      var srcId = struct.source;
      var tgtId = struct.target;
      var srcExists = cy.getElementById( srcId ).length > 0;
      var tgtExists = cy.getElementById( tgtId ).length > 0;

      if( srcExists || tgtExists ){
        var jsons = this.jsons();

        this.remove();

        for( var i = 0; i < jsons.length; i++ ){
          var json = jsons[i];

          if( json.group === 'edges' ){
            if( srcExists ){ json.data.source = srcId; }
            if( tgtExists ){ json.data.target = tgtId; }
          }
        }

        return cy.add( jsons );
      }
 
    } else if( struct.parent !== undefined ){ // move node to new parent
      var parentId = struct.parent;
      var parentExists = parentId === null || cy.getElementById( parentId ).length > 0;
    
      if( parentExists ){
        var jsons = this.jsons();
        var descs = this.descendants();
        var descsEtc = descs.merge( descs.add(this).connectedEdges() );

        this.remove(); // NB: also removes descendants and their connected edges

        for( var i = 0; i < this.length; i++ ){
          var json = jsons[i];

          if( json.group === 'nodes' ){
            json.data.parent = parentId === null ? undefined : parentId;
          }
        }
      }

      return cy.add( jsons ).merge( descsEtc.restore() );
    }

    return this; // if nothing done
  };
  
})( cytoscape );


;(function($$){ 'use strict';

  // search, spanning trees, etc
  $$.fn.eles({

    // std functional ele first callback style
    stdBreadthFirstSearch: function( options ){
      options = $$.util.extend( {}, options, {
        std: true
      } );

      return this.breadthFirstSearch( options );
    },

    // do a breadth first search from the nodes in the collection
    // from pseudocode on wikipedia
    breadthFirstSearch: function( roots, fn, directed ){
      var options;
      var std;
      var thisArg;
      if( $$.is.plainObject(roots) && !$$.is.elementOrCollection(roots) ){
        options = roots;
        roots = options.roots;
        fn = options.visit;
        directed = options.directed;
        std = options.std;
        thisArg = options.thisArg;
      }

      directed = arguments.length === 2 && !$$.is.fn(fn) ? fn : directed;
      fn = $$.is.fn(fn) ? fn : function(){};
      
      var cy = this._private.cy;
      var v = $$.is.string(roots) ? this.filter(roots) : roots;
      var Q = [];
      var connectedNodes = [];
      var connectedBy = {};
      var id2depth = {};
      var V = {};
      var j = 0;
      var found;
      var nodes = this.nodes();
      var edges = this.edges();

      // enqueue v
      for( var i = 0; i < v.length; i++ ){
        if( v[i].isNode() ){
          Q.unshift( v[i] );
          V[ v[i].id() ] = true; 

          connectedNodes.push( v[i] );
          id2depth[ v[i].id() ] = 0;
        }
      }

      while( Q.length !== 0 ){
        var v = Q.shift();
        var depth = id2depth[ v.id() ];
        var prevEdge = connectedBy[ v.id() ];
        var prevNode = prevEdge == null ? undefined : prevEdge.connectedNodes().not( v )[0];
        var ret;

        if( std ){
          ret = fn.call(thisArg, v, prevEdge, prevNode, j++, depth);
        } else {
          ret = fn.call(v, j++, depth, v, prevEdge, prevNode);
        }

        if( ret === true ){
          found = v;
          break;
        }

        if( ret === false ){
          break;
        }

        var vwEdges = v.connectedEdges(directed ? function(){ return this.data('source') === v.id(); } : undefined).intersect( edges );
        for( var i = 0; i < vwEdges.length; i++ ){
          var e = vwEdges[i];
          var w = e.connectedNodes(function(){ return this.id() !== v.id(); }).intersect( nodes );

          if( w.length !== 0 && !V[ w.id() ] ){
            w = w[0];

            Q.push( w );
            V[ w.id() ] = true;

            id2depth[ w.id() ] = id2depth[ v.id() ] + 1;

            connectedNodes.push( w );
            connectedBy[ w.id() ] = e;
          }
        }
        
      }

      var connectedEles = [];

      for( var i = 0; i < connectedNodes.length; i++ ){
        var node = connectedNodes[i];
        var edge = connectedBy[ node.id() ];

        if( edge ){
          connectedEles.push( edge );
        }

        connectedEles.push( node );
      }

      return {
        path: new $$.Collection( cy, connectedEles, { unique: true } ),
        found: new $$.Collection( cy, found, { unique: true } )
      };
    },

    // std functional ele first callback style
    stdDepthFirstSearch: function( options ){
      options = $$.util.extend( {}, options, {
        std: true
      } );

      return this.depthFirstSearch( options );
    },

    // do a depth first search on the nodes in the collection
    // from pseudocode on wikipedia (iterative impl)
    depthFirstSearch: function( roots, fn, directed ){
      var options;
      var std;
      var thisArg;
      if( $$.is.plainObject(roots) && !$$.is.elementOrCollection(roots) ){
        options = roots;
        roots = options.roots;
        fn = options.visit;
        directed = options.directed;
        std = options.std;
        thisArg = options.thisArg;
      }
      
      directed = arguments.length === 2 && !$$.is.fn(fn) ? fn : directed;
      fn = $$.is.fn(fn) ? fn : function(){};
      var cy = this._private.cy;
      var v = $$.is.string(roots) ? this.filter(roots) : roots;
      var S = [];
      var connectedNodes = [];
      var connectedBy = {};
      var id2depth = {};
      var discovered = {};
      var j = 0;
      var found;
      var edges = this.edges();
      var nodes = this.nodes();

      // push v
      for( var i = 0; i < v.length; i++ ){
        if( v[i].isNode() ){
          S.push( v[i] );

          connectedNodes.push( v[i] );
          id2depth[ v[i].id() ] = 0;
        }
      }

      while( S.length !== 0 ){
        var v = S.pop();

        if( !discovered[ v.id() ] ){
          discovered[ v.id() ] = true;

          var depth = id2depth[ v.id() ];
          var prevEdge = connectedBy[ v.id() ];
          var prevNode = prevEdge == null ? undefined : prevEdge.connectedNodes().not( v )[0];
          var ret;

          if( std ){
            ret = fn.call(thisArg, v, prevEdge, prevNode, j++, depth);
          } else {
            ret = fn.call(v, j++, depth, v, prevEdge, prevNode);
          }

          if( ret === true ){
            found = v;
            break;
          }

          if( ret === false ){
            break;
          }

          var vwEdges = v.connectedEdges(directed ? function(){ return this.data('source') === v.id(); } : undefined).intersect( edges );
          
          for( var i = 0; i < vwEdges.length; i++ ){
            var e = vwEdges[i];
            var w = e.connectedNodes(function(){ return this.id() !== v.id(); }).intersect( nodes );

            if( w.length !== 0 && !discovered[ w.id() ] ){
              w = w[0];

              S.push( w );

              id2depth[ w.id() ] = id2depth[ v.id() ] + 1;

              connectedNodes.push( w );
              connectedBy[ w.id() ] = e;
            }
          }
        }
      }

      var connectedEles = [];

      for( var i = 0; i < connectedNodes.length; i++ ){
        var node = connectedNodes[i];
        var edge = connectedBy[ node.id() ];

        if( edge ){
          connectedEles.push( edge );
        }

        connectedEles.push( node );
      }

      return {
        path: new $$.Collection( cy, connectedEles, { unique: true } ),
        found: new $$.Collection( cy, found, { unique: true } )
      };
    },

    // kruskal's algorithm (finds min spanning tree, assuming undirected graph)
    // implemented from pseudocode from wikipedia
    kruskal: function( weightFn ){
      weightFn = $$.is.fn(weightFn) ? weightFn : function(){ return 1; }; // if not specified, assume each edge has equal weight (1)

      function findSet(ele){
        for( var i = 0; i < forest.length; i++ ){
          var eles = forest[i];

          if( eles.anySame(ele) ){
            return {
              eles: eles,
              index: i
            };
          }
        }
      }

      var A = new $$.Collection(this._private.cy, []);
      var forest = [];
      var nodes = this.nodes();

      for( var i = 0; i < nodes.length; i++ ){
        forest.push( nodes[i].collection() );
      }

      var edges = this.edges();
      var S = edges.toArray().sort(function(a, b){
        var weightA = weightFn.call(a, a);
        var weightB = weightFn.call(b, b);

        return weightA - weightB;
      });

      for(var i = 0; i < S.length; i++){
        var edge = S[i];
        var u = edge.source()[0];
        var v = edge.target()[0];
        var setU = findSet(u);
        var setV = findSet(v);

        if( setU.index !== setV.index ){
          A = A.add( edge );

          // combine forests for u and v
          forest[ setU.index ] = setU.eles.add( setV.eles );
          forest.splice( setV.index, 1 );
        }
      }

      return nodes.add( A );

    },

    dijkstra: function( root, weightFn, directed ){
      var options;
      if( $$.is.plainObject(root) && !$$.is.elementOrCollection(root) ){
        options = root;
        root = options.root;
        weightFn = options.weight;
        directed = options.directed;
      }

      var cy = this._private.cy;
      weightFn = $$.is.fn(weightFn) ? weightFn : function(){ return 1; }; // if not specified, assume each edge has equal weight (1)

      var source = $$.is.string(root) ? this.filter(root)[0] : root[0];
      var dist = {};
      var prev = {};
      var knownDist = {};

      var edges = this.edges().filter(function(){ return !this.isLoop(); });
      var nodes = this.nodes();
      var Q = [];

      for( var i = 0; i < nodes.length; i++ ){
        dist[ nodes[i].id() ] = nodes[i].same( source ) ? 0 : Infinity;
        Q.push( nodes[i] );
      }

      var valueFn = function(node) {
        return dist[ node.id() ];
      };
      
      Q = new $$.Collection(cy, Q);
    
      var heap = $$.Minheap(cy, Q, valueFn);
    
      var distBetween = function(u, v){
        var uvs = ( directed ? u.edgesTo(v) : u.edgesWith(v) ).intersect(edges);
        var smallestDistance = Infinity;
        var smallestEdge;

        for( var i = 0; i < uvs.length; i++ ){
          var edge = uvs[i];
          var weight = weightFn.apply( edge, [edge] );

          if( weight < smallestDistance || !smallestEdge ){
            smallestDistance = weight;
            smallestEdge = edge;
          }
        }

        return {
          edge: smallestEdge,
          dist: smallestDistance
        };
      };

      while(heap.size() > 0){
        var smallestEl = heap.pop(),
        smalletsDist = smallestEl.value,
        uid = smallestEl.id,
        u = cy.getElementById(uid);
    
        knownDist[uid] = smalletsDist;
      
        if( smalletsDist === Math.Infinite ){
          break;
        }

        var neighbors = u.neighborhood().intersect(nodes);
        for( var i = 0; i < neighbors.length; i++ ){
          var v = neighbors[i];
          var vid = v.id();
          var vDist = distBetween(u, v);

          var alt = smalletsDist + vDist.dist;

          if( alt < heap.getValueById(vid) ){
            heap.edit(vid, alt);
            prev[ vid ] = {
              node: u,
              edge: vDist.edge
            };
          }
        } // for 
      } // while

      return {
        distanceTo: function(node){
          var target = $$.is.string(node) ? nodes.filter(node)[0] : node[0];

          return knownDist[ target.id() ];
        },

        pathTo: function(node){
          var target = $$.is.string(node) ? nodes.filter(node)[0] : node[0];
          var S = [];
          var u = target;

          if( target.length > 0 ){
            S.unshift( target );

            while( prev[ u.id() ] ){
              var p = prev[ u.id() ];

              S.unshift( p.edge );
              S.unshift( p.node );

              u = p.node;
            }
          }

          return new $$.Collection( cy, S );
        }
      };
    }  
  });

  // nice, short mathemathical alias
  $$.elesfn.bfs = $$.elesfn.breadthFirstSearch;
  $$.elesfn.dfs = $$.elesfn.depthFirstSearch;
  $$.elesfn.stdBfs = $$.elesfn.stdBreadthFirstSearch;
  $$.elesfn.stdDfs = $$.elesfn.stdDepthFirstSearch;
  
})( cytoscape );

;(function($$) { 
  'use strict';

  // Additional graph analysis algorithms
  $$.fn.eles({

    // Implemented from pseudocode from wikipedia

    // options => options object
    //   root // starting node (either element or selector string)
    //   weight: function( edge ){} // specifies weight to use for `edge`/`this`. If not present, it will be asumed a weight of 1 for all edges
    //   heuristic: function( node ){} // specifies heuristic value for `node`/`this`
    //   directed // default false
    //   goal // target node (either element or selector string). Mandatory.

    // retObj => returned object by function
    //   found : true/false // whether a path from root to goal has been found
    //   distance // Distance for the shortest path from root to goal
    //   path // Array of ids of nodes in shortest path
    aStar: function(options) {
      options = options || {};

      // var logDebug = function() {
      //   if (debug) {
      //     console.log.apply(console, arguments);
      //   }
      // };

      // Reconstructs the path from Start to End, acumulating the result in pathAcum
      var reconstructPath = function(start, end, cameFromMap, pathAcum) {
        // Base case
        if (start == end) {
          pathAcum.push( cy.getElementById(end) );
          return pathAcum;
        }
        
        if (end in cameFromMap) {
          // We know which node is before the last one
          var previous = cameFromMap[end];
          var previousEdge = cameFromEdge[end];

          pathAcum.push( cy.getElementById(end) );
          pathAcum.push( cy.getElementById(previousEdge) );


          return reconstructPath(start, 
                       previous, 
                       cameFromMap, 
                       pathAcum);
        }

        // We should not reach here!
        return undefined;       
      };

      // Returns the index of the element in openSet which has minimum fScore
      var findMin = function(openSet, fScore) {
        if (openSet.length === 0) {
          // Should never be the case
          return undefined;
        }
        var minPos = 0;
        var tempScore = fScore[openSet[0]];
        for (var i = 1; i < openSet.length; i++) {
          var s = fScore[openSet[i]];
          if (s < tempScore) {
            tempScore = s;
            minPos = i;
          }
        }
        return minPos;
      };

      // Parse options
      // debug - optional
      // if (options.debug != null) {
      //   var debug = options.debug;
      // } else {
      //   var debug = false;
      // }

      // logDebug("Starting aStar..."); 
      var cy = this._private.cy;

      // root - mandatory!
      if (options != null && options.root != null) {        
        var source = $$.is.string(options.root) ? 
          // use it as a selector, e.g. "#rootID
          this.filter(options.root)[0] : 
          options.root[0];
        // logDebug("Source node: %s", source.id()); 
      } else {
        return undefined;
      }
      
      // goal - mandatory!
      if (options.goal != null) {       
        var target = $$.is.string(options.goal) ? 
          // use it as a selector, e.g. "#goalID
          this.filter(options.goal)[0] : 
          options.goal[0];
        // logDebug("Target node: %s", target.id()); 
      } else {
        return undefined;
      }

      // Heuristic function - optional
      if (options.heuristic != null && $$.is.fn(options.heuristic)) {       
        var heuristic = options.heuristic;
      } else {
        var heuristic = function(){ return 0; }; // use constant if unspecified
        // $$.util.error("Missing required parameter (heuristic)! Aborting.");
        // return;
      }

      // Weight function - optional
      if (options.weight != null && $$.is.fn(options.weight)) {       
        var weightFn = options.weight;
      } else {
        // If not specified, assume each edge has equal weight (1)
        var weightFn = function(e) {return 1;};
      }

      // directed - optional
      if (options.directed != null) {       
        var directed = options.directed;
      } else {
        var directed = false;
      }

      var closedSet = [];
      var openSet = [source.id()];
      var cameFrom = {};
      var cameFromEdge = {};
      var gScore = {};
      var fScore = {};

      gScore[source.id()] = 0;
      fScore[source.id()] = heuristic(source);
      
      var edges = this.edges().stdFilter(function(e){ return !e.isLoop(); });
      var nodes = this.nodes();

      // Counter
      var steps = 0;

      // Main loop 
      while (openSet.length > 0) {
        var minPos = findMin(openSet, fScore);
        var cMin = cy.getElementById( openSet[minPos] );
        steps++;

        // logDebug("\nStep: %s", steps);
        // logDebug("Processing node: %s, fScore = %s", cMin.id(), fScore[cMin.id()]);
        
        // If we've found our goal, then we are done
        if (cMin.id() == target.id()) {
          // logDebug("Found goal node!");
          var rPath = reconstructPath(source.id(), target.id(), cameFrom, []);
          rPath.reverse();
          // logDebug("Path: %s", rPath);
          return {
            found : true,
            distance : gScore[cMin.id()],
            path : new $$.Collection(cy, rPath),
            steps : steps
          };          
        }
        
        // Add cMin to processed nodes
        closedSet.push(cMin.id());
        // Remove cMin from boundary nodes
        openSet.splice(minPos, 1);
        // logDebug("Added node to closedSet, removed from openSet.");
        // logDebug("Processing neighbors...");

        // Update scores for neighbors of cMin
        // Take into account if graph is directed or not
        var vwEdges = cMin.connectedEdges();
        if( directed ){ vwEdges = vwEdges.stdFilter(function(ele){ return ele.data('source') === cMin.id(); }); }
        vwEdges = vwEdges.intersect(edges);  
        
        for (var i = 0; i < vwEdges.length; i++) {
          var e = vwEdges[i];
          var w = e.connectedNodes().stdFilter(function(n){ return n.id() !== cMin.id(); }).intersect(nodes);

          // logDebug("   processing neighbor: %s", w.id());
          // if node is in closedSet, ignore it
          if (closedSet.indexOf(w.id()) != -1) {
            // logDebug("   already in closedSet, ignoring it.");
            continue;
          }
          
          // New tentative score for node w
          var tempScore = gScore[cMin.id()] + weightFn.apply(e, [e]);
          // logDebug("   tentative gScore: %d", tempScore);

          // Update gScore for node w if:
          //   w not present in openSet
          // OR
          //   tentative gScore is less than previous value

          // w not in openSet
          if (openSet.indexOf(w.id()) == -1) {
            gScore[w.id()] = tempScore;
            fScore[w.id()] = tempScore + heuristic(w);
            openSet.push(w.id()); // Add node to openSet
            cameFrom[w.id()] = cMin.id();
            cameFromEdge[w.id()] = e.id();
            // logDebug("   not in openSet, adding it. ");
            // logDebug("   fScore(%s) = %s", w.id(), tempScore);
            continue;
          }
          // w already in openSet, but with greater gScore
          if (tempScore < gScore[w.id()]) {
            gScore[w.id()] = tempScore;
            fScore[w.id()] = tempScore + heuristic(w);
            cameFrom[w.id()] = cMin.id();
            // logDebug("   better score, replacing gScore. ");
            // logDebug("   fScore(%s) = %s", w.id(), tempScore);
          }

        } // End of neighbors update

      } // End of main loop

      // If we've reached here, then we've not reached our goal
      // logDebug("Reached end of computation without finding our goal");
      return {
        found : false,
        distance : undefined,
        path : undefined,
        steps : steps
      };
    }, // aStar()


    // Implemented from pseudocode from wikipedia
    // options => options object
    //   weight: function( edge ){} // specifies weight to use for `edge`/`this`. If not present, it will be asumed a weight of 1 for all edges
    //   directed // default false
    // retObj => returned object by function
    //   pathTo : function(fromId, toId) // Returns the shortest path from node with ID "fromID" to node with ID "toId", as an array of node IDs
    //   distanceTo: function(fromId, toId) // Returns the distance of the shortest path from node with ID "fromID" to node with ID "toId"
    floydWarshall: function(options) {
      options = options || {};

      // var logDebug = function() {
      //   if (debug) {
      //     console.log.apply(console, arguments);
      //   }
      // };

      // Parse options
      // debug - optional
      // if (options.debug != null) {
      //   var debug = options.debug;
      // } else {
      //   var debug = false;
      // }
      // logDebug("Starting floydWarshall..."); 

      var cy = this._private.cy;

      // Weight function - optional
      if (options.weight != null && $$.is.fn(options.weight)) {       
        var weightFn = options.weight;
      } else {
        // If not specified, assume each edge has equal weight (1)
        var weightFn = function(e) {return 1;};
      }

      // directed - optional
      if (options.directed != null) {       
        var directed = options.directed;
      } else {
        var directed = false;
      }

      var edges = this.edges().stdFilter(function(e){ return !e.isLoop(); });
      var nodes = this.nodes();
      var numNodes = nodes.length;

      // mapping: node id -> position in nodes array
      var id2position = {};
      for (var i = 0; i < numNodes; i++) {
        id2position[nodes[i].id()] = i;
      }     

      // Initialize distance matrix
      var dist = [];
      for (var i = 0; i < numNodes; i++) {
        var newRow = new Array(numNodes);
        for (var j = 0; j < numNodes; j++) {
          if (i == j) {
            newRow[j] = 0;
          } else {
            newRow[j] = Infinity;
          }
        }
        dist.push(newRow);
      }           

      // Initialize matrix used for path reconstruction
      // Initialize distance matrix
      var next = [];
      var edgeNext = [];

      var initMatrix = function(next){
        for (var i = 0; i < numNodes; i++) {
          var newRow = new Array(numNodes);
          for (var j = 0; j < numNodes; j++) {
            newRow[j] = undefined;
          }
          next.push(newRow);
        }
      };

      initMatrix(next);
      initMatrix(edgeNext);
      
      // Process edges
      for (var i = 0; i < edges.length ; i++) {     
        var sourceIndex = id2position[edges[i].source().id()];
        var targetIndex = id2position[edges[i].target().id()];    
        var weight = weightFn.apply(edges[i], [edges[i]]);
        
        // Check if already process another edge between same 2 nodes
        if (dist[sourceIndex][targetIndex] > weight) {
          dist[sourceIndex][targetIndex] = weight;
          next[sourceIndex][targetIndex] = targetIndex;
          edgeNext[sourceIndex][targetIndex] = edges[i];
        }
      }

      // If undirected graph, process 'reversed' edges
      if (!directed) {
        for (var i = 0; i < edges.length ; i++) {     
          var sourceIndex = id2position[edges[i].target().id()];    
          var targetIndex = id2position[edges[i].source().id()];
          var weight = weightFn.apply(edges[i], [edges[i]]);
          
          // Check if already process another edge between same 2 nodes
          if (dist[sourceIndex][targetIndex] > weight) {
            dist[sourceIndex][targetIndex] = weight;
            next[sourceIndex][targetIndex] = targetIndex;
            edgeNext[sourceIndex][targetIndex] = edges[i];
          }
        }
      }

      // Main loop
      for (var k = 0; k < numNodes; k++) {
        for (var i = 0; i < numNodes; i++) {
          for (var j = 0; j < numNodes; j++) {            
            if (dist[i][k] + dist[k][j] < dist[i][j]) {
              dist[i][j] = dist[i][k] + dist[k][j];
              next[i][j] = next[i][k];
            }
          }
        }
      }

      // Build result object       
      var position2id = [];
      for (var i = 0; i < numNodes; i++) {
        position2id.push(nodes[i].id());
      }

      var res = {
        distance: function(from, to) {
          if ($$.is.string(from)) {
            // from is a selector string
            var fromId = (cy.filter(from)[0]).id();
          } else {
            // from is a node
            var fromId = from.id();
          }

          if ($$.is.string(to)) {
            // to is a selector string
            var toId = (cy.filter(to)[0]).id();
          } else {
            // to is a node
            var toId = to.id();
          }

          return dist[id2position[fromId]][id2position[toId]];
        },

        path: function(from, to) {
          var reconstructPathAux = function(from, to, next, position2id, edgeNext) {
            if (from === to) {
              return cy.getElementById( position2id[from] );
            }
            if (next[from][to] === undefined) {
              return undefined;
            }

            var path = [ cy.getElementById(position2id[from]) ];
            var prev = from;
            while (from !== to) {
              prev = from;
              from = next[from][to];

              var edge = edgeNext[prev][from];
              path.push( edge );

              path.push( cy.getElementById(position2id[from]) );
            }
            return path;
          };

          if ($$.is.string(from)) {
            // from is a selector string
            var fromId = (cy.filter(from)[0]).id();
          } else {
            // from is a node
            var fromId = from.id();
          }

          if ($$.is.string(to)) {
            // to is a selector string
            var toId = (cy.filter(to)[0]).id();
          } else {
            // to is a node
            var toId = to.id();
          }
          
          var pathArr = reconstructPathAux(id2position[fromId], 
                        id2position[toId], 
                        next,
                        position2id,
                        edgeNext);

          return new $$.Collection( cy, pathArr );
        },
      };

      return res;

    }, // floydWarshall


    // Implemented from pseudocode from wikipedia
    // options => options object
    //   root: starting node (either element or selector string)
    //   weight: function( edge ){} // specifies weight to use for `edge`/`this`. If not present, it will be asumed a weight of 1 for all edges
    //   directed // default false
    // retObj => returned object by function
    //   pathTo : function(toId) // Returns the shortest path from root node to node with ID "toId", as an array of node IDs
    //   distanceTo: function(toId) // Returns the distance of the shortest path from root node to node with ID "toId"
    //   hasNegativeWeightCycle: true/false (if true, pathTo and distanceTo will be undefined)
    bellmanFord: function(options) {
      options = options || {};

      // var logDebug = function() {
      //   if (debug) {
      //     console.log.apply(console, arguments);
      //   }
      // };

      // Parse options
      // debug - optional
      // if (options.debug != null) {
      //   var debug = options.debug;
      // } else {
      //   var debug = false;
      // }
      // logDebug("Starting bellmanFord..."); 

      // Weight function - optional
      if (options.weight != null && $$.is.fn(options.weight)) {       
        var weightFn = options.weight;
      } else {
        // If not specified, assume each edge has equal weight (1)
        var weightFn = function(e) {return 1;};
      }

      // directed - optional
      if (options.directed != null) {       
        var directed = options.directed;
      } else {
        var directed = false;
      }

      // root - mandatory!
      if (options.root != null) {       
        if ($$.is.string(options.root)) {
          // use it as a selector, e.g. "#rootID
          var source = this.filter(options.root)[0];
        } else {
          var source = options.root[0];
        }
        // logDebug("Source node: %s", source.id()); 
      } else {
        $$.util.error("options.root required");
        return undefined;
      }

      var cy = this._private.cy;
      var edges = this.edges().stdFilter(function(e){ return !e.isLoop(); });
      var nodes = this.nodes();
      var numNodes = nodes.length;

      // mapping: node id -> position in nodes array
      var id2position = {};
      for (var i = 0; i < numNodes; i++) {
        id2position[nodes[i].id()] = i;
      }     

      // Initializations
      var cost = [];
      var predecessor = [];
      var predEdge = [];
      
      for (var i = 0; i < numNodes; i++) {
        if (nodes[i].id() === source.id()) {
          cost[i] = 0;
        } else {
          cost[i] = Infinity;
        } 
        predecessor[i] = undefined;
      }
      
      // Edges relaxation      
      var flag = false;
      for (var i = 1; i < numNodes; i++) {
        flag = false;
        for (var e = 0; e < edges.length; e++) {
          var sourceIndex = id2position[edges[e].source().id()];
          var targetIndex = id2position[edges[e].target().id()];    
          var weight = weightFn.apply(edges[e], [edges[e]]);
          
          var temp = cost[sourceIndex] + weight;
          if (temp < cost[targetIndex]) {
            cost[targetIndex] = temp;
            predecessor[targetIndex] = sourceIndex;
            predEdge[targetIndex] = edges[e];
            flag = true;
          }

          // If undirected graph, we need to take into account the 'reverse' edge
          if (!directed) {
            var temp = cost[targetIndex] + weight;
            if (temp < cost[sourceIndex]) {
              cost[sourceIndex] = temp;
              predecessor[sourceIndex] = targetIndex;
              predEdge[sourceIndex] = edges[e];
              flag = true;
            }
          }
        }

        if (!flag) {
          break;
        }
      }      
            
      if (flag) {
        // Check for negative weight cycles
        for (var e = 0; e < edges.length; e++) {
          var sourceIndex = id2position[edges[e].source().id()];
          var targetIndex = id2position[edges[e].target().id()];    
          var weight = weightFn.apply(edges[e], [edges[e]]);
          
          if (cost[sourceIndex] + weight < cost[targetIndex]) {
            $$.util.error("Error: graph contains a negative weigth cycle!"); 
            return { pathTo: undefined,
                 distanceTo: undefined,
                 hasNegativeWeightCycle: true};
          }
        }     
      }

      // Build result object       
      var position2id = [];
      for (var i = 0; i < numNodes; i++) {
        position2id.push(nodes[i].id());
      }
      
      
      var res = {       
        distanceTo : function(to) {
          if ($$.is.string(to)) {
            // to is a selector string
            var toId = (cy.filter(to)[0]).id();
          } else {
            // to is a node
            var toId = to.id();
          }

          return cost[id2position[toId]];
        }, 

        pathTo : function(to) {

          var reconstructPathAux = function(predecessor, fromPos, toPos, position2id, acumPath, predEdge) {
            for(;;){
              // Add toId to path
              acumPath.push( cy.getElementById(position2id[toPos]) );
              acumPath.push( predEdge[toPos] );

              if (fromPos === toPos) {
                // reached starting node
                return acumPath;
              }

              // If no path exists, discart acumulated path and return undefined
              var predPos = predecessor[toPos];
              if (typeof predPos === "undefined") {
                return undefined;
              }

              toPos = predPos;
            }

          };

          if ($$.is.string(to)) {
            // to is a selector string
            var toId = (cy.filter(to)[0]).id();
          } else {
            // to is a node
            var toId = to.id();
          }
          var path = [];

          // This returns a reversed path 
          var res =  reconstructPathAux(predecessor, 
                        id2position[source.id()],
                        id2position[toId], 
                        position2id, 
                        path,
                        predEdge);

          // Get it in the correct order and return it
          if (res != null) {
            res.reverse();
          }

          return new $$.Collection(cy, res);                       
        }, 

        hasNegativeWeightCycle: false
      };

      return res;

    }, // bellmanFord


    // Computes the minimum cut of an undirected graph
    // Returns the correct answer with high probability
    // options => options object
    // 
    // retObj => returned object by function
    //   cut : list of IDs of edges in the cut,
    //   partition1: list of IDs of nodes in one partition
    //   partition2: list of IDs of nodes in the other partition
    kargerStein: function(options) {
      options = options || {};
      
      // var logDebug = function() {
      //   if (debug) {
      //     console.log.apply(console, arguments);
      //   }
      // };

      // Function which colapses 2 (meta) nodes into one
      // Updates the remaining edge lists
      // Receives as a paramater the edge which causes the collapse
      var colapse = function(edgeIndex, nodeMap, remainingEdges) {
        var edgeInfo = remainingEdges[edgeIndex];
        var sourceIn = edgeInfo[1];
        var targetIn = edgeInfo[2];
        var partition1 = nodeMap[sourceIn];
        var partition2 = nodeMap[targetIn];

        // Delete all edges between partition1 and partition2
        var newEdges = remainingEdges.filter(function(edge) {
          if (nodeMap[edge[1]] === partition1 && nodeMap[edge[2]] === partition2) {
            return false;
          }
          if (nodeMap[edge[1]] === partition2 && nodeMap[edge[2]] === partition1) {
            return false;
          }
          return true;
        });
        
        // All edges pointing to partition2 should now point to partition1
        for (var i = 0; i < newEdges.length; i++) {
          var edge = newEdges[i];
          if (edge[1] === partition2) { // Check source
            newEdges[i] = edge.slice(0);
            newEdges[i][1] = partition1;
          } else if (edge[2] === partition2) { // Check target
            newEdges[i] = edge.slice(0);
            newEdges[i][2] = partition1;
          }
        } 
        
        // Move all nodes from partition2 to partition1
        for (var i = 0; i < nodeMap.length; i++) {
          if (nodeMap[i] === partition2) {
            nodeMap[i] = partition1;
          }
        }
        
        return newEdges;
      };


      // Contracts a graph until we reach a certain number of meta nodes
      var contractUntil = function(metaNodeMap, 
                     remainingEdges,
                     size, 
                     sizeLimit) {
        // Stop condition
        if (size <= sizeLimit) {
          return remainingEdges;
        }
        
        // Choose an edge randomly
        var edgeIndex = Math.floor((Math.random() * remainingEdges.length));

        // Colapse graph based on edge
        var newEdges = colapse(edgeIndex, metaNodeMap, remainingEdges);
        
        return contractUntil(metaNodeMap, 
                   newEdges, 
                   size - 1, 
                   sizeLimit);        
      };


      // Parse options
      // debug - optional
      // if (options != null && options.debug != null) {
      //   var debug = options.debug;
      // } else {
      //   var debug = false;
      // }
      // logDebug("Starting kargerStein..."); 

      var cy = this._private.cy;
      var edges = this.edges().stdFilter(function(e){ return !e.isLoop(); });
      var nodes = this.nodes();
      var numNodes = nodes.length;
      var numEdges = edges.length;
      var numIter = Math.ceil(Math.pow(Math.log(numNodes) / Math.LN2, 2));
      var stopSize = Math.floor(numNodes / Math.sqrt(2));

      if (numNodes < 2) {
        $$.util.error("At least 2 nodes are required for KargerSteing algorithm!"); 
        return undefined;
      }

      // Create numerical identifiers for each node
      // mapping: node id -> position in nodes array
      // for reverse mapping, simply use nodes array
      var id2position = {};
      for (var i = 0; i < numNodes; i++) {
        id2position[nodes[i].id()] = i;
      }

      // Now store edge destination as indexes
      // Format for each edge (edge index, source node index, target node index)
      var edgeIndexes = [];
      for (var i = 0; i < numEdges; i++) {
        var e = edges[i];
        edgeIndexes.push([i, id2position[e.source().id()], id2position[e.target().id()]]);
      }

      // We will store the best cut found here
      var minCutSize = Infinity;
      var minCut;     

      // Initial meta node partition
      var originalMetaNode = [];
      for (var i = 0; i < numNodes; i++) {
        originalMetaNode.push(i);
      }

      // Main loop
      for (var iter = 0; iter <= numIter; iter++) {
        // Create new meta node partition
        var metaNodeMap = originalMetaNode.slice(0);

        // Contract until stop point (stopSize nodes)
        var edgesState = contractUntil(metaNodeMap, edgeIndexes, numNodes, stopSize);
        
        // Create a copy of the colapsed nodes state
        var metaNodeMap2 = metaNodeMap.slice(0);

        // Run 2 iterations starting in the stop state
        var res1 = contractUntil(metaNodeMap, edgesState, stopSize, 2);
        var res2 = contractUntil(metaNodeMap2, edgesState, stopSize, 2);

        // Is any of the 2 results the best cut so far?
        if (res1.length <= res2.length && res1.length < minCutSize) {
          minCutSize = res1.length;
          minCut = [res1, metaNodeMap];
        } else if (res2.length <= res1.length && res2.length < minCutSize) {
          minCutSize = res2.length;
          minCut = [res2, metaNodeMap2];
        }
      } // end of main loop

      
      // Construct result
      var resEdges = (minCut[0]).map(function(e){ return edges[e[0]]; });
      var partition1 = [];
      var partition2 = [];

      // traverse metaNodeMap for best cut
      var witnessNodePartition = minCut[1][0];
      for (var i = 0; i < minCut[1].length; i++) { 
        var partitionId = minCut[1][i]; 
        if (partitionId === witnessNodePartition) {
          partition1.push(nodes[i]);
        } else {
          partition2.push(nodes[i]);
        }       
      }
      
      var ret = {
        cut: new $$.Collection(cy, resEdges),
        partition1: new $$.Collection(cy, partition1),
        partition2: new $$.Collection(cy, partition2)
      };
      
      return ret;
    },


    // 
    // options => options object
    //   dampingFactor: optional
    //   precision: optional
    //   iterations : optional
    // retObj => returned object by function
    //  rank : function that returns the pageRank of a given node (object or selector string)
    pageRank: function(options) {
      options = options || {};
      
      var normalizeVector = function(vector) {
        var length = vector.length;

        // First, get sum of all elements
        var total = 0; 
        for (var i = 0; i < length; i++) {
          total += vector[i];
        }

        // Now, divide each by the sum of all elements
        for (var i = 0; i < length; i++) {
          vector[i] = vector[i] / total;
        }
      };
      
      // var logDebug = function() {
      //   if (debug) {
      //     console.log.apply(console, arguments);
      //   }
      // };
      
      // Parse options
      // debug - optional
      // if (options != null && 
      //   options.debug != null) {
      //   var debug = options.debug;
      // } else {
      //   var debug = false;
      // }
      // logDebug("Starting pageRank..."); 

      // dampingFactor - optional
      if (options != null && 
        options.dampingfactor != null) {
        var dampingFactor = options.dampingFactor;
      } else {
        var dampingFactor = 0.8; // Default damping factor
      }

      // desired precision - optional
      if (options != null && 
        options.precision != null) {
        var epsilon = options.precision;
      } else {
        var epsilon = 0.000001; // Default precision
      }

      // Max number of iterations - optional
      if (options != null && 
        options.iterations != null) {
        var numIter = options.iterations;
      } else {
        var numIter = 200; // Default number of iterations
      }

      // Weight function - optional
      if (options != null && 
        options.weight != null && 
        $$.is.fn(options.weight)) {       
        var weightFn = options.weight;
      } else {
        // If not specified, assume each edge has equal weight (1)
        var weightFn = function(e) {return 1;}; 
      }

      var cy = this._private.cy;
      var edges = this.edges().stdFilter(function(e){ return !e.isLoop(); });
      var nodes = this.nodes();
      var numNodes = nodes.length;
      var numEdges = edges.length;

      // Create numerical identifiers for each node
      // mapping: node id -> position in nodes array
      // for reverse mapping, simply use nodes array
      var id2position = {};
      for (var i = 0; i < numNodes; i++) {
        id2position[nodes[i].id()] = i;
      }

      // Construct transposed adjacency matrix
      // First lets have a zeroed matrix of the right size
      // We'll also keep track of the sum of each column
      var matrix = [];
      var columnSum = [];
      var additionalProb = (1 - dampingFactor) / numNodes;

      // Create null matric
      for (var i = 0; i < numNodes; i++) { 
        var newRow = [];
        for (var j = 0; j < numNodes; j++) {
          newRow.push(0.0);
        }
        matrix.push(newRow);
        columnSum.push(0.0);
      }

      // Now, process edges
      for (var i = 0; i < numEdges; i++) {
        var edge = edges[i];
        var s = id2position[edge.source().id()];
        var t = id2position[edge.target().id()];
        var w = weightFn.apply(edge, [edge]);
        
        // Update matrix
        matrix[t][s] += w;

        // Update column sum
        columnSum[s] += w; 
      }

      // Add additional probability based on damping factor
      // Also, take into account columns that have sum = 0
      var p = 1.0 / numNodes + additionalProb; // Shorthand
      // Traverse matrix, column by column
      for (var j = 0; j < numNodes; j++) { 
        if (columnSum[j] === 0) {
          // No 'links' out from node jth, assume equal probability for each possible node
          for (var i = 0; i < numNodes; i++) {
            matrix[i][j] = p;
          }
        } else {
          // Node jth has outgoing link, compute normalized probabilities
          for (var i = 0; i < numNodes; i++) {
            matrix[i][j] = matrix[i][j] / columnSum[j] + additionalProb;
          }         
        }
      }

      // Compute dominant eigenvector using power method
      var eigenvector = [];
      var nullVector = [];
      var previous;

      // Start with a vector of all 1's
      // Also, initialize a null vector which will be used as shorthand
      for (var i = 0; i < numNodes; i++) {
        eigenvector.push(1.0);
        nullVector.push(0.0);
      }
            
      for (var iter = 0; iter < numIter; iter++) {
        // New array with all 0's
        var temp = nullVector.slice(0);
        
        // Multiply matrix with previous result
        for (var i = 0; i < numNodes; i++) {
          for (var j = 0; j < numNodes; j++) {        
            temp[i] += matrix[i][j] * eigenvector[j];
          }
        }

        normalizeVector(temp);
        previous = eigenvector;
        eigenvector = temp;

        var diff = 0;
        // Compute difference (squared module) of both vectors
        for (var i = 0; i < numNodes; i++) {
          diff += Math.pow(previous[i] - eigenvector[i], 2);
        }
        
        // If difference is less than the desired threshold, stop iterating
        if (diff < epsilon) {
          // logDebug("Stoped at iteration %s", iter);
          break;
        }
      }
            
      // logDebug("Result:\n" + eigenvector);

      // Construct result
      var res = {
        rank : function(node) {
          if ($$.is.string(node)) {
            // is a selector string
            var nodeId = (cy.filter(node)[0]).id();
          } else {
            // is a node object
            var nodeId = node.id();
          }
          return eigenvector[id2position[nodeId]];
        }
      };


      return res;
    }, // pageRank


    // options => options object
    //   weight: function( edge ){} // specifies weight to use for `edge`/`this`. If not present, it will be asumed a weight of 1 for all edges
    //   directed // default false
    // retObj => returned object by function
    // if directed
    //   indegree : function(node) // Returns the normalized indegree of the given node
    //   outdegree: function(node) // Returns the normalized outdegree of the given node
    // if undirected
    //   degree : function(node) // Returns the normalized degree of the given node
    degreeCentralityNormalized: function (options) {
      options = options || {};

      // var logDebug = function () {
      //   if (debug) {
      //     console.log.apply(console, arguments);
      //   }
      // };

      // Parse options
      // debug - optional
      // if (options.debug != null) {
      //   var debug = options.debug;
      // } else {
      //   var debug = false;
      // }

      // directed - optional
      if (options.directed != null) {
        var directed = options.directed;
      } else {
        var directed = false;
      }

      // logDebug("Starting degree centrality...");
      var nodes = this.nodes();
      var numNodes = nodes.length;

      if (!directed) {
        var degrees = {};
        var maxDegree = 0;

        for (var i = 0; i < numNodes; i++) {
          var node = nodes[i];
          // add current node to the current options object and call degreeCentrality 
          var currDegree = this.degreeCentrality($$.util.extend({}, options, {root: node}));
          if (maxDegree < currDegree.degree)
            maxDegree = currDegree.degree;

          degrees[node.id()] = currDegree.degree;
        }

        return {
          degree: function (node) {
            if ($$.is.string(node)) {
              // from is a selector string
              var node = (cy.filter(node)[0]).id();
            } else {
              // from is a node
              var node = node.id();
            }

            return degrees[node] / maxDegree;
          }
        };
      } else {
        var indegrees = {};
        var outdegrees = {};
        var maxIndegree = 0;
        var maxOutdegree = 0;

        for (var i = 0; i < numNodes; i++) {
          var node = nodes[i];
          // add current node to the current options object and call degreeCentrality 
          var currDegree = this.degreeCentrality($$.util.extend({}, options, {root: node}));

          if (maxIndegree < currDegree.indegree)
            maxIndegree = currDegree.indegree;

          if (maxOutdegree < currDegree.outdegree)
            maxOutdegree = currDegree.outdegree;

          indegrees[node.id()] = currDegree.indegree;
          outdegrees[node.id()] = currDegree.outdegree;
        }

        return {
          indegree: function (node) {
            if ($$.is.string(node)) {
              // from is a selector string
              var node = (cy.filter(node)[0]).id();
            } else {
              // from is a node
              var node = node.id();
            }

            return indegrees[node] / maxIndegree;
          },
          outdegree: function (node) {
            if ($$.is.string(node)) {
              // from is a selector string
              var node = (cy.filter(node)[0]).id();
            } else {
              // from is a node
              var node = node.id();
            }

            return outdegrees[node] / maxOutdegree;
          }

        };
      }

    }, // degreeCentralityNormalized

    // Implemented from the algorithm in Opsahl's paper "Node centrality in weighted networks: Generalizing degree and shortest paths" check the heading 2 "Degree"
    // options => options object
    //   node : focal node
    //   weight: function( edge ){} // specifies weight to use for `edge`/`this`. If not present, it will be asumed a weight of 1 for all edges
    //   alpha : alpha value for the algorithm (Benchmark values of alpha: 0 -> disregards the weights focuses on number of edges
    //                                                                     1 -> disregards the number of edges focuses on total amount of weight 
    //   directed // default false
    // retObj => returned object by function
    // if directed
    //   indegree : indegree of the given node
    //   outdegree: outdegree of the given node
    // if undirected
    //   degree : degree of the given node
    degreeCentrality: function (options) {
      options = options || {};

      var callingEles = this;

      // var logDebug = function () {
      //   if (debug) {
      //     console.log.apply(console, arguments);
      //   }
      // };

      // Parse options
      // debug - optional
      // if (options.debug != null) {
      //   var debug = options.debug;
      // } else {
      //   var debug = false;
      // }

      // logDebug("Starting degree centrality...");

      // root - mandatory!
      if (options != null && options.root != null) {
        var root = $$.is.string(options.root) ? this.filter(options.root)[0] : options.root[0];
        // logDebug("Source node: %s", root.id());
      } else {
        return undefined;
      }

      // weight - optional
      if (options.weight != null && $$.is.fn(options.weight)) {
        var weightFn = options.weight;
      } else {
        // If not specified, assume each edge has equal weight (1)
        var weightFn = function (e) {
          return 1;
        };
      }

      // directed - optional
      if (options.directed != null) {
        var directed = options.directed;
      } else {
        var directed = false;
      }

      // alpha - optional
      if (options.alpha != null && $$.is.number(options.alpha)) {
        var alpha = options.alpha;
      } else {
        alpha = 0;
      }


      if (!directed) {
        var connEdges = root.connectedEdges().intersection( callingEles );
        var k = connEdges.length;
        var s = 0;

        // Now, sum edge weights
        for (var i = 0; i < connEdges.length; i++) {
          var edge = connEdges[i];
          s += weightFn.apply(edge, [edge]);
        }

        return {
          degree: Math.pow(k, 1 - alpha) * Math.pow(s, alpha)
        };
      } else {
        var incoming = root.connectedEdges('edge[target = "' + root.id() + '"]').intersection( callingEles );
        var outgoing = root.connectedEdges('edge[source = "' + root.id() + '"]').intersection( callingEles );
        var k_in = incoming.length;
        var k_out = outgoing.length;
        var s_in = 0;
        var s_out = 0;

        // Now, sum incoming edge weights
        for (var i = 0; i < incoming.length; i++) {
          var edge = incoming[i];
          s_in += weightFn.apply(edge, [edge]);
        }

        // Now, sum outgoing edge weights
        for (var i = 0; i < outgoing.length; i++) {
          var edge = outgoing[i];
          s_out += weightFn.apply(edge, [edge]);
        }

        return {
          indegree: Math.pow(k_in, 1 - alpha) * Math.pow(s_in, alpha),
          outdegree: Math.pow(k_out, 1 - alpha) * Math.pow(s_out, alpha)
        };
      }
    }, // degreeCentrality

    // options => options object
    //   weight: function( edge ){} // specifies weight to use for `edge`/`this`. If not present, it will be asumed a weight of 1 for all edges
    //   directed // default false
    //   harmonic // use harmonic mean instead of arithmetic mean
    // retObj => returned object by function
    //   closeness : function(node) // Returns the normalized closeness of the given node
    closenessCentralityNormalized: function (options) {
      options = options || {};

      // var logDebug = function () {
      //   if (debug) {
      //     console.log.apply(console, arguments);
      //   }
      // };

      // Parse options
      // debug - optional
      // if (options.debug != null) {
      //   var debug = options.debug;
      // } else {
      //   var debug = false;
      // }

      // logDebug("Starting closeness centrality...");

      var harmonic = options.harmonic;
      if( harmonic === undefined ){
        harmonic = true;
      }
 
      var closenesses = {};
      var maxCloseness = 0;
      var nodes = this.nodes();
      var fw = this.floydWarshall({ weight: options.weight, directed: options.directed });

      // Compute closeness for every node and find the maximum closeness
      for(var i = 0; i < nodes.length; i++){
        var currCloseness = 0;
        for (var j = 0; j < nodes.length; j++) {
          if (i != j) {
            var d = fw.distance(nodes[i], nodes[j]);
            
            if( harmonic ){
              currCloseness += 1 / d;
            } else {
              currCloseness += d;
            }
          }
        }
        
        if( !harmonic ){
          currCloseness = 1 / currCloseness;
        }

        if (maxCloseness < currCloseness){
          maxCloseness = currCloseness;
        }

        closenesses[nodes[i].id()] = currCloseness;
      }

      return {
        closeness: function (node) {
          if ($$.is.string(node)) {
            // from is a selector string
            var node = (cy.filter(node)[0]).id();
          } else {
            // from is a node
            var node = node.id();
          }

          return closenesses[node] / maxCloseness;
        }
      };
    },
    // Implemented from pseudocode from wikipedia
    // options => options object
    //   root : focal node
    //   weight: function( edge ){} // specifies weight to use for `edge`/`this`. If not present, it will be asumed a weight of 1 for all edges
    //   directed // default false
    // closeness => returned value by the function. Closeness value of the given node.
    closenessCentrality: function (options) {
      options = options || {};

      // var logDebug = function () {
      //   if (debug) {
      //     console.log.apply(console, arguments);
      //   }
      // };

      // Parse options
      // debug - optional
      // if (options.debug != null) {
      //   var debug = options.debug;
      // } else {
      //   var debug = false;
      // }

      // logDebug("Starting closeness centrality...");

      // root - mandatory!
      if (options.root != null) {
        if ($$.is.string(options.root)) {
          // use it as a selector, e.g. "#rootID
          var root = this.filter(options.root)[0];
        } else {
          var root = options.root[0];
        }
        // logDebug("Source node: %s", root.id());
      } else {
        $$.util.error("options.root required");
        return undefined;
      }

      // weight - optional
      if (options.weight != null && $$.is.fn(options.weight)) {
        var weight = options.weight;
      } else {
        var weight = function(){return 1;};
      }

      // directed - optional
      if (options.directed != null && $$.is.bool(options.directed)) {
        var directed = options.directed;
      } else {
        var directed = false;
      }
      
      var harmonic = options.harmonic;
      if( harmonic === undefined ){
        harmonic = true;
      }

      // we need distance from this node to every other node
      var dijkstra = this.dijkstra({
        root: root,
        weight: weight,
        directed: directed
      });
      var totalDistance = 0;

      var nodes = this.nodes();
      for (var i = 0; i < nodes.length; i++){
        if (nodes[i].id() != root.id()){
          var d = dijkstra.distanceTo(nodes[i]);
          
          if( harmonic ){
            totalDistance += 1 / d; 
          } else {
            totalDistance += d;
          }
        }
      }

      return harmonic ? totalDistance : 1 / totalDistance;
    }, // closenessCentrality

    // Implemented from the algorithm in the paper "On Variants of Shortest-Path Betweenness Centrality and their Generic Computation" by Ulrik Brandes
    // options => options object
    //   weight: function( edge ){} // specifies weight to use for `edge`/`this`. If not present, it will be asumed a weight of 1 for all edges
    //   directed // default false
    // retObj => returned object by function
    //   betweenness : function(node) // Returns the betweenness centrality of the given node
    //   betweennessNormalized : function(node) // Returns the normalized betweenness centrality of the given node
    betweennessCentrality: function (options) {
      options = options || {};

      // var logDebug = function () {
      //   if (debug) {
      //     console.log.apply(console, arguments);
      //   }
      // };

      // Parse options
      // debug - optional
      // if (options.debug != null) {
      //   var debug = options.debug;
      // } else {
      //   var debug = false;
      // }

      // logDebug("Starting betweenness centrality...");

      // Weight - optional
      if (options.weight != null && $$.is.fn(options.weight)) {
        var weightFn = options.weight;
        var weighted = true;
      } else {
        var weighted = false;
      }

      // Directed - default false
      if (options.directed != null && $$.is.bool(options.directed)) {
        var directed = options.directed;
      } else {
        var directed = false;
      }

      var priorityInsert = function (queue, ele) {
        queue.unshift(ele);
        for (var i = 0; d[queue[i]] < d[queue[i + 1]] && i < queue.length - 1; i++) {
          var tmp = queue[i];
          queue[i] = queue[i + 1];
          queue[i + 1] = tmp;
        }
      };

      var cy = this._private.cy;

      // starting
      var V = this.nodes();
      var A = {};
      var C = {};

      // A contains the neighborhoods of every node
      for (var i = 0; i < V.length; i++) {
        if (directed) {
          A[V[i].id()] = V[i].outgoers("node"); // get outgoers of every node
        } else {
          A[V[i].id()] = V[i].openNeighborhood("node"); // get neighbors of every node          
        }
      }

      // C contains the betweenness values
      for (var i = 0; i < V.length; i++) {
        C[V[i].id()] = 0;
      }

      for (var s = 0; s < V.length; s++) {
        var S = []; // stack
        var P = {};
        var g = {};
        var d = {};
        var Q = []; // queue

        // init dictionaries
        for (var i = 0; i < V.length; i++) {
          P[V[i].id()] = [];
          g[V[i].id()] = 0;
          d[V[i].id()] = Number.POSITIVE_INFINITY;
        }

        g[V[s].id()] = 1; // sigma
        d[V[s].id()] = 0; // distance to s

        Q.unshift(V[s].id());

        while (Q.length > 0) {
          var v = Q.pop();
          S.push(v);
          if (weighted) {
            A[v].forEach(function (w) {
              if (cy.$('#' + v).edgesTo(w).length > 0) {
                var edge = cy.$('#' + v).edgesTo(w)[0];
              } else {
                var edge = w.edgesTo('#' + v)[0];
              }
              
              var edgeWeight = weightFn.apply(edge, [edge]);

              if (d[w.id()] > d[v] + edgeWeight) {
                d[w.id()] = d[v] + edgeWeight;
                if (Q.indexOf(w.id()) < 0) { //if w is not in Q
                  priorityInsert(Q, w.id());
                } else { // update position if w is in Q
                  Q.splice(Q.indexOf(w.id()), 1);
                  priorityInsert(Q, w.id());
                }
                g[w.id()] = 0;
                P[w.id()] = [];
              }
              if (d[w.id()] == d[v] + edgeWeight) {
                g[w.id()] = g[w.id()] + g[v];
                P[w.id()].push(v);
              }
            });
          } else {
            A[v].forEach(function (w) {
              if (d[w.id()] == Number.POSITIVE_INFINITY) {
                Q.unshift(w.id());
                d[w.id()] = d[v] + 1;
              }
              if (d[w.id()] == d[v] + 1) {
                g[w.id()] = g[w.id()] + g[v];
                P[w.id()].push(v);
              }
            });
          }
        }

        var e = {};
        for (var i = 0; i < V.length; i++) {
          e[V[i].id()] = 0;
        }

        while (S.length > 0) {
          var w = S.pop();
          P[w].forEach(function (v) {
            e[v] = e[v] + (g[v] / g[w]) * (1 + e[w]);
            if (w != V[s].id())
              C[w] = C[w] + e[w];
          });
        }
      }

      var max = 0;
      for (var key in C) {
        if (max < C[key])
          max = C[key];
      }

      var ret = {
        betweenness: function (node) {
          if ($$.is.string(node)) {
            var node = (cy.filter(node)[0]).id();
          } else {
            var node = node.id();
          }

          return C[node];
        },

        betweennessNormalized: function (node) {
          if ($$.is.string(node)) {
            var node = (cy.filter(node)[0]).id();
          } else {
            var node = node.id();
          }

          return C[node] / max;
        }
      };

      // alias
      ret.betweennessNormalised = ret.betweennessNormalized;

      return ret;
    } // betweennessCentrality
  }); // $$.fn.eles

  // nice, short mathemathical alias
  $$.elesfn.dc = $$.elesfn.degreeCentrality;
  $$.elesfn.dcn = $$.elesfn.degreeCentralityNormalised = $$.elesfn.degreeCentralityNormalized;
  $$.elesfn.cc = $$.elesfn.closenessCentrality;
  $$.elesfn.ccn = $$.elesfn.closenessCentralityNormalised = $$.elesfn.closenessCentralityNormalized;
  $$.elesfn.bc = $$.elesfn.betweennessCentrality;
}) (cytoscape);

;(function( $$ ){ 'use strict';

  $$.fn.eles({
    animated: $$.define.animated(),
    clearQueue: $$.define.clearQueue(),
    delay: $$.define.delay(),
    animate: $$.define.animate(),
    stop: $$.define.stop()
  });
  
})( cytoscape );  

;(function( $$ ){ 'use strict';
  
  $$.fn.eles({
    addClass: function(classes){
      classes = classes.split(/\s+/);
      var self = this;
      var changed = [];
      
      for( var i = 0; i < classes.length; i++ ){
        var cls = classes[i];
        if( $$.is.emptyString(cls) ){ continue; }
        
        for( var j = 0; j < self.length; j++ ){
          var ele = self[j];
          var hasClass = ele._private.classes[cls];
          ele._private.classes[cls] = true;

          if( !hasClass ){ // if didn't already have, add to list of changed
            changed.push( ele );
          }
        }
      }
      
      // trigger update style on those eles that had class changes
      if( changed.length > 0 ){
        new $$.Collection(this._private.cy, changed)
          .updateStyle()
          .trigger('class')
        ;
      }

      return self;
    },

    hasClass: function(className){
      var ele = this[0];
      return ( ele != null && ele._private.classes[className] ) ? true : false;
    },

    toggleClass: function(classesStr, toggle){
      var classes = classesStr.split(/\s+/);
      var self = this;
      var changed = []; // eles who had classes changed
      
      for( var i = 0, il = self.length; i < il; i++ ){
        var ele = self[i];

        for( var j = 0; j < classes.length; j++ ){
          var cls = classes[j];

          if( $$.is.emptyString(cls) ){ continue; }
          
          var hasClass = ele._private.classes[cls];
          var shouldAdd = toggle || (toggle === undefined && !hasClass);

          if( shouldAdd ){
            ele._private.classes[cls] = true;

            if( !hasClass ){ changed.push(ele); }
          } else { // then remove
            ele._private.classes[cls] = false;

            if( hasClass ){ changed.push(ele); }
          }

        } // for j classes
      } // for i eles
      
      // trigger update style on those eles that had class changes
      if( changed.length > 0 ){
        new $$.Collection(this._private.cy, changed)
          .updateStyle()
          .trigger('class')
        ;
      }

      return self;
    },

    removeClass: function(classes){
      classes = classes.split(/\s+/);
      var self = this;
      var changed = [];

      for( var i = 0; i < self.length; i++ ){
        var ele = self[i];

        for( var j = 0; j < classes.length; j++ ){
          var cls = classes[j];
          if( !cls || cls === '' ){ continue; }

          var hasClass = ele._private.classes[cls];
          ele._private.classes[cls] = undefined;

          if( hasClass ){ // then we changed its set of classes
            changed.push( ele );
          }
        }
      }
      
      // trigger update style on those eles that had class changes
      if( changed.length > 0 ){
        new $$.Collection(self._private.cy, changed).updateStyle();
      }

      self.trigger('class');
      return self;
    },

    flashClass: function(classes, duration){
      var self = this;

      if( duration == null ){
        duration = 250;
      } else if( duration === 0 ){
        return self; // nothing to do really
      }

      self.addClass( classes );
      setTimeout(function(){
        self.removeClass( classes );
      }, duration);

      return self;
    }
  });
  
})( cytoscape );

;(function($$){ 'use strict';

  $$.fn.eles({
    allAre: function( selector ){
      return this.filter(selector).length === this.length;
    },

    is: function( selector ){
      return this.filter(selector).length > 0;
    },

    some: function( fn, thisArg ){
      for( var i = 0; i < this.length; i++ ){
        var ret = !thisArg ? fn( this[i], i, this ) : fn.apply( thisArg, [ this[i], i, this ] );

        if( ret ){
          return true;
        }
      }

      return false;
    },

    every: function( fn, thisArg ){
      for( var i = 0; i < this.length; i++ ){
        var ret = !thisArg ? fn( this[i], i, this ) : fn.apply( thisArg, [ this[i], i, this ] );

        if( !ret ){
          return false;
        }
      }

      return true;
    },

    same: function( collection ){
      collection = this.cy().collection( collection );

      // cheap extra check
      if( this.length !== collection.length ){
        return false;
      }

      return this.intersect( collection ).length === this.length;
    },

    anySame: function( collection ){
      collection = this.cy().collection( collection );

      return this.intersect( collection ).length > 0;
    },

    allAreNeighbors: function( collection ){
      collection = this.cy().collection( collection );

      return this.neighborhood().intersect( collection ).length === collection.length;
    }
  });

  $$.elesfn.allAreNeighbours = $$.elesfn.allAreNeighbors;
  
})( cytoscape );

;(function($$){ 'use strict';

  // Compound functions
  /////////////////////

  $$.fn.eles({
    parent: function( selector ){
      var parents = [];
      var cy = this._private.cy;

      for( var i = 0; i < this.length; i++ ){
        var ele = this[i];
        var parent = cy.getElementById( ele._private.data.parent );

        if( parent.size() > 0 ){
          parents.push( parent );
        }
      }
      
      return new $$.Collection( cy, parents, { unique: true } ).filter( selector );
    },

    parents: function( selector ){
      var parents = [];

      var eles = this.parent();
      while( eles.nonempty() ){
        for( var i = 0; i < eles.length; i++ ){
          var ele = eles[i];
          parents.push( ele );
        }

        eles = eles.parent();
      }

      return new $$.Collection( this.cy(), parents, { unique: true } ).filter( selector );
    },

    commonAncestors: function( selector ){
      var ancestors;

      for( var i = 0; i < this.length; i++ ){
        var ele = this[i];
        var parents = ele.parents();
        
        ancestors = ancestors || parents;

        ancestors = ancestors.intersect( parents ); // current list must be common with current ele parents set
      }

      return ancestors.filter( selector );
    },

    orphans: function( selector ){
      return this.stdFilter(function( ele ){
        return ele.isNode() && ele.parent().empty();
      }).filter( selector );
    },

    nonorphans: function( selector ){
      return this.stdFilter(function( ele ){
        return ele.isNode() && ele.parent().nonempty();
      }).filter( selector );
    },

    children: function( selector ){
      var children = [];

      for( var i = 0; i < this.length; i++ ){
        var ele = this[i];
        children = children.concat( ele._private.children );
      }

      return new $$.Collection( this.cy(), children, { unique: true } ).filter( selector );
    },

    siblings: function( selector ){
      return this.parent().children().not( this ).filter( selector );
    },

    isParent: function(){
      var ele = this[0];

      if( ele ){
        return ele._private.children.length !== 0;
      }
    },

    isChild: function(){
      var ele = this[0];

      if( ele ){
        return ele._private.data.parent !== undefined && ele.parent().length !== 0;
      }
    },

    descendants: function( selector ){
      var elements = [];

      function add( eles ){
        for( var i = 0; i < eles.length; i++ ){
          var ele = eles[i];

          elements.push( ele );

          if( ele.children().nonempty() ){
            add( ele.children() );
          }
        }
      }

      add( this.children() );

      return new $$.Collection( this.cy(), elements, { unique: true } ).filter( selector );
    }
  });

  // aliases
  $$.elesfn.ancestors = $$.elesfn.parents;
  
})( cytoscape );
;(function($$){ 'use strict';

  var borderWidthMultiplier = 2 * 0.5;
  var borderWidthAdjustment = 0;

  $$.fn.eles({

    data: $$.define.data({
      field: 'data',
      bindingEvent: 'data',
      allowBinding: true,
      allowSetting: true,
      settingEvent: 'data',
      settingTriggersEvent: true,
      triggerFnName: 'trigger',
      allowGetting: true,
      immutableKeys: {
        'id': true,
        'source': true,
        'target': true,
        'parent': true
      },
      updateStyle: true
    }),

    removeData: $$.define.removeData({
      field: 'data',
      event: 'data',
      triggerFnName: 'trigger',
      triggerEvent: true,
      immutableKeys: {
        'id': true,
        'source': true,
        'target': true,
        'parent': true
      },
      updateStyle: true
    }),

    scratch: $$.define.data({
      field: 'scratch',
      bindingEvent: 'scratch',
      allowBinding: true,
      allowSetting: true,
      settingEvent: 'scratch',
      settingTriggersEvent: true,
      triggerFnName: 'trigger',
      allowGetting: true,
      updateStyle: true
    }),

    removeScratch: $$.define.removeData({
      field: 'scratch',
      event: 'scratch',
      triggerFnName: 'trigger',
      triggerEvent: true,
      updateStyle: true
    }),

    rscratch: $$.define.data({
      field: 'rscratch',
      allowBinding: false,
      allowSetting: true,
      settingTriggersEvent: false,
      allowGetting: true
    }),

    removeRscratch: $$.define.removeData({
      field: 'rscratch',
      triggerEvent: false
    }),

    id: function(){
      var ele = this[0];

      if( ele ){
        return ele._private.data.id;
      }
    },

    position: $$.define.data({
      field: 'position',
      bindingEvent: 'position',
      allowBinding: true,
      allowSetting: true,
      settingEvent: 'position',
      settingTriggersEvent: true,
      triggerFnName: 'rtrigger',
      allowGetting: true,
      validKeys: ['x', 'y'],
      onSet: function( eles ){
        var updatedEles = eles.updateCompoundBounds();
        updatedEles.rtrigger('position');
      },
      canSet: function( ele ){
        return !ele.locked();
      }
    }),

    // position but no notification to renderer
    silentPosition: $$.define.data({
      field: 'position',
      bindingEvent: 'position',
      allowBinding: false,
      allowSetting: true,
      settingEvent: 'position',
      settingTriggersEvent: false,
      triggerFnName: 'trigger',
      allowGetting: true,
      validKeys: ['x', 'y'],
      onSet: function( eles ){
        eles.updateCompoundBounds();
      },
      canSet: function( ele ){
        return !ele.locked();
      }
    }),

    positions: function( pos, silent ){
      if( $$.is.plainObject(pos) ){
        this.position(pos);

      } else if( $$.is.fn(pos) ){
        var fn = pos;

        for( var i = 0; i < this.length; i++ ){
          var ele = this[i];

          var pos = fn.apply(ele, [i, ele]);

          if( pos && !ele.locked() ){
            var elePos = ele._private.position;
            elePos.x = pos.x;
            elePos.y = pos.y;
          }
        }

        var updatedEles = this.updateCompoundBounds();
        var toTrigger = updatedEles.length > 0 ? this.add( updatedEles ) : this;

        if( silent ){
          toTrigger.trigger('position');
        } else {
          toTrigger.rtrigger('position');
        }
      }

      return this; // chaining
    },

    silentPositions: function( pos ){
      return this.positions( pos, true );
    },

    updateCompoundBounds: function(){
      var cy = this.cy();

      if( !cy.styleEnabled() || !cy.hasCompoundNodes() ){ return cy.collection(); } // save cycles for non compound graphs or when style disabled

      var updated = [];

      function update( parent ){
        var children = parent.children();
        var style = parent._private.style;
        var includeLabels = style['compound-sizing-wrt-labels'].value === 'include';
        var bb = children.boundingBox({ includeLabels: includeLabels, includeEdges: true });
        var padding = {
          top: style['padding-top'].pxValue,
          bottom: style['padding-bottom'].pxValue,
          left: style['padding-left'].pxValue,
          right: style['padding-right'].pxValue
        };
        var pos = parent._private.position;
        var didUpdate = false;

        if( style['width'].value === 'auto' ){
          parent._private.autoWidth = bb.w + padding.left + padding.right;
          pos.x = (bb.x1 + bb.x2 - padding.left + padding.right)/2;
          didUpdate = true;
        }

        if( style['height'].value === 'auto' ){
          parent._private.autoHeight = bb.h + padding.top + padding.bottom;
          pos.y = (bb.y1 + bb.y2 - padding.top + padding.bottom)/2;
          didUpdate = true;
        }

        if( didUpdate ){
          updated.push( parent );
        }
      }

      // go up, level by level
      var eles = this.parent();
      while( eles.nonempty() ){

        // update each parent node in this level
        for( var i = 0; i < eles.length; i++ ){
          var ele = eles[i];

          update( ele );
        }

        // next level
        eles = eles.parent();
      }

      // return changed
      return new $$.Collection( cy, updated );
    },

    // get/set the rendered (i.e. on screen) positon of the element
    renderedPosition: function( dim, val ){
      var ele = this[0];
      var cy = this.cy();
      var zoom = cy.zoom();
      var pan = cy.pan();
      var rpos = $$.is.plainObject( dim ) ? dim : undefined;
      var setting = rpos !== undefined || ( val !== undefined && $$.is.string(dim) );

      if( ele && ele.isNode() ){ // must have an element and must be a node to return position
        if( setting ){
          for( var i = 0; i < this.length; i++ ){
            var ele = this[i];

            if( val !== undefined ){ // set one dimension
              ele._private.position[dim] = ( val - pan[dim] )/zoom;
            } else if( rpos !== undefined ){ // set whole position
              ele._private.position = {
                x: ( rpos.x - pan.x ) /zoom,
                y: ( rpos.y - pan.y ) /zoom
              };
            }
          }

          this.rtrigger('position');
        } else { // getting
          var pos = ele._private.position;
          rpos = {
            x: pos.x * zoom + pan.x,
            y: pos.y * zoom + pan.y
          };

          if( dim === undefined ){ // then return the whole rendered position
            return rpos;
          } else { // then return the specified dimension
            return rpos[ dim ];
          }
        }
      } else if( !setting ){
        return undefined; // for empty collection case
      }

      return this; // chaining
    },

    // get/set the position relative to the parent
    relativePosition: function( dim, val ){
      var ele = this[0];
      var cy = this.cy();
      var ppos = $$.is.plainObject( dim ) ? dim : undefined;
      var setting = ppos !== undefined || ( val !== undefined && $$.is.string(dim) );
      var hasCompoundNodes = cy.hasCompoundNodes();

      if( ele && ele.isNode() ){ // must have an element and must be a node to return position
        if( setting ){
          for( var i = 0; i < this.length; i++ ){
            var ele = this[i];
            var parent = hasCompoundNodes ? ele.parent() : null;
            var hasParent = parent && parent.length > 0;
            var relativeToParent = hasParent;

            if( hasParent ){
              parent = parent[0];
            }

            var origin = relativeToParent ? parent._private.position : { x: 0, y: 0 };

            if( val !== undefined ){ // set one dimension
              ele._private.position[dim] = val + origin[dim];
            } else if( ppos !== undefined ){ // set whole position
              ele._private.position = {
                x: ppos.x + origin.x,
                y: ppos.y + origin.y,
              };
            }
          }

          this.rtrigger('position');

        } else { // getting
          var pos = ele._private.position;
          var parent = hasCompoundNodes ? ele.parent() : null;
          var hasParent = parent && parent.length > 0;
          var relativeToParent = hasParent;

          if( hasParent ){
            parent = parent[0];
          }

          var origin = relativeToParent ? parent._private.position : { x: 0, y: 0 };

          ppos = {
            x: pos.x - origin.x,
            y: pos.y - origin.y
          };

          if( dim === undefined ){ // then return the whole rendered position
            return ppos;
          } else { // then return the specified dimension
            return ppos[ dim ];
          }
        }
      } else if( !setting ){
        return undefined; // for empty collection case
      }

      return this; // chaining
    },

    // convenience function to get a numerical value for the width of the node/edge
    width: function(){
      var ele = this[0];
      var cy = ele._private.cy;
      var styleEnabled = cy._private.styleEnabled;

      if( ele ){
        if( styleEnabled ){
          var w = ele._private.style.width;
          return w.strValue === 'auto' ? ele._private.autoWidth : w.pxValue;
        } else {
          return 1;
        }
      }
    },

    outerWidth: function(){
      var ele = this[0];
      var cy = ele._private.cy;
      var styleEnabled = cy._private.styleEnabled;

      if( ele ){
        if( styleEnabled ){
          var style = ele._private.style;
          var width = style.width.strValue === 'auto' ? ele._private.autoWidth : style.width.pxValue;
          var border = style['border-width'] ? style['border-width'].pxValue * borderWidthMultiplier + borderWidthAdjustment : 0;

          return width + border;
        } else {
          return 1;
        }
      }
    },

    renderedWidth: function(){
      var ele = this[0];

      if( ele ){
        var width = ele.width();
        return width * this.cy().zoom();
      }
    },

    renderedOuterWidth: function(){
      var ele = this[0];

      if( ele ){
        var owidth = ele.outerWidth();
        return owidth * this.cy().zoom();
      }
    },

    // convenience function to get a numerical value for the height of the node
    height: function(){
      var ele = this[0];
      var cy = ele._private.cy;
      var styleEnabled = cy._private.styleEnabled;

      if( ele && ele._private.group === 'nodes' ){
        if( styleEnabled ){
          var h = ele._private.style.height;
          return h.strValue === 'auto' ? ele._private.autoHeight : h.pxValue;
        } else {
          return 1;
        }
      }
    },

    outerHeight: function(){
      var ele = this[0];
      var cy = ele._private.cy;
      var styleEnabled = cy._private.styleEnabled;

      if( ele && ele._private.group === 'nodes' ){
        if( styleEnabled ){
          var style = ele._private.style;
          var height = style.height.strValue === 'auto' ? ele._private.autoHeight : style.height.pxValue;
          var border = style['border-width'] ? style['border-width'].pxValue * borderWidthMultiplier + borderWidthAdjustment : 0;
        } else {
          return 1;
        }

        return height + border;
      }
    },

    renderedHeight: function(){
      var ele = this[0];

      if( ele && ele._private.group === 'nodes' ){
        var height = ele.height();
        return height * this.cy().zoom();
      }
    },

    renderedOuterHeight: function(){
      var ele = this[0];

      if( ele && ele._private.group === 'nodes' ){
        var oheight = ele.outerHeight();
        return oheight * this.cy().zoom();
      }
    },

    renderedBoundingBox: function( options ){
      var bb = this.boundingBox( options );
      var cy = this.cy();
      var zoom = cy.zoom();
      var pan = cy.pan();

      var x1 = bb.x1 * zoom + pan.x;
      var x2 = bb.x2 * zoom + pan.x;
      var y1 = bb.y1 * zoom + pan.y;
      var y2 = bb.y2 * zoom + pan.y;

      return {
        x1: x1,
        x2: x2,
        y1: y1,
        y2: y2,
        w: x2 - x1,
        h: y2 - y1
      };
    },

    // get the bounding box of the elements (in raw model position)
    boundingBox: function( options ){
      var eles = this;
      var cy = eles._private.cy;
      var cy_p = cy._private;
      var styleEnabled = cy_p.styleEnabled;

      options = options || {};

      var includeNodes = options.includeNodes === undefined ? true : options.includeNodes;
      var includeEdges = options.includeEdges === undefined ? true : options.includeEdges;
      var includeLabels = options.includeLabels === undefined ? true : options.includeLabels;

      // recalculate projections etc
      if( styleEnabled ){
        cy_p.renderer.recalculateRenderedStyle( this );
      }

      var x1 = Infinity;
      var x2 = -Infinity;
      var y1 = Infinity;
      var y2 = -Infinity;

      // find bounds of elements
      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        var _p = ele._private;
        var style = _p.style;
        var display = styleEnabled ? _p.style['display'].value : 'element';
        var isNode = _p.group === 'nodes';
        var ex1, ex2, ey1, ey2, x, y;
        var includedEle = false;

        if( display === 'none' ){ continue; } // then ele doesn't take up space

        if( isNode && includeNodes ){
          includedEle = true;

          var pos = _p.position;
          x = pos.x;
          y = pos.y;
          var w = ele.outerWidth();
          var halfW = w/2;
          var h = ele.outerHeight();
          var halfH = h/2;

          // handle node dimensions
          /////////////////////////

          ex1 = x - halfW;
          ex2 = x + halfW;
          ey1 = y - halfH;
          ey2 = y + halfH;

          x1 = ex1 < x1 ? ex1 : x1;
          x2 = ex2 > x2 ? ex2 : x2;
          y1 = ey1 < y1 ? ey1 : y1;
          y2 = ey2 > y2 ? ey2 : y2;

        } else if( ele.isEdge() && includeEdges ){
          includedEle = true;

          var n1 = _p.source;
          var n1_p = n1._private;
          var n1pos = n1_p.position;
          
          var n2 = _p.target;
          var n2_p = n2._private;
          var n2pos = n2_p.position;
          

          // handle edge dimensions (rough box estimate)
          //////////////////////////////////////////////

          var rstyle = _p.rstyle || {};

          ex1 = n1pos.x;
          ex2 = n2pos.x;
          ey1 = n1pos.y;
          ey2 = n2pos.y;
          
          if( ex1 > ex2 ){
            var temp = ex1;
            ex1 = ex2;
            ex2 = temp;
          }

          if( ey1 > ey2 ){
            var temp = ey1;
            ey1 = ey2;
            ey2 = temp;
          }

          x1 = ex1 < x1 ? ex1 : x1;
          x2 = ex2 > x2 ? ex2 : x2;
          y1 = ey1 < y1 ? ey1 : y1;
          y2 = ey2 > y2 ? ey2 : y2;

          // handle points along edge (sanity check)
          //////////////////////////////////////////

          if( styleEnabled ){
            var bpts = rstyle.bezierPts || [];

            var w = style['width'].pxValue;
            var wHalf = w/2;

            for( var j = 0; j < bpts.length; j++ ){
              var bpt = bpts[j];

              ex1 = bpt.x - wHalf;
              ex2 = bpt.x + wHalf;
              ey1 = bpt.y - wHalf;
              ey2 = bpt.y + wHalf;

              x1 = ex1 < x1 ? ex1 : x1;
              x2 = ex2 > x2 ? ex2 : x2;
              y1 = ey1 < y1 ? ey1 : y1;
              y2 = ey2 > y2 ? ey2 : y2;
            }
          }
          
          // precise haystacks (sanity check)
          ///////////////////////////////////
          
          if( styleEnabled && style['curve-style'].strValue === 'haystack' ){
            var hpts = _p.rscratch.haystackPts;
            
            ex1 = hpts[0];
            ey1 = hpts[1];
            ex2 = hpts[2];
            ey2 = hpts[3];

            if( ex1 > ex2 ){
              var temp = ex1;
              ex1 = ex2;
              ex2 = temp;
            }

            if( ey1 > ey2 ){
              var temp = ey1;
              ey1 = ey2;
              ey2 = temp;
            }

            x1 = ex1 < x1 ? ex1 : x1;
            x2 = ex2 > x2 ? ex2 : x2;
            y1 = ey1 < y1 ? ey1 : y1;
            y2 = ey2 > y2 ? ey2 : y2;  
          }

        } // edges
            

        // handle label dimensions
        //////////////////////////

        if( styleEnabled ){

          var style = ele._private.style;
          var rstyle = ele._private.rstyle;
          var label = style['content'].strValue;
          var fontSize = style['font-size'];
          var halign = style['text-halign'];
          var valign = style['text-valign'];
          var labelWidth = rstyle.labelWidth;
          var labelHeight = rstyle.labelHeight;
          var labelX = rstyle.labelX;
          var labelY = rstyle.labelY;

          if( includedEle && includeLabels && label && fontSize && labelHeight != null && labelWidth != null && labelX != null && labelY != null && halign && valign ){
            var lh = labelHeight;
            var lw = labelWidth;
            var lx1, lx2, ly1, ly2;

            if( ele.isEdge() ){
              lx1 = labelX - lw/2;
              lx2 = labelX + lw/2;
              ly1 = labelY - lh/2;
              ly2 = labelY + lh/2;
            } else {
              switch( halign.value ){
                case 'left':
                  lx1 = labelX - lw;
                  lx2 = labelX;
                  break;

                case 'center':
                  lx1 = labelX - lw/2;
                  lx2 = labelX + lw/2;
                  break;

                case 'right':
                  lx1 = labelX;
                  lx2 = labelX + lw;
                  break;
              }

              switch( valign.value ){
                case 'top':
                  ly1 = labelY - lh;
                  ly2 = labelY;
                  break;

                case 'center':
                  ly1 = labelY - lh/2;
                  ly2 = labelY + lh/2;
                  break;

                case 'bottom':
                  ly1 = labelY;
                  ly2 = labelY + lh;
                  break;
              }
            }

            x1 = lx1 < x1 ? lx1 : x1;
            x2 = lx2 > x2 ? lx2 : x2;
            y1 = ly1 < y1 ? ly1 : y1;
            y2 = ly2 > y2 ? ly2 : y2;
          }
        } // style enabled
      } // for

      var noninf = function(x){
        if( x === Infinity || x === -Infinity ){
          return 0;
        }
        
        return x;
      };

      x1 = noninf(x1);
      x2 = noninf(x2);
      y1 = noninf(y1);
      y2 = noninf(y2);

      return {
        x1: x1,
        x2: x2,
        y1: y1,
        y2: y2,
        w: x2 - x1,
        h: y2 - y1
      };
    }
  });

  // aliases
  var fn = $$.elesfn;
  fn.attr = fn.data;
  fn.removeAttr = fn.removeData;
  fn.modelPosition = fn.point = fn.position;
  fn.modelPositions = fn.points = fn.positions;
  fn.renderedPoint = fn.renderedPosition;
  fn.relativePoint = fn.relativePosition;
  fn.boundingbox = fn.boundingBox;
  fn.renderedBoundingbox = fn.renderedBoundingBox;

})( cytoscape );

;(function( $$ ){ 'use strict';
  
  // Regular degree functions (works on single element)
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  function defineDegreeFunction(callback){
    return function( includeLoops ){
      var self = this;

      if( includeLoops === undefined ){
        includeLoops = true;
      }
      
      if( self.length === 0 ){ return; }

      if( self.isNode() && !self.removed() ){
        var degree = 0;
        var node = self[0];
        var connectedEdges = node._private.edges;

        for( var i = 0; i < connectedEdges.length; i++ ){
          var edge = connectedEdges[i];

          if( !includeLoops && edge.isLoop() ){
            continue;
          }

          degree += callback( node, edge );
        }
        
        return degree;
      } else {
        return;
      }
    };
  }
  
  $$.fn.eles({
    degree: defineDegreeFunction(function(node, edge){
      if( edge.source().same( edge.target() ) ){
        return 2;
      } else {
        return 1;
      }
    }),

    indegree: defineDegreeFunction(function(node, edge){
      if( edge.target().same(node) ){
        return 1;
      } else {
        return 0;
      }
    }),

    outdegree: defineDegreeFunction(function(node, edge){
      if( edge.source().same(node) ){
        return 1;
      } else {
        return 0;
      }
    })
  });
  
  
  // Collection degree stats
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  function defineDegreeBoundsFunction(degreeFn, callback){
    return function( includeLoops ){
      var ret;
      var nodes = this.nodes();

      for( var i = 0; i < nodes.length; i++ ){
        var ele = nodes[i];
        var degree = ele[degreeFn]( includeLoops );
        if( degree !== undefined && (ret === undefined || callback(degree, ret)) ){
          ret = degree;
        }
      }
      
      return ret;
    };
  }
  
  $$.fn.eles({
    minDegree: defineDegreeBoundsFunction('degree', function(degree, min){
      return degree < min;
    }),

    maxDegree: defineDegreeBoundsFunction('degree', function(degree, max){
      return degree > max;
    }),

    minIndegree: defineDegreeBoundsFunction('indegree', function(degree, min){
      return degree < min;
    }),

    maxIndegree: defineDegreeBoundsFunction('indegree', function(degree, max){
      return degree > max;
    }),

    minOutdegree: defineDegreeBoundsFunction('outdegree', function(degree, min){
      return degree < min;
    }),

    maxOutdegree: defineDegreeBoundsFunction('outdegree', function(degree, max){
      return degree > max;
    })
  });
  
  $$.fn.eles({
    totalDegree: function( includeLoops ){
      var total = 0;
      var nodes = this.nodes();

      for( var i = 0; i < nodes.length; i++ ){
        total += nodes[i].degree( includeLoops );
      }

      return total;
    }
  });
  
})( cytoscape );

  
;(function($$){ 'use strict';
  
  // Functions for binding & triggering events
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  $$.fn.eles({
    on: $$.define.on(), // .on( events [, selector] [, data], handler)
    one: $$.define.on({ unbindSelfOnTrigger: true }),
    once: $$.define.on({ unbindAllBindersOnTrigger: true }),
    off: $$.define.off(), // .off( events [, selector] [, handler] )
    trigger: $$.define.trigger(), // .trigger( events [, extraParams] )

    rtrigger: function(event, extraParams){ // for internal use only
      if( this.length === 0 ){ return; } // empty collections don't need to notify anything

      // notify renderer
      this.cy().notify({
        type: event,
        collection: this
      });
      
      this.trigger(event, extraParams);
      return this;
    }
  });

  // aliases:
  $$.define.eventAliasesOn( $$.elesfn );
  
})( cytoscape );

;(function($$){ 'use strict';

  $$.fn.eles({
    nodes: function( selector ){
      return this.filter(function(i, element){
        return element.isNode();
      }).filter(selector);
    },

    edges: function( selector ){
      return this.filter(function(i, element){
        return element.isEdge();
      }).filter(selector);
    },

    filter: function( filter ){
      var cy = this._private.cy;
      
      if( $$.is.fn(filter) ){
        var elements = [];

        for( var i = 0; i < this.length; i++ ){
          var ele = this[i];

          if( filter.apply(ele, [i, ele]) ){
            elements.push(ele);
          }
        }
        
        return new $$.Collection(cy, elements);
      
      } else if( $$.is.string(filter) || $$.is.elementOrCollection(filter) ){
        return new $$.Selector(filter).filter(this);
      
      } else if( filter === undefined ){
        return this;
      }

      return new $$.Collection( cy ); // if not handled by above, give 'em an empty collection
    },

    not: function( toRemove ){
      var cy = this._private.cy;

      if( !toRemove ){
        return this;
      } else {
      
        if( $$.is.string( toRemove ) ){
          toRemove = this.filter( toRemove );
        }
        
        var elements = [];
        
        for( var i = 0; i < this.length; i++ ){
          var element = this[i];

          var remove = toRemove._private.ids[ element.id() ];
          if( !remove ){
            elements.push( element );
          }
        }
        
        return new $$.Collection( cy, elements );
      }
      
    },

    absoluteComplement: function(){
      var cy = this._private.cy;

      return cy.elements().not( this );
    },

    intersect: function( other ){
      var cy = this._private.cy;
      
      // if a selector is specified, then filter by it instead
      if( $$.is.string(other) ){
        var selector = other;
        return this.filter( selector );
      }
      
      var elements = [];
      var col1 = this;
      var col2 = other;
      var col1Smaller = this.length < other.length;
      // var ids1 = col1Smaller ? col1._private.ids : col2._private.ids;
      var ids2 = col1Smaller ? col2._private.ids : col1._private.ids;
      var col = col1Smaller ? col1 : col2;
      
      for( var i = 0; i < col.length; i++ ){
        var id = col[i]._private.data.id;
        var ele = ids2[ id ];

        if( ele ){
          elements.push( ele );
        }
      }
      
      return new $$.Collection( cy, elements );
    },

    xor: function( other ){
      var cy = this._private.cy;

      if( $$.is.string(other) ){
        other = cy.$( other );
      }

      var elements = [];
      var col1 = this;
      var col2 = other;
      
      var add = function( col, other ){

        for( var i = 0; i < col.length; i++ ){
          var ele = col[i];
          var id = ele._private.data.id;
          var inOther = other._private.ids[ id ];
          
          if( !inOther ){
            elements.push( ele );
          }
        }

      };

      add( col1, col2 );
      add( col2, col1 );

      return new $$.Collection( cy, elements );
    },  

    diff: function( other ){
      var cy = this._private.cy;

      if( $$.is.string(other) ){
        other = cy.$( other );
      }

      var left = [];
      var right = [];
      var both = [];
      var col1 = this;
      var col2 = other;

      var add = function( col, other, retEles ){

        for( var i = 0; i < col.length; i++ ){
          var ele = col[i];
          var id = ele._private.data.id;
          var inOther = other._private.ids[ id ];
          
          if( inOther ){
            both.push( ele );
          } else {
            retEles.push( ele );
          }
        }

      };

      add( col1, col2, left );
      add( col2, col1, right );

      return {
        left: new $$.Collection( cy, left, { unique: true } ),
        right: new $$.Collection( cy, right, { unique: true } ),
        both: new $$.Collection( cy, both, { unique: true } )
      };
    },

    add: function( toAdd ){
      var cy = this._private.cy;    
      
      if( !toAdd ){
        return this;
      }
      
      if( $$.is.string(toAdd) ){
        var selector = toAdd;
        toAdd = cy.elements(selector);
      }
      
      var elements = [];

      for( var i = 0; i < this.length; i++ ){
        elements.push( this[i] );
      }

      for( var i = 0; i < toAdd.length; i++ ){

        var add = !this._private.ids[ toAdd[i].id() ];
        if( add ){
          elements.push( toAdd[i] );
        }
      }
      
      return new $$.Collection(cy, elements);
    },

    // in place merge on calling collection
    merge: function( toAdd ){
      var _p = this._private;
      var cy = _p.cy;    
      
      if( !toAdd ){
        return this;
      }
      
      if( $$.is.string(toAdd) ){
        var selector = toAdd;
        toAdd = cy.elements(selector);
      }

      for( var i = 0; i < toAdd.length; i++ ){
        var toAddEle = toAdd[i];
        var id = toAddEle.id();
        var add = !_p.ids[ id ];

        if( add ){
          var index = this.length++;

          this[ index ] = toAddEle;
          _p.ids[ id ] = toAddEle;
          _p.indexes[ id ] = index;
        }
      }
      
      return this; // chaining
    },

    // remove single ele in place in calling collection
    unmergeOne: function( ele ){
      ele = ele[0];

      var _p = this._private;
      var id = ele.id();
      var i = _p.indexes[ id ];

      if( i == null ){
        return this; // no need to remove
      }

      // remove ele
      this[i] = undefined;
      _p.ids[ id ] = undefined;
      _p.indexes[ id ] = undefined;

      var unmergedLastEle = i === this.length - 1;

      // replace empty spot with last ele in collection
      if( this.length > 1 && !unmergedLastEle ){
        var lastEleI = this.length - 1;
        var lastEle = this[ lastEleI ];

        this[ lastEleI ] = undefined;
        this[i] = lastEle;
        _p.indexes[ lastEle.id() ] = i;
      }

      // the collection is now 1 ele smaller
      this.length--;

      return this;
    },

    // remove eles in place on calling collection
    unmerge: function( toRemove ){
      var cy = this._private.cy;    
      
      if( !toRemove ){
        return this;
      }

      if( $$.is.string(toRemove) ){
        var selector = toRemove;
        toRemove = cy.elements(selector);
      }

      for( var i = 0; i < toRemove.length; i++ ){
        this.unmergeOne( toRemove[i] );
      }
      
      return this; // chaining
    },

    map: function( mapFn, thisArg ){
      var arr = [];
      var eles = this;

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        var ret = thisArg ? mapFn.apply( thisArg, [ele, i, eles] ) : mapFn( ele, i, eles );

        arr.push( ret );
      }

      return arr;
    },

    stdFilter: function( fn, thisArg ){
      var filterEles = [];
      var eles = this;
      var cy = this._private.cy;

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        var include = thisArg ? fn.apply( thisArg, [ele, i, eles] ) : fn( ele, i, eles );

        if( include ){
          filterEles.push( ele );
        }
      }

      return new $$.Collection( cy, filterEles );
    },

    max: function( valFn, thisArg ){
      var max = -Infinity;
      var maxEle;
      var eles = this;

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        var val = thisArg ? valFn.apply( thisArg, [ ele, i, eles ] ) : valFn( ele, i, eles );

        if( val > max ){
          max = val;
          maxEle = ele;
        }
      }

      return {
        value: max,
        ele: maxEle
      };
    },

    min: function( valFn, thisArg ){
      var min = Infinity;
      var minEle;
      var eles = this;

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        var val = thisArg ? valFn.apply( thisArg, [ ele, i, eles ] ) : valFn( ele, i, eles );

        if( val < min ){
          min = val;
          minEle = ele;
        }
      }

      return {
        value: min,
        ele: minEle
      };
    }
  });

  // aliases
  var fn = $$.elesfn;
  fn['u'] = fn['|'] = fn['+'] = fn.union = fn.or = fn.add;
  fn['\\'] = fn['!'] = fn['-'] = fn.difference = fn.relativeComplement = fn.not;
  fn['n'] = fn['&'] = fn['.'] = fn.and = fn.intersection = fn.intersect;
  fn['^'] = fn['(+)'] = fn['(-)'] = fn.symmetricDifference = fn.symdiff = fn.xor;
  fn.fnFilter = fn.filterFn = fn.stdFilter;
  fn.complement = fn.abscomp = fn.absoluteComplement;
  
})( cytoscape );
;(function($$){ 'use strict';

  $$.fn.eles({
    isNode: function(){
      return this.group() === 'nodes';
    },

    isEdge: function(){
      return this.group() === 'edges';
    },

    isLoop: function(){
      return this.isEdge() && this.source().id() === this.target().id();
    },

    isSimple: function(){
      return this.isEdge() && this.source().id() !== this.target().id();
    },

    group: function(){
      var ele = this[0];

      if( ele ){
        return ele._private.group;
      }
    }
  });

  
})( cytoscape );

;(function($$){ 'use strict';
  
  // Functions for iterating over collections
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  $$.fn.eles({
    each: function(fn){
      if( $$.is.fn(fn) ){
        for(var i = 0; i < this.length; i++){
          var ele = this[i];
          var ret = fn.apply( ele, [ i, ele ] );

          if( ret === false ){ break; } // exit each early on return false
        }
      }
      return this;
    },

    forEach: function(fn, thisArg){
      if( $$.is.fn(fn) ){

        for(var i = 0; i < this.length; i++){
          var ele = this[i];
          var ret = thisArg ? fn.apply( thisArg, [ ele, i, this ] ) : fn( ele, i, this );

          if( ret === false ){ break; } // exit each early on return false
        }
      }

      return this;
    },

    toArray: function(){
      var array = [];
      
      for(var i = 0; i < this.length; i++){
        array.push( this[i] );
      }
      
      return array;
    },

    slice: function(start, end){
      var array = [];
      var thisSize = this.length;
      
      if( end == null ){
        end = thisSize;
      }

      if( start == null ){
        start = 0;
      }
      
      if( start < 0 ){
        start = thisSize + start;
      }

      if( end < 0 ){
        end = thisSize + end;
      }
      
      for(var i = start; i >= 0 && i < end && i < thisSize; i++){
        array.push( this[i] );
      }
      
      return new $$.Collection(this.cy(), array);
    },

    size: function(){
      return this.length;
    },

    eq: function(i){
      return this[i] || new $$.Collection( this.cy() );
    },

    first: function(){
      return this[0] || new $$.Collection( this.cy() );
    },

    last: function(){
      return this[ this.length - 1 ] || new $$.Collection( this.cy() );
    },

    empty: function(){
      return this.length === 0;
    },

    nonempty: function(){
      return !this.empty();
    },

    sort: function( sortFn ){
      if( !$$.is.fn( sortFn ) ){
        return this;
      }

      var cy = this.cy();      
      var sorted = this.toArray().sort( sortFn );

      return new $$.Collection(cy, sorted);
    },

    sortByZIndex: function(){
      return this.sort( $$.Collection.zIndexSort );
    },

    zDepth: function(){
      var ele = this[0];
      if( !ele ){ return undefined; }

      // var cy = ele.cy();
      var _p = ele._private;
      var group = _p.group;

      if( group === 'nodes' ){
        var depth = _p.data.parent ? ele.parents().size() : 0;
        
        if( !ele.isParent() ){
          return Number.MAX_VALUE; // childless nodes always on top
        }
        
        return depth;
      } else {
        var src = _p.source;
        var tgt = _p.target;
        var srcDepth = src.zDepth();
        var tgtDepth = tgt.zDepth();

        return Math.max( srcDepth, tgtDepth, 0 ); // depth of deepest parent
      }
    }
  });

  $$.Collection.zIndexSort = function(a, b){
    var cy = a.cy();
    var a_p = a._private;
    var b_p = b._private;
    var zDiff = a_p.style['z-index'].value - b_p.style['z-index'].value;
    var depthA = 0;
    var depthB = 0;
    var hasCompoundNodes = cy.hasCompoundNodes();
    var aIsNode = a_p.group === 'nodes';
    var aIsEdge = a_p.group === 'edges';
    var bIsNode = b_p.group === 'nodes';
    var bIsEdge = b_p.group === 'edges';

    // no need to calculate element depth if there is no compound node
    if( hasCompoundNodes ){
      depthA = a.zDepth();
      depthB = b.zDepth();
    }

    var depthDiff = depthA - depthB;
    var sameDepth = depthDiff === 0;

    if( sameDepth ){
      
      if( aIsNode && bIsEdge ){      
        return 1; // 'a' is a node, it should be drawn later       
      
      } else if( aIsEdge && bIsNode ){
        return -1; // 'a' is an edge, it should be drawn first

      } else { // both nodes or both edges        
        if( zDiff === 0 ){ // same z-index => compare indices in the core (order added to graph w/ last on top)
          return a_p.index - b_p.index;
        } else {
          return zDiff;
        }
      }
    
    // elements on different level
    } else {      
      return depthDiff; // deeper element should be drawn later
    }

  };
  
})( cytoscape );

;(function($$){ 'use strict';
  
  // Functions for layouts on nodes
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  $$.fn.eles({

    // using standard layout options, apply position function (w/ or w/o animation)
    layoutPositions: function( layout, options, fn ){
      var nodes = this.nodes();
      var cy = this.cy();

      layout.trigger({ type: 'layoutstart', layout: layout });

      if( options.animate ){
        for( var i = 0; i < nodes.length; i++ ){
          var node = nodes[i];
          var lastNode = i === nodes.length - 1;

          var newPos = fn.call( node, i, node );
          var pos = node.position();

          if( !$$.is.number(pos.x) || !$$.is.number(pos.y) ){
            node.silentPosition({ x: 0, y: 0 });
          }

          node.animate({
            position: newPos
          }, {
            duration: options.animationDuration,
            step: !lastNode ? undefined : function(){
              if( options.fit ){
                cy.fit( options.eles, options.padding );
              } 
            },
            complete: !lastNode ? undefined : function(){
              if( options.zoom != null ){
                cy.zoom( options.zoom );
              }

              if( options.pan ){
                cy.pan( options.pan );
              } 

              if( options.fit ){
                cy.fit( options.eles, options.padding );
              } 
              
              layout.one('layoutstop', options.stop);
              layout.trigger({ type: 'layoutstop', layout: layout });
            }
          });
        }

        layout.one('layoutready', options.ready);
        layout.trigger({ type: 'layoutready', layout: layout });
      } else {
        nodes.positions( fn );

        if( options.fit ){
          cy.fit( options.eles, options.padding );
        }

        if( options.zoom != null ){
          cy.zoom( options.zoom );
        }

        if( options.pan ){
          cy.pan( options.pan );
        } 

        layout.one('layoutready', options.ready);
        layout.trigger({ type: 'layoutready', layout: layout });
        
        layout.one('layoutstop', options.stop);
        layout.trigger({ type: 'layoutstop', layout: layout });
      }

      return this; // chaining
    },

    layout: function( options ){
      var cy = this.cy();

      cy.layout( $$.util.extend({}, options, {
        eles: this
      }) );

      return this;
    },

    makeLayout: function( options ){
      var cy = this.cy();

      return cy.makeLayout( $$.util.extend({}, options, {
        eles: this
      }) );
    }

  });

  // aliases:
  $$.elesfn.createLayout = $$.elesfn.makeLayout;
  
})( cytoscape );

;(function($$){ 'use strict';

  $$.fn.eles({

    // fully updates (recalculates) the style for the elements
    updateStyle: function( notifyRenderer ){
      var cy = this._private.cy;

      if( !cy.styleEnabled() ){ return this; }

      if( cy._private.batchingStyle ){
        var bEles = cy._private.batchStyleEles;

        for( var i = 0; i < this.length; i++ ){
          var ele = this[i];

          if( !bEles.ids[ ele._private.id ] ){
            bEles.push( ele );
          }
        }

        return this; // chaining and exit early when batching
      }

      var style = cy.style();
      notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;

      style.apply( this );

      var updatedCompounds = this.updateCompoundBounds();
      var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;

      if( notifyRenderer ){
        toNotify.rtrigger('style'); // let renderer know we changed style
      } else {
        toNotify.trigger('style'); // just fire the event
      }
      return this; // chaining
    },

    // just update the mappers in the elements' styles; cheaper than eles.updateStyle()
    updateMappers: function( notifyRenderer ){
      var cy = this._private.cy;
      var style = cy.style();
      notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;

      if( !cy.styleEnabled() ){ return this; }

      style.updateMappers( this );

      var updatedCompounds = this.updateCompoundBounds();
      var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;

      if( notifyRenderer ){
        toNotify.rtrigger('style'); // let renderer know we changed style
      } else {
        toNotify.trigger('style'); // just fire the event
      }
      return this; // chaining
    },

    // get the specified css property as a rendered value (i.e. on-screen value)
    // or get the whole rendered style if no property specified (NB doesn't allow setting)
    renderedCss: function( property ){
      var cy = this.cy();
      if( !cy.styleEnabled() ){ return this; }

      var ele = this[0];

      if( ele ){
        var renstyle = ele.cy().style().getRenderedStyle( ele );

        if( property === undefined ){
          return renstyle;
        } else {
          return renstyle[ property ];
        }
      }
    },

    // read the calculated css style of the element or override the style (via a bypass)
    css: function( name, value ){
      var cy = this.cy();
      
      if( !cy.styleEnabled() ){ return this; }

      var updateTransitions = false;
      var style = cy.style();

      if( $$.is.plainObject(name) ){ // then extend the bypass
        var props = name;
        style.applyBypass( this, props, updateTransitions );

        var updatedCompounds = this.updateCompoundBounds();
        var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;
        toNotify.rtrigger('style'); // let the renderer know we've updated style

      } else if( $$.is.string(name) ){
  
        if( value === undefined ){ // then get the property from the style
          var ele = this[0];

          if( ele ){
            return ele._private.style[ name ].strValue;
          } else { // empty collection => can't get any value
            return;
          }

        } else { // then set the bypass with the property value
          style.applyBypass( this, name, value, updateTransitions );

          var updatedCompounds = this.updateCompoundBounds();
          var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;
          toNotify.rtrigger('style'); // let the renderer know we've updated style
        }

      } else if( name === undefined ){
        var ele = this[0];

        if( ele ){
          return style.getRawStyle( ele );
        } else { // empty collection => can't get any value
          return;
        }
      }

      return this; // chaining
    },

    removeCss: function( names ){
      var cy = this.cy();
      
      if( !cy.styleEnabled() ){ return this; }

      var updateTransitions = false;
      var style = cy.style();
      var eles = this;

      if( names === undefined ){
        for( var i = 0; i < eles.length; i++ ){
          var ele = eles[i];

          style.removeAllBypasses( ele, updateTransitions );
        }
      } else {
        names = names.split(/\s+/);

        for( var i = 0; i < eles.length; i++ ){
          var ele = eles[i];

          style.removeBypasses( ele, names, updateTransitions );
        }
      }

      var updatedCompounds = this.updateCompoundBounds();
      var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;
      toNotify.rtrigger('style'); // let the renderer know we've updated style

      return this; // chaining
    },

    show: function(){
      this.css('display', 'element');
      return this; // chaining
    },

    hide: function(){
      this.css('display', 'none');
      return this; // chaining
    },

    visible: function(){
      var cy = this.cy();
      if( !cy.styleEnabled() ){ return true; }

      var ele = this[0];
      var hasCompoundNodes = cy.hasCompoundNodes();

      if( ele ){
        var style = ele._private.style;

        if(
          style['visibility'].value !== 'visible'
          || style['display'].value !== 'element'
        ){
          return false;
        }
        
        if( ele._private.group === 'nodes' ){
          if( !hasCompoundNodes ){ return true; }

          var parents = ele._private.data.parent ? ele.parents() : null;

          if( parents ){
            for( var i = 0; i < parents.length; i++ ){
              var parent = parents[i];
              var pStyle = parent._private.style;
              var pVis = pStyle['visibility'].value;
              var pDis = pStyle['display'].value;

              if( pVis !== 'visible' || pDis !== 'element' ){
                return false;
              }
            }
          }

          return true;
        } else {
          var src = ele._private.source;
          var tgt = ele._private.target;

          return src.visible() && tgt.visible();
        }

      }
    },

    hidden: function(){
      var ele = this[0];

      if( ele ){
        return !ele.visible();
      }
    },

    effectiveOpacity: function(){
      var cy = this.cy();
      if( !cy.styleEnabled() ){ return 1; }

      var hasCompoundNodes = cy.hasCompoundNodes();
      var ele = this[0];

      if( ele ){
        var _p = ele._private;
        var parentOpacity = _p.style.opacity.value;

        if( !hasCompoundNodes ){ return parentOpacity; }

        var parents = !_p.data.parent ? null : ele.parents();
        
        if( parents ){
          for( var i = 0; i < parents.length; i++ ){
            var parent = parents[i];
            var opacity = parent._private.style.opacity.value;

            parentOpacity = opacity * parentOpacity;
          }
        }

        return parentOpacity;
      }
    },

    transparent: function(){
      var cy = this.cy();
      if( !cy.styleEnabled() ){ return false; }

      var ele = this[0];
      var hasCompoundNodes = ele.cy().hasCompoundNodes();

      if( ele ){
        if( !hasCompoundNodes ){
          return ele._private.style.opacity.value === 0;
        } else {
          return ele.effectiveOpacity() === 0;
        }
      }
    },

    isFullAutoParent: function(){
      var cy = this.cy();
      if( !cy.styleEnabled() ){ return false; }

      var ele = this[0];

      if( ele ){
        var autoW = ele._private.style['width'].value === 'auto';
        var autoH = ele._private.style['height'].value === 'auto';

        return ele.isParent() && autoW && autoH;
      }
    },

    backgrounding: function(){
      var cy = this.cy();
      if( !cy.styleEnabled() ){ return false; }

      var ele = this[0];

      return ele._private.backgrounding ? true : false;
    }

  });


  $$.elesfn.bypass = $$.elesfn.style = $$.elesfn.css;
  $$.elesfn.renderedStyle = $$.elesfn.renderedCss;
  $$.elesfn.removeBypass = $$.elesfn.removeStyle = $$.elesfn.removeCss;
  
})( cytoscape );
;(function($$){ 'use strict';
  
  // Collection functions that toggle a boolean value
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  
  function defineSwitchFunction(params){
    return function(){
      var args = arguments;
      var changedEles = [];
      
      // e.g. cy.nodes().select( data, handler )
      if( args.length === 2 ){
        var data = args[0];
        var handler = args[1];
        this.bind( params.event, data, handler );
      } 
      
      // e.g. cy.nodes().select( handler )
      else if( args.length === 1 ){
        var handler = args[0];
        this.bind( params.event, handler );
      }
      
      // e.g. cy.nodes().select()
      else if( args.length === 0 ){
        for( var i = 0; i < this.length; i++ ){
          var ele = this[i];
          var able = !params.ableField || ele._private[params.ableField];
          var changed = ele._private[params.field] != params.value;

          if( params.overrideAble ){
            var overrideAble = params.overrideAble(ele);

            if( overrideAble !== undefined ){
              able = overrideAble;

              if( !overrideAble ){ return this; } // to save cycles assume not able for all on override
            }
          }

          if( able ){
            ele._private[params.field] = params.value;

            if( changed ){
              changedEles.push( ele );
            }
          }
        }

        var changedColl = $$.Collection( this.cy(), changedEles );
        changedColl.updateStyle(); // change of state => possible change of style
        changedColl.trigger( params.event );
      }

      return this;
    };
  }
  
  function defineSwitchSet( params ){
    $$.elesfn[ params.field ] = function(){
      var ele = this[0];

      if( ele ){
        if( params.overrideField ){
          var val = params.overrideField(ele);

          if( val !== undefined ){
            return val;
          }
        }

        return ele._private[ params.field ];
      }
    };
    
    $$.elesfn[ params.on ] = defineSwitchFunction({
      event: params.on,
      field: params.field,
      ableField: params.ableField,
      overrideAble: params.overrideAble,
      value: true
    });

    $$.elesfn[ params.off ] = defineSwitchFunction({
      event: params.off,
      field: params.field,
      ableField: params.ableField,
      overrideAble: params.overrideAble,
      value: false
    });
  }
  
  defineSwitchSet({
    field: 'locked',
    overrideField: function(ele){
      return ele.cy().autolock() ? true : undefined;
    },
    on: 'lock',
    off: 'unlock'
  });
  
  defineSwitchSet({
    field: 'grabbable',
    overrideField: function(ele){
      return ele.cy().autoungrabify() ? false : undefined;
    },
    on: 'grabify',
    off: 'ungrabify'
  });
  
  defineSwitchSet({
    field: 'selected',
    ableField: 'selectable',
    overrideAble: function(ele){
      return ele.cy().autounselectify() ? false : undefined;
    },
    on: 'select',
    off: 'unselect'
  });
  
  defineSwitchSet({
    field: 'selectable',
    overrideField: function(ele){
      return ele.cy().autounselectify() ? false : undefined;
    },
    on: 'selectify',
    off: 'unselectify'
  });

  $$.elesfn.deselect = $$.elesfn.unselect;
  
  $$.elesfn.grabbed = function(){
    var ele = this[0];
    if( ele ){
      return ele._private.grabbed;
    }
  };

  defineSwitchSet({
    field: 'active',
    on: 'activate',
    off: 'unactivate'
  });

  $$.elesfn.inactive = function(){
    var ele = this[0];
    if( ele ){
      return !ele._private.active;
    }
  };
  
})( cytoscape );

;(function($$){ 'use strict';

  // DAG functions
  //////////////////////////

  $$.fn.eles({
    // get the root nodes in the DAG
    roots: function( selector ){
      var eles = this;
      var roots = [];

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        if( !ele.isNode() ){
          continue;
        }

        var hasEdgesPointingIn = ele.connectedEdges(function(){
          return this.data('target') === ele.id() && this.data('source') !== ele.id();
        }).length > 0;

        if( !hasEdgesPointingIn ){
          roots.push( ele );
        }
      }

      return new $$.Collection( this._private.cy, roots, { unique: true } ).filter( selector );
    },

    // get the leaf nodes in the DAG
    leaves: function( selector ){
      var eles = this;
      var leaves = [];

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        if( !ele.isNode() ){
          continue;
        }

        var hasEdgesPointingOut = ele.connectedEdges(function(){
          return this.data('source') === ele.id() && this.data('target') !== ele.id();
        }).length > 0;

        if( !hasEdgesPointingOut ){
          leaves.push( ele );
        }
      }

      return new $$.Collection( this._private.cy, leaves, { unique: true } ).filter( selector );
    },

    // normally called children in graph theory
    // these nodes =edges=> outgoing nodes
    outgoers: function( selector ){
      var eles = this;
      var oEles = [];

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        var eleId = ele.id();

        if( !ele.isNode() ){ continue; }

        var edges = ele._private.edges;
        for( var j = 0; j < edges.length; j++ ){
          var edge = edges[j];
          var srcId = edge._private.data.source;
          var tgtId = edge._private.data.target;

          if( srcId === eleId && tgtId !== eleId ){
            oEles.push( edge );
            oEles.push( edge.target()[0] );
          }
        }
      }

      return new $$.Collection( this._private.cy, oEles, { unique: true } ).filter( selector );
    },

    // aka DAG descendants
    successors: function( selector ){
      var eles = this;
      var sEles = [];
      var sElesIds = {};

      for(;;){
        var outgoers = eles.outgoers();

        if( outgoers.length === 0 ){ break; } // done if no outgoers left

        var newOutgoers = false;
        for( var i = 0; i < outgoers.length; i++ ){
          var outgoer = outgoers[i];
          var outgoerId = outgoer.id();

          if( !sElesIds[ outgoerId ] ){
            sElesIds[ outgoerId ] = true;
            sEles.push( outgoer );
            newOutgoers = true;
          }
        }

        if( !newOutgoers ){ break; } // done if touched all outgoers already

        eles = outgoers;
      }

      return new $$.Collection( this._private.cy, sEles, { unique: true } ).filter( selector );
    },

    // normally called parents in graph theory
    // these nodes <=edges= incoming nodes
    incomers: function( selector ){
      var eles = this;
      var oEles = [];

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        var eleId = ele.id();

        if( !ele.isNode() ){ continue; }

        var edges = ele._private.edges;
        for( var j = 0; j < edges.length; j++ ){
          var edge = edges[j];
          var srcId = edge._private.data.source;
          var tgtId = edge._private.data.target;

          if( tgtId === eleId && srcId !== eleId ){
            oEles.push( edge );
            oEles.push( edge.source()[0] );
          }
        }
      }

      return new $$.Collection( this._private.cy, oEles, { unique: true } ).filter( selector );
    },

    // aka DAG ancestors
    predecessors: function( selector ){
      var eles = this;
      var pEles = [];
      var pElesIds = {};

      for(;;){
        var incomers = eles.incomers();

        if( incomers.length === 0 ){ break; } // done if no incomers left

        var newIncomers = false;
        for( var i = 0; i < incomers.length; i++ ){
          var incomer = incomers[i];
          var incomerId = incomer.id();

          if( !pElesIds[ incomerId ] ){
            pElesIds[ incomerId ] = true;
            pEles.push( incomer );
            newIncomers = true;
          }
        }

        if( !newIncomers ){ break; } // done if touched all incomers already

        eles = incomers;
      }

      return new $$.Collection( this._private.cy, pEles, { unique: true } ).filter( selector );
    }
  });


  // Neighbourhood functions
  //////////////////////////

  $$.fn.eles({
    neighborhood: function(selector){
      var elements = [];
      var cy = this._private.cy;
      var nodes = this.nodes();

      for( var i = 0; i < nodes.length; i++ ){ // for all nodes
        var node = nodes[i];
        var connectedEdges = node.connectedEdges();

        // for each connected edge, add the edge and the other node
        for( var j = 0; j < connectedEdges.length; j++ ){
          var edge = connectedEdges[j];
          var otherNode = edge.connectedNodes().not(node);

          // need check in case of loop
          if( otherNode.length > 0 ){
            elements.push( otherNode[0] ); // add node 1 hop away
          }
          
          // add connected edge
          elements.push( edge[0] );
        }

      }
      
      return ( new $$.Collection( cy, elements, { unique: true } ) ).filter( selector );
    },

    closedNeighborhood: function(selector){
      return this.neighborhood().add( this ).filter( selector );
    },

    openNeighborhood: function(selector){
      return this.neighborhood( selector );
    }
  });  

  // aliases
  $$.elesfn.neighbourhood = $$.elesfn.neighborhood;
  $$.elesfn.closedNeighbourhood = $$.elesfn.closedNeighborhood;
  $$.elesfn.openNeighbourhood = $$.elesfn.openNeighborhood;


  // Edge functions
  /////////////////

  $$.fn.eles({
    source: function( selector ){
      var ele = this[0];
      var src;

      if( ele ){
        src = ele._private.source;
      }

      return src && selector ? src.filter( selector ) : src;
    },

    target: function( selector ){
      var ele = this[0];
      var tgt;

      if( ele ){
        tgt = ele._private.target;
      }

      return tgt && selector ? tgt.filter( selector ) : tgt;
    },

    sources: defineSourceFunction({
      attr: 'source'
    }),

    targets: defineSourceFunction({
      attr: 'target'
    })
  });
  
  function defineSourceFunction( params ){
    return function( selector ){
      var sources = [];
      var cy = this._private.cy;

      for( var i = 0; i < this.length; i++ ){
        var ele = this[i];
        var src = ele._private[ params.attr ];

        if( src ){
          sources.push( src );
        }
      }
      
      return new $$.Collection( cy, sources, { unique: true } ).filter( selector );
    };
  }

  $$.fn.eles({
    edgesWith: defineEdgesWithFunction(),

    edgesTo: defineEdgesWithFunction({
      thisIs: 'source'
    })
  });
  
  function defineEdgesWithFunction( params ){
    
    return function(otherNodes){
      var elements = [];
      var cy = this._private.cy;
      var p = params || {};

      // get elements if a selector is specified
      if( $$.is.string(otherNodes) ){
        otherNodes = cy.$( otherNodes );
      }
      
      var thisIds = this._private.ids;
      var otherIds = otherNodes._private.ids;
      
      for( var h = 0; h < otherNodes.length; h++ ){
        var edges = otherNodes[h]._private.edges;
        
        for( var i = 0; i < edges.length; i++ ){
          var edge = edges[i];
          var foundId;
          var edgeData = edge._private.data;
          var thisToOther = thisIds[ edgeData.source ] && otherIds[ edgeData.target ];
          var otherToThis = otherIds[ edgeData.source ] && thisIds[ edgeData.target ];
          var edgeConnectsThisAndOther = thisToOther || otherToThis;

          if( !edgeConnectsThisAndOther ){ continue; }

          if( p.thisIs ){
            if( p.thisIs === 'source' && !thisToOther ){ continue; }
            
            if( p.thisIs === 'target' && !otherToThis ){ continue; }
          }
          
          elements.push( edge );
        }
      }
      
      return new $$.Collection( cy, elements, { unique: true } );
    };
  }
  
  $$.fn.eles({
    connectedEdges: function( selector ){
      var retEles = [];
      var cy = this._private.cy;
      
      var eles = this;
      for( var i = 0; i < eles.length; i++ ){
        var node = eles[i];
        if( !node.isNode() ){ continue; }

        var edges = node._private.edges;

        for( var j = 0; j < edges.length; j++ ){
          var edge = edges[j];          
          retEles.push( edge );
        }
      }
      
      return new $$.Collection( cy, retEles, { unique: true } ).filter( selector );
    },

    connectedNodes: function( selector ){
      var retEles = [];
      var cy = this._private.cy;

      var eles = this;
      for( var i = 0; i < eles.length; i++ ){
        var edge = eles[i];
        if( !edge.isEdge() ){ continue; }

        retEles.push( edge.source()[0] );
        retEles.push( edge.target()[0] );
      }

      return new $$.Collection( cy, retEles, { unique: true } ).filter( selector );
    },

    parallelEdges: defineParallelEdgesFunction(),

    codirectedEdges: defineParallelEdgesFunction({
      codirected: true
    })
  });
  
  function defineParallelEdgesFunction(params){
    var defaults = {
      codirected: false
    };
    params = $$.util.extend({}, defaults, params);
    
    return function( selector ){
      var cy = this._private.cy;
      var elements = [];
      var edges = this.edges();
      var p = params;

      // look at all the edges in the collection
      for( var i = 0; i < edges.length; i++ ){
        var edge1 = edges[i];
        var src1 = edge1.source()[0];
        var srcid1 = src1.id();
        var tgt1 = edge1.target()[0];
        var tgtid1 = tgt1.id();
        var srcEdges1 = src1._private.edges;

        // look at edges connected to the src node of this edge
        for( var j = 0; j < srcEdges1.length; j++ ){
          var edge2 = srcEdges1[j];
          var edge2data = edge2._private.data;
          var tgtid2 = edge2data.target;
          var srcid2 = edge2data.source;

          var codirected = tgtid2 === tgtid1 && srcid2 === srcid1;
          var oppdirected = srcid1 === tgtid2 && tgtid1 === srcid2;
          
          if( (p.codirected && codirected) || (!p.codirected && (codirected || oppdirected)) ){
            elements.push( edge2 );
          }
        }
      }
      
      return new $$.Collection( cy, elements, { unique: true } ).filter( selector );
    };
  
  }

  
})( cytoscape );

;(function($$){ 'use strict';

  $$.fn.eles({

    fit: function(){},
    center: function(){}

  });
  
})( cytoscape );
;(function ($$) {
  "use strict";

  /*  Min and Max heap predefaults */
  
  $$.Minheap = function (cy, eles, valueFn) {
    return new $$.Heap(cy, eles, $$.Heap.minHeapComparator, valueFn);
  };

  $$.Maxheap = function (cy, eles, valueFn) {
    return new $$.Heap(cy, eles, $$.Heap.maxHeapComparator, valueFn);
  };
  
  $$.Heap = function (cy, eles, comparator, valueFn) {
    if (typeof comparator === "undefined" || typeof eles === "undefined") {
      return;
    }
    
    if (typeof valueFn === "undefined") {
      valueFn = $$.Heap.idFn;
    }

    var sourceHeap = [],
      pointers = {},
      elements = [],
      i = 0,
      id,
      heap,
      elesLen;

    eles = this.getArgumentAsCollection(eles, cy);
    elesLen = eles.length;

    for (i = 0; i < elesLen; i += 1) {
      sourceHeap.push(valueFn.call(cy, eles[i], i, eles));

      id = eles[i].id();
      
      if (pointers.hasOwnProperty(id)) {
        throw "ERROR: Multiple items with the same id found: " + id;
      }
      
      pointers[id] = i;
      elements.push(id);
    }

    this._private = {
      cy: cy,
      heap: sourceHeap,
      pointers: pointers,
      elements: elements,
      comparator: comparator,
      extractor: valueFn,
      length: elesLen
    };

    for (i = Math.floor(elesLen / 2); i >= 0; i -= 1) {
      heap = this.heapify(i);
    }

    return heap;
  };

  /* static methods */
  $$.Heap.idFn = function (node) {
    return node.id();
  };

  $$.Heap.minHeapComparator = function (a, b) {
    return a >= b;
  };

  $$.Heap.maxHeapComparator = function (a, b) {
    return a <= b;
  };

  $$.fn.heap = function( fnMap, options ){
    for( var name in fnMap ){
      var fn = fnMap[name];
      $$.Heap.prototype[ name ] = fn;
    }
  };

  $$.heapfn = $$.Heap.prototype; // short alias

  /* object methods */
  $$.heapfn.size = function () {
    return this._private.length;
  };

  $$.heapfn.getArgumentAsCollection = function (eles, cy) {
    var result;
    if(typeof cy === "undefined") {
      cy = this._private.cy;
    }

    if ($$.is.elementOrCollection(eles)) {
      result = eles;

    } else {
      var resultArray = [],
        sourceEles = [].concat.apply([], [eles]);

      for (var i = 0; i < sourceEles.length; i++) {
        var id = sourceEles[i],
          ele = cy.getElementById(id);

        if(ele.length > 0) {
          resultArray.push(ele);
        }
      }

      result = new $$.Collection(cy, resultArray);
    }

    return result;
  };

  $$.heapfn.isHeap = function () {
    var array = this._private.heap,
      arrlen = array.length,
      i,
      left,
      right,
      lCheck,
      rCheck,
      comparator = this._private.comparator;

    for (i = 0; i < arrlen; i += 1) {
      left = 2 * i + 1;
      right = left + 1;
      lCheck = left < arrlen ? comparator(array[left], array[i]) : true;
      rCheck = right < arrlen ? comparator(array[right], array[i]) : true;

      if (!lCheck || !rCheck) {
        return false;
      }
    }

    return true;
  };

  $$.heapfn.heapSwap = function (i, j) {
    var heap = this._private.heap,
      pointers = this._private.pointers,
      elements = this._private.elements,
      swapValue = heap[i],
      swapElems = elements[i],
      idI = elements[i],
      idJ = elements[j];

    heap[i] = heap[j];
    elements[i] = elements[j];

    pointers[idI] = j;
    pointers[idJ] = i;

    heap[j] = swapValue;
    elements[j] = swapElems;
  };

  $$.heapfn.heapify = function (i, rootToLeaf) {
    var treeLen = 0,
      condHeap = false,
      array,
      current,
      left,
      right,
      best,
      comparator,
      parent;
    
    if (typeof rootToLeaf === "undefined") {
      rootToLeaf = true;
    }

    array = this._private.heap;
    treeLen = array.length;
    comparator = this._private.comparator;
    current = i;

    while (!condHeap) {

      if (rootToLeaf) {
        left = 2 * current + 1;
        right = left + 1;
        best = current;
        
        if (left < treeLen && !comparator(array[left], array[best])) {
          best = left;
        }
        
        if (right < treeLen && !comparator(array[right], array[best])) {
          best = right;
        }
        
        condHeap = best === current;
        
        if (!condHeap) {
          this.heapSwap(best, current);
          current = best;
        }

      } else {
        parent = Math.floor((current - 1) / 2);
        best = current;
        condHeap = parent < 0 || comparator(array[best], array[parent]);

        if (!condHeap) {
          this.heapSwap(best, parent);
          current = parent;
        }
      }

    } // while
  };

  /* collectionOrElement */
  $$.heapfn.insert = function (eles) {
    var elements = this.getArgumentAsCollection(eles),
      elsize = elements.length,
      element,
      elindex,
      elvalue,
      elid,
      i;

    for (i = 0; i < elsize; i += 1) {
      element = elements[i];
      elindex = this._private.heap.length;
      elvalue = this._private.extractor(element);
      elid = element.id();

      if (this._private.pointers.hasOwnProperty(elid)) {
        throw "ERROR: Multiple items with the same id found: " + elid;
      }

      this._private.heap.push(elvalue);
      this._private.elements.push(elid);
      this._private.pointers[elid] = elindex;
      this.heapify(elindex, false);
    }

    this._private.length = this._private.heap.length;
  };

  $$.heapfn.getValueById = function (elementId) {
    if (this._private.pointers.hasOwnProperty(elementId)) {
      var elementIndex = this._private.pointers[elementId];

      return this._private.heap[elementIndex];
    }
  };
  
  $$.heapfn.contains = function (eles) {
    var elements = this.getArgumentAsCollection(eles);

    for (var i = 0; i < elements.length; i += 1) {
      var elementId = elements[i].id();

      if(!this._private.pointers.hasOwnProperty(elementId)) {
        return false;
      }
    }

    return true;
  };
  
  $$.heapfn.top = function () {
    if (this._private.length > 0) {

      return {
        value: this._private.heap[0],
        id: this._private.elements[0]
      };

    }
  };

  $$.heapfn.pop = function () {
    if (this._private.length > 0) {
      var top = this.top(),
        lastIndex = this._private.length - 1,
        removeCandidate,
        removeValue,
        remId;

      this.heapSwap(0, lastIndex);

      removeCandidate = this._private.elements[lastIndex];
      removeValue = this._private.heap[lastIndex];
      remId = removeCandidate;

      this._private.heap.pop();
      this._private.elements.pop();
      this._private.length = this._private.heap.length;
      this._private.pointers[remId] = undefined;

      this.heapify(0);
      return top;
    }
  };

  $$.heapfn.findDirectionHeapify = function (index) {
    var parent = Math.floor((index - 1) / 2),
      array = this._private.heap,
      condHeap = parent < 0 || this._private.comparator(array[index], array[parent]);

    this.heapify(index, condHeap);
  };

  /* edit is a new value or function */
  // only values in heap are updated. elements themselves are not!
  $$.heapfn.edit = function (eles, edit) {
    var elements = this.getArgumentAsCollection(eles);
    
    for (var i = 0; i < elements.length; i += 1) {
      var elementId = elements[i].id(),
        elementIndex = this._private.pointers[elementId],
        elementValue = this._private.heap[elementIndex];
      
      if ($$.is.number(edit)) {
        this._private.heap[elementIndex] = edit;
        
      } else if ($$.is.fn(edit)) {
        this._private.heap[elementIndex] = edit.call(this._private.cy, elementValue, elementIndex);
      }

      this.findDirectionHeapify(elementIndex);
    }
  };

  $$.heapfn.remove = function (eles) {
    var elements = this.getArgumentAsCollection(eles);
    
    for (var i = 0; i < elements.length; i += 1) {
      var elementId = elements[i].id(),
        elementIndex = this._private.pointers[elementId],
        lastIndex = this._private.length - 1,
        removeCandidate,
        removeValue,
        remId;

      if (elementIndex !== lastIndex) {
        this.heapSwap(elementIndex, lastIndex);
      }

      removeCandidate = this._private.elements[lastIndex];
      removeValue = this._private.heap[lastIndex];
      remId = removeCandidate;

      this._private.heap.pop();
      this._private.elements.pop();
      this._private.length = this._private.heap.length;
      this._private.pointers[remId] = undefined;

      this.findDirectionHeapify(elementIndex);
    }

    return removeValue;
  };

})(cytoscape);
/*
  The canvas renderer was written by Yue Dong.

  Modifications tracked on Github.
*/

(function($$) { 'use strict';

  CanvasRenderer.CANVAS_LAYERS = 3;
  //
  CanvasRenderer.SELECT_BOX = 0;
  CanvasRenderer.DRAG = 1;
  CanvasRenderer.NODE = 2;

  CanvasRenderer.BUFFER_COUNT = 3;
  //
  CanvasRenderer.TEXTURE_BUFFER = 0;
  CanvasRenderer.MOTIONBLUR_BUFFER_NODE = 1;
  CanvasRenderer.MOTIONBLUR_BUFFER_DRAG = 2;

  function CanvasRenderer(options) {  

    this.options = options;

    this.data = {
        
      select: [undefined, undefined, undefined, undefined, 0], // Coordinates for selection box, plus enabled flag 
      renderer: this, cy: options.cy, container: options.cy.container(),
      
      canvases: new Array(CanvasRenderer.CANVAS_LAYERS),
      contexts: new Array(CanvasRenderer.CANVAS_LAYERS),
      canvasNeedsRedraw: new Array(CanvasRenderer.CANVAS_LAYERS),
      
      bufferCanvases: new Array(CanvasRenderer.BUFFER_COUNT),
      bufferContexts: new Array(CanvasRenderer.CANVAS_LAYERS)

    };
    
    //--Pointer-related data
    this.hoverData = {down: null, last: null, 
        downTime: null, triggerMode: null, 
        dragging: false, 
        initialPan: [null, null], capture: false};
    
    this.timeoutData = {panTimeout: null};
    
    this.dragData = {possibleDragElements: []};
    
    this.touchData = {start: null, capture: false,
        // These 3 fields related to tap, taphold events
        startPosition: [null, null, null, null, null, null],
        singleTouchStartTime: null,
        singleTouchMoved: true,
        
        
        now: [null, null, null, null, null, null], 
        earlier: [null, null, null, null, null, null] };
    //--
    
    //--Wheel-related data 
    this.zoomData = {freeToZoom: false, lastPointerX: null};
    //--
    
    this.redraws = 0;
    this.showFps = options.showFps;

    this.bindings = [];
    
    this.data.canvasContainer = document.createElement('div');
    var containerStyle = this.data.canvasContainer.style;
    containerStyle.position = 'absolute';
    containerStyle.zIndex = '0';
    containerStyle.overflow = 'hidden';

    this.data.container.appendChild( this.data.canvasContainer );

    for (var i = 0; i < CanvasRenderer.CANVAS_LAYERS; i++) {
      this.data.canvases[i] = document.createElement('canvas');
      this.data.contexts[i] = this.data.canvases[i].getContext('2d');
      this.data.canvases[i].style.position = 'absolute';
      this.data.canvases[i].setAttribute('data-id', 'layer' + i);
      this.data.canvases[i].style.zIndex = String(CanvasRenderer.CANVAS_LAYERS - i);
      this.data.canvasContainer.appendChild(this.data.canvases[i]);
      
      this.data.canvasNeedsRedraw[i] = false;
    }
    this.data.topCanvas = this.data.canvases[0];

    this.data.canvases[CanvasRenderer.NODE].setAttribute('data-id', 'layer' + CanvasRenderer.NODE + '-node');
    this.data.canvases[CanvasRenderer.SELECT_BOX].setAttribute('data-id', 'layer' + CanvasRenderer.SELECT_BOX + '-selectbox');
    this.data.canvases[CanvasRenderer.DRAG].setAttribute('data-id', 'layer' + CanvasRenderer.DRAG + '-drag');
    
    for (var i = 0; i < CanvasRenderer.BUFFER_COUNT; i++) {
      this.data.bufferCanvases[i] = document.createElement('canvas');
      this.data.bufferContexts[i] = this.data.bufferCanvases[i].getContext('2d');
      this.data.bufferCanvases[i].style.position = 'absolute';
      this.data.bufferCanvases[i].setAttribute('data-id', 'buffer' + i);
      this.data.bufferCanvases[i].style.zIndex = String(-i - 1);
      this.data.bufferCanvases[i].style.visibility = 'hidden';
      //this.data.canvasContainer.appendChild(this.data.bufferCanvases[i]);
    }

    this.hideEdgesOnViewport = options.hideEdgesOnViewport;
    this.hideLabelsOnViewport = options.hideLabelsOnViewport;
    this.textureOnViewport = options.textureOnViewport;
    this.wheelSensitivity = options.wheelSensitivity;
    this.motionBlurEnabled = options.motionBlur; // on by default
    this.forcedPixelRatio = options.pixelRatio;
    this.motionBlur = true; // for initial kick off
    this.motionBlurOpacity = options.motionBlurOpacity;
    this.motionBlurTransparency = 1 - this.motionBlurOpacity;
    this.motionBlurPxRatio = 1;
    this.mbPxRBlurry = 1; //0.8;
    this.minMbLowQualFrames = 4;
    this.fullQualityMb = false;
    this.clearedForMotionBlur = [];
    this.desktopTapThreshold = options.desktopTapThreshold;
    this.desktopTapThreshold2 = options.desktopTapThreshold * options.desktopTapThreshold;
    this.touchTapThreshold = options.touchTapThreshold;
    this.touchTapThreshold2 = options.touchTapThreshold * options.touchTapThreshold;
    this.tapholdDuration = 500;

    this.load();
  }

  CanvasRenderer.panOrBoxSelectDelay = 400;

  // whether to use Path2D caching for drawing
  var pathsImpld = typeof Path2D !== 'undefined';
  CanvasRenderer.usePaths = function(){
    return pathsImpld;
  };

  CanvasRenderer.prototype.notify = function(params) {
    var types;

    if( $$.is.array( params.type ) ){
      types = params.type;

    } else {
      types = [ params.type ];
    }

    for( var i = 0; i < types.length; i++ ){
      var type = types[i];

      switch( type ){
        case 'destroy':
          this.destroy();
          return;

        case 'add':
        case 'remove':
        case 'load':
          this.updateNodesCache();
          this.updateEdgesCache();
          break;

        case 'viewport':
          this.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;
          break;

        case 'style':
          this.updateCachedZSortedEles();
          break;
      }

      if( type === 'load' || type === 'resize' ){
        this.invalidateContainerClientCoordsCache();
        this.matchCanvasSize(this.data.container);
      }
    } // for
    
    this.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true;
    this.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true;

    this.redraw();
  };

  CanvasRenderer.prototype.destroy = function(){
    this.destroyed = true;

    for( var i = 0; i < this.bindings.length; i++ ){
      var binding = this.bindings[i];
      var b = binding;

      b.target.removeEventListener(b.event, b.handler, b.useCapture);
    }

    if( this.removeObserver ){
      this.removeObserver.disconnect();
    }

    if( this.labelCalcDiv ){
      try{
        document.body.removeChild(this.labelCalcDiv);
      } catch(e){
        // ie10 issue #1014
      }
    }
  };

  

  // copy the math functions into the renderer prototype
  // unfortunately these functions are used interspersed t/o the code
  // and this makes sure things work just in case a ref was missed in refactoring
  // TODO remove this eventually
  for( var fnName in $$.math ){
    CanvasRenderer.prototype[ fnName ] = $$.math[ fnName ];
  }
  
  
  $$('renderer', 'canvas', CanvasRenderer);
  
})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');
  var rendFunc = CanvasRenderer.prototype;
  var arrowShapes = CanvasRenderer.arrowShapes = {};

  CanvasRenderer.arrowShapeHeight = 0.3;

  // Contract for arrow shapes:
  // 0, 0 is arrow tip
  // (0, 1) is direction towards node
  // (1, 0) is right
  //
  // functional api:
  // collide: check x, y in shape
  // roughCollide: called before collide, no false negatives
  // draw: draw
  // spacing: dist(arrowTip, nodeBoundary)
  // gap: dist(edgeTip, nodeBoundary), edgeTip may != arrowTip

  var bbCollide = function(x, y, centerX, centerY, width, height, direction, padding){
    var x1 = centerX - width/2;
    var x2 = centerX + width/2;
    var y1 = centerY - height/2;
    var y2 = centerY + height/2;

    return (x1 <= x && x <= x2) && (y1 <= y && y <= y2);
  };

  var transform = function(x, y, size, angle, translation){
    angle = -angle; // b/c of notation used in arrow draw fn

    var xRotated = x * Math.cos(angle) - y * Math.sin(angle);
    var yRotated = x * Math.sin(angle) + y * Math.cos(angle);
    
    var xScaled = xRotated * size;
    var yScaled = yRotated * size;

    var xTranslated = xScaled + translation.x;
    var yTranslated = yScaled + translation.y;
    
    return {
      x: xTranslated,
      y: yTranslated
    };
  };

  arrowShapes['arrow'] = {
    _points: [
      -0.15, -0.3,
      0, 0,
      0.15, -0.3
    ],
    
    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      var points = arrowShapes['arrow']._points;
      
//      console.log("collide(): " + direction);
      
      return $$.math.pointInsidePolygon(
        x, y, points, centerX, centerY, width, height, direction, padding);
    },
    
    roughCollide: bbCollide,
    
    draw: function(context, size, angle, translation) {
      var points = arrowShapes['arrow']._points;
    
      for (var i = 0; i < points.length / 2; i++) {
        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );

        context.lineTo(pt.x, pt.y);
      }

    },
    
    spacing: function(edge) {
      return 0;
    },
    
    gap: function(edge) {
      return edge._private.style['width'].pxValue * 2;
    }
  };

  arrowShapes['triangle'] = arrowShapes['arrow'];
  
  arrowShapes['triangle-backcurve'] = {
    _ctrlPt: [ 0, -0.15 ],

    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      var points = arrowShapes['triangle']._points;
      
//      console.log("collide(): " + direction);
      
      return $$.math.pointInsidePolygon(
        x, y, points, centerX, centerY, width, height, direction, padding);
    },
    
    roughCollide: bbCollide,
    
    draw: function(context, size, angle, translation) {
      var points = arrowShapes['triangle']._points;
      var firstPt;
    
      for (var i = 0; i < points.length / 2; i++) {
        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );

        if( i === 0 ){
          firstPt = pt;
        }

        context.lineTo(pt.x, pt.y);
      }

      var ctrlPt = this._ctrlPt;
      var ctrlPtTrans = transform( ctrlPt[0], ctrlPt[1], size, angle, translation );

      context.quadraticCurveTo( ctrlPtTrans.x, ctrlPtTrans.y, firstPt.x, firstPt.y );
    },
    
    spacing: function(edge) {
      return 0;
    },
    
    gap: function(edge) {
      return edge._private.style['width'].pxValue * 2;
    }
  };
  

  arrowShapes['triangle-tee'] = {
    _points: [
      -0.15, -0.3,
      0, 0,
      0.15, -0.3,
      -0.15, -0.3
    ],

    _pointsTee: [
      -0.15, -0.4,
      -0.15, -0.5,
      0.15, -0.5,
      0.15, -0.4
    ],
    
    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      var triPts = arrowShapes['triangle-tee']._points;
      var teePts = arrowShapes['triangle-tee']._pointsTee;
      
      var inside = $$.math.pointInsidePolygon(x, y, teePts, centerX, centerY, width, height, direction, padding) 
        || $$.math.pointInsidePolygon(x, y, triPts, centerX, centerY, width, height, direction, padding);

      return inside;
    },
    
    roughCollide: bbCollide,
    
    draw: function(context, size, angle, translation) {
      var triPts = arrowShapes['triangle-tee']._points;
      for (var i = 0; i < triPts.length / 2; i++){
        var pt = transform( triPts[ i * 2 ],  triPts[ i * 2 + 1 ], size, angle, translation );
        
        context.lineTo( pt.x, pt.y );
      }

      var teePts = arrowShapes['triangle-tee']._pointsTee;
      var firstTeePt = transform( teePts[0], teePts[1], size, angle, translation );
      context.moveTo( firstTeePt.x, firstTeePt.y );

      for (var i = 0; i < teePts.length / 2; i++){
        var pt = transform( teePts[ i * 2 ],  teePts[ i * 2 + 1 ], size, angle, translation );
        
        context.lineTo( pt.x, pt.y );
      }
    },
    
    spacing: function(edge) {
      return 0;
    },
    
    gap: function(edge) {
      return edge._private.style['width'].pxValue * 2;
    }
  };

  arrowShapes['half-triangle-overshot'] = {
    _points: [
      0, -0.25,
      -0.5, -0.25,
      0.5, 0.25
    ],
    
    leavePathOpen: true,
    matchEdgeWidth: true,

    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      var points = this._points;
      
//      console.log("collide(): " + direction);
      
      return $$.math.pointInsidePolygon(
        x, y, points, centerX, centerY, width, height, direction, padding);
    },
    
    roughCollide: bbCollide,
    
    draw: function(context, size, angle, translation) {
      var points = this._points;
    
      for (var i = 0; i < points.length / 2; i++) {
        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );

        context.lineTo(pt.x, pt.y);
      }
    },
    
    spacing: function(edge) {
      return 0;
    },
    
    gap: function(edge) {
      return edge._private.style['width'].pxValue * 2;
    }
  };

  arrowShapes['none'] = {
    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      return false;
    },
    
    roughCollide: function(x, y, centerX, centerY, width, height, direction, padding) {
      return false;
    },
    
    draw: function(context) {
    },
    
    spacing: function(edge) {
      return 0;
    },
    
    gap: function(edge) {
      return 0;
    }
  };
  
  arrowShapes['circle'] = {
    _baseRadius: 0.15,
    
    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      // Transform x, y to get non-rotated ellipse
      
      if (width != height) {                  
        var aspectRatio = (height + padding) / (width + padding);
        y /= aspectRatio;
        centerY /= aspectRatio;
        
        return (Math.pow(centerX - x, 2) 
          + Math.pow(centerY - y, 2) <= Math.pow((width + padding)
            * arrowShapes['circle']._baseRadius, 2));
      } else {
        return (Math.pow(centerX - x, 2) 
          + Math.pow(centerY - y, 2) <= Math.pow((width + padding)
            * arrowShapes['circle']._baseRadius, 2));
      }
    },
    
    roughCollide: bbCollide,
    
    draw: function(context, size, angle, translation) {
      context.arc(translation.x, translation.y, arrowShapes['circle']._baseRadius * size, 0, Math.PI * 2, false);
    },
    
    spacing: function(edge) {
      return rendFunc.getArrowWidth(edge._private.style['width'].pxValue)
        * arrowShapes['circle']._baseRadius;
    },
    
    gap: function(edge) {
      return edge._private.style['width'].pxValue * 2;
    }
  };
  
  arrowShapes['inhibitor'] = {
    _points: [
      -0.25, 0,
      -0.25, -0.1,
      0.25, -0.1,
      0.25, 0
    ],
    
    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      var points = arrowShapes['inhibitor']._points;
      
      return $$.math.pointInsidePolygon(
        x, y, points, centerX, centerY, width, height, direction, padding);
    },
    
    roughCollide: bbCollide,
    
    draw: function(context, size, angle, translation) {
      var points = arrowShapes['inhibitor']._points;
      
      for (var i = 0; i < points.length / 2; i++) {
        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );

        context.lineTo(pt.x, pt.y);
      }
    },
    
    spacing: function(edge) {
      return 1;
    },
    
    gap: function(edge) {
      return 1;
    }
  };

  arrowShapes['tee'] = arrowShapes['inhibitor'];

  arrowShapes['square'] = {
    _points: [
      -0.15, 0.00,
      0.15, 0.00,
      0.15, -0.3,
      -0.15, -0.3
    ],
    
    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      var points = arrowShapes['square']._points;
      
      return $$.math.pointInsidePolygon(
        x, y, points, centerX, centerY, width, height, direction, padding);
    },
    
    roughCollide: bbCollide,
    
    draw: function(context, size, angle, translation) {
      var points = arrowShapes['square']._points;
    
      for (var i = 0; i < points.length / 2; i++) {
        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );

        context.lineTo(pt.x, pt.y);
      }
    },
    
    spacing: function(edge) {
      return 0;
    },

    gap: function(edge) {
      return edge._private.style['width'].pxValue * 2;
    }
  };

  arrowShapes['diamond'] = {
    _points: [
      -0.15, -0.15,
      0, -0.3,
      0.15, -0.15,
      0, 0
    ],

    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      var points = arrowShapes['diamond']._points;
          
      return $$.math.pointInsidePolygon(
        x, y, points, centerX, centerY, width, height, direction, padding);
    },

    roughCollide: bbCollide,

    draw: function(context, size, angle, translation) {
      var points = arrowShapes['diamond']._points;
    
      for (var i = 0; i < points.length / 2; i++) {
        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );

        context.lineTo(pt.x, pt.y);
      }
    },
    
    spacing: function(edge) {
      return 0;
    },
    
    gap: function(edge) {
      return edge._private.style['width'].pxValue;
    }
  };

})( cytoscape );
;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');
  var CRp = CanvasRenderer.prototype;

  CRp.getCachedNodes = function() {
    var data = this.data; var cy = this.data.cy;
    
    if (data.cache == null) {
      data.cache = {};
    }
    
    if (data.cache.cachedNodes == null) {
      data.cache.cachedNodes = cy.nodes();
    }
    
    return data.cache.cachedNodes;
  };
  
  CRp.updateNodesCache = function() {
    var data = this.data; var cy = this.data.cy;
    
    if (data.cache == null) {
      data.cache = {};
    }
    
    data.cache.cachedNodes = cy.nodes();
  };
  
  CRp.getCachedEdges = function() {
    var data = this.data; var cy = this.data.cy;
    
    if (data.cache == null) {
      data.cache = {};
    }
    
    if (data.cache.cachedEdges == null) {
      data.cache.cachedEdges = cy.edges();
    }
    
    return data.cache.cachedEdges;
  };
  
  CRp.updateEdgesCache = function() {
    var data = this.data; var cy = this.data.cy;
    
    if (data.cache == null) {
      data.cache = {};
    }
    
    data.cache.cachedEdges = cy.edges();
  };

})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');
  var CRp = CanvasRenderer.prototype;

  // Project mouse
  CRp.projectIntoViewport = function(clientX, clientY) {
    var offsets = this.findContainerClientCoords();
    var offsetLeft = offsets[0];
    var offsetTop = offsets[1];
    
    var x = clientX - offsetLeft; 
    var y = clientY - offsetTop;
    
    x -= this.data.cy.pan().x; y -= this.data.cy.pan().y; x /= this.data.cy.zoom(); y /= this.data.cy.zoom();
    return [x, y];
  };

  CRp.findContainerClientCoords = function() {
    var container = this.data.container;

    var bb = this.containerBB = this.containerBB || container.getBoundingClientRect();

    return [bb.left, bb.top, bb.right - bb.left, bb.bottom - bb.top];
  };

  CRp.invalidateContainerClientCoordsCache = function(){
    this.containerBB = null;
  };

  // Find nearest element
  CRp.findNearestElement = function(x, y, visibleElementsOnly, isTouch){
    var self = this;
    var eles = this.getCachedZSortedEles();
    var near = [];
    var zoom = this.data.cy.zoom();
    var hasCompounds = this.data.cy.hasCompoundNodes();
    var edgeThreshold = (isTouch ? 24 : 8) / zoom;
    var nodeThreshold = (isTouch ? 8 : 2) / zoom;

    function checkNode(node){
      var width = node.outerWidth() + 2*nodeThreshold;
      var height = node.outerHeight() + 2*nodeThreshold;
      var hw = width/2;
      var hh = height/2;
      var pos = node._private.position;

      if(
        pos.x - hw <= x && x <= pos.x + hw // bb check x
          &&
        pos.y - hh <= y && y <= pos.y + hh // bb check y
      ){
        var visible = !visibleElementsOnly || ( node.visible() && !node.transparent() );

        // exit early if invisible edge and must be visible
        if( visibleElementsOnly && !visible ){
          return;
        }

        var shape = CanvasRenderer.nodeShapes[ self.getNodeShape(node) ];
        var borderWO = node._private.style['border-width'].pxValue / 2;

        if(
          shape.checkPoint(x, y, 0, width, height, pos.x, pos.y)
        ){
          near.push( node );
        }

      }
    }

    function checkEdge(edge){
      var rs = edge._private.rscratch;
      var style = edge._private.style;
      var width = style['width'].pxValue/2 + edgeThreshold; // more like a distance radius from centre
      var widthSq = width * width;
      var width2 = width * 2;
      var src = edge._private.source;
      var tgt = edge._private.target;
      var inEdgeBB = false;
      var sqDist;

      // exit early if invisible edge and must be visible
      var passedVisibilityCheck;
      var passesVisibilityCheck = function(){
        if( passedVisibilityCheck !== undefined ){
          return passedVisibilityCheck;
        }

        if( !visibleElementsOnly ){
          passedVisibilityCheck = true;
          return true;
        }

        var visible = edge.visible() && !edge.transparent();
        if( visible ){
          passedVisibilityCheck = true;
          return true;
        }

        passedVisibilityCheck = false;
        return false;
      };

      if (rs.edgeType === 'self' || rs.edgeType === 'compound') {
        if(
            (
              (inEdgeBB = $$.math.inBezierVicinity(x, y, rs.startX, rs.startY, rs.cp2ax, rs.cp2ay, rs.selfEdgeMidX, rs.selfEdgeMidY, widthSq))
                && passesVisibilityCheck() &&
              ( widthSq > (sqDist = $$.math.sqDistanceToQuadraticBezier(x, y, rs.startX, rs.startY, rs.cp2ax, rs.cp2ay, rs.selfEdgeMidX, rs.selfEdgeMidY)) )
            )
              ||
            (
              (inEdgeBB = $$.math.inBezierVicinity(x, y, rs.selfEdgeMidX, rs.selfEdgeMidY, rs.cp2cx, rs.cp2cy, rs.endX, rs.endY, widthSq))
                && passesVisibilityCheck() &&
              ( widthSq > (sqDist = $$.math.sqDistanceToQuadraticBezier(x, y, rs.selfEdgeMidX, rs.selfEdgeMidY, rs.cp2cx, rs.cp2cy, rs.endX, rs.endY)) )
            )
        ){
          near.push( edge );
        }
      
      } else if (rs.edgeType === 'haystack') {
        var radius = style['haystack-radius'].value;
        var halfRadius = radius/2; // b/c have to half width/height

        var tgtPos = tgt._private.position;
        var tgtW = tgt.width();
        var tgtH = tgt.height();
        var srcPos = src._private.position;
        var srcW = src.width();
        var srcH = src.height();

        var startX = srcPos.x + rs.source.x * srcW * halfRadius;
        var startY = srcPos.y + rs.source.y * srcH * halfRadius;
        var endX = tgtPos.x + rs.target.x * tgtW * halfRadius;
        var endY = tgtPos.y + rs.target.y * tgtH * halfRadius;

        if( 
          (inEdgeBB = $$.math.inLineVicinity(x, y, startX, startY, endX, endY, width2))
            && passesVisibilityCheck() &&
          widthSq > ( sqDist = $$.math.sqDistanceToFiniteLine( x, y, startX, startY, endX, endY ) )
        ){
          near.push( edge );
        }
      
      } else if (rs.edgeType === 'straight') {
        if(
          (inEdgeBB = $$.math.inLineVicinity(x, y, rs.startX, rs.startY, rs.endX, rs.endY, width2))
            && passesVisibilityCheck() &&
          widthSq > ( sqDist = $$.math.sqDistanceToFiniteLine(x, y, rs.startX, rs.startY, rs.endX, rs.endY) )
        ){
          near.push( edge );
        }
      
      } else if (rs.edgeType === 'bezier') {
        if(
          (inEdgeBB = $$.math.inBezierVicinity(x, y, rs.startX, rs.startY, rs.cp2x, rs.cp2y, rs.endX, rs.endY, widthSq))
            && passesVisibilityCheck() &&
          (widthSq > (sqDist = $$.math.sqDistanceToQuadraticBezier(x, y, rs.startX, rs.startY, rs.cp2x, rs.cp2y, rs.endX, rs.endY)) )
        ){
          near.push( edge );
        }
      }
      
      // if we're close to the edge but didn't hit it, maybe we hit its arrows
      if( inEdgeBB && passesVisibilityCheck() && near.length === 0 || near[near.length - 1] !== edge ){
        var srcShape = CanvasRenderer.arrowShapes[ style['source-arrow-shape'].value ];
        var tgtShape = CanvasRenderer.arrowShapes[ style['target-arrow-shape'].value ];

        var src = src || edge._private.source;
        var tgt = tgt || edge._private.target;

        var tgtPos = tgt._private.position;
        var srcPos = src._private.position;

        var srcArW = self.getArrowWidth( style['width'].pxValue );
        var srcArH = self.getArrowHeight( style['width'].pxValue );

        var tgtArW = srcArW;
        var tgtArH = srcArH;

        if(
          (
            srcShape.roughCollide(x, y, rs.arrowStartX, rs.arrowStartY, srcArW, srcArH, [rs.arrowStartX - srcPos.x, rs.arrowStartY - srcPos.y], edgeThreshold)
              && 
            srcShape.collide(x, y, rs.arrowStartX, rs.arrowStartY, srcArW, srcArH, [rs.arrowStartX - srcPos.x, rs.arrowStartY - srcPos.y], edgeThreshold)
          )
            ||
          (
            tgtShape.roughCollide(x, y, rs.arrowEndX, rs.arrowEndY, tgtArW, tgtArH, [rs.arrowEndX - tgtPos.x, rs.arrowEndY - tgtPos.y], edgeThreshold)
              &&
            tgtShape.collide(x, y, rs.arrowEndX, rs.arrowEndY, tgtArW, tgtArH, [rs.arrowEndX - tgtPos.x, rs.arrowEndY - tgtPos.y], edgeThreshold)
          )
        ){
          near.push( edge );
        }
      }

      // for compound graphs, hitting edge may actually want a connected node instead (b/c edge may have greater z-index precedence)
      if( hasCompounds &&  near.length > 0 && near[ near.length - 1 ] === edge ){
        checkNode( src );
        checkNode( tgt );
      }
    }

    for( var i = eles.length - 1; i >= 0; i-- ){ // reverse order for precedence
      var ele = eles[i];

      if( near.length > 0 ){ break; } // since we check in z-order, first found is top and best result => exit early

      if( ele._private.group === 'nodes' ){ 
        checkNode( eles[i] );

      } else  { // then edge
        checkEdge( eles[i] );
      }

    }
  
    
    if( near.length > 0 ){
      return near[ near.length - 1 ];
    } else {
      return null;
    }
  }; 

  // 'Give me everything from this box'
  CRp.getAllInBox = function(x1, y1, x2, y2) {
    var nodes = this.getCachedNodes();
    var edges = this.getCachedEdges();
    var box = [];
    
    var x1c = Math.min(x1, x2);
    var x2c = Math.max(x1, x2);
    var y1c = Math.min(y1, y2);
    var y2c = Math.max(y1, y2); 

    x1 = x1c; 
    x2 = x2c; 
    y1 = y1c; 
    y2 = y2c; 

    var heur;
    
    for ( var i = 0; i < nodes.length; i++ ){
      var pos = nodes[i]._private.position;
      var nShape = this.getNodeShape(nodes[i]);
      var w = this.getNodeWidth(nodes[i]);
      var h = this.getNodeHeight(nodes[i]);
      var border = nodes[i]._private.style['border-width'].pxValue / 2;
      var shapeObj = CanvasRenderer.nodeShapes[ nShape ];

      if ( shapeObj.intersectBox(x1, y1, x2, y2, w, h, pos.x, pos.y, border) ){
        box.push(nodes[i]);
      }
    }
    
    for ( var i = 0; i < edges.length; i++ ){
      var rs = edges[i]._private.rscratch;

      if (edges[i]._private.rscratch.edgeType == 'self') {
        if ((heur = $$.math.boxInBezierVicinity(x1, y1, x2, y2,
            rs.startX, rs.startY,
            rs.cp2ax, rs.cp2ay,
            rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))
              &&
            (heur == 2 || (heur == 1 && $$.math.checkBezierInBox(x1, y1, x2, y2,
              rs.startX, rs.startY,
              rs.cp2ax, rs.cp2ay,
              rs.endX, rs.endY, edges[i]._private.style['width'].pxValue)))
                ||
          (heur = $$.math.boxInBezierVicinity(x1, y1, x2, y2,
            rs.startX, rs.startY,
            rs.cp2cx, rs.cp2cy,
            rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))
              &&
            (heur == 2 || (heur == 1 && $$.math.checkBezierInBox(x1, y1, x2, y2,
              rs.startX, rs.startY,
              rs.cp2cx, rs.cp2cy,
              rs.endX, rs.endY, edges[i]._private.style['width'].pxValue)))
          )
        { box.push(edges[i]); }
      }
      
      if (rs.edgeType == 'bezier' &&
        (heur = $$.math.boxInBezierVicinity(x1, y1, x2, y2,
            rs.startX, rs.startY,
            rs.cp2x, rs.cp2y,
            rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))
              &&
            (heur == 2 || (heur == 1 && $$.math.checkBezierInBox(x1, y1, x2, y2,
              rs.startX, rs.startY,
              rs.cp2x, rs.cp2y,
              rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))))
        { box.push(edges[i]); }
    
      if (rs.edgeType == 'straight' &&
        (heur = $$.math.boxInBezierVicinity(x1, y1, x2, y2,
            rs.startX, rs.startY,
            rs.startX * 0.5 + rs.endX * 0.5, 
            rs.startY * 0.5 + rs.endY * 0.5, 
            rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))
              && /* console.log('test', heur) == undefined && */
            (heur == 2 || (heur == 1 && $$.math.checkStraightEdgeInBox(x1, y1, x2, y2,
              rs.startX, rs.startY,
              rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))))
        { box.push(edges[i]); }


      if (rs.edgeType == 'haystack'){
        var tgt = edges[i].target()[0];
        var tgtPos = tgt.position();
        var src = edges[i].source()[0];
        var srcPos = src.position();

        var startX = srcPos.x + rs.source.x;
        var startY = srcPos.y + rs.source.y;
        var endX = tgtPos.x + rs.target.x;
        var endY = tgtPos.y + rs.target.y;

        var startInBox = (x1 <= startX && startX <= x2) && (y1 <= startY && startY <= y2);
        var endInBox = (x1 <= endX && endX <= x2) && (y1 <= endY && endY <= y2);

        if( startInBox && endInBox ){
          box.push( edges[i] );
        }
      }
      
    }
    
    return box;
  };


  /**
   * Returns the width of the given node. If the width is set to auto,
   * returns the value of the autoWidth field.
   *
   * @param node          a node
   * @return {number}     width of the node
   */
  CRp.getNodeWidth = function(node)
  {
    return node.width();
  };

  /**
   * Returns the height of the given node. If the height is set to auto,
   * returns the value of the autoHeight field.
   *
   * @param node          a node
   * @return {number}     width of the node
   */
  CRp.getNodeHeight = function(node)
  {
    return node.height();
  };

  /**
   * Returns the shape of the given node. If the height or width of the given node
   * is set to auto, the node is considered to be a compound.
   *
   * @param node          a node
   * @return {String}     shape of the node
   */
  CRp.getNodeShape = function(node)
  {
    // TODO only allow rectangle for a compound node?
//    if (node._private.style['width'].value == 'auto' ||
//        node._private.style['height'].value == 'auto')
//    {
//      return 'rectangle';
//    }

    var shape = node._private.style['shape'].value;

    if( node.isParent() ){
      if( shape === 'rectangle' || shape === 'roundrectangle' ){
        return shape;
      } else {
        return 'rectangle';
      }
    }

    return shape;
  };


  CRp.getNodePadding = function(node)
  {
    var left = node._private.style['padding-left'].pxValue;
    var right = node._private.style['padding-right'].pxValue;
    var top = node._private.style['padding-top'].pxValue;
    var bottom = node._private.style['padding-bottom'].pxValue;

    if (isNaN(left))
    {
      left = 0;
    }

    if (isNaN(right))
    {
      right = 0;
    }

    if (isNaN(top))
    {
      top = 0;
    }

    if (isNaN(bottom))
    {
      bottom = 0;
    }

    return {left : left,
      right : right,
      top : top,
      bottom : bottom};
  };

  CRp.zOrderSort = $$.Collection.zIndexSort;

  CRp.updateCachedZSortedEles = function(){
    this.getCachedZSortedEles( true );
  };

  CRp.getCachedZSortedEles = function( forceRecalc ){
    var lastNodes = this.lastZOrderCachedNodes;
    var lastEdges = this.lastZOrderCachedEdges;
    var nodes = this.getCachedNodes();
    var edges = this.getCachedEdges();
    var eles = [];

    if( forceRecalc || !lastNodes || !lastEdges || lastNodes !== nodes || lastEdges !== edges ){ 
      //console.time('cachezorder')
      
      for( var i = 0; i < nodes.length; i++ ){
        if( nodes[i].visible() && !nodes[i].transparent() ){
          eles.push( nodes[i] );
        }
      }

      for( var i = 0; i < edges.length; i++ ){
        if( edges[i].visible() && !edges[i].transparent() ){
          eles.push( edges[i] );
        }
      }

      eles.sort( this.zOrderSort );
      this.cachedZSortedEles = eles;
      //console.log('make cache')

      //console.timeEnd('cachezorder')
    } else {
      eles = this.cachedZSortedEles;
      //console.log('read cache')
    }

    this.lastZOrderCachedNodes = nodes;
    this.lastZOrderCachedEdges = edges;

    return eles;
  };

  CRp.projectBezier = function(edge){
    var qbezierAt = $$.math.qbezierAt;
    var rs = edge._private.rscratch;
    var bpts = edge._private.rstyle.bezierPts = [];

    function pushBezierPts(pts){
      bpts.push({
        x: qbezierAt( pts[0], pts[2], pts[4], 0.05 ),
        y: qbezierAt( pts[1], pts[3], pts[5], 0.05 )
      });

      bpts.push({
        x: qbezierAt( pts[0], pts[2], pts[4], 0.25 ),
        y: qbezierAt( pts[1], pts[3], pts[5], 0.25 )
      });

      bpts.push({
        x: qbezierAt( pts[0], pts[2], pts[4], 0.4 ),
        y: qbezierAt( pts[1], pts[3], pts[5], 0.4 )
      });

      var mid = {
        x: qbezierAt( pts[0], pts[2], pts[4], 0.5 ),
        y: qbezierAt( pts[1], pts[3], pts[5], 0.5 )
      };

      bpts.push( mid );

      if( rs.edgeType === 'self' || rs.edgeType === 'compound' ){
        rs.midX = rs.selfEdgeMidX;
        rs.midY = rs.selfEdgeMidY;
      } else {
        rs.midX = mid.x;
        rs.midY = mid.y;
      }

      bpts.push({
        x: qbezierAt( pts[0], pts[2], pts[4], 0.6 ),
        y: qbezierAt( pts[1], pts[3], pts[5], 0.6 )
      });

      bpts.push({
        x: qbezierAt( pts[0], pts[2], pts[4], 0.75 ),
        y: qbezierAt( pts[1], pts[3], pts[5], 0.75 )
      });

      bpts.push({
        x: qbezierAt( pts[0], pts[2], pts[4], 0.95 ),
        y: qbezierAt( pts[1], pts[3], pts[5], 0.95 )
      });
    }

    if( rs.edgeType === 'self' ){
      pushBezierPts( [rs.startX, rs.startY, rs.cp2ax, rs.cp2ay, rs.selfEdgeMidX, rs.selfEdgeMidY] );
      pushBezierPts( [rs.selfEdgeMidX, rs.selfEdgeMidY, rs.cp2cx, rs.cp2cy, rs.endX, rs.endY] );
    } else if( rs.edgeType === 'bezier' ){
      pushBezierPts( [rs.startX, rs.startY, rs.cp2x, rs.cp2y, rs.endX, rs.endY] );
    }
  };

  CRp.recalculateNodeLabelProjection = function( node ){ 
    var content = node._private.style['content'].strValue;
    if( !content || content.match(/^\s+$/) ){ return; }

    var textX, textY;
    var nodeWidth = node.outerWidth();
    var nodeHeight = node.outerHeight();
    var nodePos = node._private.position;
    var textHalign = node._private.style['text-halign'].strValue;
    var textValign = node._private.style['text-valign'].strValue;
    var rs = node._private.rscratch;
    var rstyle = node._private.rstyle;

    switch( textHalign ){
      case 'left':
        textX = nodePos.x - nodeWidth / 2;
        break;

      case 'right':
        textX = nodePos.x + nodeWidth / 2;
        break;

      default: // e.g. center
        textX = nodePos.x;
    }

    switch( textValign ){
      case 'top':
        textY = nodePos.y - nodeHeight / 2;
        break;

      case 'bottom':
        textY = nodePos.y + nodeHeight / 2;
        break;

      default: // e.g. middle
        textY = nodePos.y;
    }
  
    rs.labelX = textX;
    rs.labelY = textY;
    rstyle.labelX = textX;
    rstyle.labelY = textY;

    this.applyLabelDimensions( node );
  };

  CRp.recalculateEdgeLabelProjection = function( edge ){
    var content = edge._private.style['content'].strValue;
    if( !content || content.match(/^\s+$/) ){ return; }

    var textX, textY;  
    var edgeCenterX, edgeCenterY;
    var _p = edge._private;
    var rs = _p.rscratch;
    //var style = _p.style;
    var rstyle = _p.rstyle;
    
    if (rs.edgeType == 'self') {
      edgeCenterX = rs.selfEdgeMidX;
      edgeCenterY = rs.selfEdgeMidY;
    } else if (rs.edgeType == 'straight') {
      edgeCenterX = (rs.startX + rs.endX) / 2;
      edgeCenterY = (rs.startY + rs.endY) / 2;
    } else if (rs.edgeType == 'bezier') {
      edgeCenterX = $$.math.qbezierAt( rs.startX, rs.cp2x, rs.endX, 0.5 );
      edgeCenterY = $$.math.qbezierAt( rs.startY, rs.cp2y, rs.endY, 0.5 );
    } else if (rs.edgeType == 'haystack') {
      // var src = _p.source;
      // var tgt = _p.target;
      // var srcPos = src._private.position;
      // var tgtPos = tgt._private.position;
      var pts = rs.haystackPts;

      edgeCenterX = ( pts[0] + pts[2] )/2;
      edgeCenterY = ( pts[1] + pts[3] )/2;
    }
    
    textX = edgeCenterX;
    textY = edgeCenterY;

    // add center point to style so bounding box calculations can use it
    rs.labelX = textX;
    rs.labelY = textY;
    rstyle.labelX = textX;
    rstyle.labelY = textY;

    this.applyLabelDimensions( edge );
  };

  CRp.applyLabelDimensions = function( ele ){
    var rs = ele._private.rscratch;
    var rstyle = ele._private.rstyle;

    var text = this.getLabelText( ele );
    var labelDims = this.calculateLabelDimensions( ele, text );
 
    rstyle.labelWidth = labelDims.width;
    rs.labelWidth = labelDims.width;
 
    rstyle.labelHeight = labelDims.height;
    rs.labelHeight = labelDims.height;
  };

  CRp.getLabelText = function( ele ){ 
    var style = ele._private.style;
    var text = ele._private.style['content'].strValue;
    var textTransform = style['text-transform'].value;
    var rscratch = ele._private.rscratch;
    
    if (textTransform == 'none') {
    } else if (textTransform == 'uppercase') {
      text = text.toUpperCase();
    } else if (textTransform == 'lowercase') {
      text = text.toLowerCase();
    }

    if( style['text-wrap'].value === 'wrap' ){
      //console.log('wrap'); 
      
      // save recalc if the label is the same as before
      if( rscratch.labelWrapKey === rscratch.labelKey ){ 
        // console.log('wrap cache hit');
        return rscratch.labelWrapCachedText;
      }
      // console.log('wrap cache miss');

      var lines = text.split('\n');
      var maxW = style['text-max-width'].pxValue;
      var wrappedLines = [];

      for( var l = 0; l < lines.length; l++ ){
        var line = lines[l];
        var lineDims = this.calculateLabelDimensions( ele, line, 'line=' + line );
        var lineW = lineDims.width;

        if( lineW > maxW ){ // line is too long
          var words = line.split(/\s+/); // NB: assume collapsed whitespace into single space
          var subline = '';

          for( var w = 0; w < words.length; w++ ){
            var word = words[w];
            var testLine = subline.length === 0 ? word : subline + ' ' + word;
            var testDims = this.calculateLabelDimensions( ele, testLine, 'testLine=' + testLine );
            var testW = testDims.width;

            if( testW <= maxW ){ // word fits on current line
              subline += word + ' ';
            } else { // word starts new line
              wrappedLines.push( subline );
              subline = word + ' ';
            }
          }

          // if there's remaining text, put it in a wrapped line
          if( !subline.match(/^\s+$/) ){
            wrappedLines.push( subline );
          }
        } else { // line is already short enough
          wrappedLines.push( line );
        }
      } // for

      rscratch.labelWrapCachedLines = wrappedLines;
      rscratch.labelWrapCachedText = text = wrappedLines.join('\n');
      rscratch.labelWrapKey = rscratch.labelKey;

      // console.log(text)
    } // if wrap

    return text;
  };

  CRp.calculateLabelDimensions = function( ele, text, extraKey ){
    var r = this;
    var style = ele._private.style;
    var fStyle = style['font-style'].strValue;
    var size = style['font-size'].pxValue + 'px';
    var family = style['font-family'].strValue;
    // var variant = style['font-variant'].strValue;
    var weight = style['font-weight'].strValue;

    var cacheKey = ele._private.labelKey;

    if( extraKey ){
      cacheKey += '$@$' + extraKey;
    }

    var cache = r.labelDimCache || (r.labelDimCache = {});

    if( cache[cacheKey] ){
      return cache[cacheKey];
    }

    var div = this.labelCalcDiv;

    if( !div ){
      div = this.labelCalcDiv = document.createElement('div');
      document.body.appendChild( div );
    }

    var ds = div.style;

    // from ele style
    ds.fontFamily = family;
    ds.fontStyle = fStyle;
    ds.fontSize = size;
    // ds.fontVariant = variant;
    ds.fontWeight = weight;

    // forced style
    ds.position = 'absolute';
    ds.left = '-9999px';
    ds.top = '-9999px';
    ds.zIndex = '-1';
    ds.visibility = 'hidden';
    ds.pointerEvents = 'none';
    ds.padding = '0';
    ds.lineHeight = '1';

    if( style['text-wrap'].value === 'wrap' ){
      ds.whiteSpace = 'pre'; // so newlines are taken into account
    } else {
      ds.whiteSpace = 'normal';
    }

    // put label content in div
    div.textContent = text;

    cache[cacheKey] = {
      width: div.clientWidth,
      height: div.clientHeight
    };

    return cache[cacheKey];
  };  

  CRp.recalculateRenderedStyle = function( eles ){
    var edges = [];
    var nodes = [];
    var handledEdge = {};

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[i];
      var _p = ele._private;
      var style = _p.style;
      var rs = _p.rscratch;
      var rstyle = _p.rstyle;
      var id = _p.data.id;
      var bbStyleSame = rs.boundingBoxKey != null && _p.boundingBoxKey === rs.boundingBoxKey;
      var labelStyleSame = rs.labelKey != null && _p.labelKey === rs.labelKey;
      var styleSame = bbStyleSame && labelStyleSame;

      if( ele._private.group === 'nodes' ){
        var pos = _p.position;
        var posSame = rstyle.nodeX != null && rstyle.nodeY != null && pos.x === rstyle.nodeX && pos.y === rstyle.nodeY;
        var wSame = rstyle.nodeW != null && rstyle.nodeW === style['width'].pxValue;
        var hSame = rstyle.nodeH != null && rstyle.nodeH === style['height'].pxValue;

        if( !posSame || !styleSame || !wSame || !hSame ){
          nodes.push( ele );
        }

        rstyle.nodeX = pos.x;
        rstyle.nodeY = pos.y;
        rstyle.nodeW = style['width'].pxValue;
        rstyle.nodeH = style['height'].pxValue;
      } else { // edges

        var srcPos = ele._private.source._private.position;
        var tgtPos = ele._private.target._private.position;
        var srcSame = rstyle.srcX != null && rstyle.srcY != null && srcPos.x === rstyle.srcX && srcPos.y === rstyle.srcY;
        var tgtSame = rstyle.tgtX != null && rstyle.tgtY != null && tgtPos.x === rstyle.tgtX && tgtPos.y === rstyle.tgtY;
        var positionsSame = srcSame && tgtSame;

        if( !positionsSame || !styleSame ){
          var curveType = _p.style['curve-style'].value;

          if( curveType === 'bezier' ){
            if( !handledEdge[ id ] ){
              edges.push( ele );
              handledEdge[ id ] = true;

              var parallelEdges = ele.parallelEdges();
              for( var i = 0; i < parallelEdges.length; i++ ){
                var pEdge = parallelEdges[i];
                var pId = pEdge._private.data.id;

                if( !handledEdge[ pId ] ){
                  edges.push( pEdge );
                  handledEdge[ pId ] = true;
                }
                
              }
            }
          } else {
            edges.push( ele );
          }
        } // if positions diff

        // update rstyle positions
        rstyle.srcX = srcPos.x;
        rstyle.srcY = srcPos.y;
        rstyle.tgtX = tgtPos.x;
        rstyle.tgtY = tgtPos.y;

      } // if edges

      rs.boundingBoxKey = _p.boundingBoxKey;
      rs.labelKey = _p.labelKey;
    }

    this.recalculateEdgeProjections( edges );
    this.recalculateLabelProjections( nodes, edges );
  };

  CRp.recalculateLabelProjections = function( nodes, edges ){
    for( var i = 0; i < nodes.length; i++ ){
      this.recalculateNodeLabelProjection( nodes[i] );
    }

    for( var i = 0; i < edges.length; i++ ){
      this.recalculateEdgeLabelProjection( edges[i] );
    }
  };

  CRp.recalculateEdgeProjections = function( edges ){
    this.findEdgeControlPoints( edges );
  };


  // Find edge control points
  CRp.findEdgeControlPoints = function(edges) {
    if( !edges || edges.length === 0 ){ return; }

    var cy = this.data.cy;
    var hasCompounds = cy.hasCompoundNodes();
    var hashTable = {};
    var pairIds = [];
    var haystackEdges = [];

    // create a table of edge (src, tgt) => list of edges between them
    var pairId;
    for (var i = 0; i < edges.length; i++){
      var edge = edges[i];
      var style = edge._private.style;
      var edgeIsUnbundled = style['curve-style'].value === 'unbundled-bezier';

      // ignore edges who are not to be displayed
      // they shouldn't take up space
      if( style.display.value === 'none' ){
        continue;
      }

      if( style['curve-style'].value === 'haystack' ){
        haystackEdges.push( edge );
        continue;
      }

      var srcId = edge._private.data.source;
      var tgtId = edge._private.data.target;

      pairId = srcId > tgtId ?
        tgtId + '-' + srcId :
        srcId + '-' + tgtId ;

      if( edgeIsUnbundled ){
        pairId = 'unbundled' + edge._private.data.id;
      }

      if (hashTable[pairId] == null) {
        hashTable[pairId] = [];
        pairIds.push( pairId );
      }
      
      hashTable[pairId].push( edge );

      if( edgeIsUnbundled ){
        hashTable[pairId].hasUnbundled = true;
      }
    }

    var src, tgt, srcPos, tgtPos, srcW, srcH, tgtW, tgtH, srcShape, tgtShape, srcBorder, tgtBorder;
    var vectorNormInverse;
    var badBezier;
    
    // for each pair (src, tgt), create the ctrl pts
    // Nested for loop is OK; total number of iterations for both loops = edgeCount  
    for (var p = 0; p < pairIds.length; p++) {
      pairId = pairIds[p];
      var pairEdges = hashTable[pairId];
    
      // for each pair id, the edges should be sorted by index
      pairEdges.sort(function(edge1, edge2){
        return edge1._private.index - edge2._private.index;
      });

      src = pairEdges[0]._private.source;
      tgt = pairEdges[0]._private.target;

      // make sure src/tgt distinction is consistent
      // (src/tgt in this case are just for ctrlpts and don't actually have to be true src/tgt)
      if( src._private.data.id > tgt._private.data.id ){
        var temp = src;
        src = tgt;
        tgt = temp;
      }

      srcPos = src._private.position;
      tgtPos = tgt._private.position;

      srcW = this.getNodeWidth(src);
      srcH = this.getNodeHeight(src);

      tgtW = this.getNodeWidth(tgt);
      tgtH = this.getNodeHeight(tgt);

      srcShape = CanvasRenderer.nodeShapes[ this.getNodeShape(src) ];
      tgtShape = CanvasRenderer.nodeShapes[ this.getNodeShape(tgt) ];

      srcBorder = src._private.style['border-width'].pxValue;
      tgtBorder = tgt._private.style['border-width'].pxValue;

      badBezier = false;
      

      if( (pairEdges.length > 1 && src !== tgt) || pairEdges.hasUnbundled ){

        // pt outside src shape to calc distance/displacement from src to tgt
        var srcOutside = srcShape.intersectLine(
          srcPos.x,
          srcPos.y,
          srcW,
          srcH,
          tgtPos.x,
          tgtPos.y,
          srcBorder / 2
        );

        // pt outside tgt shape to calc distance/displacement from src to tgt
        var tgtOutside = tgtShape.intersectLine(
          tgtPos.x,
          tgtPos.y,
          tgtW,
          tgtH,
          srcPos.x,
          srcPos.y,
          tgtBorder / 2
        );

        var midptSrcPts = {
          x1: srcOutside[0],
          x2: tgtOutside[0],
          y1: srcOutside[1],
          y2: tgtOutside[1]
        };

        var dy = ( tgtOutside[1] - srcOutside[1] );
        var dx = ( tgtOutside[0] - srcOutside[0] );
        var l = Math.sqrt( dx*dx + dy*dy );

        var vector = {
          x: dx,
          y: dy
        };
        
        var vectorNorm = {
          x: vector.x/l,
          y: vector.y/l
        };
        vectorNormInverse = {
          x: -vectorNorm.y,
          y: vectorNorm.x
        };

        // if src intersection is inside tgt or tgt intersection is inside src, then no ctrl pts to draw
        if( 
          tgtShape.checkPoint( srcOutside[0], srcOutside[1], tgtBorder/2, tgtW, tgtH, tgtPos.x, tgtPos.y )  ||
          srcShape.checkPoint( tgtOutside[0], tgtOutside[1], srcBorder/2, srcW, srcH, srcPos.x, srcPos.y ) 
        ){
          vectorNormInverse = {};
          badBezier = true;
        }
        
      }
      
      var edge;
      var rs;
      
      for (var i = 0; i < pairEdges.length; i++) {
        edge = pairEdges[i];
        rs = edge._private.rscratch;
        
        var edgeIndex1 = rs.lastEdgeIndex;
        var edgeIndex2 = i;

        var numEdges1 = rs.lastNumEdges;
        var numEdges2 = pairEdges.length;

        var eStyle = edge._private.style;
        var stepSize = eStyle['control-point-step-size'].pxValue;
        var stepDist = eStyle['control-point-distance'] !== undefined ? eStyle['control-point-distance'].pxValue : undefined;
        var stepWeight = eStyle['control-point-weight'].value;
        var edgeIsUnbundled = eStyle['curve-style'].value === 'unbundled-bezier';
        
        var swappedDirection = edge._private.source !== src;

        if( swappedDirection && edgeIsUnbundled ){
          stepDist *= -1;
        }

        var srcX1 = rs.lastSrcCtlPtX;
        var srcX2 = srcPos.x;
        var srcY1 = rs.lastSrcCtlPtY;
        var srcY2 = srcPos.y;
        var srcW1 = rs.lastSrcCtlPtW;
        var srcW2 = src.outerWidth();
        var srcH1 = rs.lastSrcCtlPtH;
        var srcH2 = src.outerHeight();

        var tgtX1 = rs.lastTgtCtlPtX;
        var tgtX2 = tgtPos.x;
        var tgtY1 = rs.lastTgtCtlPtY;
        var tgtY2 = tgtPos.y;
        var tgtW1 = rs.lastTgtCtlPtW;
        var tgtW2 = tgt.outerWidth();
        var tgtH1 = rs.lastTgtCtlPtH;
        var tgtH2 = tgt.outerHeight();

        var width1 = rs.lastW;
        var width2 = eStyle['control-point-step-size'].pxValue;

        if( badBezier ){
          rs.badBezier = true;
        } else {
          rs.badBezier = false;
        }

        if( srcX1 === srcX2 && srcY1 === srcY2 && srcW1 === srcW2 && srcH1 === srcH2
        &&  tgtX1 === tgtX2 && tgtY1 === tgtY2 && tgtW1 === tgtW2 && tgtH1 === tgtH2
        &&  width1 === width2
        &&  ((edgeIndex1 === edgeIndex2 && numEdges1 === numEdges2) || edgeIsUnbundled) ){
          // console.log('edge ctrl pt cache HIT')
          continue; // then the control points haven't changed and we can skip calculating them
        } else {
          rs.lastSrcCtlPtX = srcX2;
          rs.lastSrcCtlPtY = srcY2;
          rs.lastSrcCtlPtW = srcW2;
          rs.lastSrcCtlPtH = srcH2;
          rs.lastTgtCtlPtX = tgtX2;
          rs.lastTgtCtlPtY = tgtY2;
          rs.lastTgtCtlPtW = tgtW2;
          rs.lastTgtCtlPtH = tgtH2;
          rs.lastEdgeIndex = edgeIndex2;
          rs.lastNumEdges = numEdges2;
          rs.lastWidth = width2;
          // console.log('edge ctrl pt cache MISS')
        }

        // Self-edge
        if ( src === tgt ) {
            
          rs.edgeType = 'self';
          
          var j = i;
          var loopDist = stepSize;

          if( edgeIsUnbundled ){
            j = 0;
            loopDist = stepDist;
          }

          // New -- fix for large nodes
          rs.cp2ax = srcPos.x;
          rs.cp2ay = srcPos.y - (1 + Math.pow(srcH, 1.12) / 100) * loopDist * (j / 3 + 1);
          
          rs.cp2cx = srcPos.x - (1 + Math.pow(srcW, 1.12) / 100) * loopDist * (j / 3 + 1);
          rs.cp2cy = srcPos.y;
          
          rs.selfEdgeMidX = (rs.cp2ax + rs.cp2cx) / 2.0;
          rs.selfEdgeMidY = (rs.cp2ay + rs.cp2cy) / 2.0;
        
        // Compound edge
        } else if(
          hasCompounds &&
          ( src.isParent() || src.isChild() || tgt.isParent() || tgt.isChild() ) &&
          ( src.parents().anySame(tgt) || tgt.parents().anySame(src) )
        ){

          rs.edgeType = 'compound';

          // because the line approximation doesn't apply for compound beziers
          // (loop/self edges are already elided b/c of cheap src==tgt check)
          rs.badBezier = false;

          var j = i;
          var loopDist = stepSize;

          if( edgeIsUnbundled ){
            j = 0;
            loopDist = stepDist;
          }

          
          var loopW = 50;

          var loopaPos = {
            x: srcPos.x - srcW/2,
            y: srcPos.y - srcH/2
          };

          var loopbPos = {
            x: tgtPos.x - tgtW/2,
            y: tgtPos.y - tgtH/2
          };

          var minCompoundStretch = 1;

          rs.cp2ax = loopaPos.x;
          rs.compoundStretchA = Math.max( minCompoundStretch, Math.log(srcW * 0.01) ); // avoids cases with impossible beziers
          rs.cp2ay = loopaPos.y - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * rs.compoundStretchA;
          
          rs.compoundStretchB = Math.max( minCompoundStretch, Math.log(tgtW * 0.01) ); // avoids cases with impossible beziers
          rs.cp2cx = loopbPos.x - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * rs.compoundStretchB;
          rs.cp2cy = loopbPos.y;
          
          rs.selfEdgeMidX = (rs.cp2ax + rs.cp2cx) / 2.0;
          rs.selfEdgeMidY = (rs.cp2ay + rs.cp2cy) / 2.0;

        // Straight edge
        } else if (pairEdges.length % 2 === 1
          && i === Math.floor(pairEdges.length / 2)
          && !edgeIsUnbundled ) {
          
          rs.edgeType = 'straight';
          
        // Bezier edge
        } else {
          var normStepDist = (0.5 - pairEdges.length / 2 + i) * stepSize;
          var manStepDist;
          var sign = $$.math.signum( normStepDist );

          if( edgeIsUnbundled ){
            manStepDist = stepDist;
          } else {
            manStepDist = stepDist !== undefined ? sign * stepDist : undefined; 
          }

          var distanceFromMidpoint = manStepDist !== undefined ? manStepDist : normStepDist;
          
          var w1 = (1 - stepWeight);
          var w2 = stepWeight;

          if( swappedDirection ){
            w1 = stepWeight;
            w2 = (1 - stepWeight);
          }

          var adjustedMidpt = {
            x: midptSrcPts.x1 * w1 + midptSrcPts.x2 * w2,
            y: midptSrcPts.y1 * w1 + midptSrcPts.y2 * w2
          };

          rs.edgeType = 'bezier';
          
          rs.cp2x = adjustedMidpt.x + vectorNormInverse.x * distanceFromMidpoint;
          rs.cp2y = adjustedMidpt.y + vectorNormInverse.y * distanceFromMidpoint;
          
          // console.log(edge, midPointX, displacementX, distanceFromMidpoint);
        }

        // find endpts for edge
        this.findEndpoints( edge );

        var badStart = !$$.is.number( rs.startX ) || !$$.is.number( rs.startY );
        var badAStart = !$$.is.number( rs.arrowStartX ) || !$$.is.number( rs.arrowStartY );
        var badEnd = !$$.is.number( rs.endX ) || !$$.is.number( rs.endY );
        var badAEnd = !$$.is.number( rs.arrowEndX ) || !$$.is.number( rs.arrowEndY );

        var minCpADistFactor = 3;
        var arrowW = this.getArrowWidth( edge._private.style['width'].pxValue ) * CanvasRenderer.arrowShapeHeight;
        var minCpADist = minCpADistFactor * arrowW;
        var startACpDist = $$.math.distance( { x: rs.cp2x, y: rs.cp2y }, { x: rs.startX, y: rs.startY } );
        var closeStartACp = startACpDist < minCpADist;
        var endACpDist = $$.math.distance( { x: rs.cp2x, y: rs.cp2y }, { x: rs.endX, y: rs.endY } );
        var closeEndACp = endACpDist < minCpADist;

        if( rs.edgeType === 'bezier' ){
          var overlapping = false;

          if( badStart || badAStart || closeStartACp ){
            overlapping = true;

            // project control point along line from src centre to outside the src shape
            // (otherwise intersection will yield nothing)
            var cpD = { // delta
              x: rs.cp2x - srcPos.x,
              y: rs.cp2y - srcPos.y
            };
            var cpL = Math.sqrt( cpD.x*cpD.x + cpD.y*cpD.y ); // length of line
            var cpM = { // normalised delta
              x: cpD.x / cpL,
              y: cpD.y / cpL
            };
            var radius = Math.max(srcW, srcH);
            var cpProj = { // *2 radius guarantees outside shape
              x: rs.cp2x + cpM.x * 2 * radius,
              y: rs.cp2y + cpM.y * 2 * radius
            };

            var srcCtrlPtIntn = srcShape.intersectLine(
              srcPos.x,
              srcPos.y,
              srcW,
              srcH,
              cpProj.x,
              cpProj.y,
              srcBorder / 2
            );

            if( closeStartACp ){
              rs.cp2x = rs.cp2x + cpM.x * (minCpADist - startACpDist); 
              rs.cp2y = rs.cp2y + cpM.y * (minCpADist - startACpDist);
            } else {
              rs.cp2x = srcCtrlPtIntn[0] + cpM.x * minCpADist; 
              rs.cp2y = srcCtrlPtIntn[1] + cpM.y * minCpADist;
            }
          }

          if( badEnd || badAEnd || closeEndACp ){
            overlapping = true;

            // project control point along line from tgt centre to outside the tgt shape
            // (otherwise intersection will yield nothing)
            var cpD = { // delta
              x: rs.cp2x - tgtPos.x,
              y: rs.cp2y - tgtPos.y
            };
            var cpL = Math.sqrt( cpD.x*cpD.x + cpD.y*cpD.y ); // length of line
            var cpM = { // normalised delta
              x: cpD.x / cpL,
              y: cpD.y / cpL
            };
            var radius = Math.max(srcW, srcH);
            var cpProj = { // *2 radius guarantees outside shape
              x: rs.cp2x + cpM.x * 2 * radius,
              y: rs.cp2y + cpM.y * 2 * radius
            };

            var tgtCtrlPtIntn = tgtShape.intersectLine(
              tgtPos.x,
              tgtPos.y,
              tgtW,
              tgtH,
              cpProj.x,
              cpProj.y,
              tgtBorder / 2
            );

            if( closeEndACp ){
              rs.cp2x = rs.cp2x + cpM.x * (minCpADist - endACpDist); 
              rs.cp2y = rs.cp2y + cpM.y * (minCpADist - endACpDist);
            } else {
              rs.cp2x = tgtCtrlPtIntn[0] + cpM.x * minCpADist; 
              rs.cp2y = tgtCtrlPtIntn[1] + cpM.y * minCpADist;
            }
            
          }

          if( overlapping ){
            // recalc endpts
            this.findEndpoints( edge );
          }
        } else if( rs.edgeType === 'straight' ){
          rs.midX = ( srcX2 + tgtX2 )/2;
          rs.midY = ( srcY2 + tgtY2 )/2;
        }

        // project the edge into rstyle
        this.projectBezier( edge );
        this.recalculateEdgeLabelProjection( edge );

      }
    }
      
    for( var i = 0; i < haystackEdges.length; i++ ){
      var edge = haystackEdges[i];
      var _p = edge._private;
      var rscratch = _p.rscratch;
      var rs = rscratch;

      if( !rscratch.haystack ){
        var angle = Math.random() * 2 * Math.PI;

        rscratch.source = {
          x: Math.cos(angle),
          y: Math.sin(angle)
        };

        var angle = Math.random() * 2 * Math.PI;

        rscratch.target = {
          x: Math.cos(angle),
          y: Math.sin(angle)
        };

      }

      var src = _p.source;
      var tgt = _p.target;
      var srcPos = src._private.position;
      var tgtPos = tgt._private.position;
      var srcW = src.width();
      var tgtW = tgt.width();
      var srcH = src.height();
      var tgtH = tgt.height();
      var radius = style['haystack-radius'].value;
      var halfRadius = radius/2; // b/c have to half width/height

      rs.haystackPts = [
        rs.source.x * srcW * halfRadius + srcPos.x,
        rs.source.y * srcH * halfRadius + srcPos.y,
        rs.target.x * tgtW * halfRadius + tgtPos.x,
        rs.target.y * tgtH * halfRadius + tgtPos.y
      ];

      // always override as haystack in case set to different type previously
      rscratch.edgeType = 'haystack';
      rscratch.haystack = true;

      this.recalculateEdgeLabelProjection( edge );
    }

    return hashTable;
  };

  CRp.findEndpoints = function(edge) {
    var intersect;

    var source = edge.source()[0];
    var target = edge.target()[0];
    
    var tgtArShape = edge._private.style['target-arrow-shape'].value;
    var srcArShape = edge._private.style['source-arrow-shape'].value;

    var tgtBorderW = target._private.style['border-width'].pxValue;
    var srcBorderW = source._private.style['border-width'].pxValue;

    var rs = edge._private.rscratch;
    
    if (rs.edgeType == 'self' || rs.edgeType == 'compound') {
      
      var cp = [rs.cp2cx, rs.cp2cy];
      
      intersect = CanvasRenderer.nodeShapes[this.getNodeShape(target)].intersectLine(
        target._private.position.x,
        target._private.position.y,
        this.getNodeWidth(target),
        this.getNodeHeight(target),
        cp[0],
        cp[1], 
        tgtBorderW / 2
      );
      
      var arrowEnd = $$.math.shortenIntersection(intersect, cp,
        CanvasRenderer.arrowShapes[tgtArShape].spacing(edge));
      var edgeEnd = $$.math.shortenIntersection(intersect, cp,
        CanvasRenderer.arrowShapes[tgtArShape].gap(edge));
      
      rs.endX = edgeEnd[0];
      rs.endY = edgeEnd[1];
      
      rs.arrowEndX = arrowEnd[0];
      rs.arrowEndY = arrowEnd[1];
      
      var cp = [rs.cp2ax, rs.cp2ay];

      intersect = CanvasRenderer.nodeShapes[this.getNodeShape(source)].intersectLine(
        source._private.position.x,
        source._private.position.y,
        this.getNodeWidth(source),
        this.getNodeHeight(source),
        cp[0], //halfPointX,
        cp[1], //halfPointY
        srcBorderW / 2
      );
      
      var arrowStart = $$.math.shortenIntersection(intersect, cp,
        CanvasRenderer.arrowShapes[srcArShape].spacing(edge));
      var edgeStart = $$.math.shortenIntersection(intersect, cp,
        CanvasRenderer.arrowShapes[srcArShape].gap(edge));
      
      rs.startX = edgeStart[0];
      rs.startY = edgeStart[1];


      rs.arrowStartX = arrowStart[0];
      rs.arrowStartY = arrowStart[1];
      
    } else if (rs.edgeType == 'straight') {
    
      intersect = CanvasRenderer.nodeShapes[this.getNodeShape(target)].intersectLine(
        target._private.position.x,
        target._private.position.y,
        this.getNodeWidth(target),
        this.getNodeHeight(target),
        source.position().x,
        source.position().y,
        tgtBorderW / 2);
        
      if (intersect.length === 0) {
        rs.noArrowPlacement = true;
        // return;
      } else {
        rs.noArrowPlacement = false;
      }
      
      var arrowEnd = $$.math.shortenIntersection(intersect,
        [source.position().x, source.position().y],
        CanvasRenderer.arrowShapes[tgtArShape].spacing(edge));
      var edgeEnd = $$.math.shortenIntersection(intersect,
        [source.position().x, source.position().y],
        CanvasRenderer.arrowShapes[tgtArShape].gap(edge));

      rs.endX = edgeEnd[0];
      rs.endY = edgeEnd[1];
      
      rs.arrowEndX = arrowEnd[0];
      rs.arrowEndY = arrowEnd[1];
    
      intersect = CanvasRenderer.nodeShapes[this.getNodeShape(source)].intersectLine(
        source._private.position.x,
        source._private.position.y,
        this.getNodeWidth(source),
        this.getNodeHeight(source),
        target.position().x,
        target.position().y,
        srcBorderW / 2);
      
      if (intersect.length === 0) {
        rs.noArrowPlacement = true;
       // return;
      } else {
        rs.noArrowPlacement = false;
      }
      
      /*
      console.log("1: "
        + CanvasRenderer.arrowShapes[srcArShape],
          srcArShape);
      */
      var arrowStart = $$.math.shortenIntersection(intersect,
        [target.position().x, target.position().y],
        CanvasRenderer.arrowShapes[srcArShape].spacing(edge));
      var edgeStart = $$.math.shortenIntersection(intersect,
        [target.position().x, target.position().y],
        CanvasRenderer.arrowShapes[srcArShape].gap(edge));

      rs.startX = edgeStart[0];
      rs.startY = edgeStart[1];
      
      rs.arrowStartX = arrowStart[0];
      rs.arrowStartY = arrowStart[1];
      
      if( !$$.is.number(rs.startX) || !$$.is.number(rs.startY) || !$$.is.number(rs.endX) || !$$.is.number(rs.endY) ){
        rs.badLine = true;
      } else {
        rs.badLine = false;
      }
            
    } else if (rs.edgeType == 'bezier') {
      // if( window.badArrow) debugger;
      var cp = [rs.cp2x, rs.cp2y];
      
      intersect = CanvasRenderer.nodeShapes[
        this.getNodeShape(target)].intersectLine(
        target._private.position.x,
        target._private.position.y,
        this.getNodeWidth(target),
        this.getNodeHeight(target),
        cp[0], //halfPointX,
        cp[1], //halfPointY
        tgtBorderW / 2
      );
      
      /*
      console.log("2: "
        + CanvasRenderer.arrowShapes[srcArShape],
          srcArShape);
      */
      var arrowEnd = $$.math.shortenIntersection(intersect, cp,
        CanvasRenderer.arrowShapes[tgtArShape].spacing(edge));
      var edgeEnd = $$.math.shortenIntersection(intersect, cp,
        CanvasRenderer.arrowShapes[tgtArShape].gap(edge));
      
      rs.endX = edgeEnd[0];
      rs.endY = edgeEnd[1];
      
      rs.arrowEndX = arrowEnd[0];
      rs.arrowEndY = arrowEnd[1];
      
      intersect = CanvasRenderer.nodeShapes[
        this.getNodeShape(source)].intersectLine(
        source._private.position.x,
        source._private.position.y,
        this.getNodeWidth(source),
        this.getNodeHeight(source),
        cp[0], //halfPointX,
        cp[1], //halfPointY
        srcBorderW / 2
      );
      
      var arrowStart = $$.math.shortenIntersection(
        intersect, 
        cp,
        CanvasRenderer.arrowShapes[srcArShape].spacing(edge)
      );
      var edgeStart = $$.math.shortenIntersection(
        intersect, 
        cp,
        CanvasRenderer.arrowShapes[srcArShape].gap(edge)
      );
    
      rs.startX = edgeStart[0];
      rs.startY = edgeStart[1];
      
      rs.arrowStartX = arrowStart[0];
      rs.arrowStartY = arrowStart[1];
      
      // if( isNaN(rs.startX) || isNaN(rs.startY) ){
      //   debugger;
      // }

    } else if (rs.isArcEdge) {
      return;
    }
  };

  // Find adjacent edges
  CRp.findEdges = function(nodeSet) {
    
    var edges = this.getCachedEdges();
    
    var hashTable = {};
    var adjacentEdges = [];
    
    for (var i = 0; i < nodeSet.length; i++) {
      hashTable[nodeSet[i]._private.data.id] = nodeSet[i];
    }
    
    for (var i = 0; i < edges.length; i++) {
      if (hashTable[edges[i]._private.data.source]
        || hashTable[edges[i]._private.data.target]) {
        
        adjacentEdges.push(edges[i]);
      }
    }
    
    return adjacentEdges;
  };

  CRp.getArrowWidth = CRp.getArrowHeight = function(edgeWidth) {
    var cache = this.arrowWidthCache = this.arrowWidthCache || {};

    var cachedVal = cache[edgeWidth];
    if( cachedVal ){
      return cachedVal;
    }

    cachedVal =  Math.max(Math.pow(edgeWidth * 13.37, 0.9), 29);
    cache[edgeWidth] = cachedVal;

    return cachedVal;
  };


})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');
  var CRp = CanvasRenderer.prototype;

// Draw edge
  CRp.drawEdge = function(context, edge, drawOverlayInstead) {
    var rs = edge._private.rscratch;
    var usePaths = CanvasRenderer.usePaths();

    // if bezier ctrl pts can not be calculated, then die
    if( rs.badBezier || ( (rs.edgeType === 'bezier' || rs.edgeType === 'straight') && isNaN(rs.startX)) ){ // extra isNaN() for safari 7.1 b/c it mangles ctrlpt calcs
      return;
    }

    var style = edge._private.style;
    
    // Edge line width
    if (style['width'].pxValue <= 0) {
      return;
    }

    var overlayPadding = style['overlay-padding'].pxValue;
    var overlayOpacity = style['overlay-opacity'].value;
    var overlayColor = style['overlay-color'].value;

    // Edge color & opacity
    if( drawOverlayInstead ){

      if( overlayOpacity === 0 ){ // exit early if no overlay
        return;
      }

      this.strokeStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity);
      context.lineCap = 'round';

      if( edge._private.rscratch.edgeType == 'self' && !usePaths ){
        context.lineCap = 'butt';
      }

    } else {
      var lineColor = style['line-color'].value;

      this.strokeStyle(context, lineColor[0], lineColor[1], lineColor[2], style.opacity.value);
      
      context.lineCap = 'butt'; 
    }
    
    var startNode, endNode, source, target;
    source = startNode = edge._private.source;
    target = endNode = edge._private.target;

    // var targetPos = target._private.position;
    // var targetW = target.width();
    // var targetH = target.height();
    // var sourcePos = source._private.position;
    // var sourceW = source.width();
    // var sourceH = source.height();


    var edgeWidth = style['width'].pxValue + (drawOverlayInstead ? 2 * overlayPadding : 0);
    var lineStyle = drawOverlayInstead ? 'solid' : style['line-style'].value;
    context.lineWidth = edgeWidth;
    
    var shadowBlur = style['shadow-blur'].pxValue;
    var shadowOpacity = style['shadow-opacity'].value;
    var shadowColor = style['shadow-color'].value;
    var shadowOffsetX = style['shadow-offset-x'].pxValue;
    var shadowOffsetY = style['shadow-offset-y'].pxValue;

    this.shadowStyle(context,  shadowColor, drawOverlayInstead ? 0 : shadowOpacity, shadowBlur, shadowOffsetX, shadowOffsetY);
    
    // if( rs.edgeType !== 'haystack' ){
    //   this.findEndpoints(edge);
    // }
    
    if( rs.edgeType === 'haystack' ){
      // var radius = style['haystack-radius'].value;
      // var halfRadius = radius/2; // b/c have to half width/height

      this.drawStyledEdge(
        edge, 
        context, 
        rs.haystackPts,
        lineStyle,
        edgeWidth
      );
    } else if (rs.edgeType === 'self' || rs.edgeType === 'compound') {
      
      var details = edge._private.rscratch;
      var points = [details.startX, details.startY, details.cp2ax,
        details.cp2ay, details.selfEdgeMidX, details.selfEdgeMidY,
        details.selfEdgeMidX, details.selfEdgeMidY,
        details.cp2cx, details.cp2cy, details.endX, details.endY];

      this.drawStyledEdge(edge, context, points, lineStyle, edgeWidth);
      
    } else if (rs.edgeType === 'straight') {
      
      var nodeDirectionX = endNode._private.position.x - startNode._private.position.x;
      var nodeDirectionY = endNode._private.position.y - startNode._private.position.y;
      
      var edgeDirectionX = rs.endX - rs.startX;
      var edgeDirectionY = rs.endY - rs.startY;
      
      if (nodeDirectionX * edgeDirectionX
        + nodeDirectionY * edgeDirectionY < 0) {
        
        rs.straightEdgeTooShort = true;  
      } else {
        
        var details = rs;
        this.drawStyledEdge(edge, context, [details.startX, details.startY,
                                      details.endX, details.endY],
                                      lineStyle,
                                      edgeWidth);
        
        rs.straightEdgeTooShort = false;  
      }  
    } else {
      
      var details = rs;
      
      this.drawStyledEdge(edge, context, [details.startX, details.startY,
        details.cp2x, details.cp2y, details.endX, details.endY],
        lineStyle,
        edgeWidth);
      
    }
    
    if( rs.edgeType === 'haystack' ){
      this.drawArrowheads(context, edge, drawOverlayInstead);
    } else if ( rs.noArrowPlacement !== true && rs.startX !== undefined ){
      this.drawArrowheads(context, edge, drawOverlayInstead);
    }

    this.shadowStyle(context, 'transparent', 0); // reset for next guy

  };
  
  
  CRp.drawStyledEdge = function(
      edge, context, pts, type, width) {

    // 3 points given -> assume Bezier
    // 2 -> assume straight
    
    var rs = edge._private.rscratch;
    var canvasCxt = context;
    var path;
    var pathCacheHit = false;
    var usePaths = CanvasRenderer.usePaths();


    if( usePaths ){

      var pathCacheKey = pts;
      var keyLengthMatches = rs.pathCacheKey && pathCacheKey.length === rs.pathCacheKey.length;
      var keyMatches = keyLengthMatches;

      for( var i = 0; keyMatches && i < pathCacheKey.length; i++ ){
        if( rs.pathCacheKey[i] !== pathCacheKey[i] ){
          keyMatches = false;
        }
      }

      if( keyMatches ){
        path = context = rs.pathCache;
        pathCacheHit = true;
      } else {
        path = context = new Path2D();
        rs.pathCacheKey = pathCacheKey;
        rs.pathCache = path;
      }

    }

    if( canvasCxt.setLineDash ){ // for very outofdate browsers
      switch( type ){
        case 'dotted':
          canvasCxt.setLineDash([ 1, 1 ]);
          break;

        case 'dashed':
          canvasCxt.setLineDash([ 6, 3 ]);
          break;

        case 'solid':
          canvasCxt.setLineDash([ ]);
          break;
      }
    }

    if( !pathCacheHit ){
      if( context.beginPath ){ context.beginPath(); }
      context.moveTo(pts[0], pts[1]);
      
      if( pts.length === 6 && !rs.badBezier ){ // bezier
        context.quadraticCurveTo(pts[2], pts[3], pts[4], pts[5]);
      } else if( pts.length === 12 && !rs.badBezier ){ // double bezier loop
        context.quadraticCurveTo(pts[2], pts[3], pts[4], pts[5]);
        context.quadraticCurveTo(pts[8], pts[9], pts[10], pts[11]);
      } else if( pts.length === 4 && !rs.badLine ){ // line
        context.lineTo(pts[2], pts[3]);
      }
    }

    context = canvasCxt;
    if( usePaths ){
      context.stroke( path );
    } else {
      context.stroke();
    }
  
    // reset any line dashes
    if( context.setLineDash ){ // for very outofdate browsers
      context.setLineDash([ ]);
    }

  };

  CRp.drawArrowheads = function(context, edge, drawOverlayInstead) {
    if( drawOverlayInstead ){ return; } // don't do anything for overlays 

    var rs = edge._private.rscratch;
    var self = this;
    var isHaystack = rs.edgeType === 'haystack';

    // Displacement gives direction for arrowhead orientation
    var dispX, dispY;
    var startX, startY, endX, endY;

    var srcPos = edge.source().position();
    var tgtPos = edge.target().position();

    if( isHaystack ){
      startX = rs.haystackPts[0];
      startY = rs.haystackPts[1];
      endX = rs.haystackPts[2];
      endY = rs.haystackPts[3];
    } else {
      startX = rs.arrowStartX;
      startY = rs.arrowStartY;
      endX = rs.arrowEndX;
      endY = rs.arrowEndY;
    }

    var style = edge._private.style;
    
    function drawArrowhead( prefix, x, y, dispX, dispY ){
      var arrowShape = style[prefix + '-arrow-shape'].value;

      if( arrowShape === 'none' ){
        return;
      }

      var gco = context.globalCompositeOperation;

      var arrowClearFill = style[prefix + '-arrow-fill'].value === 'hollow' ? 'both' : 'filled';
      var arrowFill = style[prefix + '-arrow-fill'].value;

      if( arrowShape === 'half-triangle-overshot' ){
        arrowFill = 'hollow';
        arrowClearFill = 'hollow';
      }

      if( style.opacity.value !== 1 || arrowFill === 'hollow' ){ // then extra clear is needed
        context.globalCompositeOperation = 'destination-out';
        
        self.fillStyle(context, 255, 255, 255, 1);
        self.strokeStyle(context, 255, 255, 255, 1);
        
        self.drawArrowShape( edge, prefix, context, 
          arrowClearFill, style['width'].pxValue, style[prefix + '-arrow-shape'].value, 
          x, y, dispX, dispY
        );

        context.globalCompositeOperation = gco;
      } // otherwise, the opaque arrow clears it for free :)

      var color = style[prefix + '-arrow-color'].value;
      self.fillStyle(context, color[0], color[1], color[2], style.opacity.value);
      self.strokeStyle(context, color[0], color[1], color[2], style.opacity.value);

      self.drawArrowShape( edge, prefix, context, 
        arrowFill, style['width'].pxValue, style[prefix + '-arrow-shape'].value, 
        x, y, dispX, dispY
      );
    }

    dispX = startX - srcPos.x;
    dispY = startY - srcPos.y;

    if( !isHaystack && !isNaN(startX) && !isNaN(startY) && !isNaN(dispX) && !isNaN(dispY) ){
      drawArrowhead( 'source', startX, startY, dispX, dispY );

    } else {
      // window.badArrow = true;
      // debugger;
    }
    
    var midX = rs.midX;
    var midY = rs.midY;

    if( isHaystack ){
      midX = ( startX + endX )/2;
      midY = ( startY + endY )/2;
    }

    dispX = startX - endX;
    dispY = startY - endY;

    if( rs.edgeType === 'self' ){
      dispX = 1;
      dispY = -1;
    }

    if( !isNaN(midX) && !isNaN(midY) ){
      drawArrowhead( 'mid-target', midX, midY, dispX, dispY );
    }

    dispX *= -1;
    dispY *= -1;

    if( !isNaN(midX) && !isNaN(midY) ){
      drawArrowhead( 'mid-source', midX, midY, dispX, dispY );
    }
    
    dispX = endX - tgtPos.x;
    dispY = endY - tgtPos.y;
    
    if( !isHaystack && !isNaN(endX) && !isNaN(endY) && !isNaN(dispX) && !isNaN(dispY) ){
      drawArrowhead( 'target', endX, endY, dispX, dispY );
    }
  };
  
  // Draw arrowshape
  CRp.drawArrowShape = function(edge, arrowType, context, fill, edgeWidth, shape, x, y, dispX, dispY) {
    var usePaths = CanvasRenderer.usePaths();
    var rs = edge._private.rscratch;
    var pathCacheHit = false;
    var path;
    var canvasContext = context;
    var translation = { x: x, y: y };

    // Negative of the angle
    var angle = Math.asin(dispY / (Math.sqrt(dispX * dispX + dispY * dispY)));
  
    if (dispX < 0) {
      angle = angle + Math.PI / 2;
    } else {
      angle = - (Math.PI / 2 + angle);
    }
    
    var size = this.getArrowWidth( edgeWidth );
    var shapeImpl = CanvasRenderer.arrowShapes[shape];

    // context.translate(x, y);

    if( usePaths ){
      var pathCacheKey = size + '$' + shape + '$' + angle + '$' + x + '$' + y;
      rs.arrowPathCacheKey = rs.arrowPathCacheKey || {};
      rs.arrowPathCache = rs.arrowPathCache || {};

      var alreadyCached = rs.arrowPathCacheKey[arrowType] === pathCacheKey;
      if( alreadyCached ){
        path = context = rs.arrowPathCache[arrowType];
        pathCacheHit = true;
      } else {
        path = context = new Path2D();
        rs.arrowPathCacheKey[arrowType] = pathCacheKey;
        rs.arrowPathCache[arrowType] = path;
      }
    }

    if( context.beginPath ){ context.beginPath(); }

    if( !pathCacheHit ){
      shapeImpl.draw(context, size, angle, translation);
    }
    
    if( !shapeImpl.leavePathOpen && context.closePath ){
      context.closePath();
    }

    context = canvasContext;

    if( fill === 'filled' || fill === 'both' ){
      if( usePaths ){
        context.fill( path );
      } else {
        context.fill();
      }
    }

    if( fill === 'hollow' || fill === 'both' ){
      context.lineWidth = ( shapeImpl.matchEdgeWidth ? edgeWidth : 1 );
      context.lineJoin = 'miter';

      if( usePaths ){
        context.stroke( path );
      } else {
        context.stroke();
      }
      
    }

    // context.translate(-x, -y);
  };

})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');
  var CRp = CanvasRenderer.prototype;

  CRp.getCachedImage = function(url, onLoad) {
    var r = this;
    var imageCache = r.imageCache = r.imageCache || {};

    if( imageCache[url] && imageCache[url].image ){
      return imageCache[url].image;
    }
    
    var cache = imageCache[url] = imageCache[url] || {};

    var image = cache.image = new Image();
    image.addEventListener('load', onLoad);
    image.src = url;
    
    return image;
  };
  
  CRp.safeDrawImage = function( context, img, ix, iy, iw, ih, x, y, w, h ){
    var r = this;
    
    try {
      context.drawImage( img, ix, iy, iw, ih, x, y, w, h );
    } catch(e){
      r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true;
      r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true;
      
      r.drawingImage = true;
      
      r.redraw();
    }
  };
  
  CRp.drawInscribedImage = function(context, img, node) {
    var r = this;
    var nodeX = node._private.position.x;
    var nodeY = node._private.position.y;
    var style = node._private.style;
    var fit = style['background-fit'].value;
    var xPos = style['background-position-x'];
    var yPos = style['background-position-y'];
    var repeat = style['background-repeat'].value;
    var nodeW = node.width();
    var nodeH = node.height();
    var rs = node._private.rscratch;
    var clip = style['background-clip'].value;
    var shouldClip = clip === 'node';
    var imgOpacity = style['background-image-opacity'].value;
    
    var w = img.width;
    var h = img.height;
    
    if( w === 0 || h === 0 ){
      return; // no point in drawing empty image (and chrome is broken in this case)
    }

    var bgW = style['background-width'];
    if( bgW.value !== 'auto' ){
      if( bgW.units === '%' ){
        w = bgW.value/100 * nodeW;
      } else {
        w = bgW.pxValue;
      }
    }

    var bgH = style['background-height'];
    if( bgH.value !== 'auto' ){
      if( bgH.units === '%' ){
        h = bgH.value/100 * nodeH;
      } else {
        h = bgH.pxValue;
      }
    }

    if( w === 0 || h === 0 ){
      return; // no point in drawing empty image (and chrome is broken in this case)
    }

    if( fit === 'contain' ){
      var scale = Math.min( nodeW/w, nodeH/h );

      w *= scale;
      h *= scale;

    } else if( fit === 'cover' ){
      var scale = Math.max( nodeW/w, nodeH/h );

      w *= scale;
      h *= scale;
    }

    var x = (nodeX - nodeW/2); // left
    if( xPos.units === '%' ){
      x += (nodeW - w) * xPos.value/100;
    } else {
      x += xPos.pxValue;
    }

    var y = (nodeY - nodeH/2); // top
    if( yPos.units === '%' ){
      y += (nodeH - h) * yPos.value/100;
    } else {
      y += yPos.pxValue;
    }

    if( rs.pathCache ){
      x -= nodeX;
      y -= nodeY;

      nodeX = 0;
      nodeY = 0;
    }

    var gAlpha = context.globalAlpha;

    context.globalAlpha = imgOpacity;

    if( repeat === 'no-repeat' ){

      if( shouldClip ){
        context.save();

        if( rs.pathCache ){
          context.clip( rs.pathCache );
        } else {
          CanvasRenderer.nodeShapes[r.getNodeShape(node)].drawPath(
            context,
            nodeX, nodeY, 
            nodeW, nodeH);

          context.clip();
        }
      }

      // context.drawImage( img, 0, 0, img.width, img.height, x, y, w, h );
      r.safeDrawImage( context, img, 0, 0, img.width, img.height, x, y, w, h );

      if( shouldClip ){
        context.restore();
      }
    } else {
      var pattern = context.createPattern( img, repeat );
      context.fillStyle = pattern;

      CanvasRenderer.nodeShapes[r.getNodeShape(node)].drawPath(
          context,
          nodeX, nodeY, 
          nodeW, nodeH);

        context.translate(x, y);
        context.fill();
        context.translate(-x, -y);
    }

    context.globalAlpha = gAlpha;
    
  };

  
})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');
  var CRp = CanvasRenderer.prototype;

  // Draw edge text
  CRp.drawEdgeText = function(context, edge) {
    var text = edge._private.style['content'].strValue;

    if( !text || text.match(/^\s+$/) ){
      return;
    }

    if( this.hideEdgesOnViewport && (this.dragData.didDrag || this.pinching || this.hoverData.dragging || this.data.wheel || this.swipePanning) ){ return; } // save cycles on pinching

    var computedSize = edge._private.style['font-size'].pxValue * edge.cy().zoom();
    var minSize = edge._private.style['min-zoomed-font-size'].pxValue;

    if( computedSize < minSize ){
      return;
    }

    // Calculate text draw position

    context.textAlign = 'center';
    context.textBaseline = 'middle';
    
    var rs = edge._private.rscratch;
    if( !$$.is.number( rs.labelX ) || !$$.is.number( rs.labelY ) ){ return; } // no pos => label can't be rendered

    var style = edge._private.style;
    var autorotate = style['edge-text-rotation'].strValue === 'autorotate';
    var theta, dx, dy;

    if( autorotate ){
      switch( rs.edgeType ){
        case 'haystack':
          dx = rs.haystackPts[2] - rs.haystackPts[0];
          dy = rs.haystackPts[3] - rs.haystackPts[1];
          break;
        default:
          dx = rs.endX - rs.startX;
          dy = rs.endY - rs.startY;
      }

      theta = Math.atan( dy / dx );

      context.translate(rs.labelX, rs.labelY);
      context.rotate(theta);

      this.drawText(context, edge, 0, 0);

      context.rotate(-theta);
      context.translate(-rs.labelX, -rs.labelY);
    } else {
      this.drawText(context, edge, rs.labelX, rs.labelY);
    }

  };

  // Draw node text
  CRp.drawNodeText = function(context, node) {
    var text = node._private.style['content'].strValue;

    if ( !text || text.match(/^\s+$/) ) {
      return;
    }

    var computedSize = node._private.style['font-size'].pxValue * node.cy().zoom();
    var minSize = node._private.style['min-zoomed-font-size'].pxValue;

    if( computedSize < minSize ){
      return;
    }

    // this.recalculateNodeLabelProjection( node );

    var textHalign = node._private.style['text-halign'].strValue;
    var textValign = node._private.style['text-valign'].strValue;
    var rs = node._private.rscratch;
    if( !$$.is.number( rs.labelX ) || !$$.is.number( rs.labelY ) ){ return; } // no pos => label can't be rendered

    switch( textHalign ){
      case 'left':
        context.textAlign = 'right';
        break;

      case 'right':
        context.textAlign = 'left';
        break;

      default: // e.g. center
        context.textAlign = 'center';
    }

    switch( textValign ){
      case 'top':
        context.textBaseline = 'bottom';
        break;

      case 'bottom':
        context.textBaseline = 'top';
        break;

      default: // e.g. center
        context.textBaseline = 'middle';
    }

    this.drawText(context, node, rs.labelX, rs.labelY);
  };

  CRp.getFontCache = function(context){
    var cache;

    this.fontCaches = this.fontCaches || [];

    for( var i = 0; i < this.fontCaches.length; i++ ){
      cache = this.fontCaches[i];

      if( cache.context === context ){
        return cache;
      }
    }

    cache = {
      context: context
    };
    this.fontCaches.push(cache);

    return cache;
  };

  // set up canvas context with font
  // returns transformed text string
  CRp.setupTextStyle = function( context, element ){
    // Font style
    var parentOpacity = element.effectiveOpacity();
    var style = element._private.style;
    var labelStyle = style['font-style'].strValue;
    var labelSize = style['font-size'].pxValue + 'px';
    var labelFamily = style['font-family'].strValue;
    var labelWeight = style['font-weight'].strValue;
    var opacity = style['text-opacity'].value * style['opacity'].value * parentOpacity;
    var outlineOpacity = style['text-outline-opacity'].value * opacity;
    var color = style['color'].value;
    var outlineColor = style['text-outline-color'].value;
    var shadowBlur = style['text-shadow-blur'].pxValue;
    var shadowOpacity = style['text-shadow-opacity'].value;
    var shadowColor = style['text-shadow-color'].value;
    var shadowOffsetX = style['text-shadow-offset-x'].pxValue;
    var shadowOffsetY = style['text-shadow-offset-y'].pxValue;

    var fontCacheKey = element._private.fontKey;
    var cache = this.getFontCache(context);

    if( cache.key !== fontCacheKey ){
      context.font = labelStyle + ' ' + labelWeight + ' ' + labelSize + ' ' + labelFamily;

      cache.key = fontCacheKey;
    }

    var text = this.getLabelText( element );

    // Calculate text draw position based on text alignment

    // so text outlines aren't jagged
    context.lineJoin = 'round';

    this.fillStyle(context, color[0], color[1], color[2], opacity);

    this.strokeStyle(context, outlineColor[0], outlineColor[1], outlineColor[2], outlineOpacity);

    this.shadowStyle(context, shadowColor, shadowOpacity, shadowBlur, shadowOffsetX, shadowOffsetY);

    return text;
  };

  function roundRect(ctx, x, y, width, height, radius) {
    var radius = radius || 5;
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + width - radius, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
    ctx.lineTo(x + width, y + height - radius);
    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    ctx.lineTo(x + radius, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();
    ctx.fill();
  }

  // Draw text
  CRp.drawText = function(context, element, textX, textY) {
    var _p = element._private;
    var style = _p.style;
    var rstyle = _p.rstyle;
    var rscratch = _p.rscratch;
    var parentOpacity = element.effectiveOpacity();
    if( parentOpacity === 0 || style['text-opacity'].value === 0){ return; }

    var text = this.setupTextStyle( context, element );
    var halign = style['text-halign'].value;
    var valign = style['text-valign'].value;

    if( element.isEdge() ){
      halign = 'center';
      valign = 'center';
    }

    if ( text != null && !isNaN(textX) && !isNaN(textY)) {
      var backgroundOpacity = style['text-background-opacity'].value;
      var borderOpacity = style['text-border-opacity'].value;
      var textBorderWidth = style['text-border-width'].pxValue;
      
      if( backgroundOpacity > 0 || (textBorderWidth > 0 && borderOpacity > 0) ){
        var margin = 4 + textBorderWidth/2;

        if (element.isNode()) {
          //Move textX, textY to include the background margins
          if (valign === 'top') {
            textY -= margin;
          } else if (valign === 'bottom') {
            textY += margin;
          }
          if (halign === 'left') {
            textX -= margin;
          } else if (halign === 'right') {
            textX += margin;
          }
        }

        var bgWidth = rstyle.labelWidth;
        var bgHeight = rstyle.labelHeight;
        var bgX = textX;

        if (halign) {
          if (halign == 'center') {
            bgX = bgX - bgWidth / 2;
          } else if (halign == 'left') {
            bgX = bgX- bgWidth;
          }
        }

        var bgY = textY;

        if (element.isNode()) {
          if (valign == 'top') {
             bgY = bgY - bgHeight;
          } else if (valign == 'center') {
            bgY = bgY- bgHeight / 2;
          }
        } else {
          bgY = bgY - bgHeight / 2;
        }

        if (style['edge-text-rotation'].strValue === 'autorotate') {
          textY = 0;
          bgWidth += 4;
          bgX = textX - bgWidth / 2;
          bgY = textY - bgHeight / 2;
        } else {
          // Adjust with border width & margin
          bgX -= margin;
          bgY -= margin;
          bgHeight += margin*2;
          bgWidth += margin*2;
        }

        if( backgroundOpacity > 0 ){
          var textFill = context.fillStyle;
          var textBackgroundColor = style['text-background-color'].value;

          context.fillStyle = 'rgba(' + textBackgroundColor[0] + ',' + textBackgroundColor[1] + ',' + textBackgroundColor[2] + ',' + backgroundOpacity * parentOpacity + ')';
          var styleShape = style['text-background-shape'].strValue;
          if (styleShape == 'roundrectangle') {
            roundRect(context, bgX, bgY, bgWidth, bgHeight, 2);
          } else {
            context.fillRect(bgX,bgY,bgWidth,bgHeight);
          }
          context.fillStyle = textFill;
        }

        if( textBorderWidth > 0 && borderOpacity > 0 ){
          var textStroke = context.strokeStyle;
          var textLineWidth = context.lineWidth;
          var textBorderColor = style['text-border-color'].value;
          var textBorderStyle = style['text-border-style'].value;

          context.strokeStyle = 'rgba(' + textBorderColor[0] + ',' + textBorderColor[1] + ',' + textBorderColor[2] + ',' + borderOpacity * parentOpacity + ')';
          context.lineWidth = textBorderWidth;

          if( context.setLineDash ){ // for very outofdate browsers
            switch( textBorderStyle ){
              case 'dotted':
                context.setLineDash([ 1, 1 ]);
                break;
              case 'dashed':
                context.setLineDash([ 4, 2 ]);
                break;
              case 'double':
                context.lineWidth = textBorderWidth/4; // 50% reserved for white between the two borders
                context.setLineDash([ ]);
                break;
              case 'solid':
                context.setLineDash([ ]);
                break;
            }
          }

          context.strokeRect(bgX,bgY,bgWidth,bgHeight);

          if( textBorderStyle === 'double' ){
            var whiteWidth = textBorderWidth/2;

            context.strokeRect(bgX+whiteWidth,bgY+whiteWidth,bgWidth-whiteWidth*2,bgHeight-whiteWidth*2);
          }

          if( context.setLineDash ){ // for very outofdate browsers
            context.setLineDash([ ]);
          }
          context.lineWidth = textLineWidth;
          context.strokeStyle = textStroke;
        }

      }

      var lineWidth = 2  * style['text-outline-width'].pxValue; // *2 b/c the stroke is drawn centred on the middle

      if( lineWidth > 0 ){
        context.lineWidth = lineWidth;
      }

      if( style['text-wrap'].value === 'wrap' ){ //console.log('draw wrap');
        var lines = rscratch.labelWrapCachedLines;
        var lineHeight = rstyle.labelHeight / lines.length;

        //console.log('lines', lines);

        switch( valign ){
          case 'top':
            textY -= (lines.length - 1) * lineHeight;
            break;

          case 'bottom':
            // nothing required
            break;

          default:
          case 'center':
            textY -= (lines.length - 1) * lineHeight / 2;
        }

        for( var l = 0; l < lines.length; l++ ){
          if( lineWidth > 0 ){
            context.strokeText( lines[l], textX, textY );
          }

          context.fillText( lines[l], textX, textY );

          textY += lineHeight;
        }

        // var fontSize = style['font-size'].pxValue;
        // wrapText(context, text, textX, textY, style['text-max-width'].pxValue, fontSize + 1);
      } else {
        if( lineWidth > 0 ){
          context.strokeText( text, textX, textY );
        }

        context.fillText( text, textX, textY );
      }


      this.shadowStyle(context, 'transparent', 0); // reset for next guy
    }
  };


})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');
  var CRp = CanvasRenderer.prototype;

  // Draw node
  CRp.drawNode = function(context, node, drawOverlayInstead) {

    var r = this;
    var nodeWidth, nodeHeight;
    var style = node._private.style;
    var rs = node._private.rscratch;
    var _p = node._private;
    
    var usePaths = CanvasRenderer.usePaths();
    var canvasContext = context;
    var path;
    var pathCacheHit = false;

    var overlayPadding = style['overlay-padding'].pxValue;
    var overlayOpacity = style['overlay-opacity'].value;
    var overlayColor = style['overlay-color'].value;

    if( drawOverlayInstead && overlayOpacity === 0 ){ // exit early if drawing overlay but none to draw
      return;
    }

    var parentOpacity = node.effectiveOpacity();
    if( parentOpacity === 0 ){ return; }

    nodeWidth = this.getNodeWidth(node);
    nodeHeight = this.getNodeHeight(node);
    
    context.lineWidth = style['border-width'].pxValue;

    if( drawOverlayInstead === undefined || !drawOverlayInstead ){

      var url = style['background-image'].value[2] ||
        style['background-image'].value[1];
      var image;

      if (url !== undefined) {
        
        // get image, and if not loaded then ask to redraw when later loaded
        image = this.getCachedImage(url, function(){
          r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true;
          r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true;
          
          r.drawingImage = true;
          
          r.redraw();
        });
        
        var prevBging = _p.backgrounding;
        _p.backgrounding = !image.complete;

        if( prevBging !== _p.backgrounding ){ // update style b/c :backgrounding state changed
          node.updateStyle( false );
        }
      } 

      // Node color & opacity

      var bgColor = style['background-color'].value;
      var borderColor = style['border-color'].value;
      var borderStyle = style['border-style'].value;

      this.fillStyle(context, bgColor[0], bgColor[1], bgColor[2], style['background-opacity'].value * parentOpacity);
      
      this.strokeStyle(context, borderColor[0], borderColor[1], borderColor[2], style['border-opacity'].value * parentOpacity);
      
      var shadowBlur = style['shadow-blur'].pxValue;
      var shadowOpacity = style['shadow-opacity'].value;
      var shadowColor = style['shadow-color'].value;
      var shadowOffsetX = style['shadow-offset-x'].pxValue;
      var shadowOffsetY = style['shadow-offset-y'].pxValue;

      this.shadowStyle(context, shadowColor, shadowOpacity, shadowBlur, shadowOffsetX, shadowOffsetY);

      context.lineJoin = 'miter'; // so borders are square with the node shape

      if( context.setLineDash ){ // for very outofdate browsers
        switch( borderStyle ){
          case 'dotted':
            context.setLineDash([ 1, 1 ]);
            break;

          case 'dashed':
            context.setLineDash([ 4, 2 ]);
            break;

          case 'solid':
          case 'double':
            context.setLineDash([ ]);
            break;
        }
      }

      
      var styleShape = style['shape'].strValue;

      var pos = node._private.position;

      if( usePaths ){
        var pathCacheKey = styleShape + '$' + nodeWidth +'$' + nodeHeight;

        context.translate( pos.x, pos.y );

        if( rs.pathCacheKey === pathCacheKey ){
          path = context = rs.pathCache;
          pathCacheHit = true;
        } else {
          path = context = new Path2D();
          rs.pathCacheKey = pathCacheKey;
          rs.pathCache = path;
        }
      }

      if( !pathCacheHit ){

        var npos = pos;

        if( usePaths ){
          npos = {
            x: 0,
            y: 0
          };
        }

        CanvasRenderer.nodeShapes[this.getNodeShape(node)].drawPath(
              context,
              npos.x,
              npos.y,
              nodeWidth,
              nodeHeight);
      }

      context = canvasContext;

      if( usePaths ){
        context.fill( path );
      } else {
        context.fill();
      }

      this.shadowStyle(context, 'transparent', 0); // reset for next guy

      if (url !== undefined) {
        if( image.complete ){
          this.drawInscribedImage(context, image, node);
        }
      } 
      
      var darkness = style['background-blacken'].value;
      var borderWidth = style['border-width'].pxValue;

      if( this.hasPie(node) ){
        this.drawPie( context, node, parentOpacity );

        // redraw path for blacken and border
        if( darkness !== 0 || borderWidth !== 0 ){

          if( !usePaths ){
            CanvasRenderer.nodeShapes[this.getNodeShape(node)].drawPath(
                context,
                pos.x,
                pos.y,
                nodeWidth,
                nodeHeight);
          }
        }
      }

      if( darkness > 0 ){
        this.fillStyle(context, 0, 0, 0, darkness);

        if( usePaths ){
          context.fill( path );
        } else {
          context.fill();
        }
        
      } else if( darkness < 0 ){
        this.fillStyle(context, 255, 255, 255, -darkness);
        
        if( usePaths ){
          context.fill( path );
        } else {
          context.fill();
        }
      }

      // Border width, draw border
      if (borderWidth > 0) {

        if( usePaths ){
          context.stroke( path );
        } else {
          context.stroke();
        }

        if( borderStyle === 'double' ){
          context.lineWidth = style['border-width'].pxValue/3;

          var gco = context.globalCompositeOperation;
          context.globalCompositeOperation = 'destination-out';

          if( usePaths ){
            context.stroke( path );
          } else {
            context.stroke();
          }

          context.globalCompositeOperation = gco;
        }

      }

      if( usePaths ){
        context.translate( -pos.x, -pos.y );
      }

      // reset in case we changed the border style
      if( context.setLineDash ){ // for very outofdate browsers
        context.setLineDash([ ]);
      }

    // draw the overlay
    } else {

      if( overlayOpacity > 0 ){
        this.fillStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity);

        CanvasRenderer.nodeShapes['roundrectangle'].drawPath(
          context,
          node._private.position.x,
          node._private.position.y,
          nodeWidth + overlayPadding * 2,
          nodeHeight + overlayPadding * 2
        );

        context.fill();
      }
    }

  };

  // does the node have at least one pie piece?
  CRp.hasPie = function(node){
    node = node[0]; // ensure ele ref
    
    return node._private.hasPie;
  };

  CRp.drawPie = function( context, node, nodeOpacity ){
    node = node[0]; // ensure ele ref

    var _p = node._private;
    var style = _p.style;
    var pieSize = style['pie-size'];
    var nodeW = this.getNodeWidth( node );
    var nodeH = this.getNodeHeight( node );
    var x = _p.position.x;
    var y = _p.position.y;
    var radius = Math.min( nodeW, nodeH ) / 2; // must fit in node
    var lastPercent = 0; // what % to continue drawing pie slices from on [0, 1]
    var usePaths = CanvasRenderer.usePaths();

    if( usePaths ){
      x = 0;
      y = 0;
    }

    if( pieSize.units === '%' ){
      radius = radius * pieSize.value / 100;
    } else if( pieSize.pxValue !== undefined ){
      radius = pieSize.pxValue / 2;
    }

    for( var i = 1; i <= $$.style.pieBackgroundN; i++ ){ // 1..N
      var size = style['pie-' + i + '-background-size'].value;
      var color = style['pie-' + i + '-background-color'].value;
      var opacity = style['pie-' + i + '-background-opacity'].value * nodeOpacity;
      var percent = size / 100; // map integer range [0, 100] to [0, 1]
      var angleStart = 1.5 * Math.PI + 2 * Math.PI * lastPercent; // start at 12 o'clock and go clockwise
      var angleDelta = 2 * Math.PI * percent;
      var angleEnd = angleStart + angleDelta;

      // ignore if
      // - zero size
      // - we're already beyond the full circle
      // - adding the current slice would go beyond the full circle
      if( size === 0 || lastPercent >= 1 || lastPercent + percent > 1 ){
        continue;
      }

      context.beginPath();
      context.moveTo(x, y);
      context.arc( x, y, radius, angleStart, angleEnd );
      context.closePath();

      this.fillStyle(context, color[0], color[1], color[2], opacity);

      context.fill();

      lastPercent += percent;
    }

  };

  
})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');
  var CR = CanvasRenderer;
  var CRp = CanvasRenderer.prototype;

  // var isFirefox = typeof InstallTrigger !== 'undefined';

  CRp.getPixelRatio = function(){ 
    var context = this.data.contexts[0];

    if( this.forcedPixelRatio != null ){
      return this.forcedPixelRatio;
    }

    var backingStore = context.backingStorePixelRatio ||
      context.webkitBackingStorePixelRatio ||
      context.mozBackingStorePixelRatio ||
      context.msBackingStorePixelRatio ||
      context.oBackingStorePixelRatio ||
      context.backingStorePixelRatio || 1;

    //console.log(window.devicePixelRatio, backingStore);

    // if( isFirefox ){ // because ff can't scale canvas properly
    //   return 1;
    // }

    return (window.devicePixelRatio || 1) / backingStore;
  };

  CRp.paintCache = function(context){
    var caches = this.paintCaches = this.paintCaches || [];
    var needToCreateCache = true;
    var cache;

    for(var i = 0; i < caches.length; i++ ){
      cache = caches[i];

      if( cache.context === context ){
        needToCreateCache = false;
        break;
      }
    }

    if( needToCreateCache ){
      cache = {
        context: context
      };
      caches.push( cache );
    }

    return cache;
  };

  CRp.fillStyle = function(context, r, g, b, a){
    context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
    
    // turn off for now, seems context does its own caching

    // var cache = this.paintCache(context);

    // var fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

    // if( cache.fillStyle !== fillStyle ){
    //   context.fillStyle = cache.fillStyle = fillStyle;
    // }
  };

  CRp.strokeStyle = function(context, r, g, b, a){
    context.strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
    
    // turn off for now, seems context does its own caching

    // var cache = this.paintCache(context);

    // var strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

    // if( cache.strokeStyle !== strokeStyle ){
    //   context.strokeStyle = cache.strokeStyle = strokeStyle;
    // }
  };
  
  CRp.shadowStyle = function(context, color, opacity, blur, offsetX, offsetY){
    var zoom = this.data.cy.zoom();

    var cache = this.paintCache(context);
    
    // don't make expensive changes to the shadow style if it's not used
    if( cache.shadowOpacity === 0 && opacity === 0 ){
      return;
    }

    cache.shadowOpacity = opacity;

    if (opacity > 0) {
      context.shadowBlur = blur * zoom;
      context.shadowColor = "rgba(" + color[0] + "," + color[1] + "," + color[2] + "," + opacity + ")";
      context.shadowOffsetX = offsetX * zoom;
      context.shadowOffsetY = offsetY * zoom;
    } else {
      context.shadowBlur = 0;
      context.shadowColor = "transparent";
    }
  };

  // Resize canvas
  CRp.matchCanvasSize = function(container) {
    var data = this.data;
    var width = container.clientWidth;
    var height = container.clientHeight;
    var pixelRatio = this.getPixelRatio();
    var mbPxRatio = this.motionBlurPxRatio;

    if(
      container === this.data.bufferCanvases[CR.MOTIONBLUR_BUFFER_NODE] ||
      container === this.data.bufferCanvases[CR.MOTIONBLUR_BUFFER_DRAG]
    ){
      pixelRatio = mbPxRatio;
    }

    var canvasWidth = width * pixelRatio;
    var canvasHeight = height * pixelRatio;
    var canvas;

    if( canvasWidth === this.canvasWidth && canvasHeight === this.canvasHeight ){
      return; // save cycles if same
    }

    this.fontCaches = null; // resizing resets the style

    var canvasContainer = data.canvasContainer;
    canvasContainer.style.width = width + 'px';
    canvasContainer.style.height = height + 'px';

    for (var i = 0; i < CanvasRenderer.CANVAS_LAYERS; i++) {

      canvas = data.canvases[i];
      
      if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {
        
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
      }
    }
    
    for (var i = 0; i < CanvasRenderer.BUFFER_COUNT; i++) {
      
      canvas = data.bufferCanvases[i];
      
      if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {
        
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
      }
    }

    this.textureMult = 1;
    if( pixelRatio <= 1 ){
      canvas = data.bufferCanvases[ CanvasRenderer.TEXTURE_BUFFER ];

      this.textureMult = 2;
      canvas.width = canvasWidth * this.textureMult;
      canvas.height = canvasHeight * this.textureMult;
    }

    this.canvasWidth = canvasWidth;
    this.canvasHeight = canvasHeight;

  };

  CRp.renderTo = function( cxt, zoom, pan, pxRatio ){
    this.redraw({
      forcedContext: cxt,
      forcedZoom: zoom,
      forcedPan: pan,
      drawAllLayers: true,
      forcedPxRatio: pxRatio
    });
  };

  CRp.timeToRender = function(){
    return this.redrawTotalTime / this.redrawCount;
  };

  CanvasRenderer.minRedrawLimit = 1000/60; // people can't see much better than 60fps
  CanvasRenderer.maxRedrawLimit = 1000;  // don't cap max b/c it's more important to be responsive than smooth
  CanvasRenderer.motionBlurDelay = 100;

  // Redraw frame
  CRp.redraw = function( options ) {
    options = options || {};

    // console.log('redraw()');

    var forcedContext = options.forcedContext;
    var drawAllLayers = options.drawAllLayers;
    var drawOnlyNodeLayer = options.drawOnlyNodeLayer;
    var forcedZoom = options.forcedZoom;
    var forcedPan = options.forcedPan;
    var r = this;
    var pixelRatio = options.forcedPxRatio === undefined ? this.getPixelRatio() : options.forcedPxRatio;
    var cy = r.data.cy; var data = r.data; 
    var needDraw = data.canvasNeedsRedraw;
    var textureDraw = r.textureOnViewport && !forcedContext && (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming);
    var motionBlur = options.motionBlur !== undefined ? options.motionBlur : r.motionBlur;
    var mbPxRatio = r.motionBlurPxRatio;
    var hasCompoundNodes = cy.hasCompoundNodes();
    var inNodeDragGesture = r.hoverData.draggingEles;
    var inBoxSelection = r.hoverData.selecting || r.touchData.selecting ? true : false;
    motionBlur = motionBlur && !forcedContext && r.motionBlurEnabled && !inBoxSelection;
    var motionBlurFadeEffect = motionBlur;

    // console.log('textureDraw?', textureDraw);


    if( !forcedContext && r.motionBlurTimeout ){
      clearTimeout( r.motionBlurTimeout );
    }

    if( !forcedContext && this.redrawTimeout ){
      clearTimeout( this.redrawTimeout );
    }
    this.redrawTimeout = null;

    if( this.averageRedrawTime === undefined ){ this.averageRedrawTime = 0; }

    var minRedrawLimit = CanvasRenderer.minRedrawLimit; 
    var maxRedrawLimit = CanvasRenderer.maxRedrawLimit;

    var redrawLimit = this.averageRedrawTime; // estimate the ideal redraw limit based on how fast we can draw
    redrawLimit = minRedrawLimit > redrawLimit ? minRedrawLimit : redrawLimit;
    redrawLimit = redrawLimit < maxRedrawLimit ? redrawLimit : maxRedrawLimit;

    //console.log('--\nideal: %i; effective: %i', this.averageRedrawTime, redrawLimit);

    if( this.lastDrawTime === undefined ){ this.lastDrawTime = 0; }

    var nowTime = Date.now();
    var timeElapsed = nowTime - this.lastDrawTime;
    var callAfterLimit = timeElapsed >= redrawLimit;

    if( !forcedContext && !r.clearingMotionBlur ){
      if( !callAfterLimit || this.currentlyDrawing ){
        // console.log('-- skip', redrawLimit);

        // we have new things to draw but we're busy, so try again when possibly free
        this.redrawTimeout = setTimeout(function(){
          r.redraw();
        }, redrawLimit);
        return;
      }

      this.lastDrawTime = nowTime;
      this.currentlyDrawing = true;
    }

    if( motionBlur ){
      if( r.mbFrames == null ){
        r.mbFrames = 0;
      }

      if( !r.drawingImage ){ // image loading frames don't count towards motion blur blurry frames
        r.mbFrames++;
      }
      
      if( r.mbFrames < 3 ){ // need several frames before even high quality motionblur
        motionBlurFadeEffect = false;
      }

      // go to lower quality blurry frames when several m/b frames have been rendered (avoids flashing)
      if( r.mbFrames > r.minMbLowQualFrames ){
        //r.fullQualityMb = false;
        r.motionBlurPxRatio = r.mbPxRBlurry;
      }
    } 

    // console.log('mb: %s, N: %s, q: %s', motionBlur, r.mbFrames, r.motionBlurPxRatio);

    if( r.clearingMotionBlur ){
      //r.fullQualityMb = true; // TODO enable when doesn't cause scaled flashing issue

      r.motionBlurPxRatio = 1;
    }


    var startTime = Date.now();

    // console.log('-- redraw --')
    
    function drawToContext(){ 
      // startTime = Date.now();
      // console.profile('draw' + startTime)
      
      // b/c drawToContext() may be async w.r.t. redraw(), keep track of last texture frame
      // because a rogue async texture frame would clear needDraw
      if( r.textureDrawLastFrame && !textureDraw ){
        needDraw[CR.NODE] = true;
        needDraw[CR.SELECT_BOX] = true;
      }
      
      // console.log('drawToContext()');
      // console.log( 'needDraw', needDraw[CR.NODE], needDraw[CR.DRAG], needDraw[CR.SELECT_BOX] );

      var edges = r.getCachedEdges();
      var coreStyle = cy.style()._private.coreStyle;
      
      var zoom = cy.zoom();
      var effectiveZoom = forcedZoom !== undefined ? forcedZoom : zoom;
      var pan = cy.pan();
      var effectivePan = {
        x: pan.x,
        y: pan.y
      };

      var vp = {
        zoom: zoom,
        pan: {
          x: pan.x,
          y: pan.y
        }
      };
      var prevVp = r.prevViewport;
      var viewportIsDiff = prevVp === undefined || vp.zoom !== prevVp.zoom || vp.pan.x !== prevVp.pan.x || vp.pan.y !== prevVp.pan.y;

      // we want the low quality motionblur only when the viewport is being manipulated etc (where it's not noticed)
      if( !viewportIsDiff && !(inNodeDragGesture && !hasCompoundNodes) ){
        r.motionBlurPxRatio = 1;
      }

      if( forcedPan ){
        effectivePan = forcedPan;
      }

      // apply pixel ratio

      effectiveZoom *= pixelRatio;
      effectivePan.x *= pixelRatio;
      effectivePan.y *= pixelRatio;
      
      var eles = {
        drag: {
          nodes: [],
          edges: [],
          eles: []
        },
        nondrag: {
          nodes: [],
          edges: [],
          eles: []
        }
      };

      function mbclear( context, x, y, w, h ){
        var gco = context.globalCompositeOperation;

        context.globalCompositeOperation = 'destination-out';
        r.fillStyle( context, 255, 255, 255, r.motionBlurTransparency );
        context.fillRect(x, y, w, h);

        context.globalCompositeOperation = gco;
      }

      function setContextTransform(context, clear){
        var ePan, eZoom, w, h;

        if( /*!r.fullQualityMb &&*/ !r.clearingMotionBlur && (context === data.bufferContexts[CR.MOTIONBLUR_BUFFER_NODE] || context === data.bufferContexts[CR.MOTIONBLUR_BUFFER_DRAG]) ){
          ePan = {
            x: pan.x * mbPxRatio,
            y: pan.y * mbPxRatio
          };

          eZoom = zoom * mbPxRatio;

          w = r.canvasWidth * mbPxRatio;
          h = r.canvasHeight * mbPxRatio;
        } else {
          ePan = effectivePan;
          eZoom = effectiveZoom;

          w = r.canvasWidth;
          h = r.canvasHeight;
        }

        context.setTransform(1, 0, 0, 1, 0, 0);

        if( clear === 'motionBlur' ){ 
          mbclear(context, 0, 0, w, h);
        } else if( !forcedContext && (clear === undefined || clear) ){
          context.clearRect(0, 0, w, h);
        }
        
        if( !drawAllLayers ){
          context.translate( ePan.x, ePan.y );
          context.scale( eZoom, eZoom );
        }
        if( forcedPan ){
          context.translate( forcedPan.x, forcedPan.y );
        } 
        if( forcedZoom ){
          context.scale( forcedZoom, forcedZoom );
        }
      }

      if( !textureDraw ){
        r.textureDrawLastFrame = false;
      }

      if( textureDraw ){
        // console.log('textureDraw')
        
        r.textureDrawLastFrame = true;

        var bb;

        if( !r.textureCache ){
          r.textureCache = {};

          bb = r.textureCache.bb = cy.elements().boundingBox();

          r.textureCache.texture = r.data.bufferCanvases[ CanvasRenderer.TEXTURE_BUFFER ];

          var cxt = r.data.bufferContexts[ CanvasRenderer.TEXTURE_BUFFER ];

          cxt.setTransform(1, 0, 0, 1, 0, 0);
          cxt.clearRect(0, 0, r.canvasWidth * r.textureMult, r.canvasHeight * r.textureMult);
          
          r.redraw({
            forcedContext: cxt,
            drawOnlyNodeLayer: true,
            forcedPxRatio: pixelRatio * r.textureMult
          });

          var vp = r.textureCache.viewport = {
            zoom: cy.zoom(),
            pan: cy.pan(),
            width: r.canvasWidth,
            height: r.canvasHeight
          };

          vp.mpan = {
            x: (0 - vp.pan.x)/vp.zoom,
            y: (0 - vp.pan.y)/vp.zoom
          };
        }

        needDraw[CR.DRAG] = false;
        needDraw[CR.NODE] = false;

        var context = data.contexts[CR.NODE];

        var texture = r.textureCache.texture;
        var vp = r.textureCache.viewport;
        bb = r.textureCache.bb;

        context.setTransform(1, 0, 0, 1, 0, 0);

        if( motionBlur ){
          mbclear(context, 0, 0, vp.width, vp.height);
        } else {
          context.clearRect(0, 0, vp.width, vp.height);
        }

        var outsideBgColor = coreStyle['outside-texture-bg-color'].value;
        var outsideBgOpacity = coreStyle['outside-texture-bg-opacity'].value;
        r.fillStyle( context, outsideBgColor[0], outsideBgColor[1], outsideBgColor[2], outsideBgOpacity );
        context.fillRect( 0, 0, vp.width, vp.height );

        var zoom = cy.zoom();
        
        setContextTransform( context, false );

        context.clearRect( vp.mpan.x, vp.mpan.y, vp.width/vp.zoom/pixelRatio, vp.height/vp.zoom/pixelRatio );
        context.drawImage( texture, vp.mpan.x, vp.mpan.y, vp.width/vp.zoom/pixelRatio, vp.height/vp.zoom/pixelRatio );

      } else if( r.textureOnViewport && !forcedContext ){ // clear the cache since we don't need it
        r.textureCache = null;
      }

      var vpManip = (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming || r.hoverData.draggingEles);
      var hideEdges = r.hideEdgesOnViewport && vpManip;
      var hideLabels = r.hideLabelsOnViewport && vpManip;

      if (needDraw[CR.DRAG] || needDraw[CR.NODE] || drawAllLayers || drawOnlyNodeLayer) {
        //NB : VERY EXPENSIVE

        if( hideEdges ){ 
        } else {
          r.findEdgeControlPoints(edges);
        }

        var zEles = r.getCachedZSortedEles();
        var extent = cy.extent();

        for (var i = 0; i < zEles.length; i++) {
          var ele = zEles[i];
          var list;
          var bb = forcedContext ? null : ele.boundingBox();
          var insideExtent = forcedContext ? true : $$.math.boundingBoxesIntersect( extent, bb );

          if( !insideExtent ){ continue; } // no need to render

          if ( ele._private.rscratch.inDragLayer ) {
            list = eles.drag;
          } else {
            list = eles.nondrag;
          }

          list.eles.push( ele );
        }

      }
      
      
      function drawElements( list, context ){
        var eles = list.eles;

        for( var i = 0; i < eles.length; i++ ){
          var ele = eles[i];

          if( ele.isNode() ){
            r.drawNode(context, ele);

            if( !hideLabels ){
              r.drawNodeText(context, ele);
            }

            r.drawNode(context, ele, true);
          } else if( !hideEdges ) {
            r.drawEdge(context, ele);

            if( !hideLabels ){
              r.drawEdgeText(context, ele);
            }

            r.drawEdge(context, ele, true);
          }
          
          
        }

      }

      var needMbClear = [];

      needMbClear[CR.NODE] = !needDraw[CR.NODE] && motionBlur && !r.clearedForMotionBlur[CR.NODE] || r.clearingMotionBlur;
      if( needMbClear[CR.NODE] ){ r.clearedForMotionBlur[CR.NODE] = true; }

      needMbClear[CR.DRAG] = !needDraw[CR.DRAG] && motionBlur && !r.clearedForMotionBlur[CR.DRAG] || r.clearingMotionBlur;
      if( needMbClear[CR.DRAG] ){ r.clearedForMotionBlur[CR.DRAG] = true; }

      // console.log('--');

      // if( needDraw[CR.DRAG] && motionBlur && needDraw[CR.NODE] && inNodeDragGesture ){
      //   console.log('NODE blurclean');
      // 
      //   var context = data.contexts[CR.NODE];
      // 
      //   setContextTransform( context, true );
      //   drawElements(eles.nondrag, context);
      // 
      //   needDraw[CR.NODE] = false; 
      //   needMbClear[CR.NODE] = false;
      // 
      // } else 
      if( needDraw[CR.NODE] || drawAllLayers || drawOnlyNodeLayer || needMbClear[CR.NODE] ){
        // console.log('NODE', needDraw[CR.NODE], needMbClear[CR.NODE]);

        var useBuffer = motionBlur && !needMbClear[CR.NODE] && mbPxRatio !== 1;
        var context = forcedContext || ( useBuffer ? r.data.bufferContexts[ CR.MOTIONBLUR_BUFFER_NODE ] : data.contexts[CR.NODE] );
        var clear = motionBlur && !useBuffer ? 'motionBlur' : undefined;

        // if( needDraw[CR.DRAG] && needDraw[CR.NODE] ){
        //   clear = true;
        // }

        setContextTransform( context, clear );
        drawElements(eles.nondrag, context);
        
        if( !drawAllLayers && !motionBlur ){
          needDraw[CR.NODE] = false; 
        }
      }

      if ( !drawOnlyNodeLayer && (needDraw[CR.DRAG] || drawAllLayers || needMbClear[CR.DRAG]) ) {
        // console.log('DRAG');

        var useBuffer = motionBlur && !needMbClear[CR.DRAG] && mbPxRatio !== 1;
        var context = forcedContext || ( useBuffer ? r.data.bufferContexts[ CR.MOTIONBLUR_BUFFER_DRAG ] : data.contexts[CR.DRAG] );
        
        setContextTransform( context, motionBlur && !useBuffer ? 'motionBlur' : undefined );
        drawElements(eles.drag, context);
        
        if( !drawAllLayers && !motionBlur ){
          needDraw[CR.DRAG] = false;
        }
      }
      
      if( r.showFps || (!drawOnlyNodeLayer && (needDraw[CR.SELECT_BOX] && !drawAllLayers)) ) {
        // console.log('redrawing selection box');
        
        var context = forcedContext || data.contexts[CR.SELECT_BOX];

        setContextTransform( context );

        if( data.select[4] == 1 && ( r.hoverData.selecting || r.touchData.selecting ) ){
          var zoom = data.cy.zoom();
          var borderWidth = coreStyle['selection-box-border-width'].value / zoom;
          
          context.lineWidth = borderWidth;
          context.fillStyle = "rgba(" 
            + coreStyle['selection-box-color'].value[0] + ","
            + coreStyle['selection-box-color'].value[1] + ","
            + coreStyle['selection-box-color'].value[2] + ","
            + coreStyle['selection-box-opacity'].value + ")";
          
          context.fillRect(
            data.select[0],
            data.select[1],
            data.select[2] - data.select[0],
            data.select[3] - data.select[1]);
          
          if (borderWidth > 0) {
            context.strokeStyle = "rgba(" 
              + coreStyle['selection-box-border-color'].value[0] + ","
              + coreStyle['selection-box-border-color'].value[1] + ","
              + coreStyle['selection-box-border-color'].value[2] + ","
              + coreStyle['selection-box-opacity'].value + ")";
            
            context.strokeRect(
              data.select[0],
              data.select[1],
              data.select[2] - data.select[0],
              data.select[3] - data.select[1]);
          }
        }

        if( data.bgActivePosistion && !r.hoverData.selecting ){
          var zoom = data.cy.zoom();
          var pos = data.bgActivePosistion;

          context.fillStyle = "rgba(" 
            + coreStyle['active-bg-color'].value[0] + ","
            + coreStyle['active-bg-color'].value[1] + ","
            + coreStyle['active-bg-color'].value[2] + ","
            + coreStyle['active-bg-opacity'].value + ")";

          context.beginPath();
          context.arc(pos.x, pos.y, coreStyle['active-bg-size'].pxValue / zoom, 0, 2 * Math.PI); 
          context.fill();
        }
        
        var timeToRender = r.averageRedrawTime;
        if( r.showFps && timeToRender ){
          timeToRender = Math.round( timeToRender );
          var fps = Math.round(1000/timeToRender);

          context.setTransform(1, 0, 0, 1, 0, 0);

          //context.font = '20px helvetica';
          context.fillStyle = 'rgba(255, 0, 0, 0.75)';
          context.strokeStyle = 'rgba(255, 0, 0, 0.75)';
          context.lineWidth = 1;
          context.fillText( '1 frame = ' + timeToRender + ' ms = ' + fps + ' fps', 0, 20);

          var maxFps = 60;
          context.strokeRect(0, 30, 250, 20);
          context.fillRect(0, 30, 250 * Math.min(fps/maxFps, 1), 20);
        }

        if( !drawAllLayers ){
          needDraw[CR.SELECT_BOX] = false; 
        }
      }

      // motionblur: blit rendered blurry frames
      if( motionBlur && mbPxRatio !== 1 ){
        var cxtNode = data.contexts[CR.NODE];
        var txtNode = r.data.bufferCanvases[ CR.MOTIONBLUR_BUFFER_NODE ];

        var cxtDrag = data.contexts[CR.DRAG];
        var txtDrag = r.data.bufferCanvases[ CR.MOTIONBLUR_BUFFER_DRAG ];

        var drawMotionBlur = function( cxt, txt, needClear ){
          cxt.setTransform(1, 0, 0, 1, 0, 0);

          if( needClear || !motionBlurFadeEffect ){
            cxt.clearRect( 0, 0, r.canvasWidth, r.canvasHeight );
          } else {
            mbclear( cxt, 0, 0, r.canvasWidth, r.canvasHeight );
          }
          
          var pxr = /*r.fullQualityMb ? 1 :*/ mbPxRatio;

          cxt.drawImage( 
            txt, // img
            0, 0, // sx, sy
            r.canvasWidth * pxr, r.canvasHeight * pxr, // sw, sh
            0, 0, // x, y
            r.canvasWidth, r.canvasHeight // w, h
          );
        };

        if( needDraw[CR.NODE] || needMbClear[CR.NODE] ){
          // console.log('mb NODE', needMbClear[CR.NODE]);

          drawMotionBlur( cxtNode, txtNode, needMbClear[CR.NODE] );
          needDraw[CR.NODE] = false;
        }

        if( needDraw[CR.DRAG] || needMbClear[CR.DRAG] ){
          // console.log('mb DRAG');

          drawMotionBlur( cxtDrag, txtDrag, needMbClear[CR.DRAG] );
          needDraw[CR.DRAG] = false;
          //needMbClear[CR.NODE] = true;
        }
      }


      var endTime = Date.now();

      if( r.averageRedrawTime === undefined ){
        r.averageRedrawTime = endTime - startTime;
      }

      if( r.redrawCount === undefined ){
        r.redrawCount = 0;
      }

      r.redrawCount++;

      if( r.redrawTotalTime === undefined ){
        r.redrawTotalTime = 0;
      }

      r.redrawTotalTime += endTime - startTime;
      r.lastRedrawTime = endTime - startTime;

      // use a weighted average with a bias from the previous average so we don't spike so easily
      r.averageRedrawTime = r.averageRedrawTime/2 + (endTime - startTime)/2;
      //console.log('actual: %i, average: %i', endTime - startTime, this.averageRedrawTime);

      r.currentlyDrawing = false;

      r.prevViewport = vp;

      // console.profileEnd('draw' + startTime)

      if( r.clearingMotionBlur ){
        r.clearingMotionBlur = false;
        r.motionBlurCleared = true;
        r.motionBlur = true;
      }

      if( motionBlur ){ 
        r.motionBlurTimeout = setTimeout(function(){
          r.motionBlurTimeout = null;
          // console.log('mb CLEAR');

          r.clearedForMotionBlur[CR.NODE] = false;
          r.clearedForMotionBlur[CR.DRAG] = false;
          r.motionBlur = false;
          r.clearingMotionBlur = !textureDraw;
          r.mbFrames = 0;

          needDraw[CR.NODE] = true; 
          needDraw[CR.DRAG] = true; 

          r.redraw();
        }, CanvasRenderer.motionBlurDelay);
      }

      r.drawingImage = false;

    } // draw to context

    if( !forcedContext ){
      $$.util.requestAnimationFrame(drawToContext); // makes direct renders to screen a bit more responsive
    } else {
      drawToContext();
    }

    if( !forcedContext && !r.initrender ){
      r.initrender = true;
      cy.trigger('initrender');
    }

    if( !forcedContext ){
      cy.triggerOnRender();
    }
    
  };

})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');
  var CRp = CanvasRenderer.prototype;

  // @O Polygon drawing
  CRp.drawPolygonPath = function(
    context, x, y, width, height, points) {

    var halfW = width / 2;
    var halfH = height / 2;

    if( context.beginPath ){ context.beginPath(); }

    context.moveTo( x + halfW * points[0], y + halfH * points[1] );

    for (var i = 1; i < points.length / 2; i++) {
      context.lineTo( x + halfW * points[i * 2], y + halfH * points[i * 2 + 1] );
    }
    
    context.closePath();
  };
  
  CRp.drawPolygon = function(
    context, x, y, width, height, points) {

    // Draw path
    this.drawPolygonPath(context, x, y, width, height, points);
    
    // Fill path
    context.fill();
  };
  
  // Round rectangle drawing
  CRp.drawRoundRectanglePath = function(
    context, x, y, width, height, radius) {
    
    var halfWidth = width / 2;
    var halfHeight = height / 2;
    var cornerRadius = $$.math.getRoundRectangleRadius(width, height);
    
    if( context.beginPath ){ context.beginPath(); }
    
    // Start at top middle
    context.moveTo(x, y - halfHeight);
    // Arc from middle top to right side
    context.arcTo(x + halfWidth, y - halfHeight, x + halfWidth, y, cornerRadius);
    // Arc from right side to bottom
    context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);
    // Arc from bottom to left side
    context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);
    // Arc from left side to topBorder
    context.arcTo(x - halfWidth, y - halfHeight, x, y - halfHeight, cornerRadius);
    // Join line
    context.lineTo(x, y - halfHeight);
    
    
    context.closePath();
  };
  
  CRp.drawRoundRectangle = function(
    context, x, y, width, height, radius) {
    
    this.drawRoundRectanglePath(context, x, y, width, height, radius);
    
    context.fill();
  };


})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');
  var CRp = CanvasRenderer.prototype;

  CRp.createBuffer = function(w, h) {
    var buffer = document.createElement('canvas');
    buffer.width = w;
    buffer.height = h;
    
    return [buffer, buffer.getContext('2d')];
  };

  CRp.bufferCanvasImage = function( options ){
    var data = this.data;
    var cy = data.cy;
    var bb = cy.elements().boundingBox();
    var width = options.full ? Math.ceil(bb.w) : this.data.container.clientWidth;
    var height = options.full ? Math.ceil(bb.h) : this.data.container.clientHeight;
    var scale = 1;

    if( options.scale !== undefined ){
      width *= options.scale;
      height *= options.scale;

      scale = options.scale;
    } else if( $$.is.number(options.maxWidth) || $$.is.number(options.maxHeight) ){
      var maxScaleW = Infinity;
      var maxScaleH = Infinity;

      if( $$.is.number(options.maxWidth) ){
        maxScaleW = scale * options.maxWidth / width;
      }

      if( $$.is.number(options.maxHeight) ){
        maxScaleH = scale * options.maxHeight / height;
      }

      scale = Math.min( maxScaleW, maxScaleH );

      width *= scale;
      height *= scale;
    }

    var buffCanvas = document.createElement('canvas');

    buffCanvas.width = width;
    buffCanvas.height = height;

    buffCanvas.style.width = width + 'px';
    buffCanvas.style.height = height + 'px';

    var buffCxt = buffCanvas.getContext('2d');

    // Rasterize the layers, but only if container has nonzero size
    if (width > 0 && height > 0) {

      buffCxt.clearRect( 0, 0, width, height );

      if( options.bg ){
        buffCxt.fillStyle = options.bg;
        buffCxt.rect( 0, 0, width, height );
        buffCxt.fill();
      }

      buffCxt.globalCompositeOperation = 'source-over';

      if( options.full ){ // draw the full bounds of the graph
        this.redraw({
          forcedContext: buffCxt,
          drawAllLayers: true,
          forcedZoom: scale,
          forcedPan: { x: -bb.x1*scale, y: -bb.y1*scale },
          forcedPxRatio: 1
        });
      } else { // draw the current view
        var cyPan = cy.pan();
        var pan = {
          x: cyPan.x * scale,
          y: cyPan.y * scale
        };
        var zoom = cy.zoom() * scale;

        this.redraw({
          forcedContext: buffCxt,
          drawAllLayers: true,
          forcedZoom: zoom,
          forcedPan: pan,
          forcedPxRatio: 1
        });
      }
    }

    return buffCanvas;
  }; 

  CRp.png = function( options ){
    return this.bufferCanvasImage( options ).toDataURL('image/png');
  };
  
  CRp.jpg = function( options ){
    return this.bufferCanvasImage( options ).toDataURL('image/jpeg');
  };

})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');
  var CR = CanvasRenderer;
  var CRp = CR.prototype;

  CRp.registerBinding = function(target, event, handler, useCapture){
    this.bindings.push({
      target: target,
      event: event,
      handler: handler,
      useCapture: useCapture
    });

    target.addEventListener(event, handler, useCapture);
  };

  CRp.nodeIsDraggable = function(node) {
    if (node._private.style['opacity'].value !== 0
      && node._private.style['visibility'].value == 'visible'
      && node._private.style['display'].value == 'element'
      && !node.locked()
      && node.grabbable() ) {

      return true;
    }

    return false;
  };

  CRp.load = function() {
    var r = this;

    var getDragListIds = function(opts){
      var listHasId;

      if( opts.addToList && r.data.cy.hasCompoundNodes() ){ // only needed for compound graphs
        if( !opts.addToList.hasId ){ // build ids lookup if doesn't already exist
          opts.addToList.hasId = {};

          for( var i = 0; i < opts.addToList.length; i++ ){
            var ele = opts.addToList[i];

            opts.addToList.hasId[ ele.id() ] = true;
          }
        }

        listHasId = opts.addToList.hasId;
      }

      return listHasId || {};
    };

    // helper function to determine which child nodes and inner edges
    // of a compound node to be dragged as well as the grabbed and selected nodes
    var addDescendantsToDrag = function(node, opts){
      if( !node._private.cy.hasCompoundNodes() ){
        return;
      }

      if( opts.inDragLayer == null && opts.addToList == null ){ return; } // nothing to do

      var listHasId = getDragListIds( opts );

      var innerNodes = node.descendants();

      // TODO do not drag hidden children & children of hidden children?
      for( var i = 0; i < innerNodes.size(); i++ ){
        var iNode = innerNodes[i];
        var _p = iNode._private;

        if( opts.inDragLayer ){
          _p.rscratch.inDragLayer = true;
        }

        if( opts.addToList && !listHasId[ iNode.id() ] ){
          opts.addToList.push( iNode );
          listHasId[ iNode.id() ] = true;

          _p.grabbed = true;
        }

        var edges = _p.edges;
        for( var j = 0; opts.inDragLayer && j < edges.length; j++ ){
          edges[j]._private.rscratch.inDragLayer = true;
        }
      }
    };

    // adds the given nodes, and its edges to the drag layer
    var addNodeToDrag = function(node, opts){

      var _p = node._private;
      var listHasId = getDragListIds( opts );

      if( opts.inDragLayer ){
        _p.rscratch.inDragLayer = true;
      }

      if( opts.addToList && !listHasId[ node.id() ] ){
        opts.addToList.push( node );
        listHasId[ node.id() ] = true;

        _p.grabbed = true;
      }

      var edges = _p.edges;
      for( var i = 0; opts.inDragLayer && i < edges.length; i++ ){
        edges[i]._private.rscratch.inDragLayer = true;
      }

      addDescendantsToDrag( node, opts ); // always add to drag

      // also add nodes and edges related to the topmost ancestor
      updateAncestorsInDragLayer( node, {
        inDragLayer: opts.inDragLayer
      } );
    };
    
    var freeDraggedElements = function( draggedElements ){
      if( !draggedElements ){ return; }
      
      for (var i=0; i < draggedElements.length; i++) {

        var dEi_p = draggedElements[i]._private;

        if(dEi_p.group === 'nodes') {
          dEi_p.rscratch.inDragLayer = false;
          dEi_p.grabbed = false;

          var sEdges = dEi_p.edges;
          for( var j = 0; j < sEdges.length; j++ ){ sEdges[j]._private.rscratch.inDragLayer = false; }

          // for compound nodes, also remove related nodes and edges from the drag layer
          updateAncestorsInDragLayer(draggedElements[i], { inDragLayer: false });

        } else if( dEi_p.group === 'edges' ){
          dEi_p.rscratch.inDragLayer = false;
        }

      }
    };

    // helper function to determine which ancestor nodes and edges should go
    // to the drag layer (or should be removed from drag layer).
    var updateAncestorsInDragLayer = function(node, opts) {

      if( opts.inDragLayer == null && opts.addToList == null ){ return; } // nothing to do

      // find top-level parent
      var parent = node;

      if( !node._private.cy.hasCompoundNodes() ){
        return;
      }

      while( parent.parent().nonempty() ){
        parent = parent.parent()[0];
      }

      // no parent node: no nodes to add to the drag layer
      if( parent == node ){
        return;
      }

      var nodes = parent.descendants()
        .merge( parent )
        .unmerge( node )
        .unmerge( node.descendants() )
      ;

      var edges = nodes.connectedEdges();

      var listHasId = getDragListIds( opts );

      for( var i = 0; i < nodes.size(); i++ ){
        if( opts.inDragLayer !== undefined ){
          nodes[i]._private.rscratch.inDragLayer = opts.inDragLayer;
        }

        if( opts.addToList && !listHasId[ nodes[i].id() ] ){
          opts.addToList.push( nodes[i] );
          listHasId[ nodes[i].id() ] = true;

          nodes[i]._private.grabbed = true;
        }
      }

      for( var j = 0; opts.inDragLayer !== undefined && j < edges.length; j++ ) {
        edges[j]._private.rscratch.inDragLayer = opts.inDragLayer;
      }
    };

    if( typeof MutationObserver !== 'undefined' ){
      r.removeObserver = new MutationObserver(function( mutns ){
        for( var i = 0; i < mutns.length; i++ ){
          var mutn = mutns[i];
          var rNodes = mutn.removedNodes;

          if( rNodes ){ for( var j = 0; j < rNodes.length; j++ ){
            var rNode = rNodes[j];

            if( rNode === r.data.container ){
              r.destroy();
              break;
            }
          } }
        }
      });

      r.removeObserver.observe( r.data.container.parentNode, { childList: true } );
    } else {
      r.registerBinding(r.data.container, 'DOMNodeRemoved', function(e){
        r.destroy();
      });
    }



    // auto resize
    r.registerBinding(window, 'resize', $$.util.debounce( function(e) {
      r.invalidateContainerClientCoordsCache();

      r.matchCanvasSize(r.data.container);
      r.data.canvasNeedsRedraw[CR.NODE] = true;
      r.redraw();
    }, 100 ) );

    var invalCtnrBBOnScroll = function(domEle){
      r.registerBinding(domEle, 'scroll', function(e){
        r.invalidateContainerClientCoordsCache();
      } );
    };

    var bbCtnr = r.data.cy.container();

    for( ;; ){

      invalCtnrBBOnScroll( bbCtnr );

      if( bbCtnr.parentNode ){
        bbCtnr = bbCtnr.parentNode;
      } else {
        break;
      }

    }

    // stop right click menu from appearing on cy
    r.registerBinding(r.data.container, 'contextmenu', function(e){
      e.preventDefault();
    });

    var inBoxSelection = function(){
      return r.data.select[4] !== 0;
    };

    // Primary key
    r.registerBinding(r.data.container, 'mousedown', function(e) {
      e.preventDefault();
      r.hoverData.capture = true;
      r.hoverData.which = e.which;

      var cy = r.data.cy;
      var pos = r.projectIntoViewport(e.clientX, e.clientY);
      var select = r.data.select;
      var near = r.findNearestElement(pos[0], pos[1], true, false);
      var draggedElements = r.dragData.possibleDragElements;

      r.hoverData.mdownPos = pos;
      
      var needsRedraw = r.data.canvasNeedsRedraw;

      var checkForTaphold = function(){
        r.hoverData.tapholdCancelled = false;

        clearTimeout( r.hoverData.tapholdTimeout );

        r.hoverData.tapholdTimeout = setTimeout(function(){

          if( r.hoverData.tapholdCancelled ){
            return;
          } else {
            var ele = r.hoverData.down;

            if( ele ){
              ele.trigger( new $$.Event(e, {
                type: 'taphold',
                cyPosition: { x: pos[0], y: pos[1] }
              }) );
            } else {
              cy.trigger( new $$.Event(e, {
                type: 'taphold',
                cyPosition: { x: pos[0], y: pos[1] }
              }) );
            }
          }

        }, r.tapholdDuration);
      };

      // Right click button
      if( e.which == 3 ){

        r.hoverData.cxtStarted = true;

        var cxtEvt = new $$.Event(e, {
          type: 'cxttapstart',
          cyPosition: { x: pos[0], y: pos[1] }
        });

        if( near ){
          near.activate();
          near.trigger( cxtEvt );

          r.hoverData.down = near;
        } else {
          cy.trigger( cxtEvt );
        }

        r.hoverData.downTime = (new Date()).getTime();
        r.hoverData.cxtDragged = false;

      // Primary button
      } else if (e.which == 1) {

        if( near ){
          near.activate();
        }

        // Element dragging
        {
          // If something is under the cursor and it is draggable, prepare to grab it
          if (near != null) {

            if( r.nodeIsDraggable(near) ){

              var grabEvent = new $$.Event(e, {
                type: 'grab',
                cyPosition: { x: pos[0], y: pos[1] }
              });

              if ( near.isNode() && !near.selected() ){

                draggedElements = r.dragData.possibleDragElements = [];
                addNodeToDrag( near, { addToList: draggedElements } );

                near.trigger(grabEvent);

              } else if ( near.isNode() && near.selected() ){
                draggedElements = r.dragData.possibleDragElements = [  ];

                var selectedNodes = cy.$(function(){ return this.isNode() && this.selected(); });

                for( var i = 0; i < selectedNodes.length; i++ ){

                  // Only add this selected node to drag if it is draggable, eg. has nonzero opacity
                  if( r.nodeIsDraggable( selectedNodes[i] ) ){
                    addNodeToDrag( selectedNodes[i], { addToList: draggedElements } );
                  }
                }

                near.trigger( grabEvent );
              }

              needsRedraw[CR.NODE] = true;
              needsRedraw[CR.DRAG] = true;

            }

            near
              .trigger(new $$.Event(e, {
                type: 'mousedown',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'tapstart',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'vmousedown',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
            ;

          } else if (near == null) {
            cy
              .trigger(new $$.Event(e, {
                type: 'mousedown',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'tapstart',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'vmousedown',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
            ;
          }

          r.hoverData.down = near;
          r.hoverData.downTime = (new Date()).getTime();

        }

        // Selection box
        if ( near == null || near.isEdge() ) {
          select[4] = 1;
          var timeUntilActive = Math.max( 0, CR.panOrBoxSelectDelay - (+new Date() - r.hoverData.downTime) );

          clearTimeout( r.bgActiveTimeout );

          if( cy.boxSelectionEnabled() || ( near && near.isEdge() ) ){
            r.bgActiveTimeout = setTimeout(function(){
              if( near ){
                near.unactivate();
              }

              r.data.bgActivePosistion = {
                x: pos[0],
                y: pos[1]
              };

              r.hoverData.dragging = true;

              //checkForTaphold();

              needsRedraw[CR.SELECT_BOX] = true;

              r.redraw();
            }, timeUntilActive);
          } else {
            r.data.bgActivePosistion = {
              x: pos[0],
              y: pos[1]
            };

            //r.hoverData.dragging = true;

            //checkForTaphold();

            needsRedraw[CR.SELECT_BOX] = true;

            r.redraw();
          }

        }

        checkForTaphold();

      }

      // Initialize selection box coordinates
      select[0] = select[2] = pos[0];
      select[1] = select[3] = pos[1];

    }, false);

    r.registerBinding(window, 'mousemove', $$.util.throttle( function(e) {
      var preventDefault = false;
      var capture = r.hoverData.capture;

      // save cycles if mouse events aren't to be captured
      if ( !capture ){
        var containerPageCoords = r.findContainerClientCoords();

        if (e.clientX > containerPageCoords[0] && e.clientX < containerPageCoords[0] + r.canvasWidth
          && e.clientY > containerPageCoords[1] && e.clientY < containerPageCoords[1] + r.canvasHeight
        ) {
          // inside container bounds so OK
        } else {
          return;
        }

        var cyContainer = r.data.container;
        var target = e.target;
        var tParent = target.parentNode;
        var containerIsTarget = false;

        while( tParent ){
          if( tParent === cyContainer ){
            containerIsTarget = true;
            break;
          }

          tParent = tParent.parentNode;
        }

        if( !containerIsTarget ){ return; } // if target is outisde cy container, then this event is not for us
      }

      var cy = r.data.cy;
      var zoom = cy.zoom();
      var pos = r.projectIntoViewport(e.clientX, e.clientY);
      var select = r.data.select;
      var needsRedraw = r.data.canvasNeedsRedraw;

      var near = null;
      if( !r.hoverData.draggingEles ){
        near = r.findNearestElement(pos[0], pos[1], true, false);
      }
      var last = r.hoverData.last;
      var down = r.hoverData.down;

      var disp = [pos[0] - select[2], pos[1] - select[3]];

      var draggedElements = r.dragData.possibleDragElements;

      var dx = select[2] - select[0];
      var dx2 = dx * dx;
      var dy = select[3] - select[1];
      var dy2 = dy * dy;
      var dist2 = dx2 + dy2;
      var rdist2 = dist2 * zoom * zoom;

      r.hoverData.tapholdCancelled = true;

      var updateDragDelta = function(){
        var dragDelta = r.hoverData.dragDelta = r.hoverData.dragDelta || [];

        if( dragDelta.length === 0 ){
          dragDelta.push( disp[0] );
          dragDelta.push( disp[1] );
        } else {
          dragDelta[0] += disp[0];
          dragDelta[1] += disp[1];
        }
      };


      preventDefault = true;

      // Mousemove event
      {
        if (near != null) {
          near
            .trigger(new $$.Event(e, {
              type: 'mousemove',
              cyPosition: { x: pos[0], y: pos[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'vmousemove',
              cyPosition: { x: pos[0], y: pos[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'tapdrag',
              cyPosition: { x: pos[0], y: pos[1] }
            }))
          ;

        } else if (near == null) {
          cy
            .trigger(new $$.Event(e, {
              type: 'mousemove',
              cyPosition: { x: pos[0], y: pos[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'vmousemove',
              cyPosition: { x: pos[0], y: pos[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'tapdrag',
              cyPosition: { x: pos[0], y: pos[1] }
            }))
          ;
        }

      }

      // trigger context drag if rmouse down
      if( r.hoverData.which === 3 ){
        var cxtEvt = new $$.Event(e, {
          type: 'cxtdrag',
          cyPosition: { x: pos[0], y: pos[1] }
        });

        if( down ){
          down.trigger( cxtEvt );
        } else {
          cy.trigger( cxtEvt );
        }

        r.hoverData.cxtDragged = true;

        if( !r.hoverData.cxtOver || near !== r.hoverData.cxtOver ){

          if( r.hoverData.cxtOver ){
            r.hoverData.cxtOver.trigger( new $$.Event(e, {
              type: 'cxtdragout',
              cyPosition: { x: pos[0], y: pos[1] }
            }) );

            // console.log('cxtdragout ' + r.hoverData.cxtOver.id());
          }

          r.hoverData.cxtOver = near;

          if( near ){
            near.trigger( new $$.Event(e, {
              type: 'cxtdragover',
              cyPosition: { x: pos[0], y: pos[1] }
            }) );

            // console.log('cxtdragover ' + near.id());
          }

        }

      // Check if we are drag panning the entire graph
      } else if (r.hoverData.dragging) {
        preventDefault = true;

        if( cy.panningEnabled() && cy.userPanningEnabled() ){
          var deltaP;

          if( r.hoverData.justStartedPan ){
            var mdPos = r.hoverData.mdownPos;

            deltaP = {
              x: ( pos[0] - mdPos[0] ) * zoom,
              y: ( pos[1] - mdPos[1] ) * zoom
            };

            r.hoverData.justStartedPan = false;

          } else {
            deltaP = {
              x: disp[0] * zoom,
              y: disp[1] * zoom
            };

          }

          cy.panBy( deltaP );

          r.hoverData.dragged = true;
        }

        // Needs reproject due to pan changing viewport
        pos = r.projectIntoViewport(e.clientX, e.clientY);

      // Checks primary button down & out of time & mouse not moved much
      } else if(
          select[4] == 1 && (down == null || down.isEdge())
          && ( !cy.boxSelectionEnabled() || (+new Date() - r.hoverData.downTime >= CR.panOrBoxSelectDelay) )
          //&& (Math.abs(select[3] - select[1]) + Math.abs(select[2] - select[0]) < 4)
          && !r.hoverData.selecting
          && rdist2 >= r.desktopTapThreshold2
          && cy.panningEnabled() && cy.userPanningEnabled()
      ){
        r.hoverData.dragging = true;
        r.hoverData.selecting = false;
        r.hoverData.justStartedPan = true;
        select[4] = 0;

      } else {
        // deactivate bg on box selection
        if (cy.boxSelectionEnabled() && !r.hoverData.dragging && Math.pow(select[2] - select[0], 2) + Math.pow(select[3] - select[1], 2) > 7 && select[4]){
          clearTimeout( r.bgActiveTimeout );
          r.data.bgActivePosistion = undefined;
          r.hoverData.selecting = true;

          needsRedraw[CR.SELECT_BOX] = true;
          r.redraw();
        }

        if( down && down.isEdge() && down.active() ){ down.unactivate(); }

        if (near != last) {

          if (last) {
            last.trigger( new $$.Event(e, {
              type: 'mouseout',
              cyPosition: { x: pos[0], y: pos[1] }
            }) );

            last.trigger( new $$.Event(e, {
              type: 'tapdragout',
              cyPosition: { x: pos[0], y: pos[1] }
            }) );
          }

          if (near) {
            near.trigger( new $$.Event(e, {
              type: 'mouseover',
              cyPosition: { x: pos[0], y: pos[1] }
            }) );

            near.trigger( new $$.Event(e, {
              type: 'tapdragover',
              cyPosition: { x: pos[0], y: pos[1] }
            }) );
          }

          r.hoverData.last = near;
        }

        if( down && down.isNode() && r.nodeIsDraggable(down) ){

          if( rdist2 >= r.desktopTapThreshold2 ){ // then drag

            var justStartedDrag = !r.dragData.didDrag;

            if( justStartedDrag ) {
              needsRedraw[CR.NODE] = true;
            }

            r.dragData.didDrag = true; // indicate that we actually did drag the node

            var toTrigger = [];

            for( var i = 0; i < draggedElements.length; i++ ){
              var dEle = draggedElements[i];

              // now, add the elements to the drag layer if not done already
              if( !r.hoverData.draggingEles ){
                addNodeToDrag( dEle, { inDragLayer: true } );
              }

              // Locked nodes not draggable, as well as non-visible nodes
              if( dEle.isNode() && r.nodeIsDraggable(dEle) && dEle.grabbed() ){
                var dPos = dEle._private.position;

                toTrigger.push( dEle );

                if( $$.is.number(disp[0]) && $$.is.number(disp[1]) ){
                  dPos.x += disp[0];
                  dPos.y += disp[1];

                  if( justStartedDrag ){
                    var dragDelta = r.hoverData.dragDelta;

                    if( $$.is.number(dragDelta[0]) && $$.is.number(dragDelta[1]) ){
                      dPos.x += dragDelta[0];
                      dPos.y += dragDelta[1];
                    }
                  }
                }

              }
            }

            r.hoverData.draggingEles = true;

            var tcol = (new $$.Collection(cy, toTrigger));

            tcol.updateCompoundBounds();
            tcol.trigger('position drag');

            needsRedraw[CR.DRAG] = true;
            r.redraw();

          } else { // otherwise save drag delta for when we actually start dragging so the relative grab pos is constant
            updateDragDelta();
          }
        }

        // prevent the dragging from triggering text selection on the page
        preventDefault = true;
      }

      select[2] = pos[0]; select[3] = pos[1];

      if( preventDefault ){
        if(e.stopPropagation) e.stopPropagation();
          if(e.preventDefault) e.preventDefault();
          return false;
        }
    }, 1000/30, { trailing: true }), false);

    r.registerBinding(window, 'mouseup', function(e) {
      // console.log('--\nmouseup', e)

      var capture = r.hoverData.capture;
      if (!capture) { return; }
      r.hoverData.capture = false;

      var cy = r.data.cy; var pos = r.projectIntoViewport(e.clientX, e.clientY); var select = r.data.select;
      var near = r.findNearestElement(pos[0], pos[1], true, false);
      var draggedElements = r.dragData.possibleDragElements; var down = r.hoverData.down;
      var shiftDown = e.shiftKey;
      var needsRedraw = r.data.canvasNeedsRedraw;

      if( r.data.bgActivePosistion ){
        needsRedraw[CR.SELECT_BOX] = true;
        r.redraw();
      }

      r.data.bgActivePosistion = undefined; // not active bg now
      clearTimeout( r.bgActiveTimeout );

      if( down ){
        down.unactivate();
      }

      if( r.hoverData.which === 3 ){
        var cxtEvt = new $$.Event(e, {
          type: 'cxttapend',
          cyPosition: { x: pos[0], y: pos[1] }
        });

        if( down ){
          down.trigger( cxtEvt );
        } else {
          cy.trigger( cxtEvt );
        }

        if( !r.hoverData.cxtDragged ){
          var cxtTap = new $$.Event(e, {
            type: 'cxttap',
            cyPosition: { x: pos[0], y: pos[1] }
          });

          if( down ){
            down.trigger( cxtTap );
          } else {
            cy.trigger( cxtTap );
          }
        }

        r.hoverData.cxtDragged = false;
        r.hoverData.which = null;

      // if not right mouse
      } else {

        // Deselect all elements if nothing is currently under the mouse cursor and we aren't dragging something
        if ( (down == null) // not mousedown on node
          && !r.dragData.didDrag // didn't move the node around
          //&& !(Math.pow(select[2] - select[0], 2) + Math.pow(select[3] - select[1], 2) > 7 && select[4]) // not box selection
          && !r.hoverData.dragged // didn't pan
        ) {

          cy.$(function(){
            return this.selected();
          }).unselect();

          if (draggedElements.length > 0) {
            needsRedraw[CR.NODE] = true;
          }

          r.dragData.possibleDragElements = draggedElements = [];
        }


        // Mouseup event
        {
          // console.log('trigger mouseup et al');

          if (near != null) {
            near
              .trigger(new $$.Event(e, {
                type: 'mouseup',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'tapend',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'vmouseup',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
            ;
          } else if (near == null) {
            cy
              .trigger(new $$.Event(e, {
                type: 'mouseup',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'tapend',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'vmouseup',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
            ;
          }
        }

        // Click event
        {
          // console.log('trigger click et al');

          if(
            //Math.pow(select[2] - select[0], 2) + Math.pow(select[3] - select[1], 2) === 0
            !r.dragData.didDrag // didn't move a node around
            && !r.hoverData.dragged // didn't pan
          ){
            if (near != null) {
              near
                .trigger( new $$.Event(e, {
                  type: 'click',
                  cyPosition: { x: pos[0], y: pos[1] }
                }) )
                .trigger( new $$.Event(e, {
                  type: 'tap',
                  cyPosition: { x: pos[0], y: pos[1] }
                }) )
                .trigger( new $$.Event(e, {
                  type: 'vclick',
                  cyPosition: { x: pos[0], y: pos[1] }
                }) )
              ;
            } else if (near == null) {
              cy
                .trigger( new $$.Event(e, {
                  type: 'click',
                  cyPosition: { x: pos[0], y: pos[1] }
                }) )
                .trigger( new $$.Event(e, {
                  type: 'tap',
                  cyPosition: { x: pos[0], y: pos[1] }
                }) )
                .trigger( new $$.Event(e, {
                  type: 'vclick',
                  cyPosition: { x: pos[0], y: pos[1] }
                }) )
              ;
            }
          }
        }

        // Single selection
        if (near == down && !r.dragData.didDrag) {
          if (near != null && near._private.selectable) {

            // console.log('single selection')

            if( r.hoverData.dragging ){
              // if panning, don't change selection state
            } else if( cy.selectionType() === 'additive' || shiftDown ){
              if( near.selected() ){
                near.unselect();
              } else {
                near.select();
              }
            } else {
              if( !shiftDown ){
                cy.$(':selected').unmerge( near ).unselect();
                near.select();
              }
            }

            needsRedraw[CR.NODE] = true;

          }

        }

        if ( r.hoverData.selecting && cy.boxSelectionEnabled() &&  Math.pow(select[2] - select[0], 2) + Math.pow(select[3] - select[1], 2) > 7 && select[4] ) {
          var newlySelected = [];
          var box = r.getAllInBox( select[0], select[1], select[2], select[3] );

          needsRedraw[CR.SELECT_BOX] = true;

          if( box.length > 0 ) {
            needsRedraw[CR.NODE] = true;
          }

          for( var i = 0; i < box.length; i++ ){
            if( box[i]._private.selectable ){
              newlySelected.push( box[i] );
            }
          }

          var newlySelCol = new $$.Collection( cy, newlySelected );

          if( cy.selectionType() === 'additive' ){
            newlySelCol.select();
          } else {
            if( !shiftDown ){
              cy.$(':selected').unmerge( newlySelCol ).unselect();
            }

            newlySelCol.select();
          }

          // always need redraw in case eles unselectable
          r.redraw();

        }

        // Cancel drag pan
        if( r.hoverData.dragging ){
          r.hoverData.dragging = false;
          
          needsRedraw[CR.SELECT_BOX] = true;
          needsRedraw[CR.NODE] = true;
          
          r.redraw();
        }

        if (!select[4]) {
          // console.log('free at end', draggedElements)

          needsRedraw[CR.DRAG] = true;
          needsRedraw[CR.NODE] = true;

          freeDraggedElements( draggedElements );

          if( down ){ down.trigger('free'); }

  //        draggedElements = r.dragData.possibleDragElements = [];

        }

      } // else not right mouse

      select[4] = 0; r.hoverData.down = null;

      //r.data.canvasNeedsRedraw[CR.SELECT_BOX] = true;

//      console.log('mu', pos[0], pos[1]);
//      console.log('ss', select);

      r.hoverData.cxtStarted = false;
      r.hoverData.draggingEles = false;
      r.hoverData.selecting = false;
      r.dragData.didDrag = false;
      r.hoverData.dragged = false;
      r.hoverData.dragDelta = [];

    }, false);

    var wheelHandler = function(e) {
      if( r.scrollingPage ){ return; } // while scrolling, ignore wheel-to-zoom

      var cy = r.data.cy;
      var pos = r.projectIntoViewport(e.clientX, e.clientY);
      var rpos = [pos[0] * cy.zoom() + cy.pan().x,
                    pos[1] * cy.zoom() + cy.pan().y];

      if( r.hoverData.draggingEles || r.hoverData.dragging || r.hoverData.cxtStarted || inBoxSelection() ){ // if pan dragging or cxt dragging, wheel movements make no zoom
        e.preventDefault();
        return;
      }

      if( cy.panningEnabled() && cy.userPanningEnabled() && cy.zoomingEnabled() && cy.userZoomingEnabled() ){
        e.preventDefault();

        r.data.wheelZooming = true;
        clearTimeout( r.data.wheelTimeout );
        r.data.wheelTimeout = setTimeout(function(){
          r.data.wheelZooming = false;

          r.data.canvasNeedsRedraw[CR.NODE] = true;
          r.redraw();
        }, 150);

        var diff = e.deltaY / -250 || e.wheelDeltaY / 1000 || e.wheelDelta / 1000;
        diff = diff * r.wheelSensitivity;

        var needsWheelFix = e.deltaMode === 1;
        if( needsWheelFix ){ // fixes slow wheel events on ff/linux and ff/windows
          diff *= 33;
        }

        cy.zoom({
          level: cy.zoom() * Math.pow(10, diff),
          renderedPosition: { x: rpos[0], y: rpos[1] }
        });
      }

    };

    // Functions to help with whether mouse wheel should trigger zooming
    // --
    r.registerBinding(r.data.container, 'wheel', wheelHandler, true);

    // disable nonstandard wheel events
    // r.registerBinding(r.data.container, 'mousewheel', wheelHandler, true);
    // r.registerBinding(r.data.container, 'DOMMouseScroll', wheelHandler, true);
    // r.registerBinding(r.data.container, 'MozMousePixelScroll', wheelHandler, true); // older firefox

    r.registerBinding(window, 'scroll', function(e){
      r.scrollingPage = true;

      clearTimeout( r.scrollingPageTimeout );
      r.scrollingPageTimeout = setTimeout(function(){
        r.scrollingPage = false;
      }, 250);
    }, true);

    // Functions to help with handling mouseout/mouseover on the Cytoscape container
          // Handle mouseout on Cytoscape container
    r.registerBinding(r.data.container, 'mouseout', function(e) {
      var pos = r.projectIntoViewport(e.clientX, e.clientY);

      r.data.cy.trigger(new $$.Event(e, {
        type: 'mouseout',
        cyPosition: { x: pos[0], y: pos[1] }
      }));
    }, false);

    r.registerBinding(r.data.container, 'mouseover', function(e) {
      var pos = r.projectIntoViewport(e.clientX, e.clientY);

      r.data.cy.trigger(new $$.Event(e, {
        type: 'mouseover',
        cyPosition: { x: pos[0], y: pos[1] }
      }));
    }, false);

    var f1x1, f1y1, f2x1, f2y1; // starting points for pinch-to-zoom
    var distance1, distance1Sq; // initial distance between finger 1 and finger 2 for pinch-to-zoom
    var center1, modelCenter1; // center point on start pinch to zoom
    var offsetLeft, offsetTop;
    var containerWidth, containerHeight;
    var twoFingersStartInside;

    var distance = function(x1, y1, x2, y2){
      return Math.sqrt( (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1) );
    };

    var distanceSq = function(x1, y1, x2, y2){
      return (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1);
    };

    r.registerBinding(r.data.container, 'touchstart', function(e) {

      clearTimeout( this.threeFingerSelectTimeout );

      if( e.target !== r.data.link ){
        e.preventDefault();
      }

      r.touchData.capture = true;
      r.data.bgActivePosistion = undefined;

      var cy = r.data.cy;
      var nodes = r.getCachedNodes();
      var edges = r.getCachedEdges();
      var now = r.touchData.now;
      var earlier = r.touchData.earlier;
      var needsRedraw = r.data.canvasNeedsRedraw;

      if (e.touches[0]) { var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY); now[0] = pos[0]; now[1] = pos[1]; }
      if (e.touches[1]) { var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY); now[2] = pos[0]; now[3] = pos[1]; }
      if (e.touches[2]) { var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY); now[4] = pos[0]; now[5] = pos[1]; }


      // record starting points for pinch-to-zoom
      if( e.touches[1] ){

        // anything in the set of dragged eles should be released
        var release = function( eles ){
          for( var i = 0; i < eles.length; i++ ){
            eles[i]._private.grabbed = false;
            eles[i]._private.rscratch.inDragLayer = false;
            if( eles[i].active() ){ eles[i].unactivate(); }
          }
        };
        release(nodes);
        release(edges);

        var offsets = r.findContainerClientCoords();
        offsetLeft = offsets[0];
        offsetTop = offsets[1];
        containerWidth = offsets[2];
        containerHeight = offsets[3];

        f1x1 = e.touches[0].clientX - offsetLeft;
        f1y1 = e.touches[0].clientY - offsetTop;

        f2x1 = e.touches[1].clientX - offsetLeft;
        f2y1 = e.touches[1].clientY - offsetTop;

        twoFingersStartInside =
             0 <= f1x1 && f1x1 <= containerWidth
          && 0 <= f2x1 && f2x1 <= containerWidth
          && 0 <= f1y1 && f1y1 <= containerHeight
          && 0 <= f2y1 && f2y1 <= containerHeight
        ;

        var pan = cy.pan();
        var zoom = cy.zoom();

        distance1 = distance( f1x1, f1y1, f2x1, f2y1 );
        distance1Sq = distanceSq( f1x1, f1y1, f2x1, f2y1 );
        center1 = [ (f1x1 + f2x1)/2, (f1y1 + f2y1)/2 ];
        modelCenter1 = [
          (center1[0] - pan.x) / zoom,
          (center1[1] - pan.y) / zoom
        ];

        // consider context tap
        var cxtDistThreshold = 200;
        var cxtDistThresholdSq = cxtDistThreshold * cxtDistThreshold;
        if( distance1Sq < cxtDistThresholdSq && !e.touches[2] ){

          var near1 = r.findNearestElement(now[0], now[1], true, true);
          var near2 = r.findNearestElement(now[2], now[3], true, true);

          //console.log(distance1)

          if( near1 && near1.isNode() ){
            near1.activate().trigger( new $$.Event(e, {
              type: 'cxttapstart',
              cyPosition: { x: now[0], y: now[1] }
            }) );
            r.touchData.start = near1;

          } else if( near2 && near2.isNode() ){
            near2.activate().trigger( new $$.Event(e, {
              type: 'cxttapstart',
              cyPosition: { x: now[0], y: now[1] }
            }) );
            r.touchData.start = near2;

          } else {
            cy.trigger( new $$.Event(e, {
              type: 'cxttapstart',
              cyPosition: { x: now[0], y: now[1] }
            }) );
            r.touchData.start = null;
          }

          if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }
          r.touchData.cxt = true;
          r.touchData.cxtDragged = false;
          r.data.bgActivePosistion = undefined;

          //console.log('cxttapstart')

          r.redraw();
          return;

        }

        // console.log(center1);
        // console.log('touchstart ptz');
        // console.log(offsetLeft, offsetTop);
        // console.log(f1x1, f1y1);
        // console.log(f2x1, f2y1);
        // console.log(distance1);
        // console.log(center1);
      }

      // console.log('another tapstart')


      if (e.touches[2]) {

      } else if (e.touches[1]) {

      } else if (e.touches[0]) {
        var near = r.findNearestElement(now[0], now[1], true, true);

        if (near != null) {
          near.activate();

          r.touchData.start = near;

          if( near.isNode() && r.nodeIsDraggable(near) ){

            var draggedEles = r.dragData.touchDragEles = [];

            needsRedraw[CR.NODE] = true;
            needsRedraw[CR.DRAG] = true;

            if( near.selected() ){
              // reset drag elements, since near will be added again

              var selectedNodes = cy.$(function(){
                return this.isNode() && this.selected();
              });

              for( var k = 0; k < selectedNodes.length; k++ ){
                var selectedNode = selectedNodes[k];

                if( r.nodeIsDraggable(selectedNode) ){
                  addNodeToDrag( selectedNode, { addToList: draggedEles } );
                }
              }
            } else {
              addNodeToDrag( near, { addToList: draggedEles } );
            }

            near.trigger( new $$.Event(e, {
              type: 'grab',
              cyPosition: { x: now[0], y: now[1] }
            }) );
          }

          near
            .trigger(new $$.Event(e, {
              type: 'touchstart',
              cyPosition: { x: now[0], y: now[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'tapstart',
              cyPosition: { x: now[0], y: now[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'vmousdown',
              cyPosition: { x: now[0], y: now[1] }
            }))
          ;
        } if (near == null) {
          cy
            .trigger(new $$.Event(e, {
              type: 'touchstart',
              cyPosition: { x: now[0], y: now[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'tapstart',
              cyPosition: { x: now[0], y: now[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'vmousedown',
              cyPosition: { x: now[0], y: now[1] }
            }))
          ;

          r.data.bgActivePosistion = {
            x: pos[0],
            y: pos[1]
          };

          needsRedraw[CR.SELECT_BOX] = true;
          r.redraw();
        }


        // Tap, taphold
        // -----

        for (var i=0; i<now.length; i++) {
          earlier[i] = now[i];
          r.touchData.startPosition[i] = now[i];
        }

        r.touchData.singleTouchMoved = false;
        r.touchData.singleTouchStartTime = +new Date();

        clearTimeout( r.touchData.tapholdTimeout );
        r.touchData.tapholdTimeout = setTimeout(function() {
          if(
              r.touchData.singleTouchMoved === false
              && !r.pinching // if pinching, then taphold unselect shouldn't take effect

              // This time double constraint prevents multiple quick taps
              // followed by a taphold triggering multiple taphold events
              //&& Date.now() - r.touchData.singleTouchStartTime > 250
          ){
            if (r.touchData.start) {
              r.touchData.start.trigger( new $$.Event(e, {
                type: 'taphold',
                cyPosition: { x: now[0], y: now[1] }
              }) );
            } else {
              r.data.cy.trigger( new $$.Event(e, {
                type: 'taphold',
                cyPosition: { x: now[0], y: now[1] }
              }) );

              cy.$(':selected').unselect();
            }

//            console.log('taphold');
          }
        }, r.tapholdDuration);
      }

      //r.redraw();

    }, false);

// console.log = function(m){ $('#console').append('<div>'+m+'</div>'); };

    r.registerBinding(window, 'touchmove', $$.util.throttle(function(e) {

      var select = r.data.select;
      var capture = r.touchData.capture; //if (!capture) { return; };
      if( capture ){ e.preventDefault(); }

      var cy = r.data.cy;
      var now = r.touchData.now; var earlier = r.touchData.earlier;
      var zoom = cy.zoom();
      
      var needsRedraw = r.data.canvasNeedsRedraw;

      if (e.touches[0]) { var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY); now[0] = pos[0]; now[1] = pos[1]; }
      if (e.touches[1]) { var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY); now[2] = pos[0]; now[3] = pos[1]; }
      if (e.touches[2]) { var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY); now[4] = pos[0]; now[5] = pos[1]; }
      var disp = []; for (var j=0;j<now.length;j++) { disp[j] = now[j] - earlier[j]; }

      var startPos = r.touchData.startPosition;

      var dx = now[0] - startPos[0];
      var dx2 = dx * dx;
      var dy = now[1] - startPos[1];
      var dy2 = dy * dy;
      var dist2 = dx2 + dy2;
      var rdist2 = dist2 * zoom * zoom;

      if( capture && r.touchData.cxt ){
        var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;
        var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop;
        // var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );
        var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );
        var factorSq = distance2Sq / distance1Sq;

        var distThreshold = 150;
        var distThresholdSq = distThreshold * distThreshold;
        var factorThreshold = 1.5;
        var factorThresholdSq = factorThreshold * factorThreshold;

        //console.log(factor, distance2)

        // cancel ctx gestures if the distance b/t the fingers increases
        if( factorSq >= factorThresholdSq || distance2Sq >= distThresholdSq ){
          r.touchData.cxt = false;
          if( r.touchData.start ){ r.touchData.start.unactivate(); r.touchData.start = null; }
          r.data.bgActivePosistion = undefined;
          needsRedraw[CR.SELECT_BOX] = true;

          var cxtEvt = new $$.Event(e, {
            type: 'cxttapend',
            cyPosition: { x: now[0], y: now[1] }
          });
          if( r.touchData.start ){
            r.touchData.start.trigger( cxtEvt );
          } else {
            cy.trigger( cxtEvt );
          }
        }

      }

      if( capture && r.touchData.cxt ){
        var cxtEvt = new $$.Event(e, {
          type: 'cxtdrag',
          cyPosition: { x: now[0], y: now[1] }
        });
        r.data.bgActivePosistion = undefined;
        needsRedraw[CR.SELECT_BOX] = true;

        if( r.touchData.start ){
          r.touchData.start.trigger( cxtEvt );
        } else {
          cy.trigger( cxtEvt );
        }

        if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }
        r.touchData.cxtDragged = true;

        //console.log('cxtdrag')

        var near = r.findNearestElement(now[0], now[1], true, true);

        if( !r.touchData.cxtOver || near !== r.touchData.cxtOver ){

          if( r.touchData.cxtOver ){
            r.touchData.cxtOver.trigger( new $$.Event(e, {
              type: 'cxtdragout',
              cyPosition: { x: now[0], y: now[1] }
            }) );

            // console.log('cxtdragout');
          }

          r.touchData.cxtOver = near;

          if( near ){
            near.trigger( new $$.Event(e, {
              type: 'cxtdragover',
              cyPosition: { x: now[0], y: now[1] }
            }) );

            // console.log('cxtdragover');
          }

        }

      } else if( capture && e.touches[2] && cy.boxSelectionEnabled() ){
        r.data.bgActivePosistion = undefined;
        clearTimeout( this.threeFingerSelectTimeout );
        this.lastThreeTouch = +new Date();
        r.touchData.selecting = true;

        needsRedraw[CR.SELECT_BOX] = true;

        if( !select || select.length === 0 || select[0] === undefined ){
          select[0] = (now[0] + now[2] + now[4])/3;
          select[1] = (now[1] + now[3] + now[5])/3;
          select[2] = (now[0] + now[2] + now[4])/3 + 1;
          select[3] = (now[1] + now[3] + now[5])/3 + 1;
        } else {
          select[2] = (now[0] + now[2] + now[4])/3;
          select[3] = (now[1] + now[3] + now[5])/3;
        }

        select[4] = 1;
        r.touchData.selecting = true;

        r.redraw();

      } else if ( capture && e.touches[1] && cy.zoomingEnabled() && cy.panningEnabled() && cy.userZoomingEnabled() && cy.userPanningEnabled() ) { // two fingers => pinch to zoom
        r.data.bgActivePosistion = undefined;
        needsRedraw[CR.SELECT_BOX] = true;

        var draggedEles = r.dragData.touchDragEles;
        if( draggedEles ){
          needsRedraw[CR.DRAG] = true;

          for( var i = 0; i < draggedEles.length; i++ ){
            draggedEles[i]._private.grabbed = false;
            draggedEles[i]._private.rscratch.inDragLayer = false;
          }
        }

        // console.log('touchmove ptz');

        // (x2, y2) for fingers 1 and 2
        var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;
        var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop;

        // console.log( f1x2, f1y2 )
        // console.log( f2x2, f2y2 )

        var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );
        // var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );
        // var factor = Math.sqrt( distance2Sq ) / Math.sqrt( distance1Sq );
        var factor = distance2 / distance1;

        // console.log(distance2)
        // console.log(factor)

        if( factor != 1 && twoFingersStartInside){

          // console.log(factor)
          // console.log(distance2 + ' / ' + distance1);
          // console.log('--');

          // delta finger1
          var df1x = f1x2 - f1x1;
          var df1y = f1y2 - f1y1;

          // delta finger 2
          var df2x = f2x2 - f2x1;
          var df2y = f2y2 - f2y1;

          // translation is the normalised vector of the two fingers movement
          // i.e. so pinching cancels out and moving together pans
          var tx = (df1x + df2x)/2;
          var ty = (df1y + df2y)/2;

          // adjust factor by the speed multiplier
          // var speed = 1.5;
          // if( factor > 1 ){
          //   factor = (factor - 1) * speed + 1;
          // } else {
          //   factor = 1 - (1 - factor) * speed;
          // }

          // now calculate the zoom
          var zoom1 = cy.zoom();
          var zoom2 = zoom1 * factor;
          var pan1 = cy.pan();

          // the model center point converted to the current rendered pos
          var ctrx = modelCenter1[0] * zoom1 + pan1.x;
          var ctry = modelCenter1[1] * zoom1 + pan1.y;

          var pan2 = {
            x: -zoom2/zoom1 * (ctrx - pan1.x - tx) + ctrx,
            y: -zoom2/zoom1 * (ctry - pan1.y - ty) + ctry
          };

          // console.log(pan2);
          // console.log(zoom2);

          // remove dragged eles
          if( r.touchData.start ){
            var draggedEles = r.dragData.touchDragEles;

            if( draggedEles ){ for( var i = 0; i < draggedEles.length; i++ ){
              var dEi_p = draggedEles[i]._private;
              
              dEi_p.grabbed = false;
              dEi_p.rscratch.inDragLayer = false;
            } }

            var start_p = r.touchData.start._private;
            start_p.active = false;
            start_p.grabbed = false;
            start_p.rscratch.inDragLayer = false;

            needsRedraw[CR.DRAG] = true;

            r.touchData.start
              .trigger('free')
              .trigger('unactivate')
            ;
          }

          cy.viewport({
            zoom: zoom2,
            pan: pan2,
            cancelOnFailedZoom: true
          });

          distance1 = distance2;
          f1x1 = f1x2;
          f1y1 = f1y2;
          f2x1 = f2x2;
          f2y1 = f2y2;

          r.pinching = true;
        }

        // Re-project
        if (e.touches[0]) { var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY); now[0] = pos[0]; now[1] = pos[1]; }
        if (e.touches[1]) { var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY); now[2] = pos[0]; now[3] = pos[1]; }
        if (e.touches[2]) { var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY); now[4] = pos[0]; now[5] = pos[1]; }

      } else if (e.touches[0]) {
        var start = r.touchData.start;
        var last = r.touchData.last;
        var near = near || r.findNearestElement(now[0], now[1], true, true);

        if( start != null && start._private.group == 'nodes' && r.nodeIsDraggable(start) ){

          if( rdist2 >= r.touchTapThreshold2 ){ // then dragging can happen
            var draggedEles = r.dragData.touchDragEles;

            for( var k = 0; k < draggedEles.length; k++ ){
              var draggedEle = draggedEles[k];

              if( r.nodeIsDraggable(draggedEle) && draggedEle.isNode() && draggedEle.grabbed() ){
                r.dragData.didDrag = true;
                var dPos = draggedEle._private.position;
                var justStartedDrag = !r.hoverData.draggingEles;

                if( $$.is.number(disp[0]) && $$.is.number(disp[1]) ){
                  dPos.x += disp[0];
                  dPos.y += disp[1];
                }

                if( justStartedDrag ){
                  addNodeToDrag( draggedEle, { inDragLayer: true } );
                  
                  needsRedraw[CR.NODE] = true;

                  var dragDelta = r.touchData.dragDelta;

                  if( $$.is.number(dragDelta[0]) && $$.is.number(dragDelta[1]) ){
                    dPos.x += dragDelta[0];
                    dPos.y += dragDelta[1];
                  }

                }
              }
            }

            var tcol = new $$.Collection(cy, draggedEle);

            tcol.updateCompoundBounds();
            tcol.trigger('position drag');

            r.hoverData.draggingEles = true;

            needsRedraw[CR.DRAG] = true;

            if(
                 r.touchData.startPosition[0] == earlier[0]
              && r.touchData.startPosition[1] == earlier[1]
            ){

              needsRedraw[CR.NODE] = true;
            }

            r.redraw();
          } else { // otherise keep track of drag delta for later
            var dragDelta = r.touchData.dragDelta = r.touchData.dragDelta || [];

            if( dragDelta.length === 0 ){
              dragDelta.push( disp[0] );
              dragDelta.push( disp[1] );
            } else {
              dragDelta[0] += disp[0];
              dragDelta[1] += disp[1];
            }
          }
        }

        // Touchmove event
        {

          if (start != null) {
            start.trigger( new $$.Event(e, {
              type: 'touchmove',
              cyPosition: { x: now[0], y: now[1] }
            }) );

            start.trigger( new $$.Event(e, {
              type: 'tapdrag',
              cyPosition: { x: now[0], y: now[1] }
            }) );

            start.trigger( new $$.Event(e, {
              type: 'vmousemove',
              cyPosition: { x: now[0], y: now[1] }
            }) );
          }

          if (start == null) {

            if (near != null) {
              near.trigger( new $$.Event(e, {
                type: 'touchmove',
                cyPosition: { x: now[0], y: now[1] }
              }) );

              near.trigger( new $$.Event(e, {
                type: 'tapdrag',
                cyPosition: { x: now[0], y: now[1] }
              }) );

              near.trigger( new $$.Event(e, {
                type: 'vmousemove',
                cyPosition: { x: now[0], y: now[1] }
              }) );
            }

            if (near == null) {
              cy.trigger( new $$.Event(e, {
                type: 'touchmove',
                cyPosition: { x: now[0], y: now[1] }
              }) );

              cy.trigger( new $$.Event(e, {
                type: 'tapdrag',
                cyPosition: { x: now[0], y: now[1] }
              }) );

              cy.trigger( new $$.Event(e, {
                type: 'vmousemove',
                cyPosition: { x: now[0], y: now[1] }
              }) );
            }
          }

          if (near != last) {
            if (last) { last.trigger(new $$.Event(e, { type: 'tapdragout', cyPosition: { x: now[0], y: now[1] } })); }
            if (near) { near.trigger(new $$.Event(e, { type: 'tapdragover', cyPosition: { x: now[0], y: now[1] } })); }
          }

          r.touchData.last = near;
        }

        // Check to cancel taphold
        for (var i=0;i<now.length;i++) {
          if (now[i]
            && r.touchData.startPosition[i]
            && Math.abs(now[i] - r.touchData.startPosition[i]) > 4) {

            r.touchData.singleTouchMoved = true;
          }
        }

        if(
            capture
            && ( start == null || start.isEdge() )
            && cy.panningEnabled() && cy.userPanningEnabled()
        ){

          if( r.swipePanning ){
            cy.panBy({
              x: disp[0] * zoom,
              y: disp[1] * zoom
            });

          } else if( rdist2 >= r.touchTapThreshold2 ){
            r.swipePanning = true;

            cy.panBy({
              x: dx * zoom,
              y: dy * zoom
            });
          }

          if( start ){
            start.unactivate();

            if( !r.data.bgActivePosistion ){
              r.data.bgActivePosistion = {
                x: now[0],
                y: now[1]
              };
            }

            needsRedraw[CR.SELECT_BOX] = true;

            r.touchData.start = null;
          }

          // Re-project
          var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
          now[0] = pos[0]; now[1] = pos[1];
        }
      }

      for (var j=0; j<now.length; j++) { earlier[j] = now[j]; }
      //r.redraw();

    }, 1000/30, { trailing: true }), false);

    r.registerBinding(window, 'touchcancel', function(e) {
      var start = r.touchData.start;

      r.touchData.capture = false;

      if( start ){
        start.unactivate();
      }
    });

    r.registerBinding(window, 'touchend', function(e) {
      var start = r.touchData.start;

      var capture = r.touchData.capture;

      if( capture ){
        r.touchData.capture = false;
      } else {
        return;
      }

      e.preventDefault();
      var select = r.data.select;

      r.swipePanning = false;
      r.hoverData.draggingEles = false;

      var cy = r.data.cy;
      var zoom = cy.zoom();
      var now = r.touchData.now;
      var earlier = r.touchData.earlier;
      
      var needsRedraw = r.data.canvasNeedsRedraw;

      if (e.touches[0]) { var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY); now[0] = pos[0]; now[1] = pos[1]; }
      if (e.touches[1]) { var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY); now[2] = pos[0]; now[3] = pos[1]; }
      if (e.touches[2]) { var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY); now[4] = pos[0]; now[5] = pos[1]; }

      if( start ){
        start.unactivate();
      }

      var ctxTapend;
      if( r.touchData.cxt ){
        ctxTapend = new $$.Event(e, {
          type: 'cxttapend',
          cyPosition: { x: now[0], y: now[1] }
        });

        if( start ){
          start.trigger( ctxTapend );
        } else {
          cy.trigger( ctxTapend );
        }

        //console.log('cxttapend')

        if( !r.touchData.cxtDragged ){
          var ctxTap = new $$.Event(e, {
            type: 'cxttap',
            cyPosition: { x: now[0], y: now[1] }
          });

          if( start ){
            start.trigger( ctxTap );
          } else {
            cy.trigger( ctxTap );
          }

          //console.log('cxttap')
        }

        if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }
        r.touchData.cxt = false;
        r.touchData.start = null;

        r.redraw();
        return;
      }

      // no more box selection if we don't have three fingers
      if( !e.touches[2] && cy.boxSelectionEnabled() && r.touchData.selecting ){
        r.touchData.selecting = false;
        clearTimeout( this.threeFingerSelectTimeout );
        //this.threeFingerSelectTimeout = setTimeout(function(){
          var newlySelected = [];
          var box = r.getAllInBox( select[0], select[1], select[2], select[3] );

          select[0] = undefined;
          select[1] = undefined;
          select[2] = undefined;
          select[3] = undefined;
          select[4] = 0;

          needsRedraw[CR.SELECT_BOX] = true;

          // console.log(box);
          for( var i = 0; i< box.length; i++ ) {
            if( box[i]._private.selectable ){
              newlySelected.push( box[i] );
            }
          }

          var newlySelCol = new $$.Collection( cy, newlySelected );

          if( cy.selectionType() === 'single' ){
            cy.$(':selected').unmerge( newlySelCol ).unselect();
          }

          newlySelCol.select();

          if( newlySelCol.length > 0 ) {
            needsRedraw[CR.NODE] = true;
          } else {
            r.redraw();
          }

        //}, 100);
      }

      var updateStartStyle = false;

      if( start != null ){
        start._private.active = false;
        updateStartStyle = true;
        start.unactivate();
      }

      if (e.touches[2]) {
        r.data.bgActivePosistion = undefined;
        needsRedraw[CR.SELECT_BOX] = true;
      } else if (e.touches[1]) {

      } else if (e.touches[0]) {

      // Last touch released
      } else if (!e.touches[0]) {

        r.data.bgActivePosistion = undefined;
        needsRedraw[CR.SELECT_BOX] = true;
        
        var draggedEles = r.dragData.touchDragEles;

        if (start != null ) {

          var startWasGrabbed = start._private.grabbed;
          
          freeDraggedElements( draggedEles );

          needsRedraw[CR.DRAG] = true;
          needsRedraw[CR.NODE] = true;
          
          if( startWasGrabbed ){
            start.trigger('free');
          }

          start
            .trigger(new $$.Event(e, {
              type: 'touchend',
              cyPosition: { x: now[0], y: now[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'tapend',
              cyPosition: { x: now[0], y: now[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'vmouseup',
              cyPosition: { x: now[0], y: now[1] }
            }))
          ;

          start.unactivate();

          r.touchData.start = null;

        } else {
          var near = r.findNearestElement(now[0], now[1], true, true);

          if (near != null) {
            near
              .trigger(new $$.Event(e, {
                type: 'touchend',
                cyPosition: { x: now[0], y: now[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'tapend',
                cyPosition: { x: now[0], y: now[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'vmouseup',
                cyPosition: { x: now[0], y: now[1] }
              }))
            ;
          }

          if (near == null) {
            cy
              .trigger(new $$.Event(e, {
                type: 'touchend',
                cyPosition: { x: now[0], y: now[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'tapend',
                cyPosition: { x: now[0], y: now[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'vmouseup',
                cyPosition: { x: now[0], y: now[1] }
              }))
            ;
          }
        }

        var dx = r.touchData.startPosition[0] - now[0];
        var dx2 = dx * dx;
        var dy = r.touchData.startPosition[1] - now[1];
        var dy2 = dy * dy;
        var dist2 = dx2 + dy2;
        var rdist2 = dist2 * zoom * zoom;

        // Prepare to select the currently touched node, only if it hasn't been dragged past a certain distance
        if (start != null
            && !r.dragData.didDrag // didn't drag nodes around
            && start._private.selectable
            && rdist2 < r.touchTapThreshold2
            && !r.pinching // pinch to zoom should not affect selection
        ) {

          if( cy.selectionType() === 'single' ){
            cy.$(':selected').unmerge( start ).unselect();
            start.select();
          } else {
            if( start.selected() ){
              start.unselect();
            } else {
              start.select();
            }
          }

          updateStartStyle = true;


          needsRedraw[CR.NODE] = true;
        }

        // Tap event, roughly same as mouse click event for touch
        if ( r.touchData.singleTouchMoved === false ) {

          if (start) {
            start
              .trigger(new $$.Event(e, {
                type: 'tap',
                cyPosition: { x: now[0], y: now[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'vclick',
                cyPosition: { x: now[0], y: now[1] }
              }))
            ;
          } else {
            cy
              .trigger(new $$.Event(e, {
                type: 'tap',
                cyPosition: { x: now[0], y: now[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'vclick',
                cyPosition: { x: now[0], y: now[1] }
              }))
            ;
          }

//          console.log('tap');
        }

        r.touchData.singleTouchMoved = true;
      }

      for( var j = 0; j < now.length; j++ ){ earlier[j] = now[j]; }

      r.dragData.didDrag = false; // reset for next mousedown

      if( e.touches.length === 0 ){
        r.touchData.dragDelta = [];
      }

      if( updateStartStyle && start ){
        start.updateStyle(false);
      }

      if( e.touches.length < 2 ){
        r.pinching = false;
        needsRedraw[CR.NODE] = true;
        r.redraw();
      }

      //r.redraw();

    }, false);
  };

})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');
  var renderer = CanvasRenderer.prototype;
  var usePaths = CanvasRenderer.usePaths();

  // Node shape contract:
  //
  // draw: draw
  // intersectLine: report intersection from x, y, to node center
  // checkPoint: check x, y in node

  var nodeShapes = CanvasRenderer.nodeShapes = {};

  var sin0 = Math.sin(0);
  var cos0 = Math.cos(0);

  var sin = {};
  var cos = {};

  var ellipseStepSize = 0.1;

  for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize ) {
    sin[i] = Math.sin(i);
    cos[i] = Math.cos(i);
  }

  nodeShapes['ellipse'] = {
    draw: function(context, centerX, centerY, width, height) {
      nodeShapes['ellipse'].drawPath(context, centerX, centerY, width, height);
      context.fill();
    },
    
    drawPath: function(context, centerX, centerY, width, height) {
      
      if( usePaths ){
        if( context.beginPath ){ context.beginPath(); }

        var xPos, yPos;
        var rw = width/2;
        var rh = height/2;
        for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize ) {
            xPos = centerX - (rw * sin[i]) * sin0 + (rw * cos[i]) * cos0;
            yPos = centerY + (rh * cos[i]) * sin0 + (rh * sin[i]) * cos0;

            if (i === 0) {
                context.moveTo(xPos, yPos);
            } else {
                context.lineTo(xPos, yPos);
            }
        }
        context.closePath();

      } else {

        if( context.beginPath ){ context.beginPath(); }
        context.translate(centerX, centerY);
        context.scale(width / 2, height / 2);
        // At origin, radius 1, 0 to 2pi
        context.arc(0, 0, 1, 0, Math.PI * 2 * 0.999, false); // *0.999 b/c chrome rendering bug on full circle
        context.closePath();

        context.scale(2/width, 2/height);
        context.translate(-centerX, -centerY);

      }
      
    },
    
    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {
      var intersect = $$.math.intersectLineEllipse(
        x, y,
        nodeX,
        nodeY,
        width / 2 + padding,
        height / 2 + padding);
      
      return intersect;
    },
    
    intersectBox: function(
      x1, y1, x2, y2, width, height, centerX, centerY, padding) {
      
      return $$.math.boxIntersectEllipse(
        x1, y1, x2, y2, padding, width, height, centerX, centerY);
    },
    
    checkPoint: function(
      x, y, padding, width, height, centerX, centerY) {
      
//      console.log(arguments);
      
      x -= centerX;
      y -= centerY;
      
      x /= (width / 2 + padding);
      y /= (height / 2 + padding);
      
      return (Math.pow(x, 2) + Math.pow(y, 2) <= 1);
    }
  };
  
  function generatePolygon( name, points ){
    nodeShapes[name] = {
      points: points,
      
      draw: function(context, centerX, centerY, width, height) {
        renderer.drawPolygon(context,
          centerX, centerY,
          width, height,
          nodeShapes[name].points);
      },
      
      drawPath: function(context, centerX, centerY, width, height) {
        renderer.drawPolygonPath(context,
          centerX, centerY,
          width, height,
          nodeShapes[name].points);
      },
      
      intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {
        return $$.math.polygonIntersectLine(
            x, y,
            nodeShapes[name].points,
            nodeX,
            nodeY,
            width / 2, height / 2,
            padding);
      },
      
      intersectBox: function(
        x1, y1, x2, y2,
        width, height, centerX, 
        centerY, padding) {
        
        var points = nodeShapes[name].points;
        
        return $$.math.boxIntersectPolygon(
          x1, y1, x2, y2,
          points, width, height, centerX, 
          centerY, [0, -1], padding);
      },
      
      checkPoint: function(
        x, y, padding, width, height, centerX, centerY) {
        
        return $$.math.pointInsidePolygon(x, y, nodeShapes[name].points,
          centerX, centerY, width, height, [0, -1], padding);
      }
    };
  }
  
  generatePolygon( 'triangle', $$.math.generateUnitNgonPointsFitToSquare(3, 0) );
  
  generatePolygon( 'square', $$.math.generateUnitNgonPointsFitToSquare(4, 0) );
  nodeShapes['rectangle'] = nodeShapes['square'];
  
  nodeShapes['roundrectangle'] = {
    points: $$.math.generateUnitNgonPointsFitToSquare(4, 0),
    
    draw: function(context, centerX, centerY, width, height) {
      renderer.drawRoundRectangle(context,
        centerX, centerY,
        width, height,
        10);
    },
    
    drawPath: function(context, centerX, centerY, width, height) {
      renderer.drawRoundRectanglePath(context,
        centerX, centerY,
        width, height,
        10);
    },
    
    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {
      return $$.math.roundRectangleIntersectLine(
          x, y,
          nodeX,
          nodeY,
          width, height,
          padding);
    },
    
    intersectBox: function(
      x1, y1, x2, y2,
      width, height, centerX, 
      centerY, padding) {

      return $$.math.roundRectangleIntersectBox(
        x1, y1, x2, y2, 
        width, height, centerX, centerY, padding);
    },
    
    // Looks like the width passed into this function is actually the total width / 2
    checkPoint: function(
      x, y, padding, width, height, centerX, centerY) {
      
      var cornerRadius = $$.math.getRoundRectangleRadius(width, height);
      
      // Check hBox
      if ($$.math.pointInsidePolygon(x, y, nodeShapes['roundrectangle'].points,
        centerX, centerY, width, height - 2 * cornerRadius, [0, -1], padding)) {
        return true;
      }
      
      // Check vBox
      if ($$.math.pointInsidePolygon(x, y, nodeShapes['roundrectangle'].points,
        centerX, centerY, width - 2 * cornerRadius, height, [0, -1], padding)) {
        return true;
      }
      
      var checkInEllipse = function(x, y, centerX, centerY, width, height, padding) {
        x -= centerX;
        y -= centerY;
        
        x /= (width / 2 + padding);
        y /= (height / 2 + padding);
        
        return (Math.pow(x, 2) + Math.pow(y, 2) <= 1);
      };
      
      
      // Check top left quarter circle
      if (checkInEllipse(x, y,
        centerX - width / 2 + cornerRadius,
        centerY - height / 2 + cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding)) {
        
        return true;
      }
      
      /*
      if (renderer.boxIntersectEllipse(x, y, x, y, padding, 
        cornerRadius * 2, cornerRadius * 2,
        centerX - width + cornerRadius,
        centerY - height + cornerRadius)) {
        return true;
      }
      */
      
      // Check top right quarter circle
      if (checkInEllipse(x, y,
        centerX + width / 2 - cornerRadius,
        centerY - height / 2 + cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding)) {
        
        return true;
      }
      
      // Check bottom right quarter circle
      if (checkInEllipse(x, y,
        centerX + width / 2 - cornerRadius,
        centerY + height / 2 - cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding)) {
        
        return true;
      }
      
      // Check bottom left quarter circle
      if (checkInEllipse(x, y,
        centerX - width / 2 + cornerRadius,
        centerY + height / 2 - cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding)) {
        
        return true;
      }
      
      return false;
    }
  };
  
  generatePolygon( 'diamond', [
    0, 1,
    1, 0,
    0, -1,
    -1, 0
  ] );
  
  generatePolygon( 'pentagon', $$.math.generateUnitNgonPointsFitToSquare(5, 0) );
  
  generatePolygon( 'hexagon', $$.math.generateUnitNgonPointsFitToSquare(6, 0) );
  
  generatePolygon( 'heptagon', $$.math.generateUnitNgonPointsFitToSquare(7, 0) );
  
  generatePolygon( 'octagon', $$.math.generateUnitNgonPointsFitToSquare(8, 0) );
    
  var star5Points = new Array(20);
  {
    var outerPoints = $$.math.generateUnitNgonPoints(5, 0);
    var innerPoints = $$.math.generateUnitNgonPoints(5, Math.PI / 5);
    
  //  console.log(outerPoints);
  //  console.log(innerPoints);
    
    // Outer radius is 1; inner radius of star is smaller
    var innerRadius = 0.5 * (3 - Math.sqrt(5));
    innerRadius *= 1.57;
    
    for (var i=0;i<innerPoints.length/2;i++) {
      innerPoints[i*2] *= innerRadius;
      innerPoints[i*2+1] *= innerRadius;
    }
    
    for (var i=0;i<20/4;i++) {
      star5Points[i*4] = outerPoints[i*2];
      star5Points[i*4+1] = outerPoints[i*2+1];
      
      star5Points[i*4+2] = innerPoints[i*2];
      star5Points[i*4+3] = innerPoints[i*2+1];
    }
    
  //  console.log(star5Points);
  }

  star5Points = $$.math.fitPolygonToSquare( star5Points );
  
  generatePolygon( 'star', star5Points );
  
  generatePolygon( 'vee', [
    -1, -1,
    0, -0.333,
    1, -1,
    0, 1
  ] );
  
  generatePolygon( 'rhomboid', [
    -1, -1,
    0.333, -1,
    1, 1,
    -0.333, 1
  ] );

})( cytoscape );

;(function($$){ 'use strict';
  
  var defaults = {
    animate: true, // whether to show the layout as it's running
    maxSimulationTime: 4000, // max length in ms to run the layout
    fit: true, // on every layout reposition of nodes, fit the viewport
    padding: 30, // padding around the simulation
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    ungrabifyWhileSimulating: false, // so you can't drag nodes during layout

    // callbacks on layout events
    ready: undefined, // callback on layoutready 
    stop: undefined, // callback on layoutstop

    // forces used by arbor (use arbor default on undefined)
    repulsion: undefined,
    stiffness: undefined,
    friction: undefined,
    gravity: true,
    fps: undefined,
    precision: undefined,

    // static numbers or functions that dynamically return what these
    // values should be for each element
    // e.g. nodeMass: function(n){ return n.data('weight') }
    nodeMass: undefined, 
    edgeLength: undefined,

    stepSize: 0.1, // smoothing of arbor bounding box

    // function that returns true if the system is stable to indicate
    // that the layout can be stopped
    stableEnergy: function( energy ){
      var e = energy; 
      return (e.max <= 0.5) || (e.mean <= 0.3);
    },

    // infinite layout options
    infinite: false // overrides all other options for a forces-all-the-time mode
  };
  
  function ArborLayout(options){
    this._private = {};

    this._private.options = $$.util.extend({}, defaults, options);
  }
    
  ArborLayout.prototype.run = function(){
    var layout = this;
    var options = this._private.options;

    $$.util.require('arbor', function(arbor){

      var cy = options.cy;
      var eles = options.eles;
      var nodes = eles.nodes().not(':parent');
      var edges = eles.edges();
      var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
        x1: 0, y1: 0, w: cy.width(), h: cy.height()
      } );
      var simUpdatingPos = false;

      layout.trigger({ type: 'layoutstart', layout: layout });

      // backward compatibility for old animation option
      if( options.liveUpdate !== undefined ){
        options.animate = options.liveUpdate;
      }

      // arbor doesn't work with just 1 node 
      if( eles.nodes().size() <= 1 ){
        if( options.fit ){
          cy.reset();
        }

        eles.nodes().position({
          x: Math.round( (bb.x1 + bb.x2)/2 ),
          y: Math.round( (bb.y1 + bb.y2)/2 )
        });

        layout.one('layoutready', options.ready);
        layout.trigger({ type: 'layoutready', layout: layout });

        layout.one('layoutstop', options.stop);
        layout.trigger({ type: 'layoutstop', layout: layout });

        return;
      }

      var sys = layout._private.system = arbor.ParticleSystem();

      sys.parameters({
        repulsion: options.repulsion,
        stiffness: options.stiffness, 
        friction: options.friction, 
        gravity: options.gravity, 
        fps: options.fps, 
        dt: options.dt, 
        precision: options.precision
      });

      if( options.animate && options.fit ){
        cy.fit( bb, options.padding );
      }
      
      var doneTime = 250;
      var doneTimeout;
      
      var ready = false;
      
      var lastDraw = +new Date();
      var sysRenderer = {
        init: function(system){
        },
        redraw: function(){
          var energy = sys.energy();

          // if we're stable (according to the client), we're done
          if( !options.infinite && options.stableEnergy != null && energy != null && energy.n > 0 && options.stableEnergy(energy) ){
            layout.stop();
            return;
          }

          if( !options.infinite && doneTime != Infinity ){
            clearTimeout(doneTimeout);
            doneTimeout = setTimeout(doneHandler, doneTime);
          }
          
          var movedNodes = cy.collection();
          
          sys.eachNode(function(n, point){ 
            var data = n.data;
            var node = data.element;
            
            if( node == null ){
              return;
            }

            if( !node.locked() && !node.grabbed() ){
              node.silentPosition({
                x: bb.x1 + point.x,
                y: bb.y1 + point.y
              });

              movedNodes.merge( node );
            }
          });
          

          if( options.animate && movedNodes.length > 0 ){
            simUpdatingPos = true;

            movedNodes.rtrigger('position');

            if( options.fit ){
              cy.fit( options.padding );
            }

            lastDraw = +new Date();
            simUpdatingPos = false;
          }

          
          if( !ready ){
            ready = true;
            layout.one('layoutready', options.ready);
            layout.trigger({ type: 'layoutready', layout: layout });
          }
        }
        
      };
      sys.renderer = sysRenderer;
      sys.screenSize( bb.w, bb.h );
      sys.screenPadding( options.padding, options.padding, options.padding, options.padding );
      sys.screenStep( options.stepSize );

      function calculateValueForElement(element, value){
        if( value == null ){
          return undefined;
        } else if( typeof value == typeof function(){} ){
          return value.apply(element, [element._private.data, {
            nodes: nodes.length,
            edges: edges.length,
            element: element
          }]); 
        } else {
          return value;
        }
      }

      var grabHandler;
      nodes.on('grab free position', grabHandler = function(e){
        if( simUpdatingPos ){ return; }

        var pos = this.position();
        var apos = sys.fromScreen( pos );
        if( !apos ){ return; }

        var p = arbor.Point(apos.x, apos.y);
        var padding = options.padding;

        if(
          bb.x1 + padding <= pos.x && pos.x <= bb.x2 - padding &&
          bb.y1 + padding <= pos.y && pos.y <= bb.y2 - padding
        ){
          this.scratch().arbor.p = p;
        }
        
        switch( e.type ){
        case 'grab':
          this.scratch().arbor.fixed = true;
          break;
        case 'free':
          this.scratch().arbor.fixed = false;
          //this.scratch().arbor.tempMass = 1000;
          break;
        }
      });

      var lockHandler;
      nodes.on('lock unlock', lockHandler = function(e){
        node.scratch().arbor.fixed = node.locked();
      });
            
      var removeHandler;
      eles.on('remove', removeHandler = function(e){ return; // TODO enable when layout add/remove api added
        // var ele = this;
        // var arborEle = ele.scratch().arbor;

        // if( !arborEle ){ return; }

        // if( ele.isNode() ){
        //   sys.pruneNode( arborEle );
        // } else {
        //   sys.pruneEdge( arborEle );
        // }
      });

      var addHandler;
      cy.on('add', '*', addHandler = function(){ return; // TODO enable when layout add/remove api added
        // var ele = this;

        // if( ele.isNode() ){
        //   addNode( ele );
        // } else {
        //   addEdge( ele );
        // }
      });

      var resizeHandler;
      cy.on('resize', resizeHandler = function(){
        if( options.boundingBox == null && layout._private.system != null ){
          var w = cy.width();
          var h = cy.height();

          sys.screenSize( w, h );
        }
      });

      function addNode( node ){
        if( node.isFullAutoParent() ){ return; } // they don't exist in the sim

        var id = node._private.data.id;
        var mass = calculateValueForElement(node, options.nodeMass);
        var locked = node._private.locked;
        var nPos = node.position();
        
        var pos = sys.fromScreen({
          x: nPos.x,
          y: nPos.y
        });

        node.scratch().arbor = sys.addNode(id, {
          element: node,
          mass: mass,
          fixed: locked,
          x: locked ? pos.x : undefined,
          y: locked ? pos.y : undefined
        });
      }

      function addEdge( edge ){
        var src = edge.source().id();
        var tgt = edge.target().id();
        var length = calculateValueForElement(edge, options.edgeLength);
        
        edge.scratch().arbor = sys.addEdge(src, tgt, {
          length: length
        }); 
      }

      nodes.each(function(i, node){
        addNode( node );
      });
      
      edges.each(function(i, edge){
        addEdge( edge );
      });
      
      var grabbableNodes = nodes.filter(":grabbable");
      // disable grabbing if so set
      if( options.ungrabifyWhileSimulating ){
        grabbableNodes.ungrabify();
      }
      
      var doneHandler = layout._private.doneHandler = function(){
        layout._private.doneHandler = null;

        if( !options.animate ){
          if( options.fit ){
            cy.reset();
          }

          nodes.rtrigger('position');
        }

        // unbind handlers
        nodes.off('grab free position', grabHandler);
        nodes.off('lock unlock', lockHandler);
        eles.off('remove', removeHandler);
        cy.off('add', '*', addHandler);
        cy.off('resize', resizeHandler);
        
        // enable back grabbing if so set
        if( options.ungrabifyWhileSimulating ){
          grabbableNodes.grabify();
        }

        layout.one('layoutstop', options.stop);
        layout.trigger({ type: 'layoutstop', layout: layout });
      };
      
      sys.start();
      if( !options.infinite && options.maxSimulationTime != null && options.maxSimulationTime > 0 && options.maxSimulationTime !== Infinity ){
        setTimeout(function(){
          layout.stop();
        }, options.maxSimulationTime);
      }
    
    }); // require

    return this; // chaining
  };


  ArborLayout.prototype.stop = function(){
    if( this._private.system != null ){
      this._private.system.stop();
    }

    if( this._private.doneHandler ){
      this._private.doneHandler();
    }

    return this; // chaining
  };
  
  $$('layout', 'arbor', ArborLayout);
  
  
})(cytoscape);

;(function($$){ 'use strict';
  
  var defaults = {
    fit: true, // whether to fit the viewport to the graph
    directed: false, // whether the tree is directed downwards (or edges can point in any direction if false)
    padding: 30, // padding on fit
    circle: false, // put depths in concentric circles if true, put depths top down if false
    spacingFactor: 1.75, // positive spacing factor, larger => more space between nodes (N.B. n/a if causes overlap)
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
    roots: undefined, // the roots of the trees
    maximalAdjustments: 0, // how many times to try to position the nodes in a maximal way (i.e. no backtracking)
    animate: false, // whether to transition the node positions
    animationDuration: 500, // duration of animation in ms if enabled
    ready: undefined, // callback on layoutready
    stop: undefined // callback on layoutstop
  };
  
  function BreadthFirstLayout( options ){
    this.options = $$.util.extend({}, defaults, options);
  }
  
  BreadthFirstLayout.prototype.run = function(){
    var params = this.options;
    var options = params;
    
    var cy = params.cy;
    var eles = options.eles;
    var nodes = eles.nodes().not(':parent');
    var graph = eles;
    
    var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
      x1: 0, y1: 0, w: cy.width(), h: cy.height()
    } );

    var roots;
    if( $$.is.elementOrCollection(options.roots) ){
      roots = options.roots;
    } else if( $$.is.array(options.roots) ){
      var rootsArray = [];

      for( var i = 0; i < options.roots.length; i++ ){
        var id = options.roots[i];
        var ele = cy.getElementById( id );
        rootsArray.push( ele );
      }

      roots = new $$.Collection( cy, rootsArray );
    } else if( $$.is.string(options.roots) ){
      roots = cy.$( options.roots );

    } else {
      if( options.directed ){
        roots = nodes.roots();
      } else {
        var components = [];
        var unhandledNodes = nodes;

        while( unhandledNodes.length > 0 ){
          var currComp = cy.collection();

          eles.bfs({
            roots: unhandledNodes[0],
            visit: function(i, depth, node, edge, pNode){
              currComp = currComp.add( node );
            },
            directed: false
          });

          unhandledNodes = unhandledNodes.not( currComp );
          components.push( currComp );
        }

        roots = cy.collection();
        for( var i = 0; i < components.length; i++ ){
          var comp = components[i];
          var maxDegree = comp.maxDegree( false );
          var compRoots = comp.filter(function(){
            return this.degree(false) === maxDegree;
          });

          roots = roots.add( compRoots );
        }
        
      }
    }


    var depths = [];
    var foundByBfs = {};
    var id2depth = {};
    var prevNode = {};
    var prevEdge = {};
    var successors = {};

    // find the depths of the nodes
    graph.bfs({
      roots: roots,
      directed: options.directed,
      visit: function(i, depth, node, edge, pNode){
        var ele = this[0];
        var id = ele.id();

        if( !depths[depth] ){
          depths[depth] = [];
        }

        depths[depth].push( ele );
        foundByBfs[ id ] = true;
        id2depth[ id ] = depth;
        prevNode[ id ] = pNode;
        prevEdge[ id ] = edge;

        if( pNode ){
          var prevId = pNode.id();
          var succ = successors[ prevId ] = successors[ prevId ] || [];
          
          succ.push( node );
        }
      }
    });

    // check for nodes not found by bfs
    var orphanNodes = [];
    for( var i = 0; i < nodes.length; i++ ){
      var ele = nodes[i];

      if( foundByBfs[ ele.id() ] ){
        continue;
      } else {
        orphanNodes.push( ele );
      }
    }

    // assign orphan nodes a depth from their neighborhood
    var maxChecks = orphanNodes.length * 3;
    var checks = 0;
    while( orphanNodes.length !== 0 && checks < maxChecks ){
      var node = orphanNodes.shift();
      var neighbors = node.neighborhood().nodes();
      var assignedDepth = false;

      for( var i = 0; i < neighbors.length; i++ ){
        var depth = id2depth[ neighbors[i].id() ];

        if( depth !== undefined ){
          depths[depth].push( node );
          assignedDepth = true;
          break;
        }
      }

      if( !assignedDepth ){
        orphanNodes.push( node );
      }

      checks++;
    }

    // assign orphan nodes that are still left to the depth of their subgraph
    while( orphanNodes.length !== 0 ){
      var node = orphanNodes.shift();
      //var subgraph = graph.bfs( node ).path;
      var assignedDepth = false;

      // for( var i = 0; i < subgraph.length; i++ ){
      //   var depth = id2depth[ subgraph[i].id() ];

      //   if( depth !== undefined ){
      //     depths[depth].push( node );
      //     assignedDepth = true;
      //     break;
      //   }
      // }

      if( !assignedDepth ){ // worst case if the graph really isn't tree friendly, then just dump it in 0
        if( depths.length === 0 ){
          depths.push([]);
        }
        
        depths[0].push( node );
      }
    }

    // assign the nodes a depth and index
    var assignDepthsToEles = function(){
      for( var i = 0; i < depths.length; i++ ){
        var eles = depths[i];

        for( var j = 0; j < eles.length; j++ ){
          var ele = eles[j];

          ele._private.scratch.breadthfirst = {
            depth: i,
            index: j
          };
        }
      }
    };
    assignDepthsToEles();


    var intersectsDepth = function( node ){ // returns true if has edges pointing in from a higher depth
      var edges = node.connectedEdges(function(){
        return this.data('target') === node.id();
      });
      var thisInfo = node._private.scratch.breadthfirst;
      var highestDepthOfOther = 0;
      var highestOther;
      for( var i = 0; i < edges.length; i++ ){
        var edge = edges[i];
        var otherNode = edge.source()[0];
        var otherInfo = otherNode._private.scratch.breadthfirst;

        if( thisInfo.depth <= otherInfo.depth && highestDepthOfOther < otherInfo.depth ){
          highestDepthOfOther = otherInfo.depth;
          highestOther = otherNode;
        }
      }

      return highestOther;
    };

     // make maximal if so set by adjusting depths
    for( var adj = 0; adj < options.maximalAdjustments; adj++ ){

      var nDepths = depths.length;
      var elesToMove = [];
      for( var i = 0; i < nDepths; i++ ){
        var depth = depths[i];

        var nDepth = depth.length;
        for( var j = 0; j < nDepth; j++ ){
          var ele = depth[j];
          var info = ele._private.scratch.breadthfirst;
          var intEle = intersectsDepth(ele);

          if( intEle ){
            info.intEle = intEle;
            elesToMove.push( ele );
          }
        }
      }

      for( var i = 0; i < elesToMove.length; i++ ){ 
        var ele = elesToMove[i];
        var info = ele._private.scratch.breadthfirst;
        var intEle = info.intEle;
        var intInfo = intEle._private.scratch.breadthfirst;

        depths[ info.depth ].splice( info.index, 1 ); // remove from old depth & index

        // add to end of new depth
        var newDepth = intInfo.depth + 1;
        while( newDepth > depths.length - 1 ){
          depths.push([]);
        }
        depths[ newDepth ].push( ele );

        info.depth = newDepth;
        info.index = depths[newDepth].length - 1;
      }

      assignDepthsToEles();
    }

    // find min distance we need to leave between nodes
    var minDistance = 0;
    if( options.avoidOverlap ){
      for( var i = 0; i < nodes.length; i++ ){
        var w = nodes[i].outerWidth();
        var h = nodes[i].outerHeight();
        
        minDistance = Math.max(minDistance, w, h);
      }
      minDistance *= options.spacingFactor; // just to have some nice spacing
    }

    // get the weighted percent for an element based on its connectivity to other levels
    var cachedWeightedPercent = {};
    var getWeightedPercent = function( ele ){
      if( cachedWeightedPercent[ ele.id() ] ){
        return cachedWeightedPercent[ ele.id() ];
      }

      var eleDepth = ele._private.scratch.breadthfirst.depth;
      var neighbors = ele.neighborhood().nodes().not(':parent');
      var percent = 0;
      var samples = 0;

      for( var i = 0; i < neighbors.length; i++ ){
        var neighbor = neighbors[i];
        var bf = neighbor._private.scratch.breadthfirst;
        var index = bf.index;
        var depth = bf.depth;
        var nDepth = depths[depth].length;

        if( eleDepth > depth || eleDepth === 0 ){ // only get influenced by elements above
          percent += index / nDepth;
          samples++;
        }
      }

      samples = Math.max(1, samples);
      percent = percent / samples;

      if( samples === 0 ){ // so lone nodes have a "don't care" state in sorting
        percent = undefined;
      }

      cachedWeightedPercent[ ele.id() ] = percent;
      return percent;
    };


    // rearrange the indices in each depth level based on connectivity

    var sortFn = function(a, b){
      var apct = getWeightedPercent( a );
      var bpct = getWeightedPercent( b );

      return apct - bpct;
    };

    for( var times = 0; times < 3; times++ ){ // do it a few times b/c the depths are dynamic and we want a more stable result

      for( var i = 0; i < depths.length; i++ ){
        depths[i] = depths[i].sort( sortFn );
      }
      assignDepthsToEles(); // and update

    }

    var biggestDepthSize = 0;
    for( var i = 0; i < depths.length; i++ ){
      biggestDepthSize = Math.max( depths[i].length, biggestDepthSize );
    }

    var center = {
      x: bb.x1 + bb.w/2,
      y: bb.x1 + bb.h/2
    };
   
    var getPosition = function( ele, isBottomDepth ){
      var info = ele._private.scratch.breadthfirst;
      var depth = info.depth;
      var index = info.index;
      var depthSize = depths[depth].length;

      var distanceX = Math.max( bb.w / (depthSize + 1), minDistance );
      var distanceY = Math.max( bb.h / (depths.length + 1), minDistance );
      var radiusStepSize = Math.min( bb.w / 2 / depths.length, bb.h / 2 / depths.length );
      radiusStepSize = Math.max( radiusStepSize, minDistance );

      if( !options.circle ){
        
        var epos = {
          x: center.x + (index + 1 - (depthSize + 1)/2) * distanceX,
          y: (depth + 1) * distanceY
        };

        if( isBottomDepth ){
          return epos;
        }

        // var succs = successors[ ele.id() ];
        // if( succs ){
        //   epos.x = 0;
        // 
        //   for( var i = 0 ; i < succs.length; i++ ){
        //     var spos = pos[ succs[i].id() ];
        //     
        //     epos.x += spos.x;
        //   }
        // 
        //   epos.x /= succs.length;
        // } else {
        //   //debugger;
        // }

        return epos;

      } else {
        if( options.circle ){
          var radius = radiusStepSize * depth + radiusStepSize - (depths.length > 0 && depths[0].length <= 3 ? radiusStepSize/2 : 0);
          var theta = 2 * Math.PI / depths[depth].length * index;

          if( depth === 0 && depths[0].length === 1 ){
            radius = 1;
          }

          return {
            x: center.x + radius * Math.cos(theta),
            y: center.y + radius * Math.sin(theta)
          };

        } else {
          return {
            x: center.x + (index + 1 - (depthSize + 1)/2) * distanceX,
            y: (depth + 1) * distanceY
          };
        }
      }
      
    };

    // get positions in reverse depth order
    var pos = {};
    for( var i = depths.length - 1; i >=0; i-- ){
      var depth = depths[i];

      for( var j = 0; j < depth.length; j++ ){
        var node = depth[j];

        pos[ node.id() ] = getPosition( node, i === depths.length - 1 );
      }
    }

    nodes.layoutPositions(this, options, function(){
      return pos[ this.id() ];
    });
    
    return this; // chaining
  };
  
  $$('layout', 'breadthfirst', BreadthFirstLayout);
  
})( cytoscape );

;(function($$){ 'use strict';
  
  var defaults = {
    fit: true, // whether to fit the viewport to the graph
    padding: 30, // the padding on fit
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    avoidOverlap: true, // prevents node overlap, may overflow boundingBox and radius if not enough space
    radius: undefined, // the radius of the circle
    startAngle: 3/2 * Math.PI, // the position of the first node
    counterclockwise: false, // whether the layout should go counterclockwise (true) or clockwise (false)
    sort: undefined, // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
    animate: false, // whether to transition the node positions
    animationDuration: 500, // duration of animation in ms if enabled
    ready: undefined, // callback on layoutready
    stop: undefined // callback on layoutstop
  };
  
  function CircleLayout( options ){
    this.options = $$.util.extend({}, defaults, options);
  }
  
  CircleLayout.prototype.run = function(){
    var params = this.options;
    var options = params;
    
    var cy = params.cy;
    var eles = options.eles;
      
    var nodes = eles.nodes().not(':parent');

    if( options.sort ){
      nodes = nodes.sort( options.sort );
    }
    
    var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
      x1: 0, y1: 0, w: cy.width(), h: cy.height()
    } );

    var center = {
      x: bb.x1 + bb.w/2,
      y: bb.y1 + bb.h/2
    };
    
    var theta = options.startAngle;
    var dTheta = 2 * Math.PI / nodes.length;
    var r;

    var minDistance = 0;
    for( var i = 0; i < nodes.length; i++ ){
      var w = nodes[i].outerWidth();
      var h = nodes[i].outerHeight();
      
      minDistance = Math.max(minDistance, w, h);
    }

    if( $$.is.number(options.radius) ){
      r = options.radius;
    } else if( nodes.length <= 1 ){
      r = 0;
    } else {
      r = Math.min( bb.h, bb.w )/2 - minDistance;
    }

    // calculate the radius
    if( nodes.length > 1 && options.avoidOverlap ){ // but only if more than one node (can't overlap)
      minDistance *= 1.75; // just to have some nice spacing

      var dTheta = 2 * Math.PI / nodes.length;
      var dcos = Math.cos(dTheta) - Math.cos(0);
      var dsin = Math.sin(dTheta) - Math.sin(0);
      var rMin = Math.sqrt( minDistance * minDistance / ( dcos*dcos + dsin*dsin ) ); // s.t. no nodes overlapping
      r = Math.max( rMin, r );
    }

    var getPos = function( i, ele ){
      var rx = r * Math.cos( theta );
      var ry = r * Math.sin( theta );
      var pos = {
        x: center.x + rx,
        y: center.y + ry
      };

      theta = options.counterclockwise ? theta - dTheta : theta + dTheta;
      return pos;
    };
    
    nodes.layoutPositions( this, options, getPos );

    return this; // chaining
  };
  
  $$('layout', 'circle', CircleLayout);
  
})( cytoscape );

;(function($$){ 'use strict';

  // default layout options
  var defaults = {
    animate: true, // whether to show the layout as it's running
    refresh: 1, // number of ticks per frame; higher is faster but more jerky
    maxSimulationTime: 4000, // max length in ms to run the layout
    ungrabifyWhileSimulating: false, // so you can't drag nodes during layout
    fit: true, // on every layout reposition of nodes, fit the viewport
    padding: 30, // padding around the simulation
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }

    // layout event callbacks
    ready: function(){}, // on layoutready
    stop: function(){}, // on layoutstop

    // positioning options
    randomize: false, // use random node positions at beginning of layout
    avoidOverlap: true, // if true, prevents overlap of node bounding boxes
    handleDisconnected: true, // if true, avoids disconnected components from overlapping
    nodeSpacing: function( node ){ return 10; }, // extra spacing around nodes
    flow: undefined, // use DAG/tree flow layout if specified, e.g. { axis: 'y', minSeparation: 30 }
    alignment: undefined, // relative alignment constraints on nodes, e.g. function( node ){ return { x: 0, y: 1 } }

    // different methods of specifying edge length
    // each can be a constant numerical value or a function like `function( edge ){ return 2; }`
    edgeLength: undefined, // sets edge length directly in simulation
    edgeSymDiffLength: undefined, // symmetric diff edge length in simulation
    edgeJaccardLength: undefined, // jaccard edge length in simulation

    // iterations of cola algorithm; uses default values on undefined
    unconstrIter: undefined, // unconstrained initial layout iterations
    userConstIter: undefined, // initial layout iterations with user-specified constraints
    allConstIter: undefined, // initial layout iterations with all constraints including non-overlap

    // infinite layout options
    infinite: false // overrides all other options for a forces-all-the-time mode
  };

  // constructor
  // options : object containing layout options
  function ColaLayout( options ){
    this.options = $$.util.extend(true, {}, defaults, options); 
  }

  // runs the layout
  ColaLayout.prototype.run = function(){
    var layout = this;
    var options = this.options;
    
    layout.manuallyStopped = false;

    $$.util.require('cola', function(cola){

      var cy = options.cy; // cy is automatically populated for us in the constructor
      var eles = options.eles;
      var nodes = eles.nodes();
      var edges = eles.edges();
      var ready = false;
      
      var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
        x1: 0, y1: 0, w: cy.width(), h: cy.height()
      } );

      var getOptVal = function( val, ele ){
        if( $$.is.fn(val) ){
          var fn = val;
          return fn.apply( ele, [ ele ] );
        } else {
          return val;
        }
      };

      var updateNodePositions = function(){
        var x = { min: Infinity, max: -Infinity };
        var y = { min: Infinity, max: -Infinity };

        for( var i = 0; i < nodes.length; i++ ){
          var node = nodes[i];
          var scratch = node._private.scratch.cola;

          x.min = Math.min( x.min, scratch.x || 0 );
          x.max = Math.max( x.max, scratch.x || 0 );

          y.min = Math.min( y.min, scratch.y || 0 );
          y.max = Math.max( y.max, scratch.y || 0 );
          
          // update node dims
          if( !scratch.updatedDims ){
            var nbb = node.boundingBox();
            var padding = getOptVal( options.nodeSpacing, node );
            
            scratch.width = nbb.w + 2*padding;
            scratch.height = nbb.h + 2*padding;
          }
        }

        nodes.positions(function(i, node){
          var scratch = node._private.scratch.cola;
          var retPos;

          if( !node.grabbed() && !node.isParent() ){
            retPos = {
              x: bb.x1 + scratch.x - x.min,
              y: bb.y1 + scratch.y - y.min
            };

            if( !$$.is.number(retPos.x) || !$$.is.number(retPos.y) ){
              retPos = undefined;
            }
          }

          return retPos;
        });

        nodes.updateCompoundBounds(); // because the way this layout sets positions is buggy for some reason; ref #878

        if( !ready ){
          onReady();
          ready = true;
        }

        if( options.fit ){
          cy.fit( options.padding );
        }
      };

      var onDone = function(){
        if( options.ungrabifyWhileSimulating ){
          grabbableNodes.grabify();
        }

        nodes.off('grab free position', grabHandler);
        nodes.off('lock unlock', lockHandler);

        // trigger layoutstop when the layout stops (e.g. finishes)
        layout.one('layoutstop', options.stop);
        layout.trigger({ type: 'layoutstop', layout: layout });
      };

      var onReady = function(){
        // trigger layoutready when each node has had its position set at least once
        layout.one('layoutready', options.ready);
        layout.trigger({ type: 'layoutready', layout: layout });
      };

      var ticksPerFrame = options.refresh;
      var tickSkip = 1; // frames until a tick; used to slow down sim for debugging

      if( options.refresh < 0 ){
        tickSkip = Math.abs( options.refresh );
        ticksPerFrame = 1;
      } else {
        ticksPerFrame = Math.max( 1, ticksPerFrame ); // at least 1
      }

      var adaptor = layout.adaptor = cola.adaptor({
        trigger: function( e ){ // on sim event      
          var TICK = cola.EventType ? cola.EventType.tick : null;
          var END = cola.EventType ? cola.EventType.end : null;
          
          switch( e.type ){
            case 'tick':
            case TICK:
              if( options.animate ){
                updateNodePositions();
              }
              break;

            case 'end':
            case END:
              updateNodePositions();
              if( !options.infinite ){ onDone(); }           
              break;
          }
        },

        kick: function(){ // kick off the simulation
          var skip = 0;

          var inftick = function(){
            if( layout.manuallyStopped ){
              onDone();
              
              return true;
            }
            
            var ret = adaptor.tick();

            if( ret && options.infinite ){ // resume layout if done
              adaptor.resume(); // resume => new kick
            }
            
            return ret; // allow regular finish b/c of new kick
          };

          var multitick = function(){ // multiple ticks in a row
            var ret;

            // skip ticks to slow down layout for debugging
            // var thisSkip = skip;
            // skip = (skip + 1) % tickSkip;
            // if( thisSkip !== 0 ){
            //   return false;
            // }

            for( var i = 0; i < ticksPerFrame && !ret; i++ ){
              ret = ret || inftick(); // pick up true ret vals => sim done
            }

            return ret;
          };

          if( options.animate ){
            var frame = function(){
              if( multitick() ){ return; }

              $$.util.requestAnimationFrame( frame );
            };

            $$.util.requestAnimationFrame( frame );
          } else {
            while( !inftick() ){}
          }
        },

        on: function( type, listener ){}, // dummy; not needed

        drag: function(){} // not needed for our case
      });
      layout.adaptor = adaptor;

      // if set no grabbing during layout
      var grabbableNodes = nodes.filter(':grabbable');
      if( options.ungrabifyWhileSimulating ){
        grabbableNodes.ungrabify();
      }

      // handle node dragging
      var grabHandler;
      nodes.on('grab free position', grabHandler = function(e){
        var node = this;
        var scrCola = node._private.scratch.cola;
        var pos = node._private.position;

        if( node.grabbed() ){
          scrCola.x = pos.x - bb.x1;
          scrCola.y = pos.y - bb.y1;

          adaptor.dragstart( scrCola );
        } else if( $$.is.number(scrCola.x) && $$.is.number(scrCola.y) ){
          pos.x = scrCola.x + bb.x1;
          pos.y = scrCola.y + bb.y1;
        }

        switch( e.type ){
          case 'grab':
            adaptor.dragstart( scrCola );
            adaptor.resume();
            break;
          case 'free':
            adaptor.dragend( scrCola );
            break;
        }
        
      });

      var lockHandler;
      nodes.on('lock unlock', lockHandler = function(e){
        var node = this;
        var scrCola = node._private.scratch.cola;
      
        if( node.locked() ){
          adaptor.dragstart( scrCola );
        } else {
          adaptor.dragend( scrCola );
        }
      });

      var nonparentNodes = nodes.stdFilter(function( node ){
        return !node.isParent();
      });

      // add nodes to cola
      adaptor.nodes( nonparentNodes.map(function( node, i ){
        var padding = getOptVal( options.nodeSpacing, node );
        var pos = node.position();
        var nbb = node.boundingBox();

        var struct = node._private.scratch.cola = {
          x: options.randomize || pos.x === undefined ? Math.round( Math.random() * bb.w ) : pos.x,
          y: options.randomize || pos.y === undefined ? Math.round( Math.random() * bb.h ) : pos.y,
          width: nbb.w + 2*padding,
          height: nbb.h + 2*padding,
          index: i
        };

        return struct;
      }) );

      if( options.alignment ){ // then set alignment constraints

        var offsetsX = [];
        var offsetsY = [];

        nonparentNodes.forEach(function( node ){
          var align = getOptVal( options.alignment, node );
          var scrCola = node._private.scratch.cola;
          var index = scrCola.index;

          if( !align ){ return; }

          if( align.x != null ){
            offsetsX.push({
              node: index,
              offset: align.x
            });
          }

          if( align.y != null ){
            offsetsY.push({
              node: index,
              offset: align.y
            });
          }
        });

        // add alignment constraints on nodes
        var constraints = [];

        if( offsetsX.length > 0 ){
          constraints.push({
            type: 'alignment',
            axis: 'x',
            offsets: offsetsX
          });
        }

        if( offsetsY.length > 0 ){
          constraints.push({
            type: 'alignment',
            axis: 'y',
            offsets: offsetsY
          });
        }
        
        adaptor.constraints( constraints );

      }

      // add compound nodes to cola
      adaptor.groups( nodes.stdFilter(function( node ){
        return node.isParent();
      }).map(function( node, i ){ // add basic group incl leaf nodes
        var style = node._private.style;
        
        var optPadding = getOptVal( options.nodeSpacing, node );
        
        var pleft = style['padding-left'].pxValue + optPadding;
        var pright = style['padding-right'].pxValue + optPadding;
        var ptop = style['padding-top'].pxValue + optPadding;
        var pbottom = style['padding-bottom'].pxValue + optPadding;
        
        node._private.scratch.cola = {
          index: i,
          
          padding: Math.max( pleft, pright, ptop, pbottom ),

          leaves: node.descendants().stdFilter(function( child ){
            return !child.isParent();
          }).map(function( child ){
            return child[0]._private.scratch.cola.index;
          })
        };

        return node;
      }).map(function( node ){ // add subgroups
        node._private.scratch.cola.groups = node.descendants().stdFilter(function( child ){
          return child.isParent();
        }).map(function( child ){
          return child._private.scratch.cola.index;
        });

        return node._private.scratch.cola;
      }) );

      // get the edge length setting mechanism
      var length;
      var lengthFnName;
      if( options.edgeLength != null ){
        length = options.edgeLength;
        lengthFnName = 'linkDistance';
      } else if( options.edgeSymDiffLength != null ){
        length = options.edgeSymDiffLength;
        lengthFnName = 'symmetricDiffLinkLengths';
      } else if( options.edgeJaccardLength != null ){
        length = options.edgeJaccardLength;
        lengthFnName = 'jaccardLinkLengths';
      } else {
        length = 100;
        lengthFnName = 'linkDistance';
      }

      var lengthGetter = function( link ){
        return link.calcLength;
      };

      // add the edges to cola
      adaptor.links( edges.stdFilter(function( edge ){
        return !edge.source().isParent() && !edge.target().isParent();
      }).map(function( edge, i ){
        var c = edge._private.scratch.cola = {
          source: edge.source()[0]._private.scratch.cola.index,
          target: edge.target()[0]._private.scratch.cola.index
        };

        if( length != null ){
          c.calcLength = getOptVal( length, edge );
        }

        return c;
      }) );

      adaptor.size([ bb.w, bb.h ]);

      if( length != null ){
        adaptor[ lengthFnName ]( lengthGetter );
      }

      // set the flow of cola
      if( options.flow ){
        var flow;
        var defAxis = 'y';
        var defMinSep = 50;

        if( $$.is.string(options.flow) ){
          flow = {
            axis: options.flow,
            minSeparation: defMinSep
          };
        } else if( $$.is.number(options.flow) ){
          flow = {
            axis: defAxis,
            minSeparation: options.flow
          };
        } else if( $$.is.plainObject(options.flow) ){
          flow = options.flow;

          flow.axis = flow.axis || defAxis;
          flow.minSeparation = flow.minSeparation != null ? flow.minSeparation : defMinSep;
        } else { // e.g. options.flow: true
          flow = {
            axis: defAxis,
            minSeparation: defMinSep
          };
        }

        adaptor.flowLayout( flow.axis , flow.minSeparation );
      }

      layout.trigger({ type: 'layoutstart', layout: layout });

      adaptor
        .avoidOverlaps( options.avoidOverlap )
        .handleDisconnected( options.handleDisconnected )
        .start( options.unconstrIter, options.userConstIter, options.allConstIter)
      ;

      if( !options.infinite ){
        setTimeout(function(){
          if( !layout.manuallyStopped ){
            adaptor.stop();
          }
        }, options.maxSimulationTime);
      }

    }); // require

    return this; // chaining
  };

  // called on continuous layouts to stop them before they finish
  ColaLayout.prototype.stop = function(){
    if( this.adaptor ){
      this.manuallyStopped = true;
      this.adaptor.stop();
    }

    return this; // chaining
  };

  // register the layout
  $$('layout', 'cola', ColaLayout);

})(cytoscape);

;(function($$){ 'use strict';
  
  var defaults = {
    fit: true, // whether to fit the viewport to the graph
    padding: 30, // the padding on fit
    startAngle: 3/2 * Math.PI, // the position of the first node
    counterclockwise: false, // whether the layout should go counterclockwise/anticlockwise (true) or clockwise (false)
    minNodeSpacing: 10, // min spacing between outside of nodes (used for radius adjustment)
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
    height: undefined, // height of layout area (overrides container height)
    width: undefined, // width of layout area (overrides container width)
    concentric: function(node){ // returns numeric value for each node, placing higher nodes in levels towards the centre
      return node.degree();
    },
    levelWidth: function(nodes){ // the variation of concentric values in each level
      return nodes.maxDegree() / 4;
    },
    animate: false, // whether to transition the node positions
    animationDuration: 500, // duration of animation in ms if enabled
    ready: undefined, // callback on layoutready
    stop: undefined // callback on layoutstop
  };
  
  function ConcentricLayout( options ){
    this.options = $$.util.extend({}, defaults, options);
  }
  
  ConcentricLayout.prototype.run = function(){
    var params = this.options;
    var options = params;
    
    var cy = params.cy;
    
    var eles = options.eles;
    var nodes = eles.nodes().not(':parent');
    
    var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
      x1: 0, y1: 0, w: cy.width(), h: cy.height()
    } );

    var center = {
      x: bb.x1 + bb.w/2,
      y: bb.y1 + bb.h/2
    };
    
    var nodeValues = []; // { node, value }
    var theta = options.startAngle;
    var maxNodeSize = 0;

    for( var i = 0; i < nodes.length; i++ ){
      var node = nodes[i];
      var value;
      
      // calculate the node value
      value = options.concentric.apply(node, [ node ]);
      nodeValues.push({
        value: value,
        node: node
      });

      // for style mapping
      node._private.scratch.concentric = value;
    }

    // in case we used the `concentric` in style
    nodes.updateStyle();

    // calculate max size now based on potentially updated mappers
    for( var i = 0; i < nodes.length; i++ ){
      var node = nodes[i];

      maxNodeSize = Math.max( maxNodeSize, node.outerWidth(), node.outerHeight() );
    }

    // sort node values in descreasing order
    nodeValues.sort(function(a, b){
      return b.value - a.value;
    });

    var levelWidth = options.levelWidth( nodes );

    // put the values into levels
    var levels = [ [] ];
    var currentLevel = levels[0];
    for( var i = 0; i < nodeValues.length; i++ ){
      var val = nodeValues[i];

      if( currentLevel.length > 0 ){
        var diff = Math.abs( currentLevel[0].value - val.value );

        if( diff >= levelWidth ){
          currentLevel = [];
          levels.push( currentLevel );
        }
      }

      currentLevel.push( val );
    }

    // create positions from levels

    var pos = {}; // id => position
    var r = 0;
    var minDist = maxNodeSize + options.minNodeSpacing; // min dist between nodes

    if( !options.avoidOverlap ){ // then strictly constrain to bb
      var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;
      var maxR = ( Math.min(bb.w, bb.h) / 2 - minDist );
      var rStep = maxR / ( levels.length + firstLvlHasMulti ? 1 : 0 );

      minDist = Math.min( minDist, rStep );
    }

    for( var i = 0; i < levels.length; i++ ){
      var level = levels[i];
      var dTheta = 2 * Math.PI / level.length;

      // calculate the radius
      if( level.length > 1 && options.avoidOverlap ){ // but only if more than one node (can't overlap)
        var dcos = Math.cos(dTheta) - Math.cos(0);
        var dsin = Math.sin(dTheta) - Math.sin(0);
        var rMin = Math.sqrt( minDist * minDist / ( dcos*dcos + dsin*dsin ) ); // s.t. no nodes overlapping
        r = Math.max( rMin, r );
      }

      for( var j = 0; j < level.length; j++ ){
        var val = level[j];
        var theta = options.startAngle + (options.counterclockwise ? -1 : 1) * dTheta * j;

        var p = {
          x: center.x + r * Math.cos(theta),
          y: center.y + r * Math.sin(theta)
        };

        pos[ val.node.id() ] = p;
      }

      r += minDist;
      
    } 

    // position the nodes
    nodes.layoutPositions(this, options, function(){
      var id = this.id();

      return pos[id];
    });
  
    return this; // chaining
  };
  
  $$('layout', 'concentric', ConcentricLayout);
  
})( cytoscape );

/*
  The CoSE layout was written by Gerardo Huck.

  Modifications tracked on Github.
*/

;(function($$) { 'use strict';

  var DEBUG;

  /**
   * @brief :  default layout options
   */
  var defaults = {
    // Called on `layoutready`
    ready               : function() {},

    // Called on `layoutstop`
    stop                : function() {},

    // Whether to animate while running the layout
    animate             : true,

    // Number of iterations between consecutive screen positions update (0 -> only updated on the end)
    refresh             : 4,
    
    // Whether to fit the network view after when done
    fit                 : true, 

    // Padding on fit
    padding             : 30, 

    // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    boundingBox         : undefined,

    // Whether to randomize node positions on the beginning
    randomize           : true,
    
    // Whether to use the JS console to print debug messages
    debug               : false,

    // Node repulsion (non overlapping) multiplier
    nodeRepulsion       : 400000,
    
    // Node repulsion (overlapping) multiplier
    nodeOverlap         : 10,
    
    // Ideal edge (non nested) length
    idealEdgeLength     : 10,
    
    // Divisor to compute edge forces
    edgeElasticity      : 100,
    
    // Nesting factor (multiplier) to compute ideal edge length for nested edges
    nestingFactor       : 5, 
    
    // Gravity force (constant)
    gravity             : 250, 
    
    // Maximum number of iterations to perform
    numIter             : 100,
    
    // Initial temperature (maximum node displacement)
    initialTemp         : 200,
    
    // Cooling factor (how the temperature is reduced between consecutive iterations
    coolingFactor       : 0.95, 
    
    // Lower temperature threshold (below this point the layout will end)
    minTemp             : 1.0
  };


  /**
   * @brief       : constructor
   * @arg options : object containing layout options
   */
  function CoseLayout(options) {
    this.options = $$.util.extend({}, defaults, options); 
  }


  /**
   * @brief : runs the layout
   */
  CoseLayout.prototype.run = function() {
    var options = this.options;
    var cy      = options.cy;
    var layout  = this;

    layout.stopped = false;

    layout.trigger({ type: 'layoutstart', layout: layout });

    // Set DEBUG - Global variable
    if (true === options.debug) {
      DEBUG = true;
    } else {
      DEBUG = false;
    }

    // Get start time
    var startTime = new Date();

    // Initialize layout info
    var layoutInfo = createLayoutInfo(cy, layout, options);
    
    // Show LayoutInfo contents if debugging
    if (DEBUG) {
      printLayoutInfo(layoutInfo);
    }

    // If required, randomize node positions
    if (true === options.randomize) {
      randomizePositions(layoutInfo, cy);
    }

    updatePositions(layoutInfo, cy, options);

    var mainLoop = function(i){
      if( layout.stopped ){
        // logDebug("Layout manually stopped. Stopping computation in step " + i);
        return false;
      }

      // Do one step in the phisical simulation
      step(layoutInfo, cy, options, i);
      
      // Update temperature
      layoutInfo.temperature = layoutInfo.temperature * options.coolingFactor;
      // logDebug("New temperature: " + layoutInfo.temperature);

      if (layoutInfo.temperature < options.minTemp) {
        // logDebug("Temperature drop below minimum threshold. Stopping computation in step " + i);
        return false;
      }

      return true;
    };

    var done = function(){
      refreshPositions(layoutInfo, cy, options);

      // Fit the graph if necessary
      if (true === options.fit) {
        cy.fit( options.padding );
      }
      
      // Get end time
      var endTime = new Date();

      console.info('Layout took ' + (endTime - startTime) + ' ms');

      // Layout has finished
      layout.one('layoutstop', options.stop);
      layout.trigger({ type: 'layoutstop', layout: layout });
    };

    if( options.animate ){
      var i = 0;
      var frame = function(){

        var f = 0;
        var loopRet;
        while( f < options.refresh && i < options.numIter ){
          var loopRet = mainLoop(i);
          if( loopRet === false ){ break; }

          f++;
          i++;
        }

        refreshPositions(layoutInfo, cy, options);
        if( options.fit ){
          cy.fit( options.padding );
        }

        if ( loopRet !== false && i + 1 < options.numIter ) {
          $$.util.requestAnimationFrame( frame );
        } else {
          done();
        }
      };

      $$.util.requestAnimationFrame( frame );
    } else {
      for (var i = 0; i < options.numIter; i++) {
        if( mainLoop(i) === false ){ break; }
      }

      done();
    }
   
    return this; // chaining
  };


  /**
   * @brief : called on continuous layouts to stop them before they finish
   */
  CoseLayout.prototype.stop = function(){
    this.stopped = true;

    return this; // chaining
  };


  /**
   * @brief     : Creates an object which is contains all the data
   *              used in the layout process
   * @arg cy    : cytoscape.js object
   * @return    : layoutInfo object initialized
   */
  var createLayoutInfo = function(cy, layout, options) {
    // Shortcut
    var edges = options.eles.edges();
    var nodes = options.eles.nodes();

    var layoutInfo   = {
      layout       : layout,
      layoutNodes  : [], 
      idToIndex    : {},
      nodeSize     : nodes.size(),
      graphSet     : [],
      indexToGraph : [], 
      layoutEdges  : [],
      edgeSize     : edges.size(),
      temperature  : options.initialTemp,
      clientWidth  : cy.width(),
      clientHeight : cy.width(),
      boundingBox  : $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
                       x1: 0, y1: 0, w: cy.width(), h: cy.height()
                     } )
    }; 
    
    // Iterate over all nodes, creating layout nodes
    for (var i = 0; i < layoutInfo.nodeSize; i++) {
      var tempNode        = {};
      tempNode.id         = nodes[i].data('id');
      tempNode.parentId   = nodes[i].data('parent');      
      tempNode.children   = [];
      tempNode.positionX  = nodes[i].position('x');
      tempNode.positionY  = nodes[i].position('y');
      tempNode.offsetX    = 0;      
      tempNode.offsetY    = 0;
      tempNode.height     = nodes[i].height();
      tempNode.width      = nodes[i].width();
      tempNode.maxX       = tempNode.positionX + tempNode.width  / 2;
      tempNode.minX       = tempNode.positionX - tempNode.width  / 2;
      tempNode.maxY       = tempNode.positionY + tempNode.height / 2;
      tempNode.minY       = tempNode.positionY - tempNode.height / 2;
      tempNode.padLeft    = nodes[i]._private.style['padding-left'].pxValue;
      tempNode.padRight   = nodes[i]._private.style['padding-right'].pxValue;
      tempNode.padTop     = nodes[i]._private.style['padding-top'].pxValue;
      tempNode.padBottom  = nodes[i]._private.style['padding-bottom'].pxValue;
      
      // Add new node
      layoutInfo.layoutNodes.push(tempNode);
      // Add entry to id-index map
      layoutInfo.idToIndex[tempNode.id] = i;
    }

    // Inline implementation of a queue, used for traversing the graph in BFS order
    var queue = [];
    var start = 0;   // Points to the start the queue
    var end   = -1;  // Points to the end of the queue

    var tempGraph = [];

    // Second pass to add child information and 
    // initialize queue for hierarchical traversal
    for (var i = 0; i < layoutInfo.nodeSize; i++) {
      var n = layoutInfo.layoutNodes[i];
      var p_id = n.parentId;
      // Check if node n has a parent node
      if (null != p_id) {
      // Add node Id to parent's list of children
      layoutInfo.layoutNodes[layoutInfo.idToIndex[p_id]].children.push(n.id);
      } else {
      // If a node doesn't have a parent, then it's in the root graph
      queue[++end] = n.id;
      tempGraph.push(n.id);    
      }
    }
    
    // Add root graph to graphSet
    layoutInfo.graphSet.push(tempGraph);

    // Traverse the graph, level by level, 
    while (start <= end) {
      // Get the node to visit and remove it from queue
      var node_id  = queue[start++];
      var node_ix  = layoutInfo.idToIndex[node_id];
      var node     = layoutInfo.layoutNodes[node_ix];
      var children = node.children;
      if (children.length > 0) {
      // Add children nodes as a new graph to graph set
      layoutInfo.graphSet.push(children);
      // Add children to que queue to be visited
      for (var i = 0; i < children.length; i++) {
        queue[++end] = children[i];
      }
      }
    }

    // Create indexToGraph map
    for (var i = 0; i < layoutInfo.graphSet.length; i++) {      
      var graph = layoutInfo.graphSet[i];
      for (var j = 0; j < graph.length; j++) {
      var index = layoutInfo.idToIndex[graph[j]];
      layoutInfo.indexToGraph[index] = i;
      }
    }
    
    // Iterate over all edges, creating Layout Edges
    for (var i = 0; i < layoutInfo.edgeSize; i++) {
      var e = edges[i];
      var tempEdge = {};      
      tempEdge.id       = e.data('id');
      tempEdge.sourceId = e.data('source');
      tempEdge.targetId = e.data('target');

      // Compute ideal length
      var idealLength = options.idealEdgeLength;

      // Check if it's an inter graph edge
      var sourceIx    = layoutInfo.idToIndex[tempEdge.sourceId];
      var targetIx    = layoutInfo.idToIndex[tempEdge.targetId];
      var sourceGraph = layoutInfo.indexToGraph[sourceIx];
      var targetGraph = layoutInfo.indexToGraph[targetIx];

      if (sourceGraph != targetGraph) {
      // Find lowest common graph ancestor
      var lca = findLCA(tempEdge.sourceId, tempEdge.targetId, layoutInfo);

      // Compute sum of node depths, relative to lca graph
      var lcaGraph = layoutInfo.graphSet[lca];
      var depth    = 0;

      // Source depth
      var tempNode = layoutInfo.layoutNodes[sourceIx];
      while (-1 === $.inArray(tempNode.id, lcaGraph)) {
        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];
        depth++;
      }

      // Target depth
      tempNode = layoutInfo.layoutNodes[targetIx];
      while (-1 === $.inArray(tempNode.id, lcaGraph)) {
        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];
        depth++;
      }

      // logDebug('LCA of nodes ' + tempEdge.sourceId + ' and ' + tempEdge.targetId +  
        //  ". Index: " + lca + " Contents: " + lcaGraph.toString() + 
        //  ". Depth: " + depth);

      // Update idealLength
      idealLength *= depth * options.nestingFactor;
      }

      tempEdge.idealLength = idealLength;

      layoutInfo.layoutEdges.push(tempEdge);
    }

    // Finally, return layoutInfo object
    return layoutInfo;
  };

  
  /**
   * @brief : This function finds the index of the lowest common 
   *          graph ancestor between 2 nodes in the subtree 
   *          (from the graph hierarchy induced tree) whose
   *          root is graphIx
   *
   * @arg node1: node1's ID
   * @arg node2: node2's ID
   * @arg layoutInfo: layoutInfo object
   *
   */
  var findLCA = function(node1, node2, layoutInfo) {
    // Find their common ancester, starting from the root graph
    var res = findLCA_aux(node1, node2, 0, layoutInfo);
    if (2 > res.count) {
      // If aux function couldn't find the common ancester, 
      // then it is the root graph
      return 0;
    } else {
      return res.graph;
    }
  };


  /**
   * @brief          : Auxiliary function used for LCA computation
   * 
   * @arg node1      : node1's ID
   * @arg node2      : node2's ID
   * @arg graphIx    : subgraph index
   * @arg layoutInfo : layoutInfo object
   *
   * @return         : object of the form {count: X, graph: Y}, where:
   *                   X is the number of ancesters (max: 2) found in 
   *                   graphIx (and it's subgraphs),
   *                   Y is the graph index of the lowest graph containing 
   *                   all X nodes
   */
  var findLCA_aux = function(node1, node2, graphIx, layoutInfo) {
    var graph = layoutInfo.graphSet[graphIx];
    // If both nodes belongs to graphIx
    if (-1 < $.inArray(node1, graph) && -1 < $.inArray(node2, graph)) {
      return {count:2, graph:graphIx};
    }

    // Make recursive calls for all subgraphs
    var c = 0;
    for (var i = 0; i < graph.length; i++) {
      var nodeId   = graph[i];
      var nodeIx   = layoutInfo.idToIndex[nodeId];
      var children = layoutInfo.layoutNodes[nodeIx].children;

      // If the node has no child, skip it
      if (0 === children.length) {
      continue;
      }

      var childGraphIx = layoutInfo.indexToGraph[layoutInfo.idToIndex[children[0]]];
      var result = findLCA_aux(node1, node2, childGraphIx, layoutInfo);
      if (0 === result.count) {
      // Neither node1 nor node2 are present in this subgraph
      continue;
      } else if (1 === result.count) {
      // One of (node1, node2) is present in this subgraph
      c++;
      if (2 === c) {
        // We've already found both nodes, no need to keep searching
        break;
      }
      } else {
      // Both nodes are present in this subgraph
      return result;
      }      
    }
    
    return {count:c, graph:graphIx};
  };


  /**
   * @brief: printsLayoutInfo into js console
   *         Only used for debbuging 
   */
  var printLayoutInfo = function(layoutInfo) {
    if (!DEBUG) {
      return;
    }
    console.debug("layoutNodes:");
    for (var i = 0; i < layoutInfo.nodeSize; i++) {
      var n = layoutInfo.layoutNodes[i];
      var s = 
      "\nindex: "     + i + 
      "\nId: "        + n.id + 
      "\nChildren: "  + n.children.toString() +  
      "\nparentId: "  + n.parentId  + 
      "\npositionX: " + n.positionX + 
      "\npositionY: " + n.positionY +
      "\nOffsetX: " + n.offsetX + 
      "\nOffsetY: " + n.offsetY + 
      "\npadLeft: " + n.padLeft + 
      "\npadRight: " + n.padRight + 
      "\npadTop: " + n.padTop + 
      "\npadBottom: " + n.padBottom;

      console.debug(s);    
    }  
    
    console.debug('idToIndex');
    for (var i in layoutInfo.idToIndex) {
      console.debug("Id: " + i + "\nIndex: " + layoutInfo.idToIndex[i]);
    }

    console.debug('Graph Set');
    var set = layoutInfo.graphSet;
    for (var i = 0; i < set.length; i ++) {
      console.debug("Set : " + i + ": " + set[i].toString());
    } 

    var s = 'IndexToGraph';
    for (var i = 0; i < layoutInfo.indexToGraph.length; i ++) {
      s += "\nIndex : " + i + " Graph: "+ layoutInfo.indexToGraph[i];
    }
    console.debug(s);

    s = 'Layout Edges';
    for (var i = 0; i < layoutInfo.layoutEdges.length; i++) {
      var e = layoutInfo.layoutEdges[i];
      s += "\nEdge Index: " + i + " ID: " + e.id + 
      " SouceID: " + e.sourceId + " TargetId: " + e.targetId + 
      " Ideal Length: " + e.idealLength;
    }
    console.debug(s);

    s =  "nodeSize: " + layoutInfo.nodeSize;
    s += "\nedgeSize: " + layoutInfo.edgeSize;
    s += "\ntemperature: " + layoutInfo.temperature;
    console.debug(s);

    return;
  };


  /**
   * @brief : Randomizes the position of all nodes
   */
  var randomizePositions = function(layoutInfo, cy) {
    var width     = layoutInfo.clientWidth;
    var height    = layoutInfo.clientHeight;

    for (var i = 0; i < layoutInfo.nodeSize; i++) {
      var n = layoutInfo.layoutNodes[i];
      // No need to randomize compound nodes
      if (true || 0 === n.children.length) {
        n.positionX = Math.random() * width;
        n.positionY = Math.random() * height;
      }
    }
  };

  
  /**
   * @brief          : Updates the positions of nodes in the network
   * @arg layoutInfo : LayoutInfo object
   * @arg cy         : Cytoscape object
   * @arg options    : Layout options
   */
  var refreshPositions = function(layoutInfo, cy, options) {  
    // var s = 'Refreshing positions';
    // logDebug(s);

    var layout = layoutInfo.layout;
    var nodes = options.eles.nodes();
    var bb = layoutInfo.boundingBox;
    var coseBB = { x1: Infinity, x2: -Infinity, y1: Infinity, y2: -Infinity };
    
    if( options.boundingBox ){
      nodes.forEach(function( node ){
        var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[node.data('id')]];

        coseBB.x1 = Math.min( coseBB.x1, lnode.positionX );
        coseBB.x2 = Math.max( coseBB.x2, lnode.positionX );

        coseBB.y1 = Math.min( coseBB.y1, lnode.positionY );
        coseBB.y2 = Math.max( coseBB.y2, lnode.positionY );
      });

      coseBB.w = coseBB.x2 - coseBB.x1;
      coseBB.h = coseBB.y2 - coseBB.y1;
    }

    nodes.positions(function(i, ele) {
      var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[ele.data('id')]];
      // s = "Node: " + lnode.id + ". Refreshed position: (" + 
      // lnode.positionX + ", " + lnode.positionY + ").";
      // logDebug(s);

      if( options.boundingBox ){ // then add extra bounding box constraint
        var pctX = (lnode.positionX - coseBB.x1) / coseBB.w;
        var pctY = (lnode.positionY - coseBB.y1) / coseBB.h;

        return {
          x: bb.x1 + pctX * bb.w,
          y: bb.y1 + pctY * bb.h
        };
      } else {
        return {
          x: lnode.positionX,
          y: lnode.positionY
        };
      }
    });

    // Trigger layoutReady only on first call
    if (true !== layoutInfo.ready) {
      // s = 'Triggering layoutready';
      // logDebug(s);
      layoutInfo.ready = true;
      layout.one('layoutready', options.ready);
      layout.trigger({ type: 'layoutready', layout: this });
    }
  };


  /**
   * @brief          : Performs one iteration of the physical simulation
   * @arg layoutInfo : LayoutInfo object already initialized
   * @arg cy         : Cytoscape object
   * @arg options    : Layout options
   */
  var step = function(layoutInfo, cy, options, step) {  
    // var s = "\n\n###############################";
    // s += "\nSTEP: " + step;
    // s += "\n###############################\n";
    // logDebug(s);

    // Calculate node repulsions
    calculateNodeForces(layoutInfo, cy, options);
    // Calculate edge forces
    calculateEdgeForces(layoutInfo, cy, options);
    // Calculate gravity forces
    calculateGravityForces(layoutInfo, cy, options);
    // Propagate forces from parent to child
    propagateForces(layoutInfo, cy, options);
    // Update positions based on calculated forces
    updatePositions(layoutInfo, cy, options);
  };

  
  /**
   * @brief : Computes the node repulsion forces
   */
  var calculateNodeForces = function(layoutInfo, cy, options) {
    // Go through each of the graphs in graphSet
    // Nodes only repel each other if they belong to the same graph
    // var s = 'calculateNodeForces';
    // logDebug(s);
    for (var i = 0; i < layoutInfo.graphSet.length; i ++) {
      var graph    = layoutInfo.graphSet[i];
      var numNodes = graph.length;

      // s = "Set: " + graph.toString();
      // logDebug(s);

      // Now get all the pairs of nodes 
      // Only get each pair once, (A, B) = (B, A)
      for (var j = 0; j < numNodes; j++) {
      var node1 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];
      for (var k = j + 1; k < numNodes; k++) {
        var node2 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[k]]];
        nodeRepulsion(node1, node2, layoutInfo, cy, options);
      } 
      }
    } 
  };


  /**
   * @brief : Compute the node repulsion forces between a pair of nodes
   */
  var nodeRepulsion = function(node1, node2, layoutInfo, cy, options) {
    // var s = "Node repulsion. Node1: " + node1.id + " Node2: " + node2.id;

    // Get direction of line connecting both node centers
    var directionX = node2.positionX - node1.positionX;
    var directionY = node2.positionY - node1.positionY;
    // s += "\ndirectionX: " + directionX + ", directionY: " + directionY;

    // If both centers are the same, apply a random force
    if (0 === directionX && 0 === directionY) {
      // s += "\nNodes have the same position.";
      return; // TODO
    }

    var overlap = nodesOverlap(node1, node2, directionX, directionY);
    
    if (overlap > 0) {
      // s += "\nNodes DO overlap.";
      // s += "\nOverlap: " + overlap;
      // If nodes overlap, repulsion force is proportional 
      // to the overlap
      var force    = options.nodeOverlap * overlap;

      // Compute the module and components of the force vector
      var distance = Math.sqrt(directionX * directionX + directionY * directionY);
      // s += "\nDistance: " + distance;
      var forceX   = force * directionX / distance;
      var forceY   = force * directionY / distance;

    } else {
      // s += "\nNodes do NOT overlap.";
      // If there's no overlap, force is inversely proportional 
      // to squared distance

      // Get clipping points for both nodes
      var point1 = findClippingPoint(node1, directionX, directionY);
      var point2 = findClippingPoint(node2, -1 * directionX, -1 * directionY);

      // Use clipping points to compute distance
      var distanceX   = point2.x - point1.x;
      var distanceY   = point2.y - point1.y;
      var distanceSqr = distanceX * distanceX + distanceY * distanceY;
      var distance    = Math.sqrt(distanceSqr);
      // s += "\nDistance: " + distance;

      // Compute the module and components of the force vector
      var force  = options.nodeRepulsion / distanceSqr;
      var forceX = force * distanceX / distance;
      var forceY = force * distanceY / distance;
    }

    // Apply force
    node1.offsetX -= forceX;
    node1.offsetY -= forceY;
    node2.offsetX += forceX;
    node2.offsetY += forceY;

    // s += "\nForceX: " + forceX + " ForceY: " + forceY;
    // logDebug(s);

    return;
  };


  /**
   * @brief : Finds the point in which an edge (direction dX, dY) intersects 
   *          the rectangular bounding box of it's source/target node 
   */
  var findClippingPoint = function(node, dX, dY) {

    // Shorcuts
    var X = node.positionX;
    var Y = node.positionY;
    var H = node.height;
    var W = node.width;
    var dirSlope     = dY / dX;
    var nodeSlope    = H / W;

    // var s = 'Computing clipping point of node ' + node.id + 
    //   " . Height:  " + H + ", Width: " + W + 
    //   "\nDirection " + dX + ", " + dY; 
    // 
    // Compute intersection
    var res = {};
    do {
      // Case: Vertical direction (up)
      if (0 === dX && 0 < dY) {
        res.x = X;
        // s += "\nUp direction";
        res.y = Y + H / 2;
        break;
      }

      // Case: Vertical direction (down)
      if (0 === dX && 0 > dY) {
        res.x = X;
        res.y = Y + H / 2;
        // s += "\nDown direction";
        break;
      }      

      // Case: Intersects the right border
      if (0 < dX && 
      -1 * nodeSlope <= dirSlope && 
      dirSlope <= nodeSlope) {
        res.x = X + W / 2;
        res.y = Y + (W * dY / 2 / dX);
        // s += "\nRightborder";
        break;
      }

      // Case: Intersects the left border
      if (0 > dX && 
      -1 * nodeSlope <= dirSlope && 
      dirSlope <= nodeSlope) {
        res.x = X - W / 2;
        res.y = Y - (W * dY / 2 / dX);
        // s += "\nLeftborder";
        break;
      }

      // Case: Intersects the top border
      if (0 < dY && 
      ( dirSlope <= -1 * nodeSlope ||
        dirSlope >= nodeSlope )) {
        res.x = X + (H * dX / 2 / dY);
        res.y = Y + H / 2;
        // s += "\nTop border";
        break;
      }

      // Case: Intersects the bottom border
      if (0 > dY && 
      ( dirSlope <= -1 * nodeSlope ||
        dirSlope >= nodeSlope )) {
        res.x = X - (H * dX / 2 / dY);
        res.y = Y - H / 2;
        // s += "\nBottom border";
        break;
      }

    } while (false);

    // s += "\nClipping point found at " + res.x + ", " + res.y;
    // logDebug(s);
    return res;
  };


  /**
   * @brief  : Determines whether two nodes overlap or not
   * @return : Amount of overlapping (0 => no overlap)
   */
  var nodesOverlap = function(node1, node2, dX, dY) {

    if (dX > 0) {
      var overlapX = node1.maxX - node2.minX;
    } else {
      var overlapX = node2.maxX - node1.minX;
    }

    if (dY > 0) {
      var overlapY = node1.maxY - node2.minY;
    } else {
      var overlapY = node2.maxY - node1.minY;
    }

    if (overlapX >= 0 && overlapY >= 0) {
      return Math.sqrt(overlapX * overlapX + overlapY * overlapY);
    } else {
      return 0;
    }
  };
    
  
  /**
   * @brief : Calculates all edge forces
   */
  var calculateEdgeForces = function(layoutInfo, cy, options) {
    // Iterate over all edges
    for (var i = 0; i < layoutInfo.edgeSize; i++) {
      // Get edge, source & target nodes
      var edge     = layoutInfo.layoutEdges[i];
      var sourceIx = layoutInfo.idToIndex[edge.sourceId];
      var source   = layoutInfo.layoutNodes[sourceIx];
      var targetIx = layoutInfo.idToIndex[edge.targetId];
      var target   = layoutInfo.layoutNodes[targetIx];

      // Get direction of line connecting both node centers
      var directionX = target.positionX - source.positionX;
      var directionY = target.positionY - source.positionY;
      
      // If both centers are the same, do nothing.
      // A random force has already been applied as node repulsion
      if (0 === directionX && 0 === directionY) {
      return;
      }

      // Get clipping points for both nodes
      var point1 = findClippingPoint(source, directionX, directionY);
      var point2 = findClippingPoint(target, -1 * directionX, -1 * directionY);


      var lx = point2.x - point1.x;
      var ly = point2.y - point1.y;
      var l  = Math.sqrt(lx * lx + ly * ly);

      var force  = Math.pow(edge.idealLength - l, 2) / options.edgeElasticity; 

      if (0 !== l) {
        var forceX = force * lx / l;
        var forceY = force * ly / l;
      } else {
        var forceX = 0;
        var forceY = 0;
      }

      // Add this force to target and source nodes
      source.offsetX += forceX;
      source.offsetY += forceY;
      target.offsetX -= forceX;
      target.offsetY -= forceY;

      // var s = 'Edge force between nodes ' + source.id + ' and ' + target.id;
      // s += "\nDistance: " + l + " Force: (" + forceX + ", " + forceY + ")";
      // logDebug(s);
    }
  };


  /**
   * @brief : Computes gravity forces for all nodes
   */
  var calculateGravityForces = function(layoutInfo, cy, options) {
    // var s = 'calculateGravityForces';
    // logDebug(s);
    for (var i = 0; i < layoutInfo.graphSet.length; i ++) {
      var graph    = layoutInfo.graphSet[i];
      var numNodes = graph.length;

      // s = "Set: " + graph.toString();
      // logDebug(s);
          
      // Compute graph center
      if (0 === i) {
        var centerX   = layoutInfo.clientHeight / 2;
        var centerY   = layoutInfo.clientWidth  / 2;    
      } else {
        // Get Parent node for this graph, and use its position as center
        var temp    = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[0]]];
        var parent  = layoutInfo.layoutNodes[layoutInfo.idToIndex[temp.parentId]];
        var centerX = parent.positionX;
        var centerY = parent.positionY;
      }
      // s = "Center found at: " + centerX + ", " + centerY;
      // logDebug(s);

      // Apply force to all nodes in graph
      for (var j = 0; j < numNodes; j++) {
        var node = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];
        // s = "Node: " + node.id;
        var dx = centerX - node.positionX;
        var dy = centerY - node.positionY;
        var d  = Math.sqrt(dx * dx + dy * dy);
        if (d > 1.0) { // TODO: Use global variable for distance threshold
          var fx = options.gravity * dx / d;
          var fy = options.gravity * dy / d;
          node.offsetX += fx;
          node.offsetY += fy;
          // s += ": Applied force: " + fx + ", " + fy;
        } else {
          // s += ": skypped since it's too close to center";
        }
        // logDebug(s);
      }
    }
  };


  /**
   * @brief          : This function propagates the existing offsets from 
   *                   parent nodes to its descendents.
   * @arg layoutInfo : layoutInfo Object
   * @arg cy         : cytoscape Object
   * @arg options    : Layout options
   */
  var propagateForces = function(layoutInfo, cy, options) {  
    // Inline implementation of a queue, used for traversing the graph in BFS order
    var queue = [];
    var start = 0;   // Points to the start the queue
    var end   = -1;  // Points to the end of the queue

    // logDebug('propagateForces');

    // Start by visiting the nodes in the root graph
    queue.push.apply(queue, layoutInfo.graphSet[0]);
    end += layoutInfo.graphSet[0].length;

    // Traverse the graph, level by level, 
    while (start <= end) {
      // Get the node to visit and remove it from queue
      var nodeId    = queue[start++];
      var nodeIndex = layoutInfo.idToIndex[nodeId];
      var node      = layoutInfo.layoutNodes[nodeIndex];
      var children  = node.children;

      // We only need to process the node if it's compound
      if (0 < children.length) {    
      var offX = node.offsetX;
      var offY = node.offsetY;

      // var s = "Propagating offset from parent node : " + node.id + 
      //   ". OffsetX: " + offX + ". OffsetY: " + offY;
      // s += "\n Children: " + children.toString();
      // logDebug(s);
      
      for (var i = 0; i < children.length; i++) {
        var childNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[children[i]]];
        // Propagate offset
        childNode.offsetX += offX;
        childNode.offsetY += offY;
        // Add children to queue to be visited
        queue[++end] = children[i];
      }
      
      // Reset parent offsets
      node.offsetX = 0;
      node.offsetY = 0;
      }
      
    }
  };


  /**
   * @brief : Updates the layout model positions, based on 
   *          the accumulated forces
   */
  var updatePositions = function(layoutInfo, cy, options) {
    // var s = 'Updating positions';
    // logDebug(s);

    // Reset boundaries for compound nodes
    for (var i = 0; i < layoutInfo.nodeSize; i++) {
      var n = layoutInfo.layoutNodes[i];
      if (0 < n.children.length) {
        // logDebug("Resetting boundaries of compound node: " + n.id);
        n.maxX = undefined;
        n.minX = undefined;
        n.maxY = undefined;
        n.minY = undefined;
      }
    }

    for (var i = 0; i < layoutInfo.nodeSize; i++) {
      var n = layoutInfo.layoutNodes[i];
      if (0 < n.children.length) {
        // No need to set compound node position
        // logDebug("Skipping position update of node: " + n.id);
        continue;
      }
      // s = "Node: " + n.id + " Previous position: (" + 
      // n.positionX + ", " + n.positionY + ")."; 

      // Limit displacement in order to improve stability
      var tempForce = limitForce(n.offsetX, n.offsetY, layoutInfo.temperature);
      n.positionX += tempForce.x; 
      n.positionY += tempForce.y;
      n.offsetX = 0;
      n.offsetY = 0;
      n.minX    = n.positionX - n.width; 
      n.maxX    = n.positionX + n.width; 
      n.minY    = n.positionY - n.height; 
      n.maxY    = n.positionY + n.height; 
      // s += " New Position: (" + n.positionX + ", " + n.positionY + ").";
      // logDebug(s);

      // Update ancestry boudaries
      updateAncestryBoundaries(n, layoutInfo);
    }

    // Update size, position of compund nodes
    for (var i = 0; i < layoutInfo.nodeSize; i++) {
      var n = layoutInfo.layoutNodes[i];
      if (0 < n.children.length) {
        n.positionX = (n.maxX + n.minX) / 2;
        n.positionY = (n.maxY + n.minY) / 2;
        n.width     = n.maxX - n.minX;
        n.height    = n.maxY - n.minY;
        // s = "Updating position, size of compound node " + n.id;
        // s += "\nPositionX: " + n.positionX + ", PositionY: " + n.positionY;
        // s += "\nWidth: " + n.width + ", Height: " + n.height;
        // logDebug(s);
      }
    }  
  };


  /**
   * @brief : Limits a force (forceX, forceY) to be not 
   *          greater (in modulo) than max. 
   8          Preserves force direction. 
   */
  var limitForce = function(forceX, forceY, max) {
    // var s = "Limiting force: (" + forceX + ", " + forceY + "). Max: " + max;
    var force = Math.sqrt(forceX * forceX + forceY * forceY);

    if (force > max) {
      var res = {
      x : max * forceX / force,
      y : max * forceY / force
      };      

    } else {
      var res = {
      x : forceX,
      y : forceY
      };
    }

    // s += ".\nResult: (" + res.x + ", " + res.y + ")";
    // logDebug(s);

    return res;
  };


  /**
   * @brief : Function used for keeping track of compound node 
   *          sizes, since they should bound all their subnodes.
   */
  var updateAncestryBoundaries = function(node, layoutInfo) {
    // var s = "Propagating new position/size of node " + node.id;
    var parentId = node.parentId;
    if (null == parentId) {
      // If there's no parent, we are done
      // s += ". No parent node.";
      // logDebug(s);
      return;
    }

    // Get Parent Node
    var p = layoutInfo.layoutNodes[layoutInfo.idToIndex[parentId]];
    var flag = false;

    // MaxX
    if (null == p.maxX || node.maxX + p.padRight > p.maxX) {
      p.maxX = node.maxX + p.padRight;
      flag = true;
      // s += "\nNew maxX for parent node " + p.id + ": " + p.maxX;
    }

    // MinX
    if (null == p.minX || node.minX - p.padLeft < p.minX) {
      p.minX = node.minX - p.padLeft;
      flag = true;
      // s += "\nNew minX for parent node " + p.id + ": " + p.minX;
    }

    // MaxY
    if (null == p.maxY || node.maxY + p.padBottom > p.maxY) {
      p.maxY = node.maxY + p.padBottom;
      flag = true;
      // s += "\nNew maxY for parent node " + p.id + ": " + p.maxY;
    }

    // MinY
    if (null == p.minY || node.minY - p.padTop < p.minY) {
      p.minY = node.minY - p.padTop;
      flag = true;
      // s += "\nNew minY for parent node " + p.id + ": " + p.minY;
    }

    // If updated boundaries, propagate changes upward
    if (flag) {
      // logDebug(s);
      return updateAncestryBoundaries(p, layoutInfo);
    } 

    // s += ". No changes in boundaries/position of parent node " + p.id;  
    // logDebug(s);
    return;
  };


  /**
   * @brief : Logs a debug message in JS console, if DEBUG is ON
   */
  // var logDebug = function(text) {
  //   if (DEBUG) {
  //     console.debug(text);
  //   }
  // };


  // register the layout
  $$('layout', 'cose', CoseLayout);

})(cytoscape);

;(function($$){ 'use strict';

  // default layout options
  var defaults = {
    // dagre algo options, uses default value on undefined
    nodeSep: undefined, // the separation between adjacent nodes in the same rank
    edgeSep: undefined, // the separation between adjacent edges in the same rank
    rankSep: undefined, // the separation between adjacent nodes in the same rank
    rankDir: undefined, // 'TB' for top to bottom flow, 'LR' for left to right
    minLen: function( edge ){ return 1; }, // number of ranks to keep between the source and target of the edge
    edgeWeight: function( edge ){ return 1; }, // higher weight edges are generally made shorter and straighter than lower weight edges
    
    // general layout options
    fit: true, // whether to fit to viewport
    padding: 30, // fit padding
    animate: false, // whether to transition the node positions
    animationDuration: 500, // duration of animation in ms if enabled
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    ready: function(){}, // on layoutready
    stop: function(){} // on layoutstop
  };

  // constructor
  // options : object containing layout options
  function DagreLayout( options ){
    this.options = $$.util.extend(true, {}, defaults, options); 
  }

  // runs the layout
  DagreLayout.prototype.run = function(){
    var options = this.options;
    var layout = this;

    $$.util.require('dagre', function(dagre){

      var cy = options.cy; // cy is automatically populated for us in the constructor
      var eles = options.eles;

      var getVal = function( ele, val ){
        return $$.is.fn(val) ? val.apply( ele, [ ele ] ) : val;
      };

      var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
        x1: 0, y1: 0, w: cy.width(), h: cy.height()
      } );

      var g = new dagre.graphlib.Graph({
        multigraph: true,
        compound: true
      });

      var gObj = {};
      var setGObj = function( name, val ){
        if( val != null ){
          gObj[ name ] = val;
        }
      };
      
      setGObj( 'nodesep', options.nodeSep );
      setGObj( 'edgesep', options.edgeSep );
      setGObj( 'ranksep', options.rankSep );
      setGObj( 'rankdir', options.rankDir );

      g.setGraph( gObj );

      g.setDefaultEdgeLabel(function() { return {}; });
      g.setDefaultNodeLabel(function() { return {}; });

      // add nodes to dagre
      var nodes = eles.nodes();
      for( var i = 0; i < nodes.length; i++ ){
        var node = nodes[i];

        g.setNode( node.id(), {
          width: node.width(),
          height: node.height(),
          name: node.id()
        } );

        // console.log( g.node(node.id()) );
      }

      // set compound parents
      for( var i = 0; i < nodes.length; i++ ){
        var node = nodes[i];

        if( node.isChild() ){
          g.setParent( node.id(), node.parent().id() );
        }
      }

      // add edges to dagre
      var edges = eles.edges().stdFilter(function( edge ){
        return !edge.source().isParent() && !edge.target().isParent(); // dagre can't handle edges on compound nodes
      });
      for( var i = 0; i < edges.length; i++ ){
        var edge = edges[i];

        g.setEdge( edge.source().id(), edge.target().id(), {
          minlen: getVal( edge, options.minLen ),
          weight: getVal( edge, options.edgeWeight ),
          name: edge.id()
        }, edge.id() );

        // console.log( g.edge(edge.source().id(), edge.target().id(), edge.id()) );
      }

      dagre.layout( g );

      var gNodeIds = g.nodes();
      for( var i = 0; i < gNodeIds.length; i++ ){
        var id = gNodeIds[i];
        var n = g.node( id );

        cy.getElementById(id).scratch().dagre = n;
      }

      var dagreBB;

      if( options.boundingBox ){
        dagreBB = { x1: Infinity, x2: -Infinity, y1: Infinity, y2: -Infinity };
        nodes.forEach(function( node ){
          var dModel = node.scratch().dagre;

          dagreBB.x1 = Math.min( dagreBB.x1, dModel.x );
          dagreBB.x2 = Math.max( dagreBB.x2, dModel.x );

          dagreBB.y1 = Math.min( dagreBB.y1, dModel.y );
          dagreBB.y2 = Math.max( dagreBB.y2, dModel.y );
        });

        dagreBB.w = dagreBB.x2 - dagreBB.x1;
        dagreBB.h = dagreBB.y2 - dagreBB.y1;
      } else {
        dagreBB = bb;
      }

      var constrainPos = function( p ){
        if( options.boundingBox ){
          var xPct = (p.x - dagreBB.x1) / dagreBB.w;
          var yPct = (p.y - dagreBB.y1) / dagreBB.h;

          return {
            x: bb.x1 + xPct * bb.w,
            y: bb.y1 + yPct * bb.h
          };
        } else {
          return p;
        }
      };

      nodes.layoutPositions(layout, options, function(){
        var dModel = this.scratch().dagre;

        return constrainPos({
          x: dModel.x,
          y: dModel.y
        });
      });

    }); // require

    return this; // chaining
  };

  // register the layout
  $$('layout', 'dagre', DagreLayout);

})(cytoscape);

;(function($$){ 'use strict';
  
  var defaults = {
    fit: true, // whether to fit the viewport to the graph
    padding: 30, // padding used on fit
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
    rows: undefined, // force num of rows in the grid
    columns: undefined, // force num of cols in the grid
    position: function( node ){}, // returns { row, col } for element
    sort: undefined, // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
    animate: false, // whether to transition the node positions
    animationDuration: 500, // duration of animation in ms if enabled
    ready: undefined, // callback on layoutready
    stop: undefined // callback on layoutstop
  };
  
  function GridLayout( options ){
    this.options = $$.util.extend({}, defaults, options);
  }
  
  GridLayout.prototype.run = function(){
    var params = this.options;
    var options = params;
    
    var cy = params.cy;
    var eles = options.eles;
    var nodes = eles.nodes().not(':parent');

    if( options.sort ){
      nodes = nodes.sort( options.sort );
    }
    
    var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
      x1: 0, y1: 0, w: cy.width(), h: cy.height()
    } );

    if( bb.h === 0 || bb.w === 0){
      nodes.layoutPositions(this, options, function(){
        return { x: bb.x1, y: bb.y1 };
      });
      
    } else {
      
      // width/height * splits^2 = cells where splits is number of times to split width
      var cells = nodes.size();
      var splits = Math.sqrt( cells * bb.h/bb.w );
      var rows = Math.round( splits );
      var cols = Math.round( bb.w/bb.h * splits );

      var small = function(val){
        if( val == null ){
          return Math.min(rows, cols);
        } else {
          var min = Math.min(rows, cols);
          if( min == rows ){
            rows = val;
          } else {
            cols = val;
          }
        }
      };
      
      var large = function(val){
        if( val == null ){
          return Math.max(rows, cols);
        } else {
          var max = Math.max(rows, cols);
          if( max == rows ){
            rows = val;
          } else {
            cols = val;
          }
        }
      };
      
      // if rows or columns were set in options, use those values
      if( options.rows != null && options.columns != null ){
        rows = options.rows;
        cols = options.columns;
      } else if( options.rows != null && options.columns == null ){
        rows = options.rows;
        cols = Math.ceil( cells / rows );
      } else if( options.rows == null && options.columns != null ){
        cols = options.columns;
        rows = Math.ceil( cells / cols );
      }
      
      // otherwise use the automatic values and adjust accordingly
      
      // if rounding was up, see if we can reduce rows or columns
      else if( cols * rows > cells ){
        var sm = small();
        var lg = large();
        
        // reducing the small side takes away the most cells, so try it first
        if( (sm - 1) * lg >= cells ){
          small(sm - 1);
        } else if( (lg - 1) * sm >= cells ){
          large(lg - 1);
        } 
      } else {
        
        // if rounding was too low, add rows or columns
        while( cols * rows < cells ){
          var sm = small();
          var lg = large();
          
          // try to add to larger side first (adds less in multiplication)
          if( (lg + 1) * sm >= cells ){
            large(lg + 1);
          } else {
            small(sm + 1);
          }
        }
      }
      
      var cellWidth = bb.w / cols;
      var cellHeight = bb.h / rows;

      if( options.avoidOverlap ){
        for( var i = 0; i < nodes.length; i++ ){
          var node = nodes[i];
          var w = node.outerWidth();
          var h = node.outerHeight();

          cellWidth = Math.max( cellWidth, w );
          cellHeight = Math.max( cellHeight, h );
        }
      }
      
      var cellUsed = {}; // e.g. 'c-0-2' => true
      
      var used = function(row, col){
        return cellUsed['c-' + row + '-' + col] ? true : false;
      };
      
      var use = function(row, col){
        cellUsed['c-' + row + '-' + col] = true;
      };

      // to keep track of current cell position
      var row = 0;
      var col = 0;
      var moveToNextCell = function(){
        col++;
        if( col >= cols ){
          col = 0;
          row++;
        }
      };

      // get a cache of all the manual positions
      var id2manPos = {};
      for( var i = 0; i < nodes.length; i++ ){
        var node = nodes[i];
        var rcPos = options.position( node );

        if( rcPos && (rcPos.row !== undefined || rcPos.col !== undefined) ){ // must have at least row or col def'd
          var pos = {
            row: rcPos.row,
            col: rcPos.col
          };

          if( pos.col === undefined ){ // find unused col
            pos.col = 0;

            while( used(pos.row, pos.col) ){
              pos.col++;
            }
          } else if( pos.row === undefined ){ // find unused row
            pos.row = 0;

            while( used(pos.row, pos.col) ){
              pos.row++;
            }
          }

          id2manPos[ node.id() ] = pos;
          use( pos.row, pos.col );
        }
      }

      var getPos = function(i, element){
        var x, y;

        if( element.locked() || element.isFullAutoParent() ){
          return false;
        }

        // see if we have a manual position set
        var rcPos = id2manPos[ element.id() ];
        if( rcPos ){
          x = rcPos.col * cellWidth + cellWidth/2 + bb.x1;
          y = rcPos.row * cellHeight + cellHeight/2 + bb.y1;
        
        } else { // otherwise set automatically
        
          while( used(row, col) ){
            moveToNextCell();
          }

          x = col * cellWidth + cellWidth/2 + bb.x1;
          y = row * cellHeight + cellHeight/2 + bb.y1;
          use( row, col );
          
          moveToNextCell();
        }
        
        return { x: x, y: y };
        
      };

      nodes.layoutPositions( this, options, getPos );
    }

    return this; // chaining
    
  };
  
  $$('layout', 'grid', GridLayout);
  
})( cytoscape );

;(function($$){ 'use strict';

  // default layout options
  var defaults = {
    ready: function(){}, // on layoutready
    stop: function(){} // on layoutstop
  };

  // constructor
  // options : object containing layout options
  function NullLayout( options ){
    this.options = $$.util.extend(true, {}, defaults, options); 
  }

  // runs the layout
  NullLayout.prototype.run = function(){
    var options = this.options;
    var eles = options.eles; // elements to consider in the layout
    var layout = this;

    // cy is automatically populated for us in the constructor
    var cy = options.cy; // jshint ignore:line

    layout.trigger('layoutstart');

    // puts all nodes at (0, 0)
    eles.nodes().positions(function(){
      return {
        x: 0,
        y: 0
      };
    });

    // trigger layoutready when each node has had its position set at least once
    layout.one('layoutready', options.ready);
    layout.trigger('layoutready');

    // trigger layoutstop when the layout stops (e.g. finishes)
    layout.one('layoutstop', options.stop);
    layout.trigger('layoutstop');

    return this; // chaining
  };

  // called on continuous layouts to stop them before they finish
  NullLayout.prototype.stop = function(){
    return this; // chaining
  };

  // register the layout
  $$('layout', 'null', NullLayout);

})(cytoscape);
;(function($$){ 'use strict';
  
  var defaults = {
    positions: undefined, // map of (node id) => (position obj); or function(node){ return somPos; }
    zoom: undefined, // the zoom level to set (prob want fit = false if set)
    pan: undefined, // the pan level to set (prob want fit = false if set)
    fit: true, // whether to fit to viewport
    padding: 30, // padding on fit
    animate: false, // whether to transition the node positions
    animationDuration: 500, // duration of animation in ms if enabled
    ready: undefined, // callback on layoutready
    stop: undefined // callback on layoutstop
  };
  
  function PresetLayout( options ){
    this.options = $$.util.extend(true, {}, defaults, options);
  }
  
  PresetLayout.prototype.run = function(){
    var options = this.options;
    var eles = options.eles;

    var nodes = eles.nodes();
    var posIsFn = $$.is.fn( options.positions );

    function getPosition(node){
      if( options.positions == null ){
        return null;
      }

      if( posIsFn ){
        return options.positions.apply( node, [ node ] );
      }
      
      var pos = options.positions[node._private.data.id];

      if( pos == null ){
        return null;
      }
      
      return pos;
    }
    
    nodes.layoutPositions(this, options, function(i, node){
      var position = getPosition(node);
      
      if( node.locked() || position == null ){
        return false;
      }
      
      return position;
    });
        
    return this; // chaining
  };
  
  $$('layout', 'preset', PresetLayout);
  
})(cytoscape);

;(function($$){ 'use strict';
  
  var defaults = {
    fit: true, // whether to fit to viewport
    padding: 30, // fit padding
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    animate: false, // whether to transition the node positions
    animationDuration: 500, // duration of animation in ms if enabled
    ready: undefined, // callback on layoutready
    stop: undefined // callback on layoutstop
  };
  
  function RandomLayout( options ){
    this.options = $$.util.extend(true, {}, defaults, options);
  }
  
  RandomLayout.prototype.run = function(){
    var options = this.options;
    var cy = options.cy;
    var eles = options.eles;
    var nodes = eles.nodes().not(':parent');
    
    var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
      x1: 0, y1: 0, w: cy.width(), h: cy.height()
    } );

    var getPos = function( i, node ){
      return {
        x: bb.x1 + Math.round( Math.random() * bb.w ),
        y: bb.y1 + Math.round( Math.random() * bb.h )
      };
    };

    nodes.layoutPositions( this, options, getPos );

    return this; // chaining
  };
  
  // register the layout
  $$(
    'layout', // we're registering a layout
    'random', // the layout name
    RandomLayout // the layout prototype
  );
  
})(cytoscape);

;( function( $$ ){ 'use strict';

  /*
   * This layout combines several algorithms:
   *
   * - It generates an initial position of the nodes by using the
   *   Fruchterman-Reingold algorithm (doi:10.1002/spe.4380211102)
   *
   * - Finally it eliminates overlaps by using the method described by
   *   Gansner and North (doi:10.1007/3-540-37623-2_28)
   */

  var defaults = {
    animate: true, // whether to show the layout as it's running
    ready: undefined, // Callback on layoutready
    stop: undefined, // Callback on layoutstop
    fit: true, // Reset viewport to fit default simulationBounds
    minDist: 20, // Minimum distance between nodes
    padding: 20, // Padding
    expandingFactor: -1.0, // If the network does not satisfy the minDist
    // criterium then it expands the network of this amount
    // If it is set to -1.0 the amount of expansion is automatically
    // calculated based on the minDist, the aspect ratio and the
    // number of nodes
    maxFruchtermanReingoldIterations: 50, // Maximum number of initial force-directed iterations
    maxExpandIterations: 4, // Maximum number of expanding iterations
    boundingBox: undefined // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  };

  function SpreadLayout( options ) {
    this.options = $$.util.extend( {}, defaults, options );
  }

  function cellCentroid( cell ) {
    var hes = cell.halfedges;
    var area = 0,
      x = 0,
      y = 0;
    var p1, p2, f;

    for( var i = 0; i < hes.length; ++i ) {
      p1 = hes[ i ].getEndpoint();
      p2 = hes[ i ].getStartpoint();

      area += p1.x * p2.y;
      area -= p1.y * p2.x;

      f = p1.x * p2.y - p2.x * p1.y;
      x += ( p1.x + p2.x ) * f;
      y += ( p1.y + p2.y ) * f;
    }

    area /= 2;
    f = area * 6;
    return {
      x: x / f,
      y: y / f
    };
  }

  function sitesDistance( ls, rs ) {
    var dx = ls.x - rs.x;
    var dy = ls.y - rs.y;
    return Math.sqrt( dx * dx + dy * dy );
  }

  SpreadLayout.prototype.run = function() {

    var layout = this;
    // var self = this;
    var options = this.options;

    $$.util.requires(['foograph', 'Voronoi'], function(foograph, Voronoi){

      var cy = options.cy;
      // var allNodes = cy.nodes();
      var nodes = cy.nodes();
      //var allEdges = cy.edges();
      var edges = cy.edges();
      var cWidth = cy.width();
      var cHeight = cy.height();
      var simulationBounds = options.boundingBox ? $$.util.makeBoundingBox( options.boundingBox ) : null;
      var padding = options.padding;
      var simBBFactor = Math.max( 1, Math.log(nodes.length) * 0.8 );
      
      if( nodes.length < 100 ){
        simBBFactor /= 2;
      }

      layout.trigger( {
        type: 'layoutstart',
        layout: layout
      } );

      var simBB = {
        x1: 0,
        y1: 0,
        x2: cWidth * simBBFactor,
        y2: cHeight * simBBFactor
      };

      if( simulationBounds ) {
        simBB.x1 = simulationBounds.x1;
        simBB.y1 = simulationBounds.y1;
        simBB.x2 = simulationBounds.x2;
        simBB.y2 = simulationBounds.y2;
      }

      simBB.x1 += padding;
      simBB.y1 += padding;
      simBB.x2 -= padding;
      simBB.y2 -= padding;

      var width = simBB.x2 - simBB.x1;
      var height = simBB.y2 - simBB.y1;

      // Get start time
      var startTime = Date.now();

      // layout doesn't work with just 1 node
      if( nodes.size() <= 1 ) {
        nodes.positions( {
          x: Math.round( ( simBB.x1 + simBB.x2 ) / 2 ),
          y: Math.round( ( simBB.y1 + simBB.y2 ) / 2 )
        } );

        if( options.fit ) {
          cy.fit( options.padding );
        }

        // Get end time
        var endTime = Date.now();
        console.info( "Layout on " + nodes.size() + " nodes took " + ( endTime - startTime ) + " ms" );

        layout.one( "layoutready", options.ready );
        layout.trigger( "layoutready" );

        layout.one( "layoutstop", options.stop );
        layout.trigger( "layoutstop" );

        return;
      }

      // First I need to create the data structure to pass to the worker
      var pData = {
        'width': width,
        'height': height,
        'minDist': options.minDist,
        'expFact': options.expandingFactor,
        'expIt': 0,
        'maxExpIt': options.maxExpandIterations,
        'vertices': [],
        'edges': [],
        'startTime': startTime,
        'maxFruchtermanReingoldIterations': options.maxFruchtermanReingoldIterations
      };

      nodes.each(
        function( i, node ) {
          var nodeId = this._private.data.id;
          pData[ 'vertices' ].push( {
            id: nodeId,
            x: 0,
            y: 0
          } );
        } );

      edges.each(
        function() {
          var srcNodeId = this.source().id();
          var tgtNodeId = this.target().id();
          pData[ 'edges' ].push( {
            src: srcNodeId,
            tgt: tgtNodeId
          } );
        } );

      //Decleration
      var t1 = $$.Thread();
      // And to add the required scripts
      //EXTERNAL 1
      t1.require( foograph, 'foograph' );
      //EXTERNAL 2
      t1.require( Voronoi );

      //Local function
      t1.require( sitesDistance );
      t1.require( cellCentroid );

      function setPositions( pData ){ //console.log('set posns')
        // First we retrieve the important data
        // var expandIteration = pData[ 'expIt' ];
        var dataVertices = pData[ 'vertices' ];
        var vertices = [];
        for( var i = 0; i < dataVertices.length; ++i ) {
          var dv = dataVertices[ i ];
          vertices[ dv.id ] = {
            x: dv.x,
            y: dv.y
          };
        }
        /*
         * FINALLY:
         *
         * We position the nodes based on the calculation
         */
        nodes.positions(
          function( i, node ) {
            var id = node._private.data.id;
            // var pos = node._private.position;
            var vertex = vertices[ id ];

            return {
              x: Math.round( simBB.x1 + vertex.x ),
              y: Math.round( simBB.y1 + vertex.y )
            };
          } );

        if( options.fit ) {
          cy.fit( options.padding );
        }

        cy.nodes().rtrigger( "position" );
      }

      var didLayoutReady = false;
      t1.on('message', function(e){
        var pData = e.message; //console.log('message', e)

        if( !options.animate ){
          return;
        }

        setPositions( pData );

        if( !didLayoutReady ){
          layout.trigger( "layoutready" );

          didLayoutReady = true;
        }
      });

      layout.one( "layoutready", options.ready );

      t1.pass( pData ).run( function( pData ) {
        
        foograph = eval('foograph');
        Voronoi = eval('Voronoi');
        
        // I need to retrieve the important data
        var lWidth = pData[ 'width' ];
        var lHeight = pData[ 'height' ];
        var lMinDist = pData[ 'minDist' ];
        var lExpFact = pData[ 'expFact' ];
        var lMaxExpIt = pData[ 'maxExpIt' ];
        var lMaxFruchtermanReingoldIterations = pData[ 'maxFruchtermanReingoldIterations' ];

        // Prepare the data to output
        var savePositions = function(){
          pData[ 'width' ] = lWidth;
          pData[ 'height' ] = lHeight;
          pData[ 'expIt' ] = expandIteration;
          pData[ 'expFact' ] = lExpFact;

          pData[ 'vertices' ] = [];
          for( var i = 0; i < fv.length; ++i ) {
            pData[ 'vertices' ].push( {
              id: fv[ i ].label,
              x: fv[ i ].x,
              y: fv[ i ].y
            } );
          }
        };

        var messagePositions = function(){
          broadcast( pData );
        };

        /*
         * FIRST STEP: Application of the Fruchterman-Reingold algorithm
         *
         * We use the version implemented by the foograph library
         *
         * Ref.: https://code.google.com/p/foograph/
         */

        // We need to create an instance of a graph compatible with the library
        var frg = new foograph.Graph( "FRgraph", false );

        var frgNodes = {};

        // Then we have to add the vertices
        var dataVertices = pData[ 'vertices' ];
        for( var ni = 0; ni < dataVertices.length; ++ni ) {
          var id = dataVertices[ ni ][ 'id' ];
          var v = new foograph.Vertex( id, Math.round( Math.random() * lHeight ), Math.round( Math.random() * lHeight ) );
          frgNodes[ id ] = v;
          frg.insertVertex( v );
        }

        var dataEdges = pData[ 'edges' ];
        for( var ei = 0; ei < dataEdges.length; ++ei ) {
          var srcNodeId = dataEdges[ ei ][ 'src' ];
          var tgtNodeId = dataEdges[ ei ][ 'tgt' ];
          frg.insertEdge( "", 1, frgNodes[ srcNodeId ], frgNodes[ tgtNodeId ] );
        }

        var fv = frg.vertices;

        // Then we apply the layout
        var iterations = lMaxFruchtermanReingoldIterations;
        var frLayoutManager = new foograph.ForceDirectedVertexLayout( lWidth, lHeight, iterations, false, lMinDist );

        frLayoutManager.callback = function(){
          savePositions();
          messagePositions();
        };

        frLayoutManager.layout( frg );

        savePositions();
        messagePositions();

        /*
         * SECOND STEP: Tiding up of the graph.
         *
         * We use the method described by Gansner and North, based on Voronoi
         * diagrams.
         *
         * Ref: doi:10.1007/3-540-37623-2_28
         */

        // We calculate the Voronoi diagram dor the position of the nodes
        var voronoi = new Voronoi();
        var bbox = {
          xl: 0,
          xr: lWidth,
          yt: 0,
          yb: lHeight
        };
        var vSites = [];
        for( var i = 0; i < fv.length; ++i ) {
          vSites[ fv[ i ].label ] = fv[ i ];
        }

        function checkMinDist( ee ) {
          var infractions = 0;
          // Then we check if the minimum distance is satisfied
          for( var eei = 0; eei < ee.length; ++eei ) {
            var e = ee[ eei ];
            if( ( e.lSite != null ) && ( e.rSite != null ) && sitesDistance( e.lSite, e.rSite ) < lMinDist ) {
              ++infractions;
            }
          }
          return infractions;
        }

        var diagram = voronoi.compute( fv, bbox );

        // Then we reposition the nodes at the centroid of their Voronoi cells
        var cells = diagram.cells;
        for( var i = 0; i < cells.length; ++i ) {
          var cell = cells[ i ];
          var site = cell.site;
          var centroid = cellCentroid( cell );
          var currv = vSites[ site.label ];
          currv.x = centroid.x;
          currv.y = centroid.y;
        }

        if( lExpFact < 0.0 ) {
          // Calculates the expanding factor
          lExpFact = Math.max( 0.05, Math.min( 0.10, lMinDist / Math.sqrt( ( lWidth * lHeight ) / fv.length ) * 0.5 ) );
          //console.info("Expanding factor is " + (options.expandingFactor * 100.0) + "%");
        }

        var prevInfractions = checkMinDist( diagram.edges );
        //console.info("Initial infractions " + prevInfractions);

        var bStop = ( prevInfractions <= 0 );

        var voronoiIteration = 0;
        var expandIteration = 0;

        // var initWidth = lWidth;

        while( !bStop ) {
          ++voronoiIteration;
          for( var it = 0; it <= 4; ++it ) {
            voronoi.recycle( diagram );
            diagram = voronoi.compute( fv, bbox );

            // Then we reposition the nodes at the centroid of their Voronoi cells
            cells = diagram.cells;
            for( var i = 0; i < cells.length; ++i ) {
              var cell = cells[ i ];
              var site = cell.site;
              var centroid = cellCentroid( cell );
              var currv = vSites[ site.label ];
              currv.x = centroid.x;
              currv.y = centroid.y;
            }
          }

          var currInfractions = checkMinDist( diagram.edges );
          //console.info("Current infractions " + currInfractions);

          if( currInfractions <= 0 ) {
            bStop = true;
          } else {
            if( currInfractions >= prevInfractions || voronoiIteration >= 4 ) {
              if( expandIteration >= lMaxExpIt ) {
                bStop = true;
              } else {
                lWidth += lWidth * lExpFact;
                lHeight += lHeight * lExpFact;
                bbox = {
                  xl: 0,
                  xr: lWidth,
                  yt: 0,
                  yb: lHeight
                };
                ++expandIteration;
                voronoiIteration = 0;
                //console.info("Expanded to ("+width+","+height+")");
              }
            }
          }
          prevInfractions = currInfractions;

          savePositions();
          messagePositions();
        }

        savePositions();
        return pData;

      } ).then( function( pData ) {
        // var expandIteration = pData[ 'expIt' ];
        var dataVertices = pData[ 'vertices' ];

        setPositions( pData );

        // Get end time
        var startTime = pData[ 'startTime' ];
        var endTime = new Date();
        console.info( "Layout on " + dataVertices.length + " nodes took " + ( endTime - startTime ) + " ms" );

        layout.one( "layoutstop", options.stop );

        if( !options.animate ){
          layout.trigger( "layoutready" );
        }

        layout.trigger( "layoutstop" );

        t1.stop();
      } );

    });

    return this;
  }; // run

  SpreadLayout.prototype.stop = function() {};

  $$( 'layout', 'spread', SpreadLayout );


} )( cytoscape );

;(function($$){ 'use strict';
  
  var defaults = {
    animate: true, // whether to show the layout as it's running
    maxSimulationTime: 4000, // max length in ms to run the layout
    ungrabifyWhileSimulating: false, // so you can't drag nodes during layout
    fit: true, // whether to fit the viewport to the graph
    padding: 30, // padding on fit
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    random: false, // whether to use random initial positions
    infinite: false, // overrides all other options for a forces-all-the-time mode
    ready: undefined, // callback on layoutready
    stop: undefined, // callback on layoutstop

    // springy forces
    stiffness: 400,
    repulsion: 400,
    damping: 0.5
  };

  function SpringyLayout( options ){
    this.options = $$.util.extend(true, {}, defaults, options);
  }
  
  SpringyLayout.prototype.run = function(){
    var layout = this;
    var self = this;
    var options = this.options;

    $$.util.require('Springy', function(Springy){

      var simUpdatingPos = false;

      var cy = options.cy;
      layout.trigger({ type: 'layoutstart', layout: layout });
      
      var eles = options.eles;
      var nodes = eles.nodes().not(':parent');
      var edges = eles.edges();
   
      var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
        x1: 0, y1: 0, w: cy.width(), h: cy.height()
      } );
      
      // make a new graph
      var graph = new Springy.Graph();

      // make some nodes
      nodes.each(function(i, node){
        node.scratch('springy', {
          model: graph.newNode({
            element: node
          })
        });
      });

      // connect them with edges
      edges.each(function(i, edge){
        var fdSrc = edge.source().scratch('springy').model;
        var fdTgt = edge.target().scratch('springy').model;
        
        edge.scratch('springy', {
          model: graph.newEdge(fdSrc, fdTgt, {
            element: edge
          })
        });
      });
      
      var sim = window.sim = new Springy.Layout.ForceDirected(graph, options.stiffness, options.repulsion, options.damping);

      if( options.infinite ){
        sim.minEnergyThreshold = -Infinity;
      }

      var currentBB = sim.getBoundingBox();
      // var targetBB = {bottomleft: new Springy.Vector(-2, -2), topright: new Springy.Vector(2, 2)};
      
      // convert to/from screen coordinates
      var toScreen = function(p) {
        currentBB = sim.getBoundingBox();

        var size = currentBB.topright.subtract(currentBB.bottomleft);
        var sx = p.subtract(currentBB.bottomleft).divide(size.x).x * bb.w + bb.x1;
        var sy = p.subtract(currentBB.bottomleft).divide(size.y).y * bb.h + bb.x1;

        return new Springy.Vector(sx, sy);
      };

      var fromScreen = function(s) {
        currentBB = sim.getBoundingBox();

        var size = currentBB.topright.subtract(currentBB.bottomleft);
        var px = ((s.x - bb.x1) / bb.w) * size.x + currentBB.bottomleft.x;
        var py = ((s.y - bb.y1) / bb.h) * size.y + currentBB.bottomleft.y;

        return new Springy.Vector(px, py);
      };
      
      var movedNodes = cy.collection();
      
      var numNodes = cy.nodes().size();
      var drawnNodes = 1;
      var fdRenderer = new Springy.Renderer(sim,
        function clear() {
          if( self.stopped ){ return; } // because springy is a buggy layout
          
          if( movedNodes.length > 0 && options.animate ){
            simUpdatingPos = true;

            movedNodes.rtrigger('position');

            if( options.fit ){
              cy.fit( options.padding );
            }

            movedNodes = cy.collection();

            simUpdatingPos = false;
          }
        },

        function drawEdge(edge, p1, p2) {
          // draw an edge
        },

        function drawNode(node, p) {
          if( self.stopped ){ return; } // because springy is a buggy layout

          var v = toScreen(p);
          var element = node.data.element;
          
          if( !element.locked() && !element.grabbed() ){
              element._private.position = {
                x: v.x,
                y: v.y
              };
              movedNodes.merge(element);
          } else {
            //setLayoutPositionForElement(element);
          }
          
          if( drawnNodes == numNodes ){
            layout.one('layoutready', options.ready);
            layout.trigger({ type: 'layoutready', layout: layout });
          } 
          
          drawnNodes++;
        
        }
      );
      
      // set initial node points
      nodes.each(function(i, ele){
        if( !options.random ){
          setLayoutPositionForElement(ele);
        }
      });
      
      // update node positions when dragging
      var dragHandler;
      nodes.on('position', dragHandler = function(){
        if( simUpdatingPos ){ return; }

        setLayoutPositionForElement(this);
      });
      
      function setLayoutPositionForElement(element){
        var fdId = element.scratch('springy').model.id;
        var fdP = fdRenderer.layout.nodePoints[fdId].p;
        var pos = element.position();
        var positionInFd = (pos.x != null && pos.y != null) ? fromScreen(element.position()) : {
          x: Math.random() * 4 - 2,
          y: Math.random() * 4 - 2
        };
        
        fdP.x = positionInFd.x;
        fdP.y = positionInFd.y;
      }
      
      var grabbableNodes = nodes.filter(":grabbable");
      
      function start(){
        self.stopped = false;

        // disable grabbing if so set
        if( options.ungrabifyWhileSimulating ){
          grabbableNodes.ungrabify();
        }
        
        fdRenderer.start();
      }
      
      self.stopSystem = function(){
        self.stopped = true;

        graph.filterNodes(function(){
          return false; // remove all nodes
        });
        
        if( options.ungrabifyWhileSimulating ){
          grabbableNodes.grabify();
        }

        if( options.fit ){
          cy.fit( options.padding );
        }
        
        nodes.off('drag position', dragHandler);

        layout.one('layoutstop', options.stop);
        layout.trigger({ type: 'layoutstop', layout: layout });

        self.stopSystem = null;
      };
      
      start();
      if( !options.infinite ){
        setTimeout(function(){
          self.stop();
        }, options.maxSimulationTime);
      }

    }); // require

    return this; // chaining
  };

  SpringyLayout.prototype.stop = function(){
    if( this.stopSystem != null ){
      this.stopSystem();
    }

    return this; // chaining
  };
  
  $$('layout', 'springy', SpringyLayout);

  
})(cytoscape);

;(function($$){ 'use strict';
    
  function NullRenderer(options){
    this.options = options;
  }
  
  NullRenderer.prototype.recalculateRenderedStyle = function(){
  };

  NullRenderer.prototype.notify = function(){
    // the null renderer does nothing
  };
  
  $$('renderer', 'null', NullRenderer);
  
})( cytoscape );

}).call(this,require('_process'),"/node_modules/cytoscape/dist")

},{"_process":11,"child_process":8,"os":9,"path":10}],13:[function(require,module,exports){
(function (process,global){
/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
 * @version   3.0.2
 */

(function() {
    "use strict";
    function lib$es6$promise$utils$$objectOrFunction(x) {
      return typeof x === 'function' || (typeof x === 'object' && x !== null);
    }

    function lib$es6$promise$utils$$isFunction(x) {
      return typeof x === 'function';
    }

    function lib$es6$promise$utils$$isMaybeThenable(x) {
      return typeof x === 'object' && x !== null;
    }

    var lib$es6$promise$utils$$_isArray;
    if (!Array.isArray) {
      lib$es6$promise$utils$$_isArray = function (x) {
        return Object.prototype.toString.call(x) === '[object Array]';
      };
    } else {
      lib$es6$promise$utils$$_isArray = Array.isArray;
    }

    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;
    var lib$es6$promise$asap$$len = 0;
    var lib$es6$promise$asap$$toString = {}.toString;
    var lib$es6$promise$asap$$vertxNext;
    var lib$es6$promise$asap$$customSchedulerFn;

    var lib$es6$promise$asap$$asap = function asap(callback, arg) {
      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;
      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;
      lib$es6$promise$asap$$len += 2;
      if (lib$es6$promise$asap$$len === 2) {
        // If len is 2, that means that we need to schedule an async flush.
        // If additional callbacks are queued before the queue is flushed, they
        // will be processed by this flush that we are scheduling.
        if (lib$es6$promise$asap$$customSchedulerFn) {
          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);
        } else {
          lib$es6$promise$asap$$scheduleFlush();
        }
      }
    }

    function lib$es6$promise$asap$$setScheduler(scheduleFn) {
      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;
    }

    function lib$es6$promise$asap$$setAsap(asapFn) {
      lib$es6$promise$asap$$asap = asapFn;
    }

    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;
    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};
    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;
    var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

    // test for web worker but not in IE10
    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&
      typeof importScripts !== 'undefined' &&
      typeof MessageChannel !== 'undefined';

    // node
    function lib$es6$promise$asap$$useNextTick() {
      // node version 0.10.x displays a deprecation warning when nextTick is used recursively
      // see https://github.com/cujojs/when/issues/410 for details
      return function() {
        process.nextTick(lib$es6$promise$asap$$flush);
      };
    }

    // vertx
    function lib$es6$promise$asap$$useVertxTimer() {
      return function() {
        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);
      };
    }

    function lib$es6$promise$asap$$useMutationObserver() {
      var iterations = 0;
      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);
      var node = document.createTextNode('');
      observer.observe(node, { characterData: true });

      return function() {
        node.data = (iterations = ++iterations % 2);
      };
    }

    // web worker
    function lib$es6$promise$asap$$useMessageChannel() {
      var channel = new MessageChannel();
      channel.port1.onmessage = lib$es6$promise$asap$$flush;
      return function () {
        channel.port2.postMessage(0);
      };
    }

    function lib$es6$promise$asap$$useSetTimeout() {
      return function() {
        setTimeout(lib$es6$promise$asap$$flush, 1);
      };
    }

    var lib$es6$promise$asap$$queue = new Array(1000);
    function lib$es6$promise$asap$$flush() {
      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {
        var callback = lib$es6$promise$asap$$queue[i];
        var arg = lib$es6$promise$asap$$queue[i+1];

        callback(arg);

        lib$es6$promise$asap$$queue[i] = undefined;
        lib$es6$promise$asap$$queue[i+1] = undefined;
      }

      lib$es6$promise$asap$$len = 0;
    }

    function lib$es6$promise$asap$$attemptVertx() {
      try {
        var r = require;
        var vertx = r('vertx');
        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
        return lib$es6$promise$asap$$useVertxTimer();
      } catch(e) {
        return lib$es6$promise$asap$$useSetTimeout();
      }
    }

    var lib$es6$promise$asap$$scheduleFlush;
    // Decide what async method to use to triggering processing of queued callbacks:
    if (lib$es6$promise$asap$$isNode) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();
    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();
    } else if (lib$es6$promise$asap$$isWorker) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();
    } else if (lib$es6$promise$asap$$browserWindow === undefined && typeof require === 'function') {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();
    } else {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();
    }

    function lib$es6$promise$$internal$$noop() {}

    var lib$es6$promise$$internal$$PENDING   = void 0;
    var lib$es6$promise$$internal$$FULFILLED = 1;
    var lib$es6$promise$$internal$$REJECTED  = 2;

    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();

    function lib$es6$promise$$internal$$selfFulfillment() {
      return new TypeError("You cannot resolve a promise with itself");
    }

    function lib$es6$promise$$internal$$cannotReturnOwn() {
      return new TypeError('A promises callback cannot return that same promise.');
    }

    function lib$es6$promise$$internal$$getThen(promise) {
      try {
        return promise.then;
      } catch(error) {
        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;
        return lib$es6$promise$$internal$$GET_THEN_ERROR;
      }
    }

    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
      try {
        then.call(value, fulfillmentHandler, rejectionHandler);
      } catch(e) {
        return e;
      }
    }

    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {
       lib$es6$promise$asap$$asap(function(promise) {
        var sealed = false;
        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {
          if (sealed) { return; }
          sealed = true;
          if (thenable !== value) {
            lib$es6$promise$$internal$$resolve(promise, value);
          } else {
            lib$es6$promise$$internal$$fulfill(promise, value);
          }
        }, function(reason) {
          if (sealed) { return; }
          sealed = true;

          lib$es6$promise$$internal$$reject(promise, reason);
        }, 'Settle: ' + (promise._label || ' unknown promise'));

        if (!sealed && error) {
          sealed = true;
          lib$es6$promise$$internal$$reject(promise, error);
        }
      }, promise);
    }

    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {
      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {
        lib$es6$promise$$internal$$fulfill(promise, thenable._result);
      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {
        lib$es6$promise$$internal$$reject(promise, thenable._result);
      } else {
        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {
          lib$es6$promise$$internal$$resolve(promise, value);
        }, function(reason) {
          lib$es6$promise$$internal$$reject(promise, reason);
        });
      }
    }

    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable) {
      if (maybeThenable.constructor === promise.constructor) {
        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);
      } else {
        var then = lib$es6$promise$$internal$$getThen(maybeThenable);

        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {
          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);
        } else if (then === undefined) {
          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
        } else if (lib$es6$promise$utils$$isFunction(then)) {
          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);
        } else {
          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
        }
      }
    }

    function lib$es6$promise$$internal$$resolve(promise, value) {
      if (promise === value) {
        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());
      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {
        lib$es6$promise$$internal$$handleMaybeThenable(promise, value);
      } else {
        lib$es6$promise$$internal$$fulfill(promise, value);
      }
    }

    function lib$es6$promise$$internal$$publishRejection(promise) {
      if (promise._onerror) {
        promise._onerror(promise._result);
      }

      lib$es6$promise$$internal$$publish(promise);
    }

    function lib$es6$promise$$internal$$fulfill(promise, value) {
      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }

      promise._result = value;
      promise._state = lib$es6$promise$$internal$$FULFILLED;

      if (promise._subscribers.length !== 0) {
        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);
      }
    }

    function lib$es6$promise$$internal$$reject(promise, reason) {
      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
      promise._state = lib$es6$promise$$internal$$REJECTED;
      promise._result = reason;

      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);
    }

    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
      var subscribers = parent._subscribers;
      var length = subscribers.length;

      parent._onerror = null;

      subscribers[length] = child;
      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;
      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;

      if (length === 0 && parent._state) {
        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);
      }
    }

    function lib$es6$promise$$internal$$publish(promise) {
      var subscribers = promise._subscribers;
      var settled = promise._state;

      if (subscribers.length === 0) { return; }

      var child, callback, detail = promise._result;

      for (var i = 0; i < subscribers.length; i += 3) {
        child = subscribers[i];
        callback = subscribers[i + settled];

        if (child) {
          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);
        } else {
          callback(detail);
        }
      }

      promise._subscribers.length = 0;
    }

    function lib$es6$promise$$internal$$ErrorObject() {
      this.error = null;
    }

    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();

    function lib$es6$promise$$internal$$tryCatch(callback, detail) {
      try {
        return callback(detail);
      } catch(e) {
        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;
        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;
      }
    }

    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {
      var hasCallback = lib$es6$promise$utils$$isFunction(callback),
          value, error, succeeded, failed;

      if (hasCallback) {
        value = lib$es6$promise$$internal$$tryCatch(callback, detail);

        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {
          failed = true;
          error = value.error;
          value = null;
        } else {
          succeeded = true;
        }

        if (promise === value) {
          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());
          return;
        }

      } else {
        value = detail;
        succeeded = true;
      }

      if (promise._state !== lib$es6$promise$$internal$$PENDING) {
        // noop
      } else if (hasCallback && succeeded) {
        lib$es6$promise$$internal$$resolve(promise, value);
      } else if (failed) {
        lib$es6$promise$$internal$$reject(promise, error);
      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {
        lib$es6$promise$$internal$$fulfill(promise, value);
      } else if (settled === lib$es6$promise$$internal$$REJECTED) {
        lib$es6$promise$$internal$$reject(promise, value);
      }
    }

    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {
      try {
        resolver(function resolvePromise(value){
          lib$es6$promise$$internal$$resolve(promise, value);
        }, function rejectPromise(reason) {
          lib$es6$promise$$internal$$reject(promise, reason);
        });
      } catch(e) {
        lib$es6$promise$$internal$$reject(promise, e);
      }
    }

    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {
      var enumerator = this;

      enumerator._instanceConstructor = Constructor;
      enumerator.promise = new Constructor(lib$es6$promise$$internal$$noop);

      if (enumerator._validateInput(input)) {
        enumerator._input     = input;
        enumerator.length     = input.length;
        enumerator._remaining = input.length;

        enumerator._init();

        if (enumerator.length === 0) {
          lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);
        } else {
          enumerator.length = enumerator.length || 0;
          enumerator._enumerate();
          if (enumerator._remaining === 0) {
            lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);
          }
        }
      } else {
        lib$es6$promise$$internal$$reject(enumerator.promise, enumerator._validationError());
      }
    }

    lib$es6$promise$enumerator$$Enumerator.prototype._validateInput = function(input) {
      return lib$es6$promise$utils$$isArray(input);
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function() {
      return new Error('Array Methods must be provided an Array');
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._init = function() {
      this._result = new Array(this.length);
    };

    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;

    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {
      var enumerator = this;

      var length  = enumerator.length;
      var promise = enumerator.promise;
      var input   = enumerator._input;

      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
        enumerator._eachEntry(input[i], i);
      }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
      var enumerator = this;
      var c = enumerator._instanceConstructor;

      if (lib$es6$promise$utils$$isMaybeThenable(entry)) {
        if (entry.constructor === c && entry._state !== lib$es6$promise$$internal$$PENDING) {
          entry._onerror = null;
          enumerator._settledAt(entry._state, i, entry._result);
        } else {
          enumerator._willSettleAt(c.resolve(entry), i);
        }
      } else {
        enumerator._remaining--;
        enumerator._result[i] = entry;
      }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
      var enumerator = this;
      var promise = enumerator.promise;

      if (promise._state === lib$es6$promise$$internal$$PENDING) {
        enumerator._remaining--;

        if (state === lib$es6$promise$$internal$$REJECTED) {
          lib$es6$promise$$internal$$reject(promise, value);
        } else {
          enumerator._result[i] = value;
        }
      }

      if (enumerator._remaining === 0) {
        lib$es6$promise$$internal$$fulfill(promise, enumerator._result);
      }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
      var enumerator = this;

      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {
        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);
      }, function(reason) {
        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);
      });
    };
    function lib$es6$promise$promise$all$$all(entries) {
      return new lib$es6$promise$enumerator$$default(this, entries).promise;
    }
    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;
    function lib$es6$promise$promise$race$$race(entries) {
      /*jshint validthis:true */
      var Constructor = this;

      var promise = new Constructor(lib$es6$promise$$internal$$noop);

      if (!lib$es6$promise$utils$$isArray(entries)) {
        lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));
        return promise;
      }

      var length = entries.length;

      function onFulfillment(value) {
        lib$es6$promise$$internal$$resolve(promise, value);
      }

      function onRejection(reason) {
        lib$es6$promise$$internal$$reject(promise, reason);
      }

      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
        lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);
      }

      return promise;
    }
    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;
    function lib$es6$promise$promise$resolve$$resolve(object) {
      /*jshint validthis:true */
      var Constructor = this;

      if (object && typeof object === 'object' && object.constructor === Constructor) {
        return object;
      }

      var promise = new Constructor(lib$es6$promise$$internal$$noop);
      lib$es6$promise$$internal$$resolve(promise, object);
      return promise;
    }
    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;
    function lib$es6$promise$promise$reject$$reject(reason) {
      /*jshint validthis:true */
      var Constructor = this;
      var promise = new Constructor(lib$es6$promise$$internal$$noop);
      lib$es6$promise$$internal$$reject(promise, reason);
      return promise;
    }
    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;

    var lib$es6$promise$promise$$counter = 0;

    function lib$es6$promise$promise$$needsResolver() {
      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
    }

    function lib$es6$promise$promise$$needsNew() {
      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
    }

    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;
    /**
      Promise objects represent the eventual result of an asynchronous operation. The
      primary way of interacting with a promise is through its `then` method, which
      registers callbacks to receive either a promise's eventual value or the reason
      why the promise cannot be fulfilled.

      Terminology
      -----------

      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
      - `thenable` is an object or function that defines a `then` method.
      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
      - `exception` is a value that is thrown using the throw statement.
      - `reason` is a value that indicates why a promise was rejected.
      - `settled` the final resting state of a promise, fulfilled or rejected.

      A promise can be in one of three states: pending, fulfilled, or rejected.

      Promises that are fulfilled have a fulfillment value and are in the fulfilled
      state.  Promises that are rejected have a rejection reason and are in the
      rejected state.  A fulfillment value is never a thenable.

      Promises can also be said to *resolve* a value.  If this value is also a
      promise, then the original promise's settled state will match the value's
      settled state.  So a promise that *resolves* a promise that rejects will
      itself reject, and a promise that *resolves* a promise that fulfills will
      itself fulfill.


      Basic Usage:
      ------------

      ```js
      var promise = new Promise(function(resolve, reject) {
        // on success
        resolve(value);

        // on failure
        reject(reason);
      });

      promise.then(function(value) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Advanced Usage:
      ---------------

      Promises shine when abstracting away asynchronous interactions such as
      `XMLHttpRequest`s.

      ```js
      function getJSON(url) {
        return new Promise(function(resolve, reject){
          var xhr = new XMLHttpRequest();

          xhr.open('GET', url);
          xhr.onreadystatechange = handler;
          xhr.responseType = 'json';
          xhr.setRequestHeader('Accept', 'application/json');
          xhr.send();

          function handler() {
            if (this.readyState === this.DONE) {
              if (this.status === 200) {
                resolve(this.response);
              } else {
                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
              }
            }
          };
        });
      }

      getJSON('/posts.json').then(function(json) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Unlike callbacks, promises are great composable primitives.

      ```js
      Promise.all([
        getJSON('/posts'),
        getJSON('/comments')
      ]).then(function(values){
        values[0] // => postsJSON
        values[1] // => commentsJSON

        return values;
      });
      ```

      @class Promise
      @param {function} resolver
      Useful for tooling.
      @constructor
    */
    function lib$es6$promise$promise$$Promise(resolver) {
      this._id = lib$es6$promise$promise$$counter++;
      this._state = undefined;
      this._result = undefined;
      this._subscribers = [];

      if (lib$es6$promise$$internal$$noop !== resolver) {
        if (!lib$es6$promise$utils$$isFunction(resolver)) {
          lib$es6$promise$promise$$needsResolver();
        }

        if (!(this instanceof lib$es6$promise$promise$$Promise)) {
          lib$es6$promise$promise$$needsNew();
        }

        lib$es6$promise$$internal$$initializePromise(this, resolver);
      }
    }

    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;
    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;
    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;
    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;
    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;
    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;
    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;

    lib$es6$promise$promise$$Promise.prototype = {
      constructor: lib$es6$promise$promise$$Promise,

    /**
      The primary way of interacting with a promise is through its `then` method,
      which registers callbacks to receive either a promise's eventual value or the
      reason why the promise cannot be fulfilled.

      ```js
      findUser().then(function(user){
        // user is available
      }, function(reason){
        // user is unavailable, and you are given the reason why
      });
      ```

      Chaining
      --------

      The return value of `then` is itself a promise.  This second, 'downstream'
      promise is resolved with the return value of the first promise's fulfillment
      or rejection handler, or rejected if the handler throws an exception.

      ```js
      findUser().then(function (user) {
        return user.name;
      }, function (reason) {
        return 'default name';
      }).then(function (userName) {
        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
        // will be `'default name'`
      });

      findUser().then(function (user) {
        throw new Error('Found user, but still unhappy');
      }, function (reason) {
        throw new Error('`findUser` rejected and we're unhappy');
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
      });
      ```
      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.

      ```js
      findUser().then(function (user) {
        throw new PedagogicalException('Upstream error');
      }).then(function (value) {
        // never reached
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // The `PedgagocialException` is propagated all the way down to here
      });
      ```

      Assimilation
      ------------

      Sometimes the value you want to propagate to a downstream promise can only be
      retrieved asynchronously. This can be achieved by returning a promise in the
      fulfillment or rejection handler. The downstream promise will then be pending
      until the returned promise is settled. This is called *assimilation*.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // The user's comments are now available
      });
      ```

      If the assimliated promise rejects, then the downstream promise will also reject.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // If `findCommentsByAuthor` fulfills, we'll have the value here
      }, function (reason) {
        // If `findCommentsByAuthor` rejects, we'll have the reason here
      });
      ```

      Simple Example
      --------------

      Synchronous Example

      ```javascript
      var result;

      try {
        result = findResult();
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js
      findResult(function(result, err){
        if (err) {
          // failure
        } else {
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findResult().then(function(result){
        // success
      }, function(reason){
        // failure
      });
      ```

      Advanced Example
      --------------

      Synchronous Example

      ```javascript
      var author, books;

      try {
        author = findAuthor();
        books  = findBooksByAuthor(author);
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js

      function foundBooks(books) {

      }

      function failure(reason) {

      }

      findAuthor(function(author, err){
        if (err) {
          failure(err);
          // failure
        } else {
          try {
            findBoooksByAuthor(author, function(books, err) {
              if (err) {
                failure(err);
              } else {
                try {
                  foundBooks(books);
                } catch(reason) {
                  failure(reason);
                }
              }
            });
          } catch(error) {
            failure(err);
          }
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findAuthor().
        then(findBooksByAuthor).
        then(function(books){
          // found books
      }).catch(function(reason){
        // something went wrong
      });
      ```

      @method then
      @param {Function} onFulfilled
      @param {Function} onRejected
      Useful for tooling.
      @return {Promise}
    */
      then: function(onFulfillment, onRejection) {
        var parent = this;
        var state = parent._state;

        if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {
          return this;
        }

        var child = new this.constructor(lib$es6$promise$$internal$$noop);
        var result = parent._result;

        if (state) {
          var callback = arguments[state - 1];
          lib$es6$promise$asap$$asap(function(){
            lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);
          });
        } else {
          lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);
        }

        return child;
      },

    /**
      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
      as the catch block of a try/catch statement.

      ```js
      function findAuthor(){
        throw new Error('couldn't find that author');
      }

      // synchronous
      try {
        findAuthor();
      } catch(reason) {
        // something went wrong
      }

      // async with promises
      findAuthor().catch(function(reason){
        // something went wrong
      });
      ```

      @method catch
      @param {Function} onRejection
      Useful for tooling.
      @return {Promise}
    */
      'catch': function(onRejection) {
        return this.then(null, onRejection);
      }
    };
    function lib$es6$promise$polyfill$$polyfill() {
      var local;

      if (typeof global !== 'undefined') {
          local = global;
      } else if (typeof self !== 'undefined') {
          local = self;
      } else {
          try {
              local = Function('return this')();
          } catch (e) {
              throw new Error('polyfill failed because global object is unavailable in this environment');
          }
      }

      var P = local.Promise;

      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {
        return;
      }

      local.Promise = lib$es6$promise$promise$$default;
    }
    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;

    var lib$es6$promise$umd$$ES6Promise = {
      'Promise': lib$es6$promise$promise$$default,
      'polyfill': lib$es6$promise$polyfill$$default
    };

    /* global define:true module:true window: true */
    if (typeof define === 'function' && define['amd']) {
      define(function() { return lib$es6$promise$umd$$ES6Promise; });
    } else if (typeof module !== 'undefined' && module['exports']) {
      module['exports'] = lib$es6$promise$umd$$ES6Promise;
    } else if (typeof this !== 'undefined') {
      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;
    }

    lib$es6$promise$polyfill$$default();
}).call(this);


}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":11}],14:[function(require,module,exports){
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.3';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result  either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = property;

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}],15:[function(require,module,exports){
module.exports = "<body>\n  <div class=\"graph\">\n    <div class=\"cy\">\n      <div class=\"status loader\"></div>\n    </div>\n    <div class=\"controls\">\n      <div>Interaction type:</div>\n      <div>\n        <button class=\"genetic\">Genetic</button><button class=\"default selected\">Both</button><button class=\"physical\">Physical</button>\n      </div>\n    </div>\n  </div>\n  <div class=\"nodeDetails\">\n    <h2 class=\"nodeTitle\"></h2>\n    <dl class=\"nodeInfo intro\">\n      <dt class=\"intro\">Click on a gene to get more info about it.</dt>\n      <!-- dynamically output data here.  -->\n    </dl>\n  </div>\n</body>\n";

},{}]},{},[4])(4)
});
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJib3dlcl9jb21wb25lbnRzL2ltanMvanMvaW0uanMiLCJqcy9jeXRvc2NhcGVTdHlsZS5qc29uIiwianMvZGF0YUZvcm1hdHRlci5qcyIsImpzL21haW4uanMiLCJqcy9xdWVyeS5qc29uIiwianMvc3RyaW5ncy5qc29uIiwianMvdWkuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL29zLWJyb3dzZXJpZnkvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wYXRoLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9kaXN0L2N5dG9zY2FwZS5qcyIsIm5vZGVfbW9kdWxlcy9lczYtcHJvbWlzZS9kaXN0L2VzNi1wcm9taXNlLmpzIiwibm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvdW5kZXJzY29yZS5qcyIsInRlbXBsYXRlL2N5dG9taW5lLmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1L1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pKQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xuekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN2OEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVnREE7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKiEgaW1qcyAtIHYzLjEzLjAgLSAyMDE1LTA1LTA4ICovXG5cbi8vIFRoaXMgbGlicmFyeSBpcyBvcGVuIHNvdXJjZSBzb2Z0d2FyZSBhY2NvcmRpbmcgdG8gdGhlIGRlZmluaXRpb24gb2YgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2VuY2UsIFZlcnNpb24gMywgKExHUEx2MykgYSBjb3B5IG9mIHdoaWNoIGlzXG4vLyBpbmNsdWRlZCB3aXRoIHRoaXMgc29mdHdhcmUuIEFsbCB1c2Ugb2YgdGhpcyBzb2Z0d2FyZSBpcyBjb3ZlcmVkIGFjY29yZGluZyB0b1xuLy8gdGhlIHRlcm1zIG9mIHRoZSBMR1BMdjMuXG4vLyBcbi8vIFRoZSBjb3B5cmlnaHQgaXMgaGVsZCBieSBJbnRlck1pbmUgKHd3dy5pbnRlcm1pbmUub3JnKSBhbmQgQWxleCBLYWxkZXJpbWlzIChhbGV4QGludGVybWluZS5vcmcpLlxuXG4oZnVuY3Rpb24gKGludGVybWluZSkge1xuIWZ1bmN0aW9uKGUpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlKW1vZHVsZS5leHBvcnRzPWUoKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZClkZWZpbmUoW10sZSk7ZWxzZXt2YXIgZjtcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P2Y9d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Zj1nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGYmJihmPXNlbGYpLGYuaW1qcz1lKCl9fShmdW5jdGlvbigpe3ZhciBkZWZpbmUsbW9kdWxlLGV4cG9ydHM7cmV0dXJuIChmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pKHsxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbigpIHtcbiAgZXhwb3J0cy5BQ0NFUFRfSEVBREVSID0ge1xuICAgICd4bWwnOiAnYXBwbGljYXRpb24veG1sJyxcbiAgICAnanNvbic6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAndHN2JzogJ3RleHQvdGFiLXNlcGFyYXRlZC12YWx1ZXMnLFxuICAgICd0YWInOiAndGV4dC90YWItc2VwYXJhdGVkLXZhbHVlcycsXG4gICAgJ2Nzdic6ICd0ZXh0L2NvbW1hLXNlcGFyYXRlZC12YWx1ZXMnLFxuICAgICdmYXN0YSc6ICd0ZXh0L3gtZmFzdGEnLFxuICAgICdnZmYzJzogJ3RleHQveC1nZmYzJyxcbiAgICAnYmVkJzogJ3RleHQveC1iZWQnLFxuICAgICdvYmplY3RzJzogJ2FwcGxpY2F0aW9uL2pzb247dHlwZT1vYmplY3RzJyxcbiAgICAnanNvbm9iamVjdHMnOiAnYXBwbGljYXRpb24vanNvbjt0eXBlPW9iamVjdHMnLFxuICAgICdqc29udGFibGUnOiAnYXBwbGljYXRpb24vanNvbjt0eXBlPXRhYmxlJyxcbiAgICAnanNvbnJvd3MnOiAnYXBwbGljYXRpb24vanNvbjt0eXBlPXJvd3MnLFxuICAgICdqc29uY291bnQnOiAnYXBwbGljYXRpb24vanNvbjt0eXBlPWNvdW50JyxcbiAgICAnanNvbnAnOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCcsXG4gICAgJ2pzb25wb2JqZWN0cyc6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0O3R5cGU9b2JqZWN0cycsXG4gICAgJ2pzb25wdGFibGUnOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdDt0eXBlPXRhYmxlJyxcbiAgICAnanNvbnByb3dzJzogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQ7dHlwZT1yb3dzJyxcbiAgICAnanNvbnBjb3VudCc6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0O3R5cGU9Y291bnQnXG4gIH07XG5cbn0pLmNhbGwodGhpcyk7XG5cbn0se31dLDI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgZXhwb3NlLCBpbWpzLCBtZXJnZTtcblxuICBfZGVyZXFfKCcuL3NoaXYnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IGltanMgPSBfZGVyZXFfKCcuL3NlcnZpY2UnKTtcblxuICBtZXJnZSA9IGltanMudXRpbHMubWVyZ2U7XG5cbiAgZXhwb3NlID0gZnVuY3Rpb24obmFtZSwgdGhpbmcpIHtcbiAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICByZXR1cm4gZGVmaW5lKG5hbWUsIFtdLCB0aGluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnbG9iYWxbbmFtZV0gPSB0aGluZztcbiAgICB9XG4gIH07XG5cbiAgZXhwb3NlKCdpbWpzJywgaW1qcyk7XG5cbiAgaWYgKHR5cGVvZiBpbnRlcm1pbmUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZXhwb3NlKCdpbnRlcm1pbmUnLCBpbWpzKTtcbiAgfSBlbHNlIHtcbiAgICBleHBvc2UoJ2ludGVybWluZScsIG1lcmdlKGludGVybWluZSwgaW1qcykpO1xuICB9XG5cbn0pLmNhbGwodGhpcyk7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7XCIuL3NlcnZpY2VcIjoxMCxcIi4vc2hpdlwiOjEyfV0sMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBBQ0NFUFRfSEVBREVSLCBKU09OU3RyZWFtLCBQRVNLWV9DT01NQSwgVVJMLCBVUkxFTkMsIFVTRVJfQUdFTlQsIFZFUlNJT04sIGJsb2NraW5nLCBkZWZlciwgZXJyb3IsIGdldE1zZywgaHR0cCwgaW52b2tlLCBtZXJnZSwgcGFyc2VPcHRpb25zLCByZWplY3RBZnRlciwgc3RyZWFtaW5nLCB1dGlscywgX3JlZjtcblxuICBVUkwgPSBfZGVyZXFfKCd1cmwnKTtcblxuICBKU09OU3RyZWFtID0gX2RlcmVxXygnSlNPTlN0cmVhbScpO1xuXG4gIGh0dHAgPSBfZGVyZXFfKCdodHRwJyk7XG5cbiAgQUNDRVBUX0hFQURFUiA9IF9kZXJlcV8oJy4vY29uc3RhbnRzJykuQUNDRVBUX0hFQURFUjtcblxuICBWRVJTSU9OID0gX2RlcmVxXygnLi92ZXJzaW9uJykuVkVSU0lPTjtcblxuICBfcmVmID0gdXRpbHMgPSBfZGVyZXFfKCcuL3V0aWwnKSwgZXJyb3IgPSBfcmVmLmVycm9yLCBkZWZlciA9IF9yZWYuZGVmZXIsIG1lcmdlID0gX3JlZi5tZXJnZSwgaW52b2tlID0gX3JlZi5pbnZva2U7XG5cbiAgVVNFUl9BR0VOVCA9IFwibm9kZS1odHRwL2ltanMtXCIgKyBWRVJTSU9OO1xuXG4gIFBFU0tZX0NPTU1BID0gLyxcXHMqJC87XG5cbiAgVVJMRU5DID0gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIjtcblxuICBleHBvcnRzLnN1cHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgc3RyZWFtaW5nID0gZnVuY3Rpb24ob3B0cywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgIHZhciBlcnJvcnMsIHJlc3VsdHM7XG4gICAgICBpZiAocmVzcC5waXBlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ3Jlc3BvbnNlIGlzIG5vdCBhIHN0cmVhbScpKTtcbiAgICAgIH1cbiAgICAgIHJlc3Aub24oJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgIGlmICgocmVzcC5zdGF0dXNDb2RlICE9IG51bGwpICYmIHJlc3Auc3RhdHVzQ29kZSAhPT0gMjAwKSB7XG4gICAgICAgIGVycm9ycyA9IEpTT05TdHJlYW0ucGFyc2UoJ2Vycm9yJyk7XG4gICAgICAgIGVycm9ycy5wYXVzZSgpO1xuICAgICAgICByZXNwLnBpcGUoZXJyb3JzKTtcbiAgICAgICAgcmV0dXJuIHJlamVjdChbcmVzcC5zdGF0dXNDb2RlLCBlcnJvcnNdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdHMgPSBKU09OU3RyZWFtLnBhcnNlKCdyZXN1bHRzLionKTtcbiAgICAgICAgcmVzdWx0cy5wYXVzZSgpO1xuICAgICAgICByZXNwLnBpcGUocmVzdWx0cyk7XG4gICAgICAgIHJldHVybiByZXNvbHZlKHJlc3VsdHMpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgZ2V0TXNnID0gZnVuY3Rpb24oX2FyZywgdGV4dCwgZSwgY29kZSkge1xuICAgIHZhciB0eXBlLCB1cmw7XG4gICAgdHlwZSA9IF9hcmcudHlwZSwgdXJsID0gX2FyZy51cmw7XG4gICAgcmV0dXJuIFwiQ291bGQgbm90IHBhcnNlIHJlc3BvbnNlIHRvIFwiICsgdHlwZSArIFwiIFwiICsgdXJsICsgXCI6IFxcXCJcIiArIHRleHQgKyBcIlxcXCIgKFwiICsgY29kZSArIFwiOiBcIiArIGUgKyBcIilcIjtcbiAgfTtcblxuICBibG9ja2luZyA9IGZ1bmN0aW9uKG9wdHMsIHJlc29sdmUsIHJlamVjdCkge1xuICAgIHJldHVybiBmdW5jdGlvbihyZXNwKSB7XG4gICAgICB2YXIgY29udGFpbmVyQnVmZmVyO1xuICAgICAgY29udGFpbmVyQnVmZmVyID0gJyc7XG4gICAgICByZXNwLm9uKCdkYXRhJywgZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lckJ1ZmZlciArPSBjaHVuaztcbiAgICAgIH0pO1xuICAgICAgcmVzcC5vbignZXJyb3InLCByZWplY3QpO1xuICAgICAgcmV0dXJuIHJlc3Aub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY3QsIGUsIGVyciwgZiwgbWF0Y2gsIHBhcnNlZCwgX3JlZjE7XG4gICAgICAgIGN0ID0gcmVzcC5oZWFkZXJzWydjb250ZW50LXR5cGUnXTtcbiAgICAgICAgaWYgKCdhcHBsaWNhdGlvbi9qc29uJyA9PT0gY3QgfHwgL2pzb24vLnRlc3Qob3B0cy5kYXRhVHlwZSkgfHwgL2pzb24vLnRlc3Qob3B0cy5kYXRhLmZvcm1hdCkpIHtcbiAgICAgICAgICBpZiAoJycgPT09IGNvbnRhaW5lckJ1ZmZlciAmJiByZXNwLnN0YXR1c0NvZGUgPT09IDIwMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcGFyc2VkID0gSlNPTi5wYXJzZShjb250YWluZXJCdWZmZXIpO1xuICAgICAgICAgICAgICBpZiAoZXJyID0gcGFyc2VkLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoZXJyKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocGFyc2VkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgICAgICAgIGlmIChyZXNwLnN0YXR1c0NvZGUgPj0gNDAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IocmVzcC5zdGF0dXNDb2RlKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoZ2V0TXNnKG9wdHMsIGNvbnRhaW5lckJ1ZmZlciwgZSwgcmVzcC5zdGF0dXNDb2RlKSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChtYXRjaCA9IGNvbnRhaW5lckJ1ZmZlci5tYXRjaCgvXFxbRVJST1JcXF0gKFxcZCspKFtcXHNcXFNdKikvKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IobWF0Y2hbMl0pKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZiA9ICgyMDAgPD0gKF9yZWYxID0gcmVzcC5zdGF0dXNDb2RlKSAmJiBfcmVmMSA8IDQwMCkgPyByZXNvbHZlIDogcmVqZWN0O1xuICAgICAgICAgICAgcmV0dXJuIGYoY29udGFpbmVyQnVmZmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG5cbiAgZXhwb3J0cy5pdGVyUmVxID0gZnVuY3Rpb24obWV0aG9kLCBwYXRoLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ocSwgcGFnZSwgY2IsIGViLCBvbkVuZCkge1xuICAgICAgdmFyIGF0dGFjaCwgcHJvbWlzZSwgcmVhZEVycm9ycywgcmVxLCBfcmVmMTtcbiAgICAgIGlmIChwYWdlID09IG51bGwpIHtcbiAgICAgICAgcGFnZSA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKGNiID09IG51bGwpIHtcbiAgICAgICAgY2IgPSAoZnVuY3Rpb24oKSB7fSk7XG4gICAgICB9XG4gICAgICBpZiAoZWIgPT0gbnVsbCkge1xuICAgICAgICBlYiA9IChmdW5jdGlvbigpIHt9KTtcbiAgICAgIH1cbiAgICAgIGlmIChvbkVuZCA9PSBudWxsKSB7XG4gICAgICAgIG9uRW5kID0gKGZ1bmN0aW9uKCkge30pO1xuICAgICAgfVxuICAgICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24ocGFnZSkpIHtcbiAgICAgICAgX3JlZjEgPSBbe30sIHBhZ2UsIGNiLCBlYl0sIHBhZ2UgPSBfcmVmMVswXSwgY2IgPSBfcmVmMVsxXSwgZWIgPSBfcmVmMVsyXSwgb25FbmQgPSBfcmVmMVszXTtcbiAgICAgIH1cbiAgICAgIHJlcSA9IG1lcmdlKHtcbiAgICAgICAgZm9ybWF0OiBmb3JtYXRcbiAgICAgIH0sIHBhZ2UsIHtcbiAgICAgICAgcXVlcnk6IHEudG9YTUwoKVxuICAgICAgfSk7XG4gICAgICBhdHRhY2ggPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgc3RyZWFtLm9uKCdkYXRhJywgY2IpO1xuICAgICAgICBzdHJlYW0ub24oJ2Vycm9yJywgZWIpO1xuICAgICAgICBzdHJlYW0ub24oJ2VuZCcsIG9uRW5kKTtcbiAgICAgICAgc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKHN0cmVhbS5yZXN1bWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmVhbS5yZXN1bWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLCAzKTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICAgIH07XG4gICAgICByZWFkRXJyb3JzID0gZnVuY3Rpb24oX2FyZykge1xuICAgICAgICB2YXIgZXJyb3JzLCBzYztcbiAgICAgICAgc2MgPSBfYXJnWzBdLCBlcnJvcnMgPSBfYXJnWzFdO1xuICAgICAgICBlcnJvcnMub24oJ2RhdGEnLCBlYik7XG4gICAgICAgIGVycm9ycy5vbignZXJyb3InLCBlYik7XG4gICAgICAgIGVycm9ycy5vbignZW5kJywgb25FbmQpO1xuICAgICAgICBpZiAoZXJyb3JzLnJlc3VtZSAhPSBudWxsKSB7XG4gICAgICAgICAgZXJyb3JzLnJlc3VtZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcihzYyk7XG4gICAgICB9O1xuICAgICAgcHJvbWlzZSA9IHRoaXMubWFrZVJlcXVlc3QobWV0aG9kLCBwYXRoLCByZXEsIG51bGwsIHRydWUpO1xuICAgICAgcHJvbWlzZS50aGVuKGF0dGFjaCwgcmVhZEVycm9ycyk7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuICB9O1xuXG4gIHJlamVjdEFmdGVyID0gZnVuY3Rpb24odGltZW91dCwgcmVqZWN0LCBwcm9taXNlKSB7XG4gICAgdmFyIHRvO1xuICAgIHRvID0gc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmVqZWN0KFwiUmVxdWVzdCB0aW1lZCBvdXQuXCIpO1xuICAgIH0pLCB0aW1lb3V0KTtcbiAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNhbmNlbFRpbWVvdXQodG8pO1xuICAgIH0pO1xuICB9O1xuXG4gIHBhcnNlT3B0aW9ucyA9IGZ1bmN0aW9uKG9wdHMpIHtcbiAgICB2YXIgaywgcGFyc2VkLCBwb3N0ZGF0YSwgc2VwLCB2LCBfcmVmMSwgX3JlZjIsIF9yZWYzO1xuICAgIGlmICghb3B0cy51cmwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHVybCBwcm92aWRlZCBpbiBcIiArIChKU09OLnN0cmluZ2lmeShvcHRzKSkpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdHMuZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHBvc3RkYXRhID0gb3B0cy5kYXRhO1xuICAgICAgaWYgKChfcmVmMSA9IG9wdHMudHlwZSkgPT09ICdHRVQnIHx8IF9yZWYxID09PSAnREVMRVRFJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlcXVlc3QuIFwiICsgb3B0cy50eXBlICsgXCIgcmVxdWVzdHMgbXVzdCBub3QgaGF2ZSBib2RpZXNcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvc3RkYXRhID0gdXRpbHMucXVlcnlzdHJpbmcob3B0cy5kYXRhKTtcbiAgICB9XG4gICAgcGFyc2VkID0gVVJMLnBhcnNlKG9wdHMudXJsLCB0cnVlKTtcbiAgICBwYXJzZWQud2l0aENyZWRlbnRpYWxzID0gZmFsc2U7XG4gICAgcGFyc2VkLm1ldGhvZCA9IG9wdHMudHlwZSB8fCAnR0VUJztcbiAgICBpZiAob3B0cy5wb3J0ICE9IG51bGwpIHtcbiAgICAgIHBhcnNlZC5wb3J0ID0gb3B0cy5wb3J0O1xuICAgIH1cbiAgICBwYXJzZWQuaGVhZGVycyA9IHtcbiAgICAgICdVc2VyLUFnZW50JzogVVNFUl9BR0VOVCxcbiAgICAgICdBY2NlcHQnOiBBQ0NFUFRfSEVBREVSW29wdHMuZGF0YVR5cGVdXG4gICAgfTtcbiAgICBpZiAoKChfcmVmMiA9IHBhcnNlZC5tZXRob2QpID09PSAnR0VUJyB8fCBfcmVmMiA9PT0gJ0RFTEVURScpICYmIChwb3N0ZGF0YSAhPSBudWxsID8gcG9zdGRhdGEubGVuZ3RoIDogdm9pZCAwKSkge1xuICAgICAgc2VwID0gL1xcPy8udGVzdChwYXJzZWQucGF0aCkgPyAnJicgOiAnPyc7XG4gICAgICBwYXJzZWQucGF0aCArPSBzZXAgKyBwb3N0ZGF0YTtcbiAgICAgIHBvc3RkYXRhID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyc2VkLmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gKG9wdHMuY29udGVudFR5cGUgfHwgVVJMRU5DKSArICc7IGNoYXJzZXQ9VVRGLTgnO1xuICAgICAgcGFyc2VkLmhlYWRlcnNbJ0NvbnRlbnQtTGVuZ3RoJ10gPSBwb3N0ZGF0YS5sZW5ndGg7XG4gICAgfVxuICAgIGlmIChvcHRzLmhlYWRlcnMgIT0gbnVsbCkge1xuICAgICAgX3JlZjMgPSBvcHRzLmhlYWRlcnM7XG4gICAgICBmb3IgKGsgaW4gX3JlZjMpIHtcbiAgICAgICAgdiA9IF9yZWYzW2tdO1xuICAgICAgICBwYXJzZWQuaGVhZGVyc1trXSA9IHY7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRzLmF1dGggIT0gbnVsbCkge1xuICAgICAgcGFyc2VkLmF1dGggPSBvcHRzLmF1dGg7XG4gICAgfVxuICAgIHJldHVybiBbcGFyc2VkLCBwb3N0ZGF0YV07XG4gIH07XG5cbiAgZXhwb3J0cy5kb1JlcSA9IGZ1bmN0aW9uKG9wdHMsIGl0ZXIpIHtcbiAgICB2YXIgZSwgaGFuZGxlciwgcG9zdGRhdGEsIHByb21pc2UsIHJlamVjdCwgcmVxLCByZXNvbHZlLCB0aW1lb3V0LCB1cmwsIF9yZWYxLCBfcmVmMjtcbiAgICBfcmVmMSA9IGRlZmVyKCksIHByb21pc2UgPSBfcmVmMS5wcm9taXNlLCByZXNvbHZlID0gX3JlZjEucmVzb2x2ZSwgcmVqZWN0ID0gX3JlZjEucmVqZWN0O1xuICAgIHByb21pc2UudGhlbihudWxsLCBvcHRzLmVycm9yKTtcbiAgICB0cnkge1xuICAgICAgX3JlZjIgPSBwYXJzZU9wdGlvbnMob3B0cyksIHVybCA9IF9yZWYyWzBdLCBwb3N0ZGF0YSA9IF9yZWYyWzFdO1xuICAgICAgaGFuZGxlciA9IChpdGVyID8gc3RyZWFtaW5nIDogYmxvY2tpbmcpKG9wdHMsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICByZXEgPSBodHRwLnJlcXVlc3QodXJsLCBoYW5kbGVyKTtcbiAgICAgIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXCJFcnJvcjogXCIgKyB1cmwubWV0aG9kICsgXCIgXCIgKyBvcHRzLnVybCArIFwiOiBcIiArIGVycikpO1xuICAgICAgfSk7XG4gICAgICBpZiAocG9zdGRhdGEgIT0gbnVsbCkge1xuICAgICAgICByZXEud3JpdGUocG9zdGRhdGEpO1xuICAgICAgfVxuICAgICAgcmVxLmVuZCgpO1xuICAgICAgdGltZW91dCA9IG9wdHMudGltZW91dDtcbiAgICAgIGlmICh0aW1lb3V0ID4gMCkge1xuICAgICAgICByZWplY3RBZnRlcih0aW1lb3V0LCByZWplY3QsIHByb21pc2UpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgZSA9IF9lcnJvcjtcbiAgICAgIHJlamVjdChlKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG5cbn0pLmNhbGwodGhpcyk7XG5cbn0se1wiLi9jb25zdGFudHNcIjoxLFwiLi91dGlsXCI6MTUsXCIuL3ZlcnNpb25cIjoxNixcIkpTT05TdHJlYW1cIjoxOCxcImh0dHBcIjo1MCxcInVybFwiOjQ3fV0sNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBDYXRlZ29yeVJlc3VsdHMsIElEUmVzb2x1dGlvbkpvYiwgSWRSZXN1bHRzLCBPTkVfTUlOVVRFLCBjb25jYXRNYXAsIGRlZmVyLCBkaWZmZXJlbmNlLCBmb2xkLCBmdW5jdXRpbHMsIGdldCwgaWQsIGludGVybWluZSwgdW5pcUJ5LCB3aXRoQ0IsXG4gICAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXG4gICAgX19pbmRleE9mID0gW10uaW5kZXhPZiB8fCBmdW5jdGlvbihpdGVtKSB7IGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKSByZXR1cm4gaTsgfSByZXR1cm4gLTE7IH0sXG4gICAgX19iaW5kID0gZnVuY3Rpb24oZm4sIG1lKXsgcmV0dXJuIGZ1bmN0aW9uKCl7IHJldHVybiBmbi5hcHBseShtZSwgYXJndW1lbnRzKTsgfTsgfTtcblxuICBmdW5jdXRpbHMgPSBfZGVyZXFfKCcuL3V0aWwnKTtcblxuICBpbnRlcm1pbmUgPSBleHBvcnRzO1xuXG4gIHVuaXFCeSA9IGZ1bmN1dGlscy51bmlxQnksIGRpZmZlcmVuY2UgPSBmdW5jdXRpbHMuZGlmZmVyZW5jZSwgZGVmZXIgPSBmdW5jdXRpbHMuZGVmZXIsIHdpdGhDQiA9IGZ1bmN1dGlscy53aXRoQ0IsIGlkID0gZnVuY3V0aWxzLmlkLCBnZXQgPSBmdW5jdXRpbHMuZ2V0LCBmb2xkID0gZnVuY3V0aWxzLmZvbGQsIGNvbmNhdE1hcCA9IGZ1bmN1dGlscy5jb25jYXRNYXA7XG5cbiAgT05FX01JTlVURSA9IDYwICogMTAwMDtcblxuICBDYXRlZ29yeVJlc3VsdHMgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGdldElzc3VlTWF0Y2hlcztcblxuICAgIGZ1bmN0aW9uIENhdGVnb3J5UmVzdWx0cyhyZXN1bHRzKSB7XG4gICAgICB2YXIgaywgdjtcbiAgICAgIGZvciAoayBpbiByZXN1bHRzKSB7XG4gICAgICAgIGlmICghX19oYXNQcm9wLmNhbGwocmVzdWx0cywgaykpIGNvbnRpbnVlO1xuICAgICAgICB2ID0gcmVzdWx0c1trXTtcbiAgICAgICAgdGhpc1trXSA9IHY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgQ2F0ZWdvcnlSZXN1bHRzLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHNbdHlwZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0cztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZ2V0SXNzdWVNYXRjaGVzID0gY29uY2F0TWFwKGdldCgnbWF0Y2hlcycpKTtcblxuICAgIENhdGVnb3J5UmVzdWx0cy5wcm90b3R5cGUuZ2V0TWF0Y2hlcyA9IGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBfcmVmO1xuICAgICAgaWYgKGsgPT09ICdNQVRDSCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2hlc1trXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAoX3JlZiA9IGdldElzc3VlTWF0Y2hlcyh0aGlzLm1hdGNoZXNba10pKSAhPSBudWxsID8gX3JlZiA6IFtdO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDYXRlZ29yeVJlc3VsdHMucHJvdG90eXBlLmdldE1hdGNoSWRzID0gZnVuY3Rpb24oaykge1xuICAgICAgaWYgKGsgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRNYXRjaGVzKGspLm1hcChnZXQoJ2lkJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxsTWF0Y2hJZHMoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2F0ZWdvcnlSZXN1bHRzLnByb3RvdHlwZS5nb29kTWF0Y2hJZHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE1hdGNoSWRzKCdNQVRDSCcpO1xuICAgIH07XG5cbiAgICBDYXRlZ29yeVJlc3VsdHMucHJvdG90eXBlLmFsbE1hdGNoSWRzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29tYmluZUlkcztcbiAgICAgIGNvbWJpbmVJZHMgPSBmb2xkKChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ocmVzLCBpc3N1ZVNldCkge1xuICAgICAgICAgIHJldHVybiByZXMuY29uY2F0KF90aGlzLmdldE1hdGNoSWRzKGlzc3VlU2V0KSk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgICByZXR1cm4gY29tYmluZUlkcyh0aGlzLmdvb2RNYXRjaElkcygpLCBbJ0RVUExJQ0FURScsICdXSUxEQ0FSRCcsICdUWVBFX0NPTlZFUlRFRCcsICdPVEhFUiddKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENhdGVnb3J5UmVzdWx0cztcblxuICB9KSgpO1xuXG4gIElkUmVzdWx0cyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgZmxhdHRlbiwgZ2V0UmVhc29ucywgaXNHb29kLCB1bmlxdWU7XG5cbiAgICB1bmlxdWUgPSB1bmlxQnkoaWQpO1xuXG4gICAgZmxhdHRlbiA9IGNvbmNhdE1hcChpZCk7XG5cbiAgICBnZXRSZWFzb25zID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgIHZhciBrLCB2YWxzO1xuICAgICAgcmV0dXJuIGZsYXR0ZW4oKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICAgIF9yZWYgPSBtYXRjaC5pZGVudGlmaWVycztcbiAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChrIGluIF9yZWYpIHtcbiAgICAgICAgICB2YWxzID0gX3JlZltrXTtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKHZhbHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH0pKCkpO1xuICAgIH07XG5cbiAgICBpc0dvb2QgPSBmdW5jdGlvbihtYXRjaCwgaykge1xuICAgICAgcmV0dXJuIChrID09IG51bGwpIHx8IF9faW5kZXhPZi5jYWxsKGdldFJlYXNvbnMobWF0Y2gpLCBrKSA+PSAwO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBJZFJlc3VsdHMocmVzdWx0cykge1xuICAgICAgdmFyIGssIHY7XG4gICAgICBmb3IgKGsgaW4gcmVzdWx0cykge1xuICAgICAgICBpZiAoIV9faGFzUHJvcC5jYWxsKHJlc3VsdHMsIGspKSBjb250aW51ZTtcbiAgICAgICAgdiA9IHJlc3VsdHNba107XG4gICAgICAgIHRoaXNba10gPSB2O1xuICAgICAgfVxuICAgIH1cblxuICAgIElkUmVzdWx0cy5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnb2JqZWN0cyc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0U3RhdHMoKTtcbiAgICAgICAgY2FzZSAnaWRlbnRpZmllcnMnOlxuICAgICAgICAgIHJldHVybiB0aGlzLmdldElkZW50aWZpZXJTdGF0cygpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvYmplY3RzOiB0aGlzLmdldE9iamVjdFN0YXRzKCksXG4gICAgICAgICAgICBpZGVudGlmaWVyczogdGhpcy5nZXRJZGVudGlmaWVyU3RhdHMoKVxuICAgICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIElkUmVzdWx0cy5wcm90b3R5cGUuZ2V0SWRlbnRpZmllclN0YXRzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYWxsLCBhbGxJZGVudHMsIGlzc3VlcywgbWF0Y2hJZGVudHMsIG1hdGNoZXMsIHRvSWRlbnRzO1xuICAgICAgdG9JZGVudHMgPSBmdW5jdGlvbihtcykge1xuICAgICAgICB2YXIgaWRlbnQsIG1hdGNoO1xuICAgICAgICByZXR1cm4gdW5pcXVlKGZsYXR0ZW4oKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBfaSwgX2xlbiwgX3Jlc3VsdHM7XG4gICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IG1zLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgICBtYXRjaCA9IG1zW19pXTtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2goKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgX3Jlc3VsdHMxO1xuICAgICAgICAgICAgICBfcmVzdWx0czEgPSBbXTtcbiAgICAgICAgICAgICAgZm9yIChpZGVudCBpbiBtYXRjaCAhPSBudWxsID8gbWF0Y2guaWRlbnRpZmllcnMgOiB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBfcmVzdWx0czEucHVzaChpZGVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF9yZXN1bHRzMTtcbiAgICAgICAgICAgIH0pKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICAgIH0pKCkpKTtcbiAgICAgIH07XG4gICAgICBtYXRjaElkZW50cyA9IHRvSWRlbnRzKHRoaXMuZ2V0TWF0Y2hlcygnTUFUQ0gnKSk7XG4gICAgICBhbGxJZGVudHMgPSB0b0lkZW50cyh0aGlzLmdldE1hdGNoZXMoKSk7XG4gICAgICBtYXRjaGVzID0gbWF0Y2hJZGVudHMubGVuZ3RoO1xuICAgICAgYWxsID0gYWxsSWRlbnRzLmxlbmd0aDtcbiAgICAgIGlzc3VlcyA9IChkaWZmZXJlbmNlKGFsbElkZW50cywgbWF0Y2hJZGVudHMpKS5sZW5ndGg7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXRjaGVzOiBtYXRjaGVzLFxuICAgICAgICBhbGw6IGFsbCxcbiAgICAgICAgaXNzdWVzOiBpc3N1ZXNcbiAgICAgIH07XG4gICAgfTtcblxuICAgIElkUmVzdWx0cy5wcm90b3R5cGUuZ2V0T2JqZWN0U3RhdHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhbGwsIGlzc3VlcywgbWF0Y2gsIG1hdGNoZXM7XG4gICAgICBtYXRjaGVzID0gdGhpcy5nb29kTWF0Y2hJZHMoKS5sZW5ndGg7XG4gICAgICBhbGwgPSB0aGlzLmFsbE1hdGNoSWRzKCkubGVuZ3RoO1xuICAgICAgaXNzdWVzID0gKChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9yZXN1bHRzO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGlkIGluIHRoaXMpIHtcbiAgICAgICAgICBpZiAoIV9faGFzUHJvcC5jYWxsKHRoaXMsIGlkKSkgY29udGludWU7XG4gICAgICAgICAgbWF0Y2ggPSB0aGlzW2lkXTtcbiAgICAgICAgICBpZiAoX19pbmRleE9mLmNhbGwoZ2V0UmVhc29ucyhtYXRjaCksICdNQVRDSCcpIDwgMCkge1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChpZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH0pLmNhbGwodGhpcykpLmxlbmd0aDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1hdGNoZXM6IG1hdGNoZXMsXG4gICAgICAgIGFsbDogYWxsLFxuICAgICAgICBpc3N1ZXM6IGlzc3Vlc1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgSWRSZXN1bHRzLnByb3RvdHlwZS5nZXRNYXRjaGVzID0gZnVuY3Rpb24oaykge1xuICAgICAgdmFyIG1hdGNoLCBfcmVzdWx0cztcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKGlkIGluIHRoaXMpIHtcbiAgICAgICAgaWYgKCFfX2hhc1Byb3AuY2FsbCh0aGlzLCBpZCkpIGNvbnRpbnVlO1xuICAgICAgICBtYXRjaCA9IHRoaXNbaWRdO1xuICAgICAgICBpZiAoaXNHb29kKG1hdGNoLCBrKSkge1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2gobWF0Y2gpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIElkUmVzdWx0cy5wcm90b3R5cGUuZ2V0TWF0Y2hJZHMgPSBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIgbWF0Y2gsIF9yZXN1bHRzO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoaWQgaW4gdGhpcykge1xuICAgICAgICBpZiAoIV9faGFzUHJvcC5jYWxsKHRoaXMsIGlkKSkgY29udGludWU7XG4gICAgICAgIG1hdGNoID0gdGhpc1tpZF07XG4gICAgICAgIGlmIChpc0dvb2QobWF0Y2gsIGspKSB7XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaChpZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgSWRSZXN1bHRzLnByb3RvdHlwZS5nb29kTWF0Y2hJZHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE1hdGNoSWRzKCdNQVRDSCcpO1xuICAgIH07XG5cbiAgICBJZFJlc3VsdHMucHJvdG90eXBlLmFsbE1hdGNoSWRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRNYXRjaElkcygpO1xuICAgIH07XG5cbiAgICByZXR1cm4gSWRSZXN1bHRzO1xuXG4gIH0pKCk7XG5cbiAgSURSZXNvbHV0aW9uSm9iID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIElEUmVzb2x1dGlvbkpvYih1aWQsIHNlcnZpY2UpIHtcbiAgICAgIHRoaXMudWlkID0gdWlkO1xuICAgICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcbiAgICAgIHRoaXMuZGVsID0gX19iaW5kKHRoaXMuZGVsLCB0aGlzKTtcbiAgICAgIHRoaXMuZmV0Y2hSZXN1bHRzID0gX19iaW5kKHRoaXMuZmV0Y2hSZXN1bHRzLCB0aGlzKTtcbiAgICAgIHRoaXMuZmV0Y2hFcnJvck1lc3NhZ2UgPSBfX2JpbmQodGhpcy5mZXRjaEVycm9yTWVzc2FnZSwgdGhpcyk7XG4gICAgICB0aGlzLmZldGNoU3RhdHVzID0gX19iaW5kKHRoaXMuZmV0Y2hTdGF0dXMsIHRoaXMpO1xuICAgIH1cblxuICAgIElEUmVzb2x1dGlvbkpvYi5wcm90b3R5cGUuZmV0Y2hTdGF0dXMgPSBmdW5jdGlvbihjYikge1xuICAgICAgcmV0dXJuIHdpdGhDQihjYiwgdGhpcy5zZXJ2aWNlLmdldChcImlkcy9cIiArIHRoaXMudWlkICsgXCIvc3RhdHVzXCIpLnRoZW4oZ2V0KCdzdGF0dXMnKSkpO1xuICAgIH07XG5cbiAgICBJRFJlc29sdXRpb25Kb2IucHJvdG90eXBlLmZldGNoRXJyb3JNZXNzYWdlID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgIHJldHVybiB3aXRoQ0IoY2IsIHRoaXMuc2VydmljZS5nZXQoXCJpZHMvXCIgKyB0aGlzLnVpZCArIFwiL3N0YXR1c1wiKS50aGVuKGdldCgnbWVzc2FnZScpKSk7XG4gICAgfTtcblxuICAgIElEUmVzb2x1dGlvbkpvYi5wcm90b3R5cGUuZmV0Y2hSZXN1bHRzID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgIHZhciBnZXR0aW5nUmVzLCBnZXR0aW5nVmVyO1xuICAgICAgZ2V0dGluZ1JlcyA9IHRoaXMuc2VydmljZS5nZXQoXCJpZHMvXCIgKyB0aGlzLnVpZCArIFwiL3Jlc3VsdFwiKS50aGVuKGdldCgncmVzdWx0cycpKTtcbiAgICAgIGdldHRpbmdWZXIgPSB0aGlzLnNlcnZpY2UuZmV0Y2hWZXJzaW9uKCk7XG4gICAgICByZXR1cm4gZ2V0dGluZ1Zlci50aGVuKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuIGdldHRpbmdSZXMudGhlbihmdW5jdGlvbihyZXN1bHRzKSB7XG4gICAgICAgICAgaWYgKHYgPj0gMTYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2F0ZWdvcnlSZXN1bHRzKHJlc3VsdHMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IElkUmVzdWx0cyhyZXN1bHRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIElEUmVzb2x1dGlvbkpvYi5wcm90b3R5cGUuZGVsID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgIHJldHVybiB3aXRoQ0IoY2IsIHRoaXMuc2VydmljZS5tYWtlUmVxdWVzdCgnREVMRVRFJywgXCJpZHMvXCIgKyB0aGlzLnVpZCkpO1xuICAgIH07XG5cbiAgICBJRFJlc29sdXRpb25Kb2IucHJvdG90eXBlLmRlY2F5ID0gNTA7XG5cbiAgICBJRFJlc29sdXRpb25Kb2IucHJvdG90eXBlLnBvbGwgPSBmdW5jdGlvbihvblN1Y2Nlc3MsIG9uRXJyb3IsIG9uUHJvZ3Jlc3MpIHtcbiAgICAgIHZhciBiYWNrT2ZmLCBub3RpZnksIHByb21pc2UsIHJlamVjdCwgcmVzb2x2ZSwgcmVzcCwgX3JlZjtcbiAgICAgIF9yZWYgPSBkZWZlcigpLCBwcm9taXNlID0gX3JlZi5wcm9taXNlLCByZXNvbHZlID0gX3JlZi5yZXNvbHZlLCByZWplY3QgPSBfcmVmLnJlamVjdDtcbiAgICAgIHByb21pc2UudGhlbihvblN1Y2Nlc3MsIG9uRXJyb3IpO1xuICAgICAgbm90aWZ5ID0gb25Qcm9ncmVzcyAhPSBudWxsID8gb25Qcm9ncmVzcyA6IChmdW5jdGlvbigpIHt9KTtcbiAgICAgIHJlc3AgPSB0aGlzLmZldGNoU3RhdHVzKCk7XG4gICAgICByZXNwLnRoZW4obnVsbCwgcmVqZWN0KTtcbiAgICAgIGJhY2tPZmYgPSB0aGlzLmRlY2F5O1xuICAgICAgdGhpcy5kZWNheSA9IE1hdGgubWluKE9ORV9NSU5VVEUsIGJhY2tPZmYgKiAxLjI1KTtcbiAgICAgIHJlc3AudGhlbigoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0YXR1cykge1xuICAgICAgICAgIG5vdGlmeShzdGF0dXMpO1xuICAgICAgICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlICdTVUNDRVNTJzpcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmZldGNoUmVzdWx0cygpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIGNhc2UgJ0VSUk9SJzpcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmZldGNoRXJyb3JNZXNzYWdlKCkudGhlbihyZWplY3QsIHJlamVjdCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnBvbGwocmVzb2x2ZSwgcmVqZWN0LCBub3RpZnkpO1xuICAgICAgICAgICAgICB9KSwgYmFja09mZik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcblxuICAgIHJldHVybiBJRFJlc29sdXRpb25Kb2I7XG5cbiAgfSkoKTtcblxuICBJRFJlc29sdXRpb25Kb2IucHJvdG90eXBlLndhaXQgPSBJRFJlc29sdXRpb25Kb2IucHJvdG90eXBlLnBvbGw7XG5cbiAgSURSZXNvbHV0aW9uSm9iLmNyZWF0ZSA9IGZ1bmN0aW9uKHNlcnZpY2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odWlkKSB7XG4gICAgICByZXR1cm4gbmV3IElEUmVzb2x1dGlvbkpvYih1aWQsIHNlcnZpY2UpO1xuICAgIH07XG4gIH07XG5cbiAgaW50ZXJtaW5lLklEUmVzb2x1dGlvbkpvYiA9IElEUmVzb2x1dGlvbkpvYjtcblxuICBpbnRlcm1pbmUuQ2F0ZWdvcnlSZXN1bHRzID0gQ2F0ZWdvcnlSZXN1bHRzO1xuXG4gIGludGVybWluZS5JZFJlc3VsdHMgPSBJZFJlc3VsdHM7XG5cbn0pLmNhbGwodGhpcyk7XG5cbn0se1wiLi91dGlsXCI6MTV9XSw1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbigpIHtcbiAgdmFyIElOVklURVMsIExpc3QsIFJFUVVJUkVTX1ZFUlNJT04sIFNIQVJFUywgVEFHU19QQVRILCBkZWpvaW4sIGdldCwgZ2V0Rm9sZGVyTmFtZSwgaW50ZXJtaW5lLCBpbnZva2UsIGlzRm9sZGVyLCBtZXJnZSwgc2V0LCB1dGlscywgd2l0aENCLFxuICAgIF9fYmluZCA9IGZ1bmN0aW9uKGZuLCBtZSl7IHJldHVybiBmdW5jdGlvbigpeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH0sXG4gICAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXG4gICAgX19pbmRleE9mID0gW10uaW5kZXhPZiB8fCBmdW5jdGlvbihpdGVtKSB7IGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKSByZXR1cm4gaTsgfSByZXR1cm4gLTE7IH07XG5cbiAgdXRpbHMgPSBfZGVyZXFfKCcuL3V0aWwnKTtcblxuICBpbnRlcm1pbmUgPSBleHBvcnRzO1xuXG4gIG1lcmdlID0gdXRpbHMubWVyZ2UsIHdpdGhDQiA9IHV0aWxzLndpdGhDQiwgZ2V0ID0gdXRpbHMuZ2V0LCBpbnZva2UgPSB1dGlscy5pbnZva2UsIFJFUVVJUkVTX1ZFUlNJT04gPSB1dGlscy5SRVFVSVJFU19WRVJTSU9OLCBzZXQgPSB1dGlscy5zZXQsIGRlam9pbiA9IHV0aWxzLmRlam9pbjtcblxuICBUQUdTX1BBVEggPSBcImxpc3QvdGFnc1wiO1xuXG4gIFNIQVJFUyA9IFwibGlzdHMvc2hhcmVzXCI7XG5cbiAgSU5WSVRFUyA9ICdsaXN0cy9pbnZpdGF0aW9ucyc7XG5cbiAgaXNGb2xkZXIgPSBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHQuc3Vic3RyKDAsIHQuaW5kZXhPZignOicpKSA9PT0gJ19fZm9sZGVyX18nO1xuICB9O1xuXG4gIGdldEZvbGRlck5hbWUgPSBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHQuc3Vic3RyKHQuaW5kZXhPZignOicpICsgMSk7XG4gIH07XG5cbiAgTGlzdCA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgZ2V0VGFncztcblxuICAgIGZ1bmN0aW9uIExpc3QocHJvcGVydGllcywgc2VydmljZSkge1xuICAgICAgdmFyIGssIHY7XG4gICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgICAgdGhpcy5fdXBkYXRlVGFncyA9IF9fYmluZCh0aGlzLl91cGRhdGVUYWdzLCB0aGlzKTtcbiAgICAgIHRoaXMuaGFzVGFnID0gX19iaW5kKHRoaXMuaGFzVGFnLCB0aGlzKTtcbiAgICAgIGZvciAoayBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmICghX19oYXNQcm9wLmNhbGwocHJvcGVydGllcywgaykpIGNvbnRpbnVlO1xuICAgICAgICB2ID0gcHJvcGVydGllc1trXTtcbiAgICAgICAgdGhpc1trXSA9IHY7XG4gICAgICB9XG4gICAgICB0aGlzLmRhdGVDcmVhdGVkID0gKHRoaXMuZGF0ZUNyZWF0ZWQgIT0gbnVsbCkgPyBuZXcgRGF0ZSh0aGlzLmRhdGVDcmVhdGVkKSA6IG51bGw7XG4gICAgICB0aGlzLmZvbGRlcnMgPSB0aGlzLnRhZ3MuZmlsdGVyKGlzRm9sZGVyKS5tYXAoZ2V0Rm9sZGVyTmFtZSk7XG4gICAgfVxuXG4gICAgTGlzdC5wcm90b3R5cGUuaGFzVGFnID0gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIF9faW5kZXhPZi5jYWxsKHRoaXMudGFncywgdCkgPj0gMDtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbih2aWV3KSB7XG4gICAgICBpZiAodmlldyA9PSBudWxsKSB7XG4gICAgICAgIHZpZXcgPSBbJyonXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnNlcnZpY2UucXVlcnkoe1xuICAgICAgICBzZWxlY3Q6IHZpZXcsXG4gICAgICAgIGZyb206IHRoaXMudHlwZSxcbiAgICAgICAgd2hlcmU6IFtbdGhpcy50eXBlLCAnSU4nLCB0aGlzLm5hbWVdXVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uKGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXJ2aWNlLm1ha2VSZXF1ZXN0KCdERUxFVEUnLCAnbGlzdHMnLCB7XG4gICAgICAgIG5hbWU6IHRoaXMubmFtZVxuICAgICAgfSwgY2IpO1xuICAgIH07XG5cbiAgICBnZXRUYWdzID0gZnVuY3Rpb24oX2FyZykge1xuICAgICAgdmFyIHRhZ3M7XG4gICAgICB0YWdzID0gX2FyZy50YWdzO1xuICAgICAgcmV0dXJuIHRhZ3M7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLl91cGRhdGVUYWdzID0gZnVuY3Rpb24oZXJyLCB0YWdzKSB7XG4gICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy50YWdzID0gdGFncy5zbGljZSgpO1xuICAgICAgcmV0dXJuIHRoaXMuZm9sZGVycyA9IHRoaXMudGFncy5maWx0ZXIoaXNGb2xkZXIpLm1hcChnZXRGb2xkZXJOYW1lKTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUuZmV0Y2hUYWdzID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgIHJldHVybiB3aXRoQ0IodGhpcy5fdXBkYXRlVGFncywgY2IsIHRoaXMuc2VydmljZS5tYWtlUmVxdWVzdCgnR0VUJywgJ2xpc3QvdGFncycsIHtcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lXG4gICAgICB9KS50aGVuKGdldFRhZ3MpKTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUuYWRkVGFncyA9IGZ1bmN0aW9uKHRhZ3MsIGNiKSB7XG4gICAgICB2YXIgcmVxO1xuICAgICAgcmVxID0ge1xuICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIHRhZ3M6IHRhZ3NcbiAgICAgIH07XG4gICAgICByZXR1cm4gd2l0aENCKHRoaXMuX3VwZGF0ZVRhZ3MsIGNiLCB0aGlzLnNlcnZpY2UubWFrZVJlcXVlc3QoJ1BPU1QnLCAnbGlzdC90YWdzJywgcmVxKS50aGVuKGdldFRhZ3MpKTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUucmVtb3ZlVGFncyA9IGZ1bmN0aW9uKHRhZ3MsIGNiKSB7XG4gICAgICB2YXIgcmVxO1xuICAgICAgcmVxID0ge1xuICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIHRhZ3M6IHRhZ3NcbiAgICAgIH07XG4gICAgICByZXR1cm4gd2l0aENCKHRoaXMuX3VwZGF0ZVRhZ3MsIGNiLCB0aGlzLnNlcnZpY2UubWFrZVJlcXVlc3QoJ0RFTEVURScsICdsaXN0L3RhZ3MnLCByZXEpLnRoZW4oZ2V0VGFncykpO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5jb250ZW50cyA9IGZ1bmN0aW9uKGNiKSB7XG4gICAgICByZXR1cm4gd2l0aENCKGNiLCB0aGlzLnF1ZXJ5KCkudGhlbihkZWpvaW4pLnRoZW4oaW52b2tlKCdyZWNvcmRzJykpKTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUucmVuYW1lID0gZnVuY3Rpb24obmV3TmFtZSwgY2IpIHtcbiAgICAgIHZhciBwcm9taXNlO1xuICAgICAgcHJvbWlzZSA9IHRoaXMuc2VydmljZS5wb3N0KCdsaXN0cy9yZW5hbWUnLCB7XG4gICAgICAgIG9sZG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgbmV3bmFtZTogbmV3TmFtZVxuICAgICAgfSkudGhlbihnZXQoJ2xpc3ROYW1lJykpLnRoZW4oKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLm5hbWUgPSBuO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpLnRoZW4odGhpcy5zZXJ2aWNlLmZldGNoTGlzdCk7XG4gICAgICByZXR1cm4gd2l0aENCKGNiLCBwcm9taXNlKTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKG9wdHMsIGNiKSB7XG4gICAgICB2YXIgYmFzZU5hbWUsIG5hbWUsIHF1ZXJ5LCB0YWdzLCBfcmVmLCBfcmVmMSwgX3JlZjI7XG4gICAgICBpZiAob3B0cyA9PSBudWxsKSB7XG4gICAgICAgIG9wdHMgPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChjYiA9PSBudWxsKSB7XG4gICAgICAgIGNiID0gKGZ1bmN0aW9uKCkge30pO1xuICAgICAgfVxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdXRpbHMuaXNGdW5jdGlvbihvcHRzKSkge1xuICAgICAgICBfcmVmID0gW3t9LCBvcHRzXSwgb3B0cyA9IF9yZWZbMF0sIGNiID0gX3JlZlsxXTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb3B0cyA9IHtcbiAgICAgICAgICBuYW1lOiBvcHRzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBuYW1lID0gYmFzZU5hbWUgPSAoX3JlZjEgPSBvcHRzLm5hbWUpICE9IG51bGwgPyBfcmVmMSA6IFwiXCIgKyB0aGlzLm5hbWUgKyBcIl9jb3B5XCI7XG4gICAgICB0YWdzID0gdGhpcy50YWdzLmNvbmNhdCgoX3JlZjIgPSBvcHRzLnRhZ3MpICE9IG51bGwgPyBfcmVmMiA6IFtdKTtcbiAgICAgIHF1ZXJ5ID0gdGhpcy5xdWVyeShbJ2lkJ10pO1xuICAgICAgcmV0dXJuIHdpdGhDQihjYiwgdGhpcy5zZXJ2aWNlLmZldGNoTGlzdHMoKS50aGVuKGludm9rZSgnbWFwJywgZ2V0KCduYW1lJykpKS50aGVuKChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24obmFtZXMpIHtcbiAgICAgICAgICB2YXIgYztcbiAgICAgICAgICBjID0gMTtcbiAgICAgICAgICB3aGlsZSAoX19pbmRleE9mLmNhbGwobmFtZXMsIG5hbWUpID49IDApIHtcbiAgICAgICAgICAgIG5hbWUgPSBcIlwiICsgYmFzZU5hbWUgKyBcIi1cIiArIChjKyspO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcXVlcnkudGhlbihpbnZva2UoJ3NhdmVBc0xpc3QnLCB7XG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgdGFnczogdGFncyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBfdGhpcy5kZXNjcmlwdGlvblxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKSk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLmVucmljaG1lbnQgPSBmdW5jdGlvbihvcHRzLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuc2VydmljZS5lbnJpY2htZW50KG1lcmdlKHtcbiAgICAgICAgbGlzdDogdGhpcy5uYW1lXG4gICAgICB9LCBvcHRzKSwgY2IpO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5zaGFyZVdpdGhVc2VyID0gZnVuY3Rpb24ocmVjaXBpZW50LCBjYikge1xuICAgICAgcmV0dXJuIHdpdGhDQihjYiwgdGhpcy5zZXJ2aWNlLnBvc3QoU0hBUkVTLCB7XG4gICAgICAgICdsaXN0JzogdGhpcy5uYW1lLFxuICAgICAgICAnd2l0aCc6IHJlY2lwaWVudFxuICAgICAgfSkpO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5pbnZpdGVVc2VyVG9TaGFyZSA9IGZ1bmN0aW9uKHJlY2lwaWVudCwgbm90aWZ5LCBjYikge1xuICAgICAgaWYgKG5vdGlmeSA9PSBudWxsKSB7XG4gICAgICAgIG5vdGlmeSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoY2IgPT0gbnVsbCkge1xuICAgICAgICBjYiA9IChmdW5jdGlvbigpIHt9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3aXRoQ0IoY2IsIHRoaXMuc2VydmljZS5wb3N0KElOVklURVMsIHtcbiAgICAgICAgbGlzdDogdGhpcy5uYW1lLFxuICAgICAgICB0bzogcmVjaXBpZW50LFxuICAgICAgICBub3RpZnk6ICEhbm90aWZ5XG4gICAgICB9KSk7XG4gICAgfTtcblxuICAgIHJldHVybiBMaXN0O1xuXG4gIH0pKCk7XG5cbiAgaW50ZXJtaW5lLkxpc3QgPSBMaXN0O1xuXG59KS5jYWxsKHRoaXMpO1xuXG59LHtcIi4vdXRpbFwiOjE1fV0sNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBKQVZBX0xBTkdfT0JKLCBNb2RlbCwgUGF0aEluZm8sIFRhYmxlLCBlcnJvciwgZmluZCwgZmxhdHRlbiwgaW50ZXJtaW5lLCBvbWFwLCBfcmVmLFxuICAgIF9fYmluZCA9IGZ1bmN0aW9uKGZuLCBtZSl7IHJldHVybiBmdW5jdGlvbigpeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH0sXG4gICAgX19pbmRleE9mID0gW10uaW5kZXhPZiB8fCBmdW5jdGlvbihpdGVtKSB7IGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKSByZXR1cm4gaTsgfSByZXR1cm4gLTE7IH07XG5cbiAgVGFibGUgPSBfZGVyZXFfKCcuL3RhYmxlJykuVGFibGU7XG5cbiAgUGF0aEluZm8gPSBfZGVyZXFfKCcuL3BhdGgnKS5QYXRoSW5mbztcblxuICBfcmVmID0gX2RlcmVxXygnLi91dGlsJyksIGZsYXR0ZW4gPSBfcmVmLmZsYXR0ZW4sIGZpbmQgPSBfcmVmLmZpbmQsIGVycm9yID0gX3JlZi5lcnJvciwgb21hcCA9IF9yZWYub21hcDtcblxuICBpbnRlcm1pbmUgPSBleHBvcnRzO1xuXG4gIEpBVkFfTEFOR19PQkogPSBuZXcgVGFibGUoe1xuICAgIG5hbWU6ICdPYmplY3QnLFxuICAgIHRhZ3M6IFtdLFxuICAgIGRpc3BsYXlOYW1lOiAnT2JqZWN0JyxcbiAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICByZWZlcmVuY2VzOiB7fSxcbiAgICBjb2xsZWN0aW9uczoge31cbiAgfSk7XG5cbiAgTW9kZWwgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gTW9kZWwoX2FyZykge1xuICAgICAgdmFyIGNsYXNzZXMsIGxpZnRUb1RhYmxlO1xuICAgICAgdGhpcy5uYW1lID0gX2FyZy5uYW1lLCBjbGFzc2VzID0gX2FyZy5jbGFzc2VzO1xuICAgICAgdGhpcy5maW5kQ29tbW9uVHlwZSA9IF9fYmluZCh0aGlzLmZpbmRDb21tb25UeXBlLCB0aGlzKTtcbiAgICAgIHRoaXMuZmluZFNoYXJlZEFuY2VzdG9yID0gX19iaW5kKHRoaXMuZmluZFNoYXJlZEFuY2VzdG9yLCB0aGlzKTtcbiAgICAgIHRoaXMuZ2V0QW5jZXN0b3JzT2YgPSBfX2JpbmQodGhpcy5nZXRBbmNlc3RvcnNPZiwgdGhpcyk7XG4gICAgICB0aGlzLmdldFN1YmNsYXNzZXNPZiA9IF9fYmluZCh0aGlzLmdldFN1YmNsYXNzZXNPZiwgdGhpcyk7XG4gICAgICB0aGlzLmdldFBhdGhJbmZvID0gX19iaW5kKHRoaXMuZ2V0UGF0aEluZm8sIHRoaXMpO1xuICAgICAgbGlmdFRvVGFibGUgPSBvbWFwKChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oaywgdikge1xuICAgICAgICAgIHJldHVybiBbaywgbmV3IFRhYmxlKHYsIF90aGlzKV07XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgICB0aGlzLmNsYXNzZXMgPSBsaWZ0VG9UYWJsZShjbGFzc2VzKTtcbiAgICAgIHRoaXMuY2xhc3Nlc1snamF2YS5sYW5nLk9iamVjdCddID0gSkFWQV9MQU5HX09CSjtcbiAgICB9XG5cbiAgICBNb2RlbC5wcm90b3R5cGUuZ2V0UGF0aEluZm8gPSBmdW5jdGlvbihwYXRoLCBzdWJjbHMpIHtcbiAgICAgIHJldHVybiBQYXRoSW5mby5wYXJzZSh0aGlzLCBwYXRoLCBzdWJjbHMpO1xuICAgIH07XG5cbiAgICBNb2RlbC5wcm90b3R5cGUuZ2V0U3ViY2xhc3Nlc09mID0gZnVuY3Rpb24oY2xzKSB7XG4gICAgICB2YXIgY2QsIGNsYXp6LCByZXQsIF8sIF9yZWYxLCBfcmVmMjtcbiAgICAgIGNsYXp6ID0gY2xzICYmIGNscy5uYW1lID8gY2xzIDogdGhpcy5jbGFzc2VzW2Nsc107XG4gICAgICBpZiAoY2xhenogPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIiArIGNscyArIFwiIGlzIG5vdCBhIHRhYmxlXCIpO1xuICAgICAgfVxuICAgICAgcmV0ID0gW2NsYXp6Lm5hbWVdO1xuICAgICAgX3JlZjEgPSB0aGlzLmNsYXNzZXM7XG4gICAgICBmb3IgKF8gaW4gX3JlZjEpIHtcbiAgICAgICAgY2QgPSBfcmVmMVtfXTtcbiAgICAgICAgaWYgKF9yZWYyID0gY2xhenoubmFtZSwgX19pbmRleE9mLmNhbGwoY2QucGFyZW50cygpLCBfcmVmMikgPj0gMCkge1xuICAgICAgICAgIHJldCA9IHJldC5jb25jYXQodGhpcy5nZXRTdWJjbGFzc2VzT2YoY2QpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgTW9kZWwucHJvdG90eXBlLmdldEFuY2VzdG9yc09mID0gZnVuY3Rpb24oY2xzKSB7XG4gICAgICB2YXIgY2xhenosIHBhcmVudHM7XG4gICAgICBjbGF6eiA9IGNscyAmJiBjbHMubmFtZSA/IGNscyA6IHRoaXMuY2xhc3Nlc1tjbHNdO1xuICAgICAgaWYgKGNsYXp6ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIgKyBjbHMgKyBcIiBpcyBub3QgYSB0YWJsZVwiKTtcbiAgICAgIH1cbiAgICAgIHBhcmVudHMgPSBjbGF6ei5wYXJlbnRzKCk7XG4gICAgICByZXR1cm4gcGFyZW50cy5maWx0ZXIoKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmNsYXNzZXNbcF07XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSkucmVkdWNlKCgoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGFzLCBwKSB7XG4gICAgICAgICAgcmV0dXJuIGFzLmNvbmNhdChfdGhpcy5nZXRBbmNlc3RvcnNPZihwKSk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSksIHBhcmVudHMpO1xuICAgIH07XG5cbiAgICBNb2RlbC5wcm90b3R5cGUuZmluZFNoYXJlZEFuY2VzdG9yID0gZnVuY3Rpb24oY2xhc3NBLCBjbGFzc0IpIHtcbiAgICAgIHZhciBhX2FuY2VzdHJ5LCBiX2FuY2VzdHJ5LCBmaXJzdENvbW1vbjtcbiAgICAgIGlmIChjbGFzc0IgPT09IG51bGwgfHwgY2xhc3NBID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGNsYXNzQSA9PT0gY2xhc3NCKSB7XG4gICAgICAgIHJldHVybiBjbGFzc0E7XG4gICAgICB9XG4gICAgICBhX2FuY2VzdHJ5ID0gdGhpcy5nZXRBbmNlc3RvcnNPZihjbGFzc0EpO1xuICAgICAgaWYgKF9faW5kZXhPZi5jYWxsKGFfYW5jZXN0cnksIGNsYXNzQikgPj0gMCkge1xuICAgICAgICByZXR1cm4gY2xhc3NCO1xuICAgICAgfVxuICAgICAgYl9hbmNlc3RyeSA9IHRoaXMuZ2V0QW5jZXN0b3JzT2YoY2xhc3NCKTtcbiAgICAgIGlmIChfX2luZGV4T2YuY2FsbChiX2FuY2VzdHJ5LCBjbGFzc0EpID49IDApIHtcbiAgICAgICAgcmV0dXJuIGNsYXNzQTtcbiAgICAgIH1cbiAgICAgIGZpcnN0Q29tbW9uID0gZmluZChhX2FuY2VzdHJ5LCBmdW5jdGlvbihhKSB7XG4gICAgICAgIHJldHVybiBfX2luZGV4T2YuY2FsbChiX2FuY2VzdHJ5LCBhKSA+PSAwO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZmlyc3RDb21tb247XG4gICAgfTtcblxuICAgIE1vZGVsLnByb3RvdHlwZS5maW5kQ29tbW9uVHlwZSA9IGZ1bmN0aW9uKHhzKSB7XG4gICAgICBpZiAoeHMgPT0gbnVsbCkge1xuICAgICAgICB4cyA9IFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHhzLnJlZHVjZSh0aGlzLmZpbmRTaGFyZWRBbmNlc3Rvcik7XG4gICAgfTtcblxuICAgIHJldHVybiBNb2RlbDtcblxuICB9KSgpO1xuXG4gIE1vZGVsLnByb3RvdHlwZS5tYWtlUGF0aCA9IE1vZGVsLnByb3RvdHlwZS5nZXRQYXRoSW5mbztcblxuICBNb2RlbC5wcm90b3R5cGUuZmluZENvbW1vblR5cGVPZk11bHRpcGxlQ2xhc3NlcyA9IE1vZGVsLnByb3RvdHlwZS5maW5kQ29tbW9uVHlwZTtcblxuICBNb2RlbC5sb2FkID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciBlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IE1vZGVsKGRhdGEpO1xuICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgZSA9IF9lcnJvcjtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIGxvYWRpbmcgbW9kZWw6IFwiICsgZSk7XG4gICAgfVxuICB9O1xuXG4gIE1vZGVsLklOVEVHUkFMX1RZUEVTID0gW1wiaW50XCIsIFwiSW50ZWdlclwiLCBcImxvbmdcIiwgXCJMb25nXCJdO1xuXG4gIE1vZGVsLkZSQUNUSU9OQUxfVFlQRVMgPSBbXCJkb3VibGVcIiwgXCJEb3VibGVcIiwgXCJmbG9hdFwiLCBcIkZsb2F0XCJdO1xuXG4gIE1vZGVsLk5VTUVSSUNfVFlQRVMgPSBNb2RlbC5JTlRFR1JBTF9UWVBFUy5jb25jYXQoTW9kZWwuRlJBQ1RJT05BTF9UWVBFUyk7XG5cbiAgTW9kZWwuQk9PTEVBTl9UWVBFUyA9IFtcImJvb2xlYW5cIiwgXCJCb29sZWFuXCJdO1xuXG4gIGludGVybWluZS5Nb2RlbCA9IE1vZGVsO1xuXG59KS5jYWxsKHRoaXMpO1xuXG59LHtcIi4vcGF0aFwiOjcsXCIuL3RhYmxlXCI6MTMsXCIuL3V0aWxcIjoxNX1dLDc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgTkFNRVMsIFBBUlNFRCwgUGF0aEluZm8sIGFueSwgY29uY2F0TWFwLCBjb3B5LCBlcnJvciwgZ2V0LCBpbnRlcm1pbmUsIG1ha2VLZXksIHNldCwgc3VjY2VzcywgdXRpbHMsIHdpdGhDQixcbiAgICBfX2JpbmQgPSBmdW5jdGlvbihmbiwgbWUpeyByZXR1cm4gZnVuY3Rpb24oKXsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9LFxuICAgIF9fc2xpY2UgPSBbXS5zbGljZSxcbiAgICBfX2luZGV4T2YgPSBbXS5pbmRleE9mIHx8IGZ1bmN0aW9uKGl0ZW0pIHsgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykgeyBpZiAoaSBpbiB0aGlzICYmIHRoaXNbaV0gPT09IGl0ZW0pIHJldHVybiBpOyB9IHJldHVybiAtMTsgfTtcblxuICBpbnRlcm1pbmUgPSBleHBvcnRzO1xuXG4gIHV0aWxzID0gX2RlcmVxXygnLi91dGlsJyk7XG5cbiAgd2l0aENCID0gdXRpbHMud2l0aENCLCBjb25jYXRNYXAgPSB1dGlscy5jb25jYXRNYXAsIGdldCA9IHV0aWxzLmdldCwgYW55ID0gdXRpbHMuYW55LCBzZXQgPSB1dGlscy5zZXQsIGNvcHkgPSB1dGlscy5jb3B5LCBzdWNjZXNzID0gdXRpbHMuc3VjY2VzcywgZXJyb3IgPSB1dGlscy5lcnJvcjtcblxuICBOQU1FUyA9IHt9O1xuXG4gIFBBUlNFRCA9IHt9O1xuXG4gIG1ha2VLZXkgPSBmdW5jdGlvbihtb2RlbCwgcGF0aCwgc3ViY2xhc3Nlcykge1xuICAgIHZhciBrLCB2LCBfcmVmO1xuICAgIHJldHVybiBcIlwiICsgKG1vZGVsICE9IG51bGwgPyBtb2RlbC5uYW1lIDogdm9pZCAwKSArIFwifFwiICsgKG1vZGVsICE9IG51bGwgPyAoX3JlZiA9IG1vZGVsLnNlcnZpY2UpICE9IG51bGwgPyBfcmVmLnJvb3QgOiB2b2lkIDAgOiB2b2lkIDApICsgXCJ8XCIgKyBwYXRoICsgXCI6XCIgKyAoKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIF9yZXN1bHRzO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoayBpbiBzdWJjbGFzc2VzKSB7XG4gICAgICAgIHYgPSBzdWJjbGFzc2VzW2tdO1xuICAgICAgICBfcmVzdWx0cy5wdXNoKFwiXCIgKyBrICsgXCI9XCIgKyB2KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9KSgpKTtcbiAgfTtcblxuICBQYXRoSW5mbyA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBQYXRoSW5mbyhfYXJnKSB7XG4gICAgICB2YXIgX2ksIF9yZWY7XG4gICAgICB0aGlzLnJvb3QgPSBfYXJnLnJvb3QsIHRoaXMubW9kZWwgPSBfYXJnLm1vZGVsLCB0aGlzLmRlc2NyaXB0b3JzID0gX2FyZy5kZXNjcmlwdG9ycywgdGhpcy5zdWJjbGFzc2VzID0gX2FyZy5zdWJjbGFzc2VzLCB0aGlzLmRpc3BsYXlOYW1lID0gX2FyZy5kaXNwbGF5TmFtZSwgdGhpcy5pZGVudCA9IF9hcmcuaWRlbnQ7XG4gICAgICB0aGlzLmFsbERlc2NyaXB0b3JzID0gX19iaW5kKHRoaXMuYWxsRGVzY3JpcHRvcnMsIHRoaXMpO1xuICAgICAgdGhpcy5nZXRDaGlsZE5vZGVzID0gX19iaW5kKHRoaXMuZ2V0Q2hpbGROb2RlcywgdGhpcyk7XG4gICAgICB0aGlzLmdldERpc3BsYXlOYW1lID0gX19iaW5kKHRoaXMuZ2V0RGlzcGxheU5hbWUsIHRoaXMpO1xuICAgICAgdGhpcy5pc2EgPSBfX2JpbmQodGhpcy5pc2EsIHRoaXMpO1xuICAgICAgdGhpcy5hcHBlbmQgPSBfX2JpbmQodGhpcy5hcHBlbmQsIHRoaXMpO1xuICAgICAgdGhpcy5nZXRQYXJlbnQgPSBfX2JpbmQodGhpcy5nZXRQYXJlbnQsIHRoaXMpO1xuICAgICAgdGhpcy5nZXRFbmRDbGFzcyA9IF9fYmluZCh0aGlzLmdldEVuZENsYXNzLCB0aGlzKTtcbiAgICAgIHRoaXMuY29udGFpbnNDb2xsZWN0aW9uID0gX19iaW5kKHRoaXMuY29udGFpbnNDb2xsZWN0aW9uLCB0aGlzKTtcbiAgICAgIHRoaXMuaXNDb2xsZWN0aW9uID0gX19iaW5kKHRoaXMuaXNDb2xsZWN0aW9uLCB0aGlzKTtcbiAgICAgIHRoaXMuaXNSZXZlcnNlUmVmZXJlbmNlID0gX19iaW5kKHRoaXMuaXNSZXZlcnNlUmVmZXJlbmNlLCB0aGlzKTtcbiAgICAgIHRoaXMuaXNSZWZlcmVuY2UgPSBfX2JpbmQodGhpcy5pc1JlZmVyZW5jZSwgdGhpcyk7XG4gICAgICB0aGlzLmlzQ2xhc3MgPSBfX2JpbmQodGhpcy5pc0NsYXNzLCB0aGlzKTtcbiAgICAgIHRoaXMuaXNBdHRyaWJ1dGUgPSBfX2JpbmQodGhpcy5pc0F0dHJpYnV0ZSwgdGhpcyk7XG4gICAgICB0aGlzLmlzUm9vdCA9IF9fYmluZCh0aGlzLmlzUm9vdCwgdGhpcyk7XG4gICAgICBfcmVmID0gdGhpcy5kZXNjcmlwdG9ycywgdGhpcy5taWQgPSAyIDw9IF9yZWYubGVuZ3RoID8gX19zbGljZS5jYWxsKF9yZWYsIDAsIF9pID0gX3JlZi5sZW5ndGggLSAxKSA6IChfaSA9IDAsIFtdKSwgdGhpcy5lbmQgPSBfcmVmW19pKytdO1xuICAgICAgaWYgKHRoaXMuaWRlbnQgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmlkZW50ID0gbWFrZUtleSh0aGlzLm1vZGVsLCB0aGlzLCB0aGlzLnN1YmNsYXNzZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIFBhdGhJbmZvLnByb3RvdHlwZS5pc1Jvb3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlc2NyaXB0b3JzLmxlbmd0aCA9PT0gMDtcbiAgICB9O1xuXG4gICAgUGF0aEluZm8ucHJvdG90eXBlLmlzQXR0cmlidXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKHRoaXMuZW5kICE9IG51bGwpICYmICF0aGlzLmlzUmVmZXJlbmNlKCk7XG4gICAgfTtcblxuICAgIFBhdGhJbmZvLnByb3RvdHlwZS5pc0NsYXNzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1Jvb3QoKSB8fCB0aGlzLmlzUmVmZXJlbmNlKCk7XG4gICAgfTtcblxuICAgIFBhdGhJbmZvLnByb3RvdHlwZS5pc1JlZmVyZW5jZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIF9yZWY7XG4gICAgICByZXR1cm4gKChfcmVmID0gdGhpcy5lbmQpICE9IG51bGwgPyBfcmVmLnJlZmVyZW5jZWRUeXBlIDogdm9pZCAwKSAhPSBudWxsO1xuICAgIH07XG5cbiAgICBQYXRoSW5mby5wcm90b3R5cGUuaXNSZXZlcnNlUmVmZXJlbmNlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZ3AsIHAsIHJlZmVyZW5jZWRUeXBlLCByZXZlcnNlUmVmZXJlbmNlLCBfcmVmO1xuICAgICAgaWYgKHRoaXMuaXNSZWZlcmVuY2UoKSAmJiAodGhpcy5taWQubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgX3JlZiA9IHRoaXMuZW5kLCByZXZlcnNlUmVmZXJlbmNlID0gX3JlZi5yZXZlcnNlUmVmZXJlbmNlLCByZWZlcmVuY2VkVHlwZSA9IF9yZWYucmVmZXJlbmNlZFR5cGU7XG4gICAgICAgIHAgPSB0aGlzLmdldFBhcmVudCgpO1xuICAgICAgICBncCA9IHAuZ2V0UGFyZW50KCk7XG4gICAgICAgIHJldHVybiAocmVmZXJlbmNlZFR5cGUgIT0gbnVsbCkgJiYgKGdwLmlzYShyZWZlcmVuY2VkVHlwZSkpICYmIChwLmVuZC5uYW1lID09PSByZXZlcnNlUmVmZXJlbmNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgUGF0aEluZm8ucHJvdG90eXBlLmlzQ29sbGVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIF9yZWYsIF9yZWYxO1xuICAgICAgcmV0dXJuIChfcmVmID0gKF9yZWYxID0gdGhpcy5lbmQpICE9IG51bGwgPyBfcmVmMS5pc0NvbGxlY3Rpb24gOiB2b2lkIDApICE9IG51bGwgPyBfcmVmIDogZmFsc2U7XG4gICAgfTtcblxuICAgIFBhdGhJbmZvLnByb3RvdHlwZS5jb250YWluc0NvbGxlY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBhbnkodGhpcy5kZXNjcmlwdG9ycywgZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4geC5pc0NvbGxlY3Rpb247XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgUGF0aEluZm8ucHJvdG90eXBlLmdldEVuZENsYXNzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3JlZjtcbiAgICAgIHJldHVybiB0aGlzLm1vZGVsLmNsYXNzZXNbdGhpcy5zdWJjbGFzc2VzW3RoaXMudG9TdHJpbmcoKV0gfHwgKChfcmVmID0gdGhpcy5lbmQpICE9IG51bGwgPyBfcmVmLnJlZmVyZW5jZWRUeXBlIDogdm9pZCAwKV0gfHwgdGhpcy5yb290O1xuICAgIH07XG5cbiAgICBQYXRoSW5mby5wcm90b3R5cGUuZ2V0UGFyZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGF0YTtcbiAgICAgIGlmICh0aGlzLmlzUm9vdCgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJvb3QgcGF0aHMgZG8gbm90IGhhdmUgcGFyZW50c1wiKTtcbiAgICAgIH1cbiAgICAgIGRhdGEgPSB7XG4gICAgICAgIHJvb3Q6IHRoaXMucm9vdCxcbiAgICAgICAgbW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICAgIGRlc2NyaXB0b3JzOiB0aGlzLm1pZC5zbGljZSgpLFxuICAgICAgICBzdWJjbGFzc2VzOiB0aGlzLnN1YmNsYXNzZXNcbiAgICAgIH07XG4gICAgICByZXR1cm4gbmV3IFBhdGhJbmZvKGRhdGEpO1xuICAgIH07XG5cbiAgICBQYXRoSW5mby5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24oYXR0cikge1xuICAgICAgdmFyIGRhdGEsIGZsZDtcbiAgICAgIGlmICh0aGlzLmlzQXR0cmlidXRlKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIgKyB0aGlzICsgXCIgaXMgYW4gYXR0cmlidXRlLlwiKTtcbiAgICAgIH1cbiAgICAgIGZsZCA9IHR5cGVvZiBhdHRyID09PSAnc3RyaW5nJyA/IHRoaXMuZ2V0VHlwZSgpLmZpZWxkc1thdHRyXSA6IGF0dHI7XG4gICAgICBpZiAoZmxkID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIgKyBhdHRyICsgXCIgaXMgbm90IGEgZmllbGQgb2YgXCIgKyAodGhpcy5nZXRUeXBlKCkpKTtcbiAgICAgIH1cbiAgICAgIGRhdGEgPSB7XG4gICAgICAgIHJvb3Q6IHRoaXMucm9vdCxcbiAgICAgICAgbW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICAgIGRlc2NyaXB0b3JzOiB0aGlzLmRlc2NyaXB0b3JzLmNvbmNhdChbZmxkXSksXG4gICAgICAgIHN1YmNsYXNzZXM6IHRoaXMuc3ViY2xhc3Nlc1xuICAgICAgfTtcbiAgICAgIHJldHVybiBuZXcgUGF0aEluZm8oZGF0YSk7XG4gICAgfTtcblxuICAgIFBhdGhJbmZvLnByb3RvdHlwZS5pc2EgPSBmdW5jdGlvbihjbGF6eikge1xuICAgICAgdmFyIG5hbWUsIHR5cGU7XG4gICAgICBpZiAoY2xhenogPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc0F0dHJpYnV0ZSgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFR5cGUoKSA9PT0gY2xheno7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuYW1lID0gY2xhenoubmFtZSA/IGNsYXp6Lm5hbWUgOiAnJyArIGNsYXp6O1xuICAgICAgICB0eXBlID0gdGhpcy5nZXRUeXBlKCk7XG4gICAgICAgIHJldHVybiAobmFtZSA9PT0gdHlwZS5uYW1lKSB8fCAoX19pbmRleE9mLmNhbGwodGhpcy5tb2RlbC5nZXRBbmNlc3RvcnNPZih0eXBlKSwgbmFtZSkgPj0gMCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFBhdGhJbmZvLnByb3RvdHlwZS5nZXREaXNwbGF5TmFtZSA9IGZ1bmN0aW9uKGNiKSB7XG4gICAgICB2YXIgY2FjaGVkLCBjdXN0b20sIHBhcmFtcywgcGF0aDtcbiAgICAgIGlmIChjdXN0b20gPSB0aGlzLmRpc3BsYXlOYW1lKSB7XG4gICAgICAgIHJldHVybiBzdWNjZXNzKGN1c3RvbSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5uYW1lUHJvbWlzZSA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMubmFtZVByb21pc2UgPSAoY2FjaGVkID0gTkFNRVNbdGhpcy5pZGVudF0pID8gc3VjY2VzcyhjYWNoZWQpIDogdGhpcy5pc1Jvb3QoKSAmJiB0aGlzLnJvb3QuZGlzcGxheU5hbWUgPyBzdWNjZXNzKHRoaXMucm9vdC5kaXNwbGF5TmFtZSkgOiB0aGlzLm1vZGVsLnNlcnZpY2UgPT0gbnVsbCA/IGVycm9yKFwiTm8gc2VydmljZVwiKSA6IChwYXRoID0gJ21vZGVsJyArIChjb25jYXRNYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICAgIHJldHVybiAnLycgKyBkLm5hbWU7XG4gICAgICAgIH0pKSh0aGlzLmFsbERlc2NyaXB0b3JzKCkpLCBwYXJhbXMgPSAoc2V0KHtcbiAgICAgICAgICBmb3JtYXQ6ICdqc29uJ1xuICAgICAgICB9KSkoY29weSh0aGlzLnN1YmNsYXNzZXMpKSwgdGhpcy5tb2RlbC5zZXJ2aWNlLmdldChwYXRoLCBwYXJhbXMpLnRoZW4oZ2V0KCdkaXNwbGF5JykpLnRoZW4oKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgIHZhciBfbmFtZTtcbiAgICAgICAgICAgIHJldHVybiBOQU1FU1tfbmFtZSA9IF90aGlzLmlkZW50XSAhPSBudWxsID8gTkFNRVNbX25hbWVdIDogTkFNRVNbX25hbWVdID0gbjtcbiAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdpdGhDQihjYiwgdGhpcy5uYW1lUHJvbWlzZSk7XG4gICAgfTtcblxuICAgIFBhdGhJbmZvLnByb3RvdHlwZS5nZXRDaGlsZE5vZGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZmxkLCBuYW1lLCBfcmVmLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgICBfcmVmMSA9ICgoX3JlZiA9IHRoaXMuZ2V0RW5kQ2xhc3MoKSkgIT0gbnVsbCA/IF9yZWYuZmllbGRzIDogdm9pZCAwKSB8fCB7fTtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKG5hbWUgaW4gX3JlZjEpIHtcbiAgICAgICAgZmxkID0gX3JlZjFbbmFtZV07XG4gICAgICAgIF9yZXN1bHRzLnB1c2godGhpcy5hcHBlbmQoZmxkKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIFBhdGhJbmZvLnByb3RvdHlwZS5hbGxEZXNjcmlwdG9ycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFt0aGlzLnJvb3RdLmNvbmNhdCh0aGlzLmRlc2NyaXB0b3JzKTtcbiAgICB9O1xuXG4gICAgUGF0aEluZm8ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5hbGxEZXNjcmlwdG9ycygpLm1hcChnZXQoJ25hbWUnKSkuam9pbignLicpO1xuICAgIH07XG5cbiAgICBQYXRoSW5mby5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzID09PSBvdGhlciB8fCAodGhpcy5pZGVudCAmJiAob3RoZXIgIT0gbnVsbCA/IG90aGVyLmlkZW50IDogdm9pZCAwKSA9PT0gdGhpcy5pZGVudCk7XG4gICAgfTtcblxuICAgIFBhdGhJbmZvLnByb3RvdHlwZS5nZXRUeXBlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3JlZiwgX3JlZjE7XG4gICAgICByZXR1cm4gKChfcmVmID0gdGhpcy5lbmQpICE9IG51bGwgPyAoX3JlZjEgPSBfcmVmLnR5cGUpICE9IG51bGwgPyBfcmVmMS5yZXBsYWNlKC9qYXZhXFwubGFuZ1xcLi8sICcnKSA6IHZvaWQgMCA6IHZvaWQgMCkgfHwgdGhpcy5nZXRFbmRDbGFzcygpO1xuICAgIH07XG5cbiAgICByZXR1cm4gUGF0aEluZm87XG5cbiAgfSkoKTtcblxuICBQYXRoSW5mby5wcm90b3R5cGUudG9QYXRoU3RyaW5nID0gUGF0aEluZm8ucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4gIFBhdGhJbmZvLnBhcnNlID0gZnVuY3Rpb24obW9kZWwsIHBhdGgsIHN1YmNsYXNzZXMpIHtcbiAgICB2YXIgY2FjaGVkLCBjZCwgZGVzY3JpcHRvcnMsIGZsZCwgaWRlbnQsIGtleVBhdGgsIHBhcnQsIHBhcnRzLCByb290O1xuICAgIGlmIChzdWJjbGFzc2VzID09IG51bGwpIHtcbiAgICAgIHN1YmNsYXNzZXMgPSB7fTtcbiAgICB9XG4gICAgaWRlbnQgPSBtYWtlS2V5KG1vZGVsLCBwYXRoLCBzdWJjbGFzc2VzKTtcbiAgICBpZiAoY2FjaGVkID0gUEFSU0VEW2lkZW50XSkge1xuICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gICAgcGFydHMgPSAocGF0aCArICcnKS5zcGxpdCgnLicpO1xuICAgIHJvb3QgPSBjZCA9IG1vZGVsLmNsYXNzZXNbcGFydHMuc2hpZnQoKV07XG4gICAga2V5UGF0aCA9IHJvb3QubmFtZTtcbiAgICBkZXNjcmlwdG9ycyA9IChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBwYXJ0cy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBwYXJ0ID0gcGFydHNbX2ldO1xuICAgICAgICBmbGQgPSAoY2QgIT0gbnVsbCA/IGNkLmZpZWxkc1twYXJ0XSA6IHZvaWQgMCkgfHwgKChfcmVmID0gKGNkID0gbW9kZWwuY2xhc3Nlc1tzdWJjbGFzc2VzW2tleVBhdGhdXSkpICE9IG51bGwgPyBfcmVmLmZpZWxkc1twYXJ0XSA6IHZvaWQgMCk7XG4gICAgICAgIGlmICghZmxkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgXCIgKyBwYXJ0ICsgXCIgaW4gXCIgKyBjZCArIFwiIHdoZW4gcGFyc2luZyBcIiArIHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGtleVBhdGggKz0gXCIuXCIgKyBwYXJ0O1xuICAgICAgICBjZCA9IG1vZGVsLmNsYXNzZXNbZmxkLnR5cGUgfHwgZmxkLnJlZmVyZW5jZWRUeXBlXTtcbiAgICAgICAgX3Jlc3VsdHMucHVzaChmbGQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIFBBUlNFRFtpZGVudF0gPSBuZXcgUGF0aEluZm8oe1xuICAgICAgcm9vdDogcm9vdCxcbiAgICAgIG1vZGVsOiBtb2RlbCxcbiAgICAgIGRlc2NyaXB0b3JzOiBkZXNjcmlwdG9ycyxcbiAgICAgIHN1YmNsYXNzZXM6IHN1YmNsYXNzZXMsXG4gICAgICBpZGVudDogaWRlbnRcbiAgICB9KTtcbiAgfTtcblxuICBQYXRoSW5mby5mbHVzaENhY2hlID0gZnVuY3Rpb24oKSB7XG4gICAgUEFSU0VEID0ge307XG4gICAgcmV0dXJuIE5BTUVTID0ge307XG4gIH07XG5cbiAgaW50ZXJtaW5lLlBhdGhJbmZvID0gUGF0aEluZm87XG5cbn0pLmNhbGwodGhpcyk7XG5cbn0se1wiLi91dGlsXCI6MTV9XSw4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbigpIHtcbiAgdmFyIFByb21pc2U7XG5cbiAgUHJvbWlzZSA9IF9kZXJlcV8oJ2VzNi1wcm9taXNlJykuUHJvbWlzZTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG5cbn0pLmNhbGwodGhpcyk7XG5cbn0se1wiZXM2LXByb21pc2VcIjoyMn1dLDk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgQkFTSUNfQVRUUlMsIENPREVTLCBFdmVudHMsIExJU1RfUElQRSwgUXVlcnksIFJFUVVJUkVTX1ZFUlNJT04sIFJFU1VMVFNfTUVUSE9EUywgU0lNUExFX0FUVFJTLCBiaW9VcmlBcmdzLCBjb25BdHRycywgY29uU3RyLCBjb25Ub0pTT04sIGNvblZhbFN0ciwgY29uY2F0TWFwLCBjb3B5Q29uLCBkZWNhcGl0YXRlLCBkaWRudFJlbW92ZSwgZiwgZmlsdGVyLCBmb2xkLCBnZXQsIGdldF9jYW5vbmljYWxfb3AsIGhlYWRMZXNzLCBpZCwgaWRDb25TdHIsIGludGVybWluZSwgaW50ZXJwcmV0Q29uQXJyYXksIGludGVycHJldENvbnN0cmFpbnQsIGludm9rZSwgbWVyZ2UsIG10aCwgbXVsdGlDb25TdHIsIG5vVW5kZWZWYWxzLCBub1ZhbHVlQ29uU3RyLCBwYXJ0aXRpb24sIHJlbW92ZUlycmVsZXZhbnRTb3J0T3JkZXJzLCBzaW1wbGVDb25TdHIsIHN0cmluZ1RvU29ydE9yZGVyLCBzdHJpbmdpZnlTb3J0T3JkZXIsIHRvUXVlcnlTdHJpbmcsIHR5cGVDb25TdHIsIHVuaW9uLCB1dGlscywgd2l0aENCLCBfZm4sIF9nZXRfZGF0YV9mZXRjaGVyLCBfaSwgX2osIF9sZW4sIF9sZW4xLCBfcmVmLFxuICAgIF9faW5kZXhPZiA9IFtdLmluZGV4T2YgfHwgZnVuY3Rpb24oaXRlbSkgeyBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7IGlmIChpIGluIHRoaXMgJiYgdGhpc1tpXSA9PT0gaXRlbSkgcmV0dXJuIGk7IH0gcmV0dXJuIC0xOyB9LFxuICAgIF9fYmluZCA9IGZ1bmN0aW9uKGZuLCBtZSl7IHJldHVybiBmdW5jdGlvbigpeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH0sXG4gICAgX19zbGljZSA9IFtdLnNsaWNlLFxuICAgIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIEV2ZW50cyA9IF9kZXJlcV8oJ2JhY2tib25lLWV2ZW50cy1zdGFuZGFsb25lJyk7XG5cbiAgaW50ZXJtaW5lID0gZXhwb3J0cztcblxuICBpbnRlcm1pbmUueG1sID0gX2RlcmVxXygnLi94bWwnKTtcblxuICB1dGlscyA9IF9kZXJlcV8oJy4vdXRpbCcpO1xuXG4gIFJFUVVJUkVTX1ZFUlNJT04gPSB1dGlscy5SRVFVSVJFU19WRVJTSU9OLCB3aXRoQ0IgPSB1dGlscy53aXRoQ0IsIG1lcmdlID0gdXRpbHMubWVyZ2UsIGZpbHRlciA9IHV0aWxzLmZpbHRlciwgcGFydGl0aW9uID0gdXRpbHMucGFydGl0aW9uLCBmb2xkID0gdXRpbHMuZm9sZCwgY29uY2F0TWFwID0gdXRpbHMuY29uY2F0TWFwLCBpZCA9IHV0aWxzLmlkLCBnZXQgPSB1dGlscy5nZXQsIGludm9rZSA9IHV0aWxzLmludm9rZTtcblxuICB0b1F1ZXJ5U3RyaW5nID0gdXRpbHMucXVlcnlzdHJpbmc7XG5cbiAgZ2V0X2Nhbm9uaWNhbF9vcCA9IGZ1bmN0aW9uKG9yaWcpIHtcbiAgICB2YXIgY2Fub25pY2FsO1xuICAgIGNhbm9uaWNhbCA9IChvcmlnICE9IG51bGwgPyBvcmlnLnRvTG93ZXJDYXNlIDogdm9pZCAwKSAhPSBudWxsID8gUXVlcnkuT1BfRElDVFtvcmlnLnRvTG93ZXJDYXNlKCldIDogbnVsbDtcbiAgICBpZiAoIWNhbm9uaWNhbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBjb25zdHJhaW50IG9wZXJhdG9yOiBcIiArIG9yaWcpO1xuICAgIH1cbiAgICByZXR1cm4gY2Fub25pY2FsO1xuICB9O1xuXG4gIEJBU0lDX0FUVFJTID0gWydwYXRoJywgJ29wJywgJ2NvZGUnXTtcblxuICBTSU1QTEVfQVRUUlMgPSBCQVNJQ19BVFRSUy5jb25jYXQoWyd2YWx1ZScsICdleHRyYVZhbHVlJ10pO1xuXG4gIFJFU1VMVFNfTUVUSE9EUyA9IFsncm93QnlSb3cnLCAnZWFjaFJvdycsICdyZWNvcmRCeVJlY29yZCcsICdlYWNoUmVjb3JkJywgJ3JlY29yZHMnLCAncm93cycsICd0YWJsZScsICd0YWJsZVJvd3MnLCAndmFsdWVzJ107XG5cbiAgTElTVF9QSVBFID0gZnVuY3Rpb24oc2VydmljZSkge1xuICAgIHJldHVybiB1dGlscy5jb21wb3NlKHNlcnZpY2UuZmV0Y2hMaXN0LCBnZXQoJ2xpc3ROYW1lJykpO1xuICB9O1xuXG4gIENPREVTID0gWydBJywgJ0InLCAnQycsICdEJywgJ0UnLCAnRicsICdHJywgJ0gnLCAnSScsICdKJywgJ0snLCAnTCcsICdNJywgJ04nLCAnTycsICdQJywgJ1EnLCAnUicsICdTJywgJ1QnLCAnVScsICdWJywgJ1cnLCAnWCcsICdZJywgJ1onXTtcblxuICBkZWNhcGl0YXRlID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09IG51bGwpIHtcbiAgICAgIHggPSAnJztcbiAgICB9XG4gICAgcmV0dXJuIHguc3Vic3RyKHguaW5kZXhPZignLicpKTtcbiAgfTtcblxuICBjb25WYWxTdHIgPSBmdW5jdGlvbih2KSB7XG4gICAgaWYgKHYgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFwiPHZhbHVlPlwiICsgKHV0aWxzLmVzY2FwZSh2KSkgKyBcIjwvdmFsdWU+XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcIjxudWxsVmFsdWUvPlwiO1xuICAgIH1cbiAgfTtcblxuICBjb25BdHRycyA9IGZ1bmN0aW9uKGMsIG5hbWVzKSB7XG4gICAgdmFyIGssIHY7XG4gICAgcmV0dXJuICgoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3Jlc3VsdHM7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChrIGluIGMpIHtcbiAgICAgICAgdiA9IGNba107XG4gICAgICAgIGlmICgoX19pbmRleE9mLmNhbGwobmFtZXMsIGspID49IDApKSB7XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaChcIlwiICsgayArIFwiPVxcXCJcIiArICh1dGlscy5lc2NhcGUodikpICsgXCJcXFwiIFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH0pKCkpLmpvaW4oJycpO1xuICB9O1xuXG4gIG5vVmFsdWVDb25TdHIgPSBmdW5jdGlvbihjKSB7XG4gICAgcmV0dXJuIFwiPGNvbnN0cmFpbnQgXCIgKyAoY29uQXR0cnMoYywgQkFTSUNfQVRUUlMpKSArIFwiLz5cIjtcbiAgfTtcblxuICB0eXBlQ29uU3RyID0gZnVuY3Rpb24oYykge1xuICAgIHJldHVybiBcIjxjb25zdHJhaW50IFwiICsgKGNvbkF0dHJzKGMsIFsncGF0aCcsICd0eXBlJ10pKSArIFwiLz5cIjtcbiAgfTtcblxuICBzaW1wbGVDb25TdHIgPSBmdW5jdGlvbihjKSB7XG4gICAgcmV0dXJuIFwiPGNvbnN0cmFpbnQgXCIgKyAoY29uQXR0cnMoYywgU0lNUExFX0FUVFJTKSkgKyBcIi8+XCI7XG4gIH07XG5cbiAgbXVsdGlDb25TdHIgPSBmdW5jdGlvbihjKSB7XG4gICAgcmV0dXJuIFwiPGNvbnN0cmFpbnQgXCIgKyAoY29uQXR0cnMoYywgQkFTSUNfQVRUUlMpKSArIFwiPlwiICsgKGNvbmNhdE1hcChjb25WYWxTdHIpKGMudmFsdWVzKSkgKyBcIjwvY29uc3RyYWludD5cIjtcbiAgfTtcblxuICBpZENvblN0ciA9IGZ1bmN0aW9uKGMpIHtcbiAgICByZXR1cm4gXCI8Y29uc3RyYWludCBcIiArIChjb25BdHRycyhjLCBCQVNJQ19BVFRSUykpICsgXCJpZHM9XFxcIlwiICsgKGMuaWRzLmpvaW4oJywnKSkgKyBcIlxcXCIvPlwiO1xuICB9O1xuXG4gIGNvblN0ciA9IGZ1bmN0aW9uKGMpIHtcbiAgICB2YXIgX3JlZjtcbiAgICBpZiAoYy52YWx1ZXMgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG11bHRpQ29uU3RyKGMpO1xuICAgIH0gZWxzZSBpZiAoYy5pZHMgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGlkQ29uU3RyKGMpO1xuICAgIH0gZWxzZSBpZiAoYy5vcCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdHlwZUNvblN0cihjKTtcbiAgICB9IGVsc2UgaWYgKF9yZWYgPSBjLm9wLCBfX2luZGV4T2YuY2FsbChRdWVyeS5OVUxMX09QUywgX3JlZikgPj0gMCkge1xuICAgICAgcmV0dXJuIG5vVmFsdWVDb25TdHIoYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzaW1wbGVDb25TdHIoYyk7XG4gICAgfVxuICB9O1xuXG4gIGhlYWRMZXNzID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIHJldHVybiBwYXRoLnJlcGxhY2UoL15bXlxcLl0rXFwuLywgJycpO1xuICB9O1xuXG4gIGNvcHlDb24gPSBmdW5jdGlvbihjb24pIHtcbiAgICB2YXIgY29kZSwgZWRpdGFibGUsIGV4dHJhVmFsdWUsIGlkcywgb3AsIHBhdGgsIHN3aXRjaGFibGUsIHN3aXRjaGVkLCB0eXBlLCB2YWx1ZSwgdmFsdWVzO1xuICAgIHBhdGggPSBjb24ucGF0aCwgdHlwZSA9IGNvbi50eXBlLCBvcCA9IGNvbi5vcCwgdmFsdWUgPSBjb24udmFsdWUsIHZhbHVlcyA9IGNvbi52YWx1ZXMsIGV4dHJhVmFsdWUgPSBjb24uZXh0cmFWYWx1ZSwgaWRzID0gY29uLmlkcywgY29kZSA9IGNvbi5jb2RlLCBlZGl0YWJsZSA9IGNvbi5lZGl0YWJsZSwgc3dpdGNoZWQgPSBjb24uc3dpdGNoZWQsIHN3aXRjaGFibGUgPSBjb24uc3dpdGNoYWJsZTtcbiAgICBpZHMgPSBpZHMgIT0gbnVsbCA/IGlkcy5zbGljZSgpIDogdm9pZCAwO1xuICAgIHZhbHVlcyA9IHZhbHVlcyAhPSBudWxsID8gdmFsdWVzLnNsaWNlKCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIG5vVW5kZWZWYWxzKHtcbiAgICAgIHBhdGg6IHBhdGgsXG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgb3A6IG9wLFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICBleHRyYVZhbHVlOiBleHRyYVZhbHVlLFxuICAgICAgaWRzOiBpZHMsXG4gICAgICBjb2RlOiBjb2RlLFxuICAgICAgZWRpdGFibGU6IGVkaXRhYmxlLFxuICAgICAgc3dpdGNoZWQ6IHN3aXRjaGVkLFxuICAgICAgc3dpdGNoYWJsZTogc3dpdGNoYWJsZVxuICAgIH0pO1xuICB9O1xuXG4gIGNvblRvSlNPTiA9IGZ1bmN0aW9uKGNvbikge1xuICAgIHZhciBjb3B5O1xuICAgIGNvcHkgPSBjb3B5Q29uKGNvbik7XG4gICAgY29weS5wYXRoID0gaGVhZExlc3MoY29weS5wYXRoKTtcbiAgICByZXR1cm4gY29weTtcbiAgfTtcblxuICBub1VuZGVmVmFscyA9IGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgaywgdjtcbiAgICBmb3IgKGsgaW4geCkge1xuICAgICAgdiA9IHhba107XG4gICAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZSB4W2tdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geDtcbiAgfTtcblxuICBkaWRudFJlbW92ZSA9IGZ1bmN0aW9uKG9yaWcsIHJlZHVjZWQpIHtcbiAgICByZXR1cm4gXCJEaWQgbm90IHJlbW92ZSBhIHNpbmdsZSBjb25zdHJhaW50LiBvcmlnaW5hbCA9IFwiICsgb3JpZyArIFwiLCByZWR1Y2VkID0gXCIgKyByZWR1Y2VkO1xuICB9O1xuXG4gIGludGVycHJldENvbnN0cmFpbnQgPSBmdW5jdGlvbihwYXRoLCBjb24pIHtcbiAgICB2YXIgY29uc3RyYWludCwgaywga2V5cywgdiwgeCwgX3JlZiwgX3JlZjE7XG4gICAgY29uc3RyYWludCA9IHtcbiAgICAgIHBhdGg6IHBhdGhcbiAgICB9O1xuICAgIGlmIChjb24gPT09IG51bGwpIHtcbiAgICAgIGNvbnN0cmFpbnQub3AgPSAnSVMgTlVMTCc7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc0FycmF5KGNvbikpIHtcbiAgICAgIGNvbnN0cmFpbnQub3AgPSAnT05FIE9GJztcbiAgICAgIGNvbnN0cmFpbnQudmFsdWVzID0gY29uO1xuICAgIH0gZWxzZSBpZiAoKF9yZWYgPSB0eXBlb2YgY29uKSA9PT0gJ3N0cmluZycgfHwgX3JlZiA9PT0gJ251bWJlcicgfHwgX3JlZiA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBpZiAoX3JlZjEgPSB0eXBlb2YgY29uLnRvVXBwZXJDYXNlID09PSBcImZ1bmN0aW9uXCIgPyBjb24udG9VcHBlckNhc2UoKSA6IHZvaWQgMCwgX19pbmRleE9mLmNhbGwoUXVlcnkuTlVMTF9PUFMsIF9yZWYxKSA+PSAwKSB7XG4gICAgICAgIGNvbnN0cmFpbnQub3AgPSBjb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdHJhaW50Lm9wID0gJz0nO1xuICAgICAgICBjb25zdHJhaW50LnZhbHVlID0gY29uO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX3Jlc3VsdHM7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoayBpbiBjb24pIHtcbiAgICAgICAgICB4ID0gY29uW2tdO1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2goayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSkoKTtcbiAgICAgIGlmIChfX2luZGV4T2YuY2FsbChrZXlzLCAnaXNhJykgPj0gMCkge1xuICAgICAgICBpZiAodXRpbHMuaXNBcnJheShjb24uaXNhKSkge1xuICAgICAgICAgIGNvbnN0cmFpbnQub3AgPSBrO1xuICAgICAgICAgIGNvbnN0cmFpbnQudmFsdWVzID0gY29uLmlzYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdHJhaW50LnR5cGUgPSBjb24uaXNhO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoX19pbmRleE9mLmNhbGwoa2V5cywgJ2V4dHJhVmFsdWUnKSA+PSAwKSB7XG4gICAgICAgICAgY29uc3RyYWludC5leHRyYVZhbHVlID0gY29uLmV4dHJhVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChrIGluIGNvbikge1xuICAgICAgICAgIHYgPSBjb25ba107XG4gICAgICAgICAgaWYgKCEoayAhPT0gJ2V4dHJhVmFsdWUnKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0cmFpbnQub3AgPSBrO1xuICAgICAgICAgIGlmICh1dGlscy5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgICBjb25zdHJhaW50LnZhbHVlcyA9IHY7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0cmFpbnQudmFsdWUgPSB2O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29uc3RyYWludDtcbiAgfTtcblxuICBpbnRlcnByZXRDb25BcnJheSA9IGZ1bmN0aW9uKGNvbkFyZ3MpIHtcbiAgICB2YXIgYTAsIGNvbnN0cmFpbnQsIHYsIF9yZWY7XG4gICAgY29uQXJncyA9IGNvbkFyZ3Muc2xpY2UoKTtcbiAgICBjb25zdHJhaW50ID0ge1xuICAgICAgcGF0aDogY29uQXJncy5zaGlmdCgpXG4gICAgfTtcbiAgICBpZiAoY29uQXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGEwID0gY29uQXJnc1swXTtcbiAgICAgIGlmIChfcmVmID0gdHlwZW9mIGEwLnRvVXBwZXJDYXNlID09PSBcImZ1bmN0aW9uXCIgPyBhMC50b1VwcGVyQ2FzZSgpIDogdm9pZCAwLCBfX2luZGV4T2YuY2FsbChRdWVyeS5OVUxMX09QUywgX3JlZikgPj0gMCkge1xuICAgICAgICBjb25zdHJhaW50Lm9wID0gYTA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdHJhaW50LnR5cGUgPSBhMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNvbkFyZ3MubGVuZ3RoID49IDIpIHtcbiAgICAgIGNvbnN0cmFpbnQub3AgPSBjb25BcmdzWzBdO1xuICAgICAgdiA9IGNvbkFyZ3NbMV07XG4gICAgICBpZiAodXRpbHMuaXNBcnJheSh2KSkge1xuICAgICAgICBjb25zdHJhaW50LnZhbHVlcyA9IHY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdHJhaW50LnZhbHVlID0gdjtcbiAgICAgIH1cbiAgICAgIGlmIChjb25BcmdzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICBjb25zdHJhaW50LmV4dHJhVmFsdWUgPSBjb25BcmdzWzJdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29uc3RyYWludDtcbiAgfTtcblxuICBzdHJpbmdpZnlTb3J0T3JkZXIgPSBmdW5jdGlvbihzb3J0T3JkZXIpIHtcbiAgICB2YXIgb2U7XG4gICAgcmV0dXJuICgoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX2ksIF9sZW4sIF9yZXN1bHRzO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gc29ydE9yZGVyLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIG9lID0gc29ydE9yZGVyW19pXTtcbiAgICAgICAgX3Jlc3VsdHMucHVzaChcIlwiICsgb2UucGF0aCArIFwiIFwiICsgb2UuZGlyZWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9KSgpKS5qb2luKCcgJyk7XG4gIH07XG5cbiAgc3RyaW5nVG9Tb3J0T3JkZXIgPSBmdW5jdGlvbihzdHIpIHtcbiAgICB2YXIgaSwgcGFydHMsIHBhdGhJbmRpY2VzLCB4LCBfaSwgX2xlbiwgX3Jlc3VsdHM7XG4gICAgaWYgKHN0ciA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHBhcnRzID0gc3RyLnNwbGl0KC9cXHMrLyk7XG4gICAgcGF0aEluZGljZXMgPSAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX2ksIF9yZWYsIF9yZXN1bHRzO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoeCA9IF9pID0gMCwgX3JlZiA9IHBhcnRzLmxlbmd0aCAvIDI7IDAgPD0gX3JlZiA/IF9pIDwgX3JlZiA6IF9pID4gX3JlZjsgeCA9IDAgPD0gX3JlZiA/ICsrX2kgOiAtLV9pKSB7XG4gICAgICAgIF9yZXN1bHRzLnB1c2goeCAqIDIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH0pKCk7XG4gICAgX3Jlc3VsdHMgPSBbXTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IHBhdGhJbmRpY2VzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBpID0gcGF0aEluZGljZXNbX2ldO1xuICAgICAgX3Jlc3VsdHMucHVzaChbcGFydHNbaV0sIHBhcnRzW2kgKyAxXV0pO1xuICAgIH1cbiAgICByZXR1cm4gX3Jlc3VsdHM7XG4gIH07XG5cbiAgcmVtb3ZlSXJyZWxldmFudFNvcnRPcmRlcnMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb2UsIG9sZE9yZGVyO1xuICAgIG9sZE9yZGVyID0gdGhpcy5zb3J0T3JkZXI7XG4gICAgdGhpcy5zb3J0T3JkZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX2ksIF9sZW4sIF9yZXN1bHRzO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gb2xkT3JkZXIubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgb2UgPSBvbGRPcmRlcltfaV07XG4gICAgICAgIGlmICh0aGlzLmlzUmVsZXZhbnQob2UucGF0aCkpIHtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKG9lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH0pLmNhbGwodGhpcyk7XG4gICAgaWYgKG9sZE9yZGVyLmxlbmd0aCAhPT0gdGhpcy5zb3J0T3JkZXIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmlnZ2VyKCdjaGFuZ2U6c29ydG9yZGVyIGNoYW5nZTpvcmRlcmJ5JywgdGhpcy5zb3J0T3JkZXIuc2xpY2UoKSk7XG4gICAgfVxuICB9O1xuXG4gIFF1ZXJ5ID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBhZGRQSSwgY0F0dHJzLCBraWRzLCBwYXJzZVN1bW1hcnksIHFBdHRycywgc2NGb2xkLCB0b0F0dHJQYWlycywgdG9QYXRoQW5kVHlwZSwgeG1sQXR0cjtcblxuICAgIFF1ZXJ5LkpPSU5fU1RZTEVTID0gWydJTk5FUicsICdPVVRFUiddO1xuXG4gICAgUXVlcnkuQklPX0ZPUk1BVFMgPSBbJ2dmZjMnLCAnZmFzdGEnLCAnYmVkJ107XG5cbiAgICBRdWVyeS5OVUxMX09QUyA9IFsnSVMgTlVMTCcsICdJUyBOT1QgTlVMTCddO1xuXG4gICAgUXVlcnkuQVRUUklCVVRFX1ZBTFVFX09QUyA9IFtcIj1cIiwgXCIhPVwiLCBcIj5cIiwgXCI+PVwiLCBcIjxcIiwgXCI8PVwiLCBcIkNPTlRBSU5TXCIsIFwiTElLRVwiLCBcIk5PVCBMSUtFXCJdO1xuXG4gICAgUXVlcnkuTVVMVElWQUxVRV9PUFMgPSBbJ09ORSBPRicsICdOT05FIE9GJ107XG5cbiAgICBRdWVyeS5SQU5HRV9PUFMgPSBbJ09WRVJMQVBTJywgJ0RPRVMgTk9UIE9WRVJMQVAnLCAnT1VUU0lERScsICdXSVRISU4nLCAnQ09OVEFJTlMnLCAnRE9FUyBOT1QgQ09OVEFJTiddO1xuXG4gICAgUXVlcnkuVEVSTkFSWV9PUFMgPSBbJ0xPT0tVUCddO1xuXG4gICAgUXVlcnkuTE9PUF9PUFMgPSBbJz0nLCAnIT0nXTtcblxuICAgIFF1ZXJ5LkxJU1RfT1BTID0gWydJTicsICdOT1QgSU4nXTtcblxuICAgIFF1ZXJ5Lk9QX0RJQ1QgPSB7XG4gICAgICAnPSc6ICc9JyxcbiAgICAgICc9PSc6ICc9PScsXG4gICAgICAnZXEnOiAnPScsXG4gICAgICAnZXFxJzogJz09JyxcbiAgICAgICchPSc6ICchPScsXG4gICAgICAnbmUnOiAnIT0nLFxuICAgICAgJz4nOiAnPicsXG4gICAgICAnZ3QnOiAnPicsXG4gICAgICAnPj0nOiAnPj0nLFxuICAgICAgJ2dlJzogJz49JyxcbiAgICAgICc8JzogJzwnLFxuICAgICAgJ2x0JzogJzwnLFxuICAgICAgJzw9JzogJzw9JyxcbiAgICAgICdsZSc6ICc8PScsXG4gICAgICAnY29udGFpbnMnOiAnQ09OVEFJTlMnLFxuICAgICAgJ0NPTlRBSU5TJzogJ0NPTlRBSU5TJyxcbiAgICAgICdkb2VzIG5vdCBjb250YWluJzogJ0RPRVMgTk9UIENPTlRBSU4nLFxuICAgICAgJ0RPRVMgTk9UIENPTlRBSU4nOiAnRE9FUyBOT1QgQ09OVEFJTicsXG4gICAgICAnbGlrZSc6ICdMSUtFJyxcbiAgICAgICdMSUtFJzogJ0xJS0UnLFxuICAgICAgJ25vdCBsaWtlJzogJ05PVCBMSUtFJyxcbiAgICAgICdOT1QgTElLRSc6ICdOT1QgTElLRScsXG4gICAgICAnbG9va3VwJzogJ0xPT0tVUCcsXG4gICAgICAnSVMgTlVMTCc6ICdJUyBOVUxMJyxcbiAgICAgICdpcyBudWxsJzogJ0lTIE5VTEwnLFxuICAgICAgJ0lTIE5PVCBOVUxMJzogJ0lTIE5PVCBOVUxMJyxcbiAgICAgICdpcyBub3QgbnVsbCc6ICdJUyBOT1QgTlVMTCcsXG4gICAgICAnT05FIE9GJzogJ09ORSBPRicsXG4gICAgICAnb25lIG9mJzogJ09ORSBPRicsXG4gICAgICAnTk9ORSBPRic6ICdOT05FIE9GJyxcbiAgICAgICdub25lIG9mJzogJ05PTkUgT0YnLFxuICAgICAgJ2luJzogJ0lOJyxcbiAgICAgICdub3QgaW4nOiAnTk9UIElOJyxcbiAgICAgICdJTic6ICdJTicsXG4gICAgICAnTk9UIElOJzogJ05PVCBJTicsXG4gICAgICAnV0lUSElOJzogJ1dJVEhJTicsXG4gICAgICAnd2l0aGluJzogJ1dJVEhJTicsXG4gICAgICAnT1ZFUkxBUFMnOiAnT1ZFUkxBUFMnLFxuICAgICAgJ292ZXJsYXBzJzogJ09WRVJMQVBTJyxcbiAgICAgICdET0VTIE5PVCBPVkVSTEFQJzogJ0RPRVMgTk9UIE9WRVJMQVAnLFxuICAgICAgJ2RvZXMgbm90IG92ZXJsYXAnOiAnRE9FUyBOT1QgT1ZFUkxBUCcsXG4gICAgICAnT1VUU0lERSc6ICdPVVRTSURFJyxcbiAgICAgICdvdXRzaWRlJzogJ09VVFNJREUnLFxuICAgICAgJ0lTQSc6ICdJU0EnLFxuICAgICAgJ2lzYSc6ICdJU0EnXG4gICAgfTtcblxuICAgIHFBdHRycyA9IFsnbmFtZScsICd2aWV3JywgJ3NvcnRPcmRlcicsICdjb25zdHJhaW50TG9naWMnLCAndGl0bGUnLCAnZGVzY3JpcHRpb24nLCAnY29tbWVudCddO1xuXG4gICAgY0F0dHJzID0gWydwYXRoJywgJ3R5cGUnLCAnb3AnLCAnY29kZScsICd2YWx1ZScsICdpZHMnXTtcblxuICAgIHRvQXR0clBhaXJzID0gZnVuY3Rpb24oZWwsIGF0dHJzKSB7XG4gICAgICB2YXIgeCwgX2ksIF9sZW4sIF9yZXN1bHRzO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gYXR0cnMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgeCA9IGF0dHJzW19pXTtcbiAgICAgICAgaWYgKGVsLmhhc0F0dHJpYnV0ZSh4KSkge1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2goW3gsIGVsLmdldEF0dHJpYnV0ZSh4KV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIGtpZHMgPSBmdW5jdGlvbihlbCwgbmFtZSkge1xuICAgICAgdmFyIGtpZCwgX2ksIF9sZW4sIF9yZWYsIF9yZXN1bHRzO1xuICAgICAgX3JlZiA9IGVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKG5hbWUpO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBraWQgPSBfcmVmW19pXTtcbiAgICAgICAgX3Jlc3VsdHMucHVzaChraWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICB4bWxBdHRyID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBRdWVyeS5mcm9tWE1MID0gZnVuY3Rpb24oeG1sKSB7XG4gICAgICB2YXIgY29uLCBkb20sIGosIHBhdGhPZiwgcSwgcXVlcnksIHN0eWxlT2Y7XG4gICAgICBkb20gPSBpbnRlcm1pbmUueG1sLnBhcnNlKHhtbCk7XG4gICAgICBxdWVyeSA9IGtpZHMoZG9tLCAncXVlcnknKVswXSB8fCBraWRzKGRvbSwgJ3RlbXBsYXRlJylbMF07XG4gICAgICBpZiAoIXF1ZXJ5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vIHF1ZXJ5IGluIHhtbFwiKTtcbiAgICAgIH1cbiAgICAgIHBhdGhPZiA9IHhtbEF0dHIoJ3BhdGgnKTtcbiAgICAgIHN0eWxlT2YgPSB4bWxBdHRyKCdzdHlsZScpO1xuICAgICAgcSA9IHV0aWxzLnBhaXJzVG9PYmoodG9BdHRyUGFpcnMocXVlcnksIHFBdHRycykpO1xuICAgICAgcS52aWV3ID0gcS52aWV3LnNwbGl0KC9cXHMrLyk7XG4gICAgICBxLnNvcnRPcmRlciA9IHN0cmluZ1RvU29ydE9yZGVyKHEuc29ydE9yZGVyKTtcbiAgICAgIHEuam9pbnMgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICAgIF9yZWYgPSBraWRzKHF1ZXJ5LCAnam9pbicpO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBqID0gX3JlZltfaV07XG4gICAgICAgICAgaWYgKHN0eWxlT2YoaikgPT09ICdPVVRFUicpIHtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2gocGF0aE9mKGopKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSkoKTtcbiAgICAgIHEuY29uc3RyYWludHMgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICAgIF9yZWYgPSBraWRzKHF1ZXJ5LCAnY29uc3RyYWludCcpO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBjb24gPSBfcmVmW19pXTtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKChmdW5jdGlvbihjb24pIHtcbiAgICAgICAgICAgIHZhciBjLCB0biwgdiwgdmFsdWVzLCB4O1xuICAgICAgICAgICAgYyA9IHV0aWxzLnBhaXJzVG9PYmoodG9BdHRyUGFpcnMoY29uLCBjQXR0cnMpKTtcbiAgICAgICAgICAgIGlmIChjLmlkcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGMuaWRzID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBfaiwgX2xlbjEsIF9yZWYxLCBfcmVzdWx0czE7XG4gICAgICAgICAgICAgICAgX3JlZjEgPSBjLmlkcy5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgICAgIF9yZXN1bHRzMSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IF9yZWYxLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgICAgICAgICAgICAgICAgeCA9IF9yZWYxW19qXTtcbiAgICAgICAgICAgICAgICAgIF9yZXN1bHRzMS5wdXNoKHBhcnNlSW50KHgsIDEwKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBfcmVzdWx0czE7XG4gICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZXMgPSBraWRzKGNvbiwgJ3ZhbHVlJyk7XG4gICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBjLnZhbHVlcyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2osIF9sZW4xLCBfcmVzdWx0czE7XG4gICAgICAgICAgICAgICAgX3Jlc3VsdHMxID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChfaiA9IDAsIF9sZW4xID0gdmFsdWVzLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgICAgICAgICAgICAgICAgdiA9IHZhbHVlc1tfal07XG4gICAgICAgICAgICAgICAgICBfcmVzdWx0czEucHVzaCgoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2ssIF9sZW4yLCBfcmVmMSwgX3Jlc3VsdHMyO1xuICAgICAgICAgICAgICAgICAgICBfcmVmMSA9IHYuY2hpbGROb2RlcztcbiAgICAgICAgICAgICAgICAgICAgX3Jlc3VsdHMyID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAoX2sgPSAwLCBfbGVuMiA9IF9yZWYxLmxlbmd0aDsgX2sgPCBfbGVuMjsgX2srKykge1xuICAgICAgICAgICAgICAgICAgICAgIHRuID0gX3JlZjFbX2tdO1xuICAgICAgICAgICAgICAgICAgICAgIF9yZXN1bHRzMi5wdXNoKHRuLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVzdWx0czI7XG4gICAgICAgICAgICAgICAgICB9KSgpKS5qb2luKCcnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBfcmVzdWx0czE7XG4gICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICB9KShjb24pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KSgpO1xuICAgICAgcmV0dXJuIHE7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5jb25zdHJhaW50cyA9IFtdO1xuXG4gICAgUXVlcnkucHJvdG90eXBlLnZpZXdzID0gW107XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuam9pbnMgPSB7fTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5jb25zdHJhaW50TG9naWMgPSAnJztcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5zb3J0T3JkZXIgPSAnJztcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5uYW1lID0gbnVsbDtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS50aXRsZSA9IG51bGw7XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuY29tbWVudCA9IG51bGw7XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuZGVzY3JpcHRpb24gPSBudWxsO1xuXG4gICAgZnVuY3Rpb24gUXVlcnkocHJvcGVydGllcywgc2VydmljZSwgX2FyZykge1xuICAgICAgdmFyIG1vZGVsLCBwcm9wLCBzdW1tYXJ5RmllbGRzLCBfaSwgX2xlbiwgX3JlZiwgX3JlZjEsIF9yZWYxMCwgX3JlZjIsIF9yZWYzLCBfcmVmNCwgX3JlZjUsIF9yZWY2LCBfcmVmNywgX3JlZjgsIF9yZWY5O1xuICAgICAgX3JlZiA9IF9hcmcgIT0gbnVsbCA/IF9hcmcgOiB7fSwgbW9kZWwgPSBfcmVmLm1vZGVsLCBzdW1tYXJ5RmllbGRzID0gX3JlZi5zdW1tYXJ5RmllbGRzO1xuICAgICAgdGhpcy5hZGRDb25zdHJhaW50ID0gX19iaW5kKHRoaXMuYWRkQ29uc3RyYWludCwgdGhpcyk7XG4gICAgICB0aGlzLmV4cGFuZFN0YXIgPSBfX2JpbmQodGhpcy5leHBhbmRTdGFyLCB0aGlzKTtcbiAgICAgIHRoaXMuYWRqdXN0UGF0aCA9IF9fYmluZCh0aGlzLmFkanVzdFBhdGgsIHRoaXMpO1xuICAgICAgdGhpcy5zZWxlY3QgPSBfX2JpbmQodGhpcy5zZWxlY3QsIHRoaXMpO1xuICAgICAgaWYgKHByb3BlcnRpZXMgPT0gbnVsbCkge1xuICAgICAgICBwcm9wZXJ0aWVzID0ge307XG4gICAgICB9XG4gICAgICB0aGlzLmNvbnN0cmFpbnRzID0gW107XG4gICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICB0aGlzLmpvaW5zID0ge307XG4gICAgICB0aGlzLmRpc3BsYXlOYW1lcyA9IHV0aWxzLmNvcHkoKF9yZWYxID0gKF9yZWYyID0gcHJvcGVydGllcy5kaXNwbGF5TmFtZXMpICE9IG51bGwgPyBfcmVmMiA6IHByb3BlcnRpZXMuYWxpYXNlcykgIT0gbnVsbCA/IF9yZWYxIDoge30pO1xuICAgICAgX3JlZjMgPSBbJ25hbWUnLCAndGl0bGUnLCAnY29tbWVudCcsICdkZXNjcmlwdGlvbicsICd0eXBlJ107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHByb3AgPSBfcmVmM1tfaV07XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzW3Byb3BdICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzW3Byb3BdID0gcHJvcGVydGllc1twcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZSAhPSBudWxsID8gc2VydmljZSA6IHt9O1xuICAgICAgdGhpcy5tb2RlbCA9IChfcmVmNCA9IG1vZGVsICE9IG51bGwgPyBtb2RlbCA6IHByb3BlcnRpZXMubW9kZWwpICE9IG51bGwgPyBfcmVmNCA6IHt9O1xuICAgICAgdGhpcy5zdW1tYXJ5RmllbGRzID0gKF9yZWY1ID0gc3VtbWFyeUZpZWxkcyAhPSBudWxsID8gc3VtbWFyeUZpZWxkcyA6IHByb3BlcnRpZXMuc3VtbWFyeUZpZWxkcykgIT0gbnVsbCA/IF9yZWY1IDoge307XG4gICAgICB0aGlzLnJvb3QgPSAoX3JlZjYgPSBwcm9wZXJ0aWVzLnJvb3QpICE9IG51bGwgPyBfcmVmNiA6IHByb3BlcnRpZXMuZnJvbTtcbiAgICAgIHRoaXMubWF4Um93cyA9IChfcmVmNyA9IChfcmVmOCA9IHByb3BlcnRpZXMuc2l6ZSkgIT0gbnVsbCA/IF9yZWY4IDogcHJvcGVydGllcy5saW1pdCkgIT0gbnVsbCA/IF9yZWY3IDogcHJvcGVydGllcy5tYXhSb3dzO1xuICAgICAgdGhpcy5zdGFydCA9IChfcmVmOSA9IChfcmVmMTAgPSBwcm9wZXJ0aWVzLnN0YXJ0KSAhPSBudWxsID8gX3JlZjEwIDogcHJvcGVydGllcy5vZmZzZXQpICE9IG51bGwgPyBfcmVmOSA6IDA7XG4gICAgICB0aGlzLnNlbGVjdChwcm9wZXJ0aWVzLnZpZXdzIHx8IHByb3BlcnRpZXMudmlldyB8fCBwcm9wZXJ0aWVzLnNlbGVjdCB8fCBbXSk7XG4gICAgICB0aGlzLmFkZENvbnN0cmFpbnRzKHByb3BlcnRpZXMuY29uc3RyYWludHMgfHwgcHJvcGVydGllcy53aGVyZSB8fCBbXSk7XG4gICAgICB0aGlzLmFkZEpvaW5zKHByb3BlcnRpZXMuam9pbnMgfHwgcHJvcGVydGllcy5qb2luIHx8IFtdKTtcbiAgICAgIHRoaXMub3JkZXJCeShwcm9wZXJ0aWVzLnNvcnRPcmRlciB8fCBwcm9wZXJ0aWVzLm9yZGVyQnkgfHwgW10pO1xuICAgICAgaWYgKHByb3BlcnRpZXMuY29uc3RyYWludExvZ2ljICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5jb25zdHJhaW50TG9naWMgPSBwcm9wZXJ0aWVzLmNvbnN0cmFpbnRMb2dpYztcbiAgICAgIH1cbiAgICAgIHRoaXMub24oJ2NoYW5nZTp2aWV3cycsIHJlbW92ZUlycmVsZXZhbnRTb3J0T3JkZXJzLCB0aGlzKTtcbiAgICB9XG5cbiAgICBRdWVyeS5wcm90b3R5cGUucmVtb3ZlRnJvbVNlbGVjdCA9IGZ1bmN0aW9uKHVud2FudGVkKSB7XG4gICAgICB2YXIgbWFwRm4sIHNvLCB1dywgdjtcbiAgICAgIGlmICh1bndhbnRlZCA9PSBudWxsKSB7XG4gICAgICAgIHVud2FudGVkID0gW107XG4gICAgICB9XG4gICAgICB1bndhbnRlZCA9IHV0aWxzLnN0cmluZ0xpc3QodW53YW50ZWQpO1xuICAgICAgbWFwRm4gPSB1dGlscy5jb21wb3NlKHRoaXMuZXhwYW5kU3RhciwgdGhpcy5hZGp1c3RQYXRoKTtcbiAgICAgIHVud2FudGVkID0gdXRpbHMuZmxhdHRlbigoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfaSwgX2xlbiwgX3Jlc3VsdHM7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gdW53YW50ZWQubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICB1dyA9IHVud2FudGVkW19pXTtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKG1hcEZuKHV3KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSkoKSk7XG4gICAgICB0aGlzLnNvcnRPcmRlciA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVmLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgICAgIF9yZWYgPSB0aGlzLnNvcnRPcmRlcjtcbiAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgc28gPSBfcmVmW19pXTtcbiAgICAgICAgICBpZiAoIShfcmVmMSA9IHNvLnBhdGgsIF9faW5kZXhPZi5jYWxsKHVud2FudGVkLCBfcmVmMSkgPj0gMCkpIHtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2goc28pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy52aWV3cyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgICAgX3JlZiA9IHRoaXMudmlld3M7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIHYgPSBfcmVmW19pXTtcbiAgICAgICAgICBpZiAoIShfX2luZGV4T2YuY2FsbCh1bndhbnRlZCwgdikgPj0gMCkpIHtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2godik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLnRyaWdnZXIoJ3JlbW92ZTp2aWV3JywgdW53YW50ZWQpO1xuICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2U6dmlld3MnLCB0aGlzLnZpZXdzKTtcbiAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoJ2NoYW5nZScsIHRoaXMudmlld3MpO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUucmVtb3ZlQ29uc3RyYWludCA9IGZ1bmN0aW9uKGNvbiwgc2lsZW50KSB7XG4gICAgICB2YXIgYywgaXNjb24sIG9yaWcsIHJlZHVjZWQ7XG4gICAgICBpZiAoc2lsZW50ID09IG51bGwpIHtcbiAgICAgICAgc2lsZW50ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBvcmlnID0gdGhpcy5jb25zdHJhaW50cztcbiAgICAgIGlzY29uID0gdHlwZW9mIGNvbiA9PT0gJ3N0cmluZycgPyAoZnVuY3Rpb24oYykge1xuICAgICAgICByZXR1cm4gYy5jb2RlID09PSBjb247XG4gICAgICB9KSA6IChmdW5jdGlvbihjKSB7XG4gICAgICAgIHZhciBfcmVmLCBfcmVmMTtcbiAgICAgICAgcmV0dXJuIChjLnBhdGggPT09IGNvbi5wYXRoKSAmJiAoYy5vcCA9PT0gY29uLm9wKSAmJiAoYy52YWx1ZSA9PT0gY29uLnZhbHVlKSAmJiAoYy5leHRyYVZhbHVlID09PSBjb24uZXh0cmFWYWx1ZSkgJiYgKGNvbi50eXBlID09PSBjLnR5cGUpICYmICgoKF9yZWYgPSBjLnZhbHVlcykgIT0gbnVsbCA/IF9yZWYuam9pbignJSUnKSA6IHZvaWQgMCkgPT09ICgoX3JlZjEgPSBjb24udmFsdWVzKSAhPSBudWxsID8gX3JlZjEuam9pbignJSUnKSA6IHZvaWQgMCkpO1xuICAgICAgfSk7XG4gICAgICByZWR1Y2VkID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX2ksIF9sZW4sIF9yZXN1bHRzO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IG9yaWcubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBjID0gb3JpZ1tfaV07XG4gICAgICAgICAgaWYgKCFpc2NvbihjKSkge1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChjKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSkoKTtcbiAgICAgIGlmIChyZWR1Y2VkLmxlbmd0aCAhPT0gb3JpZy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihkaWRudFJlbW92ZShvcmlnLCByZWR1Y2VkKSk7XG4gICAgICB9XG4gICAgICB0aGlzLmNvbnN0cmFpbnRzID0gcmVkdWNlZDtcbiAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlOmNvbnN0cmFpbnRzJyk7XG4gICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoJ3JlbW92ZWQ6Y29uc3RyYWludCcsIHV0aWxzLmZpbmQob3JpZywgaXNjb24pKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLmFkZFRvU2VsZWN0ID0gZnVuY3Rpb24odmlld3MsIG9wdHMpIHtcbiAgICAgIHZhciBkdXBzLCBtYXBGbiwgcCwgdG9BZGQsIHYsIHgsIF9yZWYsIF9yZWYxO1xuICAgICAgaWYgKHZpZXdzID09IG51bGwpIHtcbiAgICAgICAgdmlld3MgPSBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRzID09IG51bGwpIHtcbiAgICAgICAgb3B0cyA9IHt9O1xuICAgICAgfVxuICAgICAgdmlld3MgPSB1dGlscy5zdHJpbmdMaXN0KHZpZXdzKTtcbiAgICAgIG1hcEZuID0gdXRpbHMuY29tcG9zZSh0aGlzLmV4cGFuZFN0YXIsIHRoaXMuYWRqdXN0UGF0aCk7XG4gICAgICB0b0FkZCA9IHV0aWxzLmZsYXR0ZW4oKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX2ksIF9sZW4sIF9yZXN1bHRzO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IHZpZXdzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgdiA9IHZpZXdzW19pXTtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKG1hcEZuKHYpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KSgpKTtcbiAgICAgIGR1cHMgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfaSwgX2xlbiwgX3Jlc3VsdHM7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gdG9BZGQubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBwID0gdG9BZGRbX2ldO1xuICAgICAgICAgIGlmIChfX2luZGV4T2YuY2FsbCh0aGlzLnZpZXdzLCBwKSA+PSAwKSB7XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKHApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgaWYgKGR1cHMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiICsgZHVwcyArIFwiIGFscmVhZHkgaW4gdGhlIHNlbGVjdCBsaXN0XCIpO1xuICAgICAgfVxuICAgICAgZHVwcyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVzdWx0cztcbiAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSB0b0FkZC5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIHAgPSB0b0FkZFtfaV07XG4gICAgICAgICAgaWYgKCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgX2osIF9sZW4xLCBfcmVzdWx0czE7XG4gICAgICAgICAgICBfcmVzdWx0czEgPSBbXTtcbiAgICAgICAgICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IHRvQWRkLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgICAgICAgICAgICB4ID0gdG9BZGRbX2pdO1xuICAgICAgICAgICAgICBpZiAoeCA9PT0gcCkge1xuICAgICAgICAgICAgICAgIF9yZXN1bHRzMS5wdXNoKHgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3Jlc3VsdHMxO1xuICAgICAgICAgIH0pKCkpLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2gocCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH0pKCk7XG4gICAgICBpZiAoZHVwcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIgKyBkdXBzICsgXCIgc3BlY2lmaWVkIG11bHRpcGxlIHRpbWVzIGFzIGFyZ3VtZW50cyB0byBhZGRUb1NlbGVjdFwiKTtcbiAgICAgIH1cbiAgICAgIChfcmVmID0gdGhpcy52aWV3cykucHVzaC5hcHBseShfcmVmLCB0b0FkZCk7XG4gICAgICBpZiAob3B0cy5zaWxlbnQpIHtcbiAgICAgICAgb3B0cy5ldmVudHMgPSAoKF9yZWYxID0gb3B0cy5ldmVudHMpICE9IG51bGwgPyBfcmVmMSA6IFtdKS5jb25jYXQoWydjaGFuZ2UnLCAnYWRkOnZpZXcnLCAnY2hhbmdlOnZpZXdzJ10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdhZGQ6dmlldyBjaGFuZ2U6dmlld3MnLCB0b0FkZCk7XG4gICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uKHZpZXdzLCBvcHRzKSB7XG4gICAgICB2YXIgZSwgb2xkVmlld3M7XG4gICAgICBvbGRWaWV3cyA9IHRoaXMudmlld3Muc2xpY2UoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy5hZGRUb1NlbGVjdCh2aWV3cywgb3B0cyk7XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgdGhpcy52aWV3cyA9IG9sZFZpZXdzO1xuICAgICAgICB1dGlscy5lcnJvcihlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuYWRqdXN0UGF0aCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIHBhdGggPSBwYXRoICYmIHBhdGgubmFtZSA/IHBhdGgubmFtZSA6IFwiXCIgKyBwYXRoO1xuICAgICAgaWYgKHRoaXMucm9vdCAhPSBudWxsKSB7XG4gICAgICAgIGlmICghcGF0aC5tYXRjaChcIl5cIiArIHRoaXMucm9vdCkpIHtcbiAgICAgICAgICBwYXRoID0gdGhpcy5yb290ICsgXCIuXCIgKyBwYXRoO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJvb3QgPSBwYXRoLnNwbGl0KCcuJylbMF07XG4gICAgICB9XG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLmdldFBvc3NpYmxlUGF0aHMgPSBmdW5jdGlvbihkZXB0aCwgYWxsb3dSZXZlcnNlUmVmZXJlbmNlcywgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgZ2V0UGF0aHMsIGtleSwgcmV0LCB0ZXN0LCBfYmFzZTtcbiAgICAgIGlmIChkZXB0aCA9PSBudWxsKSB7XG4gICAgICAgIGRlcHRoID0gMztcbiAgICAgIH1cbiAgICAgIGlmIChhbGxvd1JldmVyc2VSZWZlcmVuY2VzID09IG51bGwpIHtcbiAgICAgICAgYWxsb3dSZXZlcnNlUmVmZXJlbmNlcyA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocHJlZGljYXRlID09IG51bGwpIHtcbiAgICAgICAgcHJlZGljYXRlID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRlc3QgPSB0eXBlb2YgcHJlZGljYXRlID09PSAnc3RyaW5nJyA/IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuIHBbcHJlZGljYXRlXSgpO1xuICAgICAgfSA6IHByZWRpY2F0ZTtcbiAgICAgIGdldFBhdGhzID0gKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihyb290LCBkKSB7XG4gICAgICAgICAgdmFyIGNkLCBmaWVsZCwgbmFtZSwgb3RoZXJzLCBwYXRoLCBzdWJQYXRocztcbiAgICAgICAgICBwYXRoID0gX3RoaXMuZ2V0UGF0aEluZm8ocm9vdCk7XG4gICAgICAgICAgaWYgKCghYWxsb3dSZXZlcnNlUmVmZXJlbmNlcykgJiYgcGF0aC5pc1JldmVyc2VSZWZlcmVuY2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH0gZWxzZSBpZiAocGF0aC5pc0F0dHJpYnV0ZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gW3BhdGhdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjZCA9IHBhdGguZ2V0VHlwZSgpO1xuICAgICAgICAgICAgc3ViUGF0aHMgPSBjb25jYXRNYXAoZnVuY3Rpb24ocmVmKSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRQYXRocyhcIlwiICsgcm9vdCArIFwiLlwiICsgcmVmLm5hbWUsIGQgLSAxKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb3RoZXJzID0gY2QgJiYgKGQgPiAwKSA/IHN1YlBhdGhzKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIF9yZWYsIF9yZXN1bHRzO1xuICAgICAgICAgICAgICBfcmVmID0gY2QuZmllbGRzO1xuICAgICAgICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKG5hbWUgaW4gX3JlZikge1xuICAgICAgICAgICAgICAgIGZpZWxkID0gX3JlZltuYW1lXTtcbiAgICAgICAgICAgICAgICBfcmVzdWx0cy5wdXNoKGZpZWxkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICAgICAgICB9KSgpKSA6IFtdO1xuICAgICAgICAgICAgcmV0dXJuIFtwYXRoXS5jb25jYXQob3RoZXJzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKTtcbiAgICAgIGtleSA9IFwiXCIgKyBkZXB0aCArIFwiLVwiICsgYWxsb3dSZXZlcnNlUmVmZXJlbmNlcztcbiAgICAgIGlmICh0aGlzLl9wb3NzaWJsZVBhdGhzID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fcG9zc2libGVQYXRocyA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0ID0gKChfYmFzZSA9IHRoaXMuX3Bvc3NpYmxlUGF0aHMpW2tleV0gIT0gbnVsbCA/IF9iYXNlW2tleV0gOiBfYmFzZVtrZXldID0gZ2V0UGF0aHModGhpcy5yb290LCBkZXB0aCkpLnNsaWNlKCk7XG4gICAgICBpZiAodGVzdCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXQuZmlsdGVyKHRlc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLmdldFBhdGhJbmZvID0gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgdmFyIGFkanVzdGVkLCBwaSwgX3JlZjtcbiAgICAgIGFkanVzdGVkID0gdGhpcy5hZGp1c3RQYXRoKHBhdGgpO1xuICAgICAgcGkgPSAoX3JlZiA9IHRoaXMubW9kZWwpICE9IG51bGwgPyB0eXBlb2YgX3JlZi5nZXRQYXRoSW5mbyA9PT0gXCJmdW5jdGlvblwiID8gX3JlZi5nZXRQYXRoSW5mbyhhZGp1c3RlZCwgdGhpcy5nZXRTdWJjbGFzc2VzKCkpIDogdm9pZCAwIDogdm9pZCAwO1xuICAgICAgaWYgKHBpICYmIGFkanVzdGVkIGluIHRoaXMuZGlzcGxheU5hbWVzKSB7XG4gICAgICAgIHBpLmRpc3BsYXlOYW1lID0gdGhpcy5kaXNwbGF5TmFtZXNbYWRqdXN0ZWRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBpO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUubWFrZVBhdGggPSBRdWVyeS5wcm90b3R5cGUuZ2V0UGF0aEluZm87XG5cbiAgICB0b1BhdGhBbmRUeXBlID0gZnVuY3Rpb24oYykge1xuICAgICAgcmV0dXJuIFtjLnBhdGgsIGMudHlwZV07XG4gICAgfTtcblxuICAgIHNjRm9sZCA9IHV0aWxzLmNvbXBvc2UodXRpbHMucGFpcnNUb09iaiwgdXRpbHMubWFwKHRvUGF0aEFuZFR5cGUpLCBmaWx0ZXIoZ2V0KCd0eXBlJykpKTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5nZXRTdWJjbGFzc2VzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc2NGb2xkKHRoaXMuY29uc3RyYWludHMpO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuZ2V0VHlwZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFBhdGhJbmZvKHBhdGgpLmdldFR5cGUoKTtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLmdldFZpZXdOb2RlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHAsIHRvUGFyZW50Tm9kZTtcbiAgICAgIHRvUGFyZW50Tm9kZSA9IChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5nZXRQYXRoSW5mbyh2KS5nZXRQYXJlbnQoKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpO1xuICAgICAgcmV0dXJuIHV0aWxzLnVuaXFCeShTdHJpbmcsIChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgICAgX3JlZiA9IHRoaXMudmlld3M7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIHAgPSBfcmVmW19pXTtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKHRvUGFyZW50Tm9kZShwKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSkuY2FsbCh0aGlzKSk7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5pc0luVmlldyA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIHZhciBwaSwgcHN0ciwgX3JlZjtcbiAgICAgIHBpID0gdGhpcy5nZXRQYXRoSW5mbyhwYXRoKTtcbiAgICAgIGlmICghcGkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwYXRoOiBcIiArIHBhdGgpO1xuICAgICAgfVxuICAgICAgaWYgKHBpLmlzQXR0cmlidXRlKCkpIHtcbiAgICAgICAgcmV0dXJuIF9yZWYgPSBwaS50b1N0cmluZygpLCBfX2luZGV4T2YuY2FsbCh0aGlzLnZpZXdzLCBfcmVmKSA+PSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHN0ciA9IHBpLnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiB1dGlscy5hbnkodGhpcy5nZXRWaWV3Tm9kZXMoKSwgZnVuY3Rpb24obikge1xuICAgICAgICAgIHJldHVybiBuLnRvU3RyaW5nKCkgPT09IHBzdHI7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuaXNDb25zdHJhaW5lZCA9IGZ1bmN0aW9uKHBhdGgsIGluY2x1ZGVBdHRycykge1xuICAgICAgdmFyIHBpLCB0ZXN0O1xuICAgICAgaWYgKGluY2x1ZGVBdHRycyA9PSBudWxsKSB7XG4gICAgICAgIGluY2x1ZGVBdHRycyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcGkgPSB0aGlzLmdldFBhdGhJbmZvKHBhdGgpO1xuICAgICAgaWYgKCFwaSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBhdGg6IFwiICsgcGF0aCk7XG4gICAgICB9XG4gICAgICB0ZXN0ID0gZnVuY3Rpb24oYykge1xuICAgICAgICByZXR1cm4gKGMub3AgIT0gbnVsbCkgJiYgYy5wYXRoID09PSBwaS50b1N0cmluZygpO1xuICAgICAgfTtcbiAgICAgIGlmICgoIXBpLmlzQXR0cmlidXRlKCkpICYmIGluY2x1ZGVBdHRycykge1xuICAgICAgICB0ZXN0ID0gKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICAgIHJldHVybiAoYy5vcCAhPSBudWxsKSAmJiAoYy5wYXRoID09PSBwaS50b1N0cmluZygpIHx8IHBpLmVxdWFscyhfdGhpcy5nZXRQYXRoSW5mbyhjLnBhdGgpLmdldFBhcmVudCgpKSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdXRpbHMuYW55KHRoaXMuY29uc3RyYWludHMsIHRlc3QpO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuY2FuSGF2ZU11bHRpcGxlVmFsdWVzID0gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UGF0aEluZm8ocGF0aCkuY29udGFpbnNDb2xsZWN0aW9uKCk7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5nZXRRdWVyeU5vZGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYywgY29uc3RyYWluZWROb2RlcywgcGksIHZpZXdOb2RlcztcbiAgICAgIHZpZXdOb2RlcyA9IHRoaXMuZ2V0Vmlld05vZGVzKCk7XG4gICAgICBjb25zdHJhaW5lZE5vZGVzID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX2ksIF9sZW4sIF9yZWYsIF9yZXN1bHRzO1xuICAgICAgICBfcmVmID0gdGhpcy5jb25zdHJhaW50cztcbiAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgYyA9IF9yZWZbX2ldO1xuICAgICAgICAgIGlmICghKGMudHlwZSA9PSBudWxsKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBpID0gdGhpcy5nZXRQYXRoSW5mbyhjLnBhdGgpO1xuICAgICAgICAgIGlmIChwaS5pc0F0dHJpYnV0ZSgpKSB7XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKHBpLmdldFBhcmVudCgpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChwaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICByZXR1cm4gdXRpbHMudW5pcUJ5KFN0cmluZywgdmlld05vZGVzLmNvbmNhdChjb25zdHJhaW5lZE5vZGVzKSk7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5pc0luUXVlcnkgPSBmdW5jdGlvbihwKSB7XG4gICAgICB2YXIgYywgcGksIHBzdHIsIF9pLCBfbGVuLCBfcmVmO1xuICAgICAgcGkgPSB0aGlzLmdldFBhdGhJbmZvKHApO1xuICAgICAgaWYgKHBpKSB7XG4gICAgICAgIHBzdHIgPSBwaS50b1BhdGhTdHJpbmcoKTtcbiAgICAgICAgX3JlZiA9IHRoaXMudmlld3MuY29uY2F0KChmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgX2osIF9sZW4sIF9yZWYsIF9yZXN1bHRzO1xuICAgICAgICAgIF9yZWYgPSB0aGlzLmNvbnN0cmFpbnRzO1xuICAgICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgICAgZm9yIChfaiA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2ogPCBfbGVuOyBfaisrKSB7XG4gICAgICAgICAgICBjID0gX3JlZltfal07XG4gICAgICAgICAgICBpZiAoYy50eXBlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChjLnBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICAgIH0pLmNhbGwodGhpcykpO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBwID0gX3JlZltfaV07XG4gICAgICAgICAgaWYgKDAgPT09IHAuaW5kZXhPZihwc3RyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuaXNSZWxldmFudCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIHZhciBub2RlcywgcGksIHNvdWdodDtcbiAgICAgIHBpID0gdGhpcy5nZXRQYXRoSW5mbyhwYXRoKTtcbiAgICAgIGlmIChwaS5pc0F0dHJpYnV0ZSgpKSB7XG4gICAgICAgIHBpID0gcGkuZ2V0UGFyZW50KCk7XG4gICAgICB9XG4gICAgICBzb3VnaHQgPSBwaS50b1N0cmluZygpO1xuICAgICAgbm9kZXMgPSB0aGlzLmdldFZpZXdOb2RlcygpO1xuICAgICAgcmV0dXJuIHV0aWxzLmFueShub2RlcywgZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gbi50b1BhdGhTdHJpbmcoKSA9PT0gc291Z2h0O1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5leHBhbmRTdGFyID0gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgdmFyIGF0dHJWaWV3cywgY2QsIGV4cGFuZCwgZm4sIG4sIG5hbWUsIHBhdGhTdGVtLCBzdGFyVmlld3M7XG4gICAgICBpZiAoL1xcKiQvLnRlc3QocGF0aCkpIHtcbiAgICAgICAgcGF0aFN0ZW0gPSBwYXRoLnN1YnN0cigwLCBwYXRoLmxhc3RJbmRleE9mKCcuJykpO1xuICAgICAgICBleHBhbmQgPSBmdW5jdGlvbih4KSB7XG4gICAgICAgICAgcmV0dXJuIHBhdGhTdGVtICsgeDtcbiAgICAgICAgfTtcbiAgICAgICAgY2QgPSB0aGlzLmdldFR5cGUocGF0aFN0ZW0pO1xuICAgICAgICBpZiAoL1xcLlxcKiQvLnRlc3QocGF0aCkpIHtcbiAgICAgICAgICBpZiAoY2QgJiYgdGhpcy5zdW1tYXJ5RmllbGRzW2NkLm5hbWVdKSB7XG4gICAgICAgICAgICBmbiA9IHV0aWxzLmNvbXBvc2UoZXhwYW5kLCBkZWNhcGl0YXRlKTtcbiAgICAgICAgICAgIHJldHVybiAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICAgICAgICAgIF9yZWYgPSB0aGlzLnN1bW1hcnlGaWVsZHNbY2QubmFtZV07XG4gICAgICAgICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgICAgICAgIG4gPSBfcmVmW19pXTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaGFzVmlldyhuKSkge1xuICAgICAgICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChmbihuKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgICAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKC9cXC5cXCpcXCokLy50ZXN0KHBhdGgpKSB7XG4gICAgICAgICAgc3RhclZpZXdzID0gdGhpcy5leHBhbmRTdGFyKHBhdGhTdGVtICsgJy4qJyk7XG4gICAgICAgICAgYXR0clZpZXdzID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIF9yZXN1bHRzO1xuICAgICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobmFtZSBpbiBjZC5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgIF9yZXN1bHRzLnB1c2goZXhwYW5kKFwiLlwiICsgbmFtZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgcmV0dXJuIHV0aWxzLnVuaXFCeShpZCwgc3RhclZpZXdzLmNvbmNhdChhdHRyVmlld3MpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5pc091dGVySm9pbiA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIHJldHVybiB0aGlzLmpvaW5zW3RoaXMuYWRqdXN0UGF0aChwKV0gPT09ICdPVVRFUic7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5oYXNWaWV3ID0gZnVuY3Rpb24odikge1xuICAgICAgdmFyIF9yZWY7XG4gICAgICByZXR1cm4gdGhpcy52aWV3cyAmJiAoX3JlZiA9IHRoaXMuYWRqdXN0UGF0aCh2KSwgX19pbmRleE9mLmNhbGwodGhpcy52aWV3cywgX3JlZikgPj0gMCk7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uKGNvbnQpIHtcbiAgICAgIGlmICh0aGlzLnNlcnZpY2UuY291bnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VydmljZS5jb3VudCh0aGlzLCBjb250KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgcXVlcnkgaGFzIG5vIHNlcnZpY2Ugd2l0aCBjb3VudCBmdW5jdGlvbmFsaXR5IGF0dGFjaGVkLlwiKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLmFwcGVuZFRvTGlzdCA9IGZ1bmN0aW9uKHRhcmdldCwgY2IpIHtcbiAgICAgIHZhciBuYW1lLCBwcm9jZXNzb3IsIHJlcSwgdG9SdW4sIHVwZGF0ZVRhcmdldDtcbiAgICAgIGlmICh0YXJnZXQgIT0gbnVsbCA/IHRhcmdldC5uYW1lIDogdm9pZCAwKSB7XG4gICAgICAgIG5hbWUgPSB0YXJnZXQubmFtZTtcbiAgICAgICAgdXBkYXRlVGFyZ2V0ID0gZnVuY3Rpb24oZXJyLCBsaXN0KSB7XG4gICAgICAgICAgaWYgKGVyciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0LnNpemUgPSBsaXN0LnNpemU7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmFtZSA9IFN0cmluZyh0YXJnZXQpO1xuICAgICAgICB1cGRhdGVUYXJnZXQgPSBudWxsO1xuICAgICAgfVxuICAgICAgdG9SdW4gPSB0aGlzLm1ha2VMaXN0UXVlcnkoKTtcbiAgICAgIHJlcSA9IHtcbiAgICAgICAgbGlzdE5hbWU6IG5hbWUsXG4gICAgICAgIHF1ZXJ5OiB0b1J1bi50b1hNTCgpXG4gICAgICB9O1xuICAgICAgcHJvY2Vzc29yID0gTElTVF9QSVBFKHRoaXMuc2VydmljZSk7XG4gICAgICByZXR1cm4gd2l0aENCKHVwZGF0ZVRhcmdldCwgY2IsIHRoaXMuc2VydmljZS5wb3N0KCdxdWVyeS9hcHBlbmQvdG9saXN0JywgcmVxKS50aGVuKHByb2Nlc3NvcikpO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuc2VsZWN0UHJlc2VydmluZ0ltcGxpZWRDb25zdHJhaW50cyA9IGZ1bmN0aW9uKHBhdGhzKSB7XG4gICAgICB2YXIgbiwgdG9SdW4sIF9pLCBfbGVuLCBfcmVmO1xuICAgICAgaWYgKHBhdGhzID09IG51bGwpIHtcbiAgICAgICAgcGF0aHMgPSBbXTtcbiAgICAgIH1cbiAgICAgIHRvUnVuID0gdGhpcy5jbG9uZSgpO1xuICAgICAgdG9SdW4uc2VsZWN0KHBhdGhzKTtcbiAgICAgIF9yZWYgPSB0aGlzLmdldFZpZXdOb2RlcygpO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIG4gPSBfcmVmW19pXTtcbiAgICAgICAgaWYgKCF0aGlzLmlzT3V0ZXJKb2luZWQobikpIHtcbiAgICAgICAgICBpZiAoISh0b1J1bi5pc0luVmlldyhuIHx8IHRvUnVuLmlzQ29uc3RyYWluZWQobikpKSAmJiAobi5nZXRFbmRDbGFzcygpLmZpZWxkcy5pZCAhPSBudWxsKSkge1xuICAgICAgICAgICAgdG9SdW4uYWRkQ29uc3RyYWludChbbi5hcHBlbmQoJ2lkJyksICdJUyBOT1QgTlVMTCddKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0b1J1bjtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLm1ha2VMaXN0UXVlcnkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwYXRocywgX3JlZjtcbiAgICAgIHBhdGhzID0gdGhpcy52aWV3cy5zbGljZSgpO1xuICAgICAgaWYgKHBhdGhzLmxlbmd0aCAhPT0gMSB8fCAhKChfcmVmID0gcGF0aHNbMF0pICE9IG51bGwgPyBfcmVmLm1hdGNoKC9cXC5pZCQvKSA6IHZvaWQgMCkpIHtcbiAgICAgICAgcGF0aHMgPSBbJ2lkJ107XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3RQcmVzZXJ2aW5nSW1wbGllZENvbnN0cmFpbnRzKHBhdGhzKTtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLnNhdmVBc0xpc3QgPSBmdW5jdGlvbihvcHRpb25zLCBjYikge1xuICAgICAgdmFyIHJlcSwgdG9SdW47XG4gICAgICB0b1J1biA9IHRoaXMubWFrZUxpc3RRdWVyeSgpO1xuICAgICAgcmVxID0gdXRpbHMuY29weShvcHRpb25zKTtcbiAgICAgIHJlcS5saXN0TmFtZSA9IHJlcS5saXN0TmFtZSB8fCByZXEubmFtZTtcbiAgICAgIHJlcS5xdWVyeSA9IHRvUnVuLnRvWE1MKCk7XG4gICAgICBpZiAob3B0aW9ucy50YWdzKSB7XG4gICAgICAgIHJlcS50YWdzID0gb3B0aW9ucy50YWdzLmpvaW4oJzsnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3aXRoQ0IoY2IsIHRoaXMuc2VydmljZS5wb3N0KCdxdWVyeS90b2xpc3QnLCByZXEpLnRoZW4oTElTVF9QSVBFKHRoaXMuc2VydmljZSkpKTtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLnN1bW1hcmlzZSA9IGZ1bmN0aW9uKHBhdGgsIGxpbWl0LCBjb250KSB7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXJTdW1tYXJ5KHBhdGgsICcnLCBsaW1pdCwgY29udCk7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5zdW1tYXJpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmdzO1xuICAgICAgYXJncyA9IDEgPD0gYXJndW1lbnRzLmxlbmd0aCA/IF9fc2xpY2UuY2FsbChhcmd1bWVudHMsIDApIDogW107XG4gICAgICByZXR1cm4gdGhpcy5zdW1tYXJpc2UuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfTtcblxuICAgIHBhcnNlU3VtbWFyeSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHZhciBpc051bWVyaWMsIHIsIHN0YXRzLCBfaSwgX2xlbiwgX3JlZiwgX3JlZjE7XG4gICAgICBpc051bWVyaWMgPSAoKF9yZWYgPSBkYXRhLnJlc3VsdHNbMF0pICE9IG51bGwgPyBfcmVmLm1heCA6IHZvaWQgMCkgIT0gbnVsbDtcbiAgICAgIF9yZWYxID0gZGF0YS5yZXN1bHRzO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICByID0gX3JlZjFbX2ldO1xuICAgICAgICByLmNvdW50ID0gcGFyc2VJbnQoci5jb3VudCwgMTApO1xuICAgICAgfVxuICAgICAgc3RhdHMgPSB7XG4gICAgICAgIHVuaXF1ZVZhbHVlczogZGF0YS51bmlxdWVWYWx1ZXMsXG4gICAgICAgIGZpbHRlcmVkQ291bnQ6IGRhdGEuZmlsdGVyZWRDb3VudFxuICAgICAgfTtcbiAgICAgIGlmIChpc051bWVyaWMpIHtcbiAgICAgICAgc3RhdHMgPSBtZXJnZShzdGF0cywgZGF0YS5yZXN1bHRzWzBdKTtcbiAgICAgIH1cbiAgICAgIGRhdGEuc3RhdHMgPSBzdGF0cztcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuZmlsdGVyU3VtbWFyeSA9IGZ1bmN0aW9uKHBhdGgsIHRlcm0sIGxpbWl0LCBjb250KSB7XG4gICAgICB2YXIgcmVxLCB0b1J1biwgX3JlZjtcbiAgICAgIGlmIChjb250ID09IG51bGwpIHtcbiAgICAgICAgY29udCA9IChmdW5jdGlvbigpIHt9KTtcbiAgICAgIH1cbiAgICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKGxpbWl0KSkge1xuICAgICAgICBfcmVmID0gW2xpbWl0LCBudWxsXSwgY29udCA9IF9yZWZbMF0sIGxpbWl0ID0gX3JlZlsxXTtcbiAgICAgIH1cbiAgICAgIHBhdGggPSB0aGlzLmFkanVzdFBhdGgocGF0aCk7XG4gICAgICB0b1J1biA9IHRoaXMuY2xvbmUoKTtcbiAgICAgIGlmIChfX2luZGV4T2YuY2FsbCh0b1J1bi52aWV3cywgcGF0aCkgPCAwKSB7XG4gICAgICAgIHRvUnVuLnZpZXdzLnB1c2gocGF0aCk7XG4gICAgICB9XG4gICAgICByZXEgPSB7XG4gICAgICAgIHF1ZXJ5OiB0b1J1bi50b1hNTCgpLFxuICAgICAgICBzdW1tYXJ5UGF0aDogcGF0aCxcbiAgICAgICAgZm9ybWF0OiAnanNvbnJvd3MnXG4gICAgICB9O1xuICAgICAgaWYgKGxpbWl0KSB7XG4gICAgICAgIHJlcS5zaXplID0gbGltaXQ7XG4gICAgICB9XG4gICAgICBpZiAodGVybSkge1xuICAgICAgICByZXEuZmlsdGVyVGVybSA9IHRlcm07XG4gICAgICB9XG4gICAgICByZXR1cm4gd2l0aENCKGNvbnQsIHRoaXMuc2VydmljZS5wb3N0KCdxdWVyeS9yZXN1bHRzJywgcmVxKS50aGVuKHBhcnNlU3VtbWFyeSkpO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbihjbG9uZUV2ZW50cykge1xuICAgICAgdmFyIGNsb25lZCwgaywgdiwgX3JlZjtcbiAgICAgIGNsb25lZCA9IG5ldyBRdWVyeSh0aGlzLCB0aGlzLnNlcnZpY2UpO1xuICAgICAgaWYgKGNsb25lZC5fY2FsbGJhY2tzID09IG51bGwpIHtcbiAgICAgICAgY2xvbmVkLl9jYWxsYmFja3MgPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChjbG9uZUV2ZW50cykge1xuICAgICAgICBfcmVmID0gdGhpcy5fY2FsbGJhY2tzO1xuICAgICAgICBmb3IgKGsgaW4gX3JlZikge1xuICAgICAgICAgIGlmICghX19oYXNQcm9wLmNhbGwoX3JlZiwgaykpIGNvbnRpbnVlO1xuICAgICAgICAgIHYgPSBfcmVmW2tdO1xuICAgICAgICAgIGNsb25lZC5fY2FsbGJhY2tzW2tdID0gdjtcbiAgICAgICAgfVxuICAgICAgICBjbG9uZWQub2ZmKCdjaGFuZ2U6dmlld3MnLCByZW1vdmVJcnJlbGV2YW50U29ydE9yZGVycywgdGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2xvbmVkO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNsb25lO1xuICAgICAgY2xvbmUgPSB0aGlzLmNsb25lKCk7XG4gICAgICBpZiAodGhpcy5tYXhSb3dzKSB7XG4gICAgICAgIGNsb25lLnN0YXJ0ID0gdGhpcy5zdGFydCArIHRoaXMubWF4Um93cztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLnByZXZpb3VzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2xvbmU7XG4gICAgICBjbG9uZSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgIGlmICh0aGlzLm1heFJvd3MpIHtcbiAgICAgICAgY2xvbmUuc3RhcnQgPSB0aGlzLnN0YXJ0IC0gdGhpcy5tYXhSb3dzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xvbmUuc3RhcnQgPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuZ2V0U29ydERpcmVjdGlvbiA9IGZ1bmN0aW9uKHNvcnRlZCkge1xuICAgICAgdmFyIGEsIHNvO1xuICAgICAgYSA9IHRoaXMuYWRqdXN0UGF0aChzb3J0ZWQpO1xuICAgICAgaWYgKCEodGhpcy5pc0luUXVlcnkoYSkgfHwgdGhpcy5pc1JlbGV2YW50KGEpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIiArIHNvcnRlZCArIFwiIGlzIG5vdCBpbiB0aGUgcXVlcnlcIik7XG4gICAgICB9XG4gICAgICBzbyA9IHV0aWxzLmZpbmQodGhpcy5zb3J0T3JkZXIsIGZ1bmN0aW9uKF9hcmcpIHtcbiAgICAgICAgdmFyIHBhdGg7XG4gICAgICAgIHBhdGggPSBfYXJnLnBhdGg7XG4gICAgICAgIHJldHVybiBhID09PSBwYXRoO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gc28gIT0gbnVsbCA/IHNvLmRpcmVjdGlvbiA6IHZvaWQgMDtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLmlzT3V0ZXJKb2luZWQgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgICB2YXIgZGlyLCBqcCwgX3JlZjtcbiAgICAgIHBhdGggPSB0aGlzLmFkanVzdFBhdGgocGF0aCk7XG4gICAgICBfcmVmID0gdGhpcy5qb2lucztcbiAgICAgIGZvciAoanAgaW4gX3JlZikge1xuICAgICAgICBkaXIgPSBfcmVmW2pwXTtcbiAgICAgICAgaWYgKGRpciA9PT0gJ09VVEVSJyAmJiBwYXRoLmluZGV4T2YoanApID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLmdldE91dGVySm9pbiA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIHZhciBqb2luUGF0aHMsIGs7XG4gICAgICBwYXRoID0gdGhpcy5hZGp1c3RQYXRoKHBhdGgpO1xuICAgICAgam9pblBhdGhzID0gKChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9yZXN1bHRzO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGsgaW4gdGhpcy5qb2lucykge1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2goayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSkuY2FsbCh0aGlzKSkuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdXRpbHMuZmluZChqb2luUGF0aHMsIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ocCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5qb2luc1twXSA9PT0gJ09VVEVSJyAmJiBwYXRoLmluZGV4T2YocCkgPT09IDA7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5fcGFyc2Vfc29ydF9vcmRlciA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICB2YXIgZGlyZWN0aW9uLCBrLCBwYXRoLCBzbywgdiwgX3JlZjtcbiAgICAgIGlmIChpbnB1dCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gaW5wdXQnKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHNvID0ge1xuICAgICAgICAgIHBhdGg6IGlucHV0LFxuICAgICAgICAgIGRpcmVjdGlvbjogJ0FTQydcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAodXRpbHMuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgcGF0aCA9IGlucHV0WzBdLCBkaXJlY3Rpb24gPSBpbnB1dFsxXTtcbiAgICAgICAgc28gPSB7XG4gICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvblxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChpbnB1dC5wYXRoID09IG51bGwpIHtcbiAgICAgICAgZm9yIChrIGluIGlucHV0KSB7XG4gICAgICAgICAgdiA9IGlucHV0W2tdO1xuICAgICAgICAgIF9yZWYgPSBbaywgdl0sIHBhdGggPSBfcmVmWzBdLCBkaXJlY3Rpb24gPSBfcmVmWzFdO1xuICAgICAgICB9XG4gICAgICAgIHNvID0ge1xuICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb25cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdGggPSBpbnB1dC5wYXRoLCBkaXJlY3Rpb24gPSBpbnB1dC5kaXJlY3Rpb247XG4gICAgICAgIHNvID0ge1xuICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb25cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHNvLnBhdGggPSB0aGlzLmFkanVzdFBhdGgoc28ucGF0aCk7XG4gICAgICBpZiAoc28uZGlyZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgc28uZGlyZWN0aW9uID0gJ0FTQyc7XG4gICAgICB9XG4gICAgICBzby5kaXJlY3Rpb24gPSBzby5kaXJlY3Rpb24udG9VcHBlckNhc2UoKTtcbiAgICAgIHJldHVybiBzbztcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLmFkZE9yU2V0U29ydE9yZGVyID0gZnVuY3Rpb24oc28pIHtcbiAgICAgIHZhciBjdXJyZW50RGlyZWN0aW9uLCBvZTtcbiAgICAgIHNvID0gdGhpcy5fcGFyc2Vfc29ydF9vcmRlcihzbyk7XG4gICAgICBjdXJyZW50RGlyZWN0aW9uID0gdGhpcy5nZXRTb3J0RGlyZWN0aW9uKHNvLnBhdGgpO1xuICAgICAgaWYgKGN1cnJlbnREaXJlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmFkZFNvcnRPcmRlcihzbyk7XG4gICAgICB9IGVsc2UgaWYgKGN1cnJlbnREaXJlY3Rpb24gIT09IHNvLmRpcmVjdGlvbikge1xuICAgICAgICBvZSA9IHV0aWxzLmZpbmQodGhpcy5zb3J0T3JkZXIsIGZ1bmN0aW9uKF9hcmcpIHtcbiAgICAgICAgICB2YXIgcGF0aDtcbiAgICAgICAgICBwYXRoID0gX2FyZy5wYXRoO1xuICAgICAgICAgIHJldHVybiBwYXRoID09PSBzby5wYXRoO1xuICAgICAgICB9KTtcbiAgICAgICAgb2UuZGlyZWN0aW9uID0gc28uZGlyZWN0aW9uO1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZTpzb3J0b3JkZXInLCB0aGlzLnNvcnRPcmRlcik7XG4gICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLmFkZFNvcnRPcmRlciA9IGZ1bmN0aW9uKHNvLCBfYXJnKSB7XG4gICAgICB2YXIgc2lsZW50O1xuICAgICAgc2lsZW50ID0gKF9hcmcgIT0gbnVsbCA/IF9hcmcgOiB7fSkuc2lsZW50O1xuICAgICAgdGhpcy5zb3J0T3JkZXIucHVzaCh0aGlzLl9wYXJzZV9zb3J0X29yZGVyKHNvKSk7XG4gICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2FkZDpzb3J0b3JkZXInLCBzbyk7XG4gICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlOnNvcnRvcmRlcicsIHRoaXMuc29ydE9yZGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5vcmRlckJ5ID0gZnVuY3Rpb24ob2VzLCBvcHRzKSB7XG4gICAgICB2YXIgY29weSwgZGlyZWN0aW9uLCBvZSwgb2xkU08sIHBhdGgsIF9pLCBfbGVuLCBfcmVmO1xuICAgICAgaWYgKG9wdHMgPT0gbnVsbCkge1xuICAgICAgICBvcHRzID0ge307XG4gICAgICB9XG4gICAgICBvbGRTTyA9IHRoaXMuc29ydE9yZGVyLnNsaWNlKCk7XG4gICAgICB0aGlzLnNvcnRPcmRlciA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBvZXMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgb2UgPSBvZXNbX2ldO1xuICAgICAgICB0aGlzLmFkZFNvcnRPcmRlcih0aGlzLl9wYXJzZV9zb3J0X29yZGVyKG9lKSwge1xuICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvcHkgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfaiwgX2xlbjEsIF9yZWYsIF9yZWYxLCBfcmVzdWx0cztcbiAgICAgICAgX3JlZiA9IHRoaXMuc29ydE9yZGVyO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKF9qID0gMCwgX2xlbjEgPSBfcmVmLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgICAgICAgIF9yZWYxID0gX3JlZltfal0sIHBhdGggPSBfcmVmMS5wYXRoLCBkaXJlY3Rpb24gPSBfcmVmMS5kaXJlY3Rpb247XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy50cmlnZ2VyKCdzZXQ6c29ydG9yZGVyJywgY29weSk7XG4gICAgICBpZiAoKHN0cmluZ2lmeVNvcnRPcmRlcihvbGRTTykpICE9PSB0aGlzLmdldFNvcnRpbmcoKSkge1xuICAgICAgICBpZiAob3B0cy5zaWxlbnQpIHtcbiAgICAgICAgICBvcHRzLmV2ZW50cyA9ICgoX3JlZiA9IG9wdHMuZXZlbnRzKSAhPSBudWxsID8gX3JlZiA6IFtdKS5jb25jYXQoWydjaGFuZ2UnLCAnY2hhbmdlOnNvcnRvcmRlciddKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZTpzb3J0b3JkZXInLCBjb3B5KTtcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLmFkZEpvaW5zID0gZnVuY3Rpb24oam9pbnMpIHtcbiAgICAgIHZhciBqLCBrLCB2LCBfaSwgX2xlbiwgX3Jlc3VsdHMsIF9yZXN1bHRzMTtcbiAgICAgIGlmICh1dGlscy5pc0FycmF5KGpvaW5zKSkge1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IGpvaW5zLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgaiA9IGpvaW5zW19pXTtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKHRoaXMuYWRkSm9pbihqKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3Jlc3VsdHMxID0gW107XG4gICAgICAgIGZvciAoayBpbiBqb2lucykge1xuICAgICAgICAgIHYgPSBqb2luc1trXTtcbiAgICAgICAgICBfcmVzdWx0czEucHVzaCh0aGlzLmFkZEpvaW4oe1xuICAgICAgICAgICAgcGF0aDogayxcbiAgICAgICAgICAgIHN0eWxlOiB2XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0czE7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5hZGRKb2luID0gZnVuY3Rpb24oam9pbikge1xuICAgICAgaWYgKHR5cGVvZiBqb2luID09PSAnc3RyaW5nJykge1xuICAgICAgICBqb2luID0ge1xuICAgICAgICAgIHBhdGg6IGpvaW4sXG4gICAgICAgICAgc3R5bGU6ICdPVVRFUidcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnNldEpvaW5TdHlsZShqb2luLnBhdGgsIGpvaW4uc3R5bGUpO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuc2V0Sm9pblN0eWxlID0gZnVuY3Rpb24ocGF0aCwgc3R5bGUpIHtcbiAgICAgIGlmIChzdHlsZSA9PSBudWxsKSB7XG4gICAgICAgIHN0eWxlID0gJ09VVEVSJztcbiAgICAgIH1cbiAgICAgIHBhdGggPSB0aGlzLmFkanVzdFBhdGgocGF0aCk7XG4gICAgICBzdHlsZSA9IHN0eWxlLnRvVXBwZXJDYXNlKCk7XG4gICAgICBpZiAoX19pbmRleE9mLmNhbGwoUXVlcnkuSk9JTl9TVFlMRVMsIHN0eWxlKSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBqb2luIHN0eWxlOiBcIiArIHN0eWxlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmpvaW5zW3BhdGhdICE9PSBzdHlsZSkge1xuICAgICAgICB0aGlzLmpvaW5zW3BhdGhdID0gc3R5bGU7XG4gICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlOmpvaW5zJywge1xuICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgc3R5bGU6IHN0eWxlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5hZGRDb25zdHJhaW50cyA9IGZ1bmN0aW9uKGNvbnN0cmFpbnRzLCBjb25qKSB7XG4gICAgICB2YXIgYywgY29uLCBvbGRMb2dpYywgcGF0aCwgX2ZuLCBfaSwgX2xlbjtcbiAgICAgIGlmIChjb25qID09IG51bGwpIHtcbiAgICAgICAgY29uaiA9ICdhbmQnO1xuICAgICAgfVxuICAgICAgdGhpcy5fX3NpbGVudF9fID0gdHJ1ZTtcbiAgICAgIG9sZExvZ2ljID0gdGhpcy5jb25zdHJhaW50TG9naWM7XG4gICAgICBpZiAodXRpbHMuaXNBcnJheShjb25zdHJhaW50cykpIHtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBjb25zdHJhaW50cy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIGMgPSBjb25zdHJhaW50c1tfaV07XG4gICAgICAgICAgdGhpcy5hZGRDb25zdHJhaW50KGMsIGNvbmopO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfZm4gPSAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24ocGF0aCwgY29uKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuYWRkQ29uc3RyYWludChpbnRlcnByZXRDb25zdHJhaW50KHBhdGgsIGNvbiksIGNvbmopO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpO1xuICAgICAgICBmb3IgKHBhdGggaW4gY29uc3RyYWludHMpIHtcbiAgICAgICAgICBjb24gPSBjb25zdHJhaW50c1twYXRoXTtcbiAgICAgICAgICBfZm4ocGF0aCwgY29uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fX3NpbGVudF9fID0gZmFsc2U7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2FkZDpjb25zdHJhaW50Jyk7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZTpjb25zdHJhaW50cycpO1xuICAgICAgaWYgKG9sZExvZ2ljICE9PSB0aGlzLmNvbnN0cmFpbnRMb2dpYykge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZTpsb2dpYycsIHRoaXMuY29uc3RyYWludExvZ2ljKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuYWRkQ29uc3RyYWludCA9IGZ1bmN0aW9uKGNvbnN0cmFpbnQsIGNvbmopIHtcbiAgICAgIHZhciBpLCBsb2dpYywgbmVlZHNMb2dpY0NsYXVzZSwgbmV3Q29uTGVuLCBuZXdMb2dpYywgb2xkTG9naWMsIF9yZWY7XG4gICAgICBpZiAoY29uaiA9PSBudWxsKSB7XG4gICAgICAgIGNvbmogPSAnYW5kJztcbiAgICAgIH1cbiAgICAgIGlmIChjb25qICE9PSAnYW5kJyAmJiBjb25qICE9PSAnb3InKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBsb2dpY2FsIGNvbmp1bmN0aW9uOiAnICsgY29uaik7XG4gICAgICB9XG4gICAgICBpZiAodXRpbHMuaXNBcnJheShjb25zdHJhaW50KSkge1xuICAgICAgICBjb25zdHJhaW50ID0gaW50ZXJwcmV0Q29uQXJyYXkoY29uc3RyYWludCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdHJhaW50ID0gY29weUNvbihjb25zdHJhaW50KTtcbiAgICAgIH1cbiAgICAgIGlmIChjb25zdHJhaW50LnN3aXRjaGVkID09PSAnT0ZGJykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGNvbnN0cmFpbnQucGF0aCA9IHRoaXMuYWRqdXN0UGF0aChjb25zdHJhaW50LnBhdGgpO1xuICAgICAgaWYgKGNvbnN0cmFpbnQudHlwZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0cmFpbnQub3AgPSBnZXRfY2Fub25pY2FsX29wKGNvbnN0cmFpbnQub3ApO1xuICAgICAgfVxuICAgICAgdGhpcy5jb25zdHJhaW50cy5wdXNoKGNvbnN0cmFpbnQpO1xuICAgICAgbmVlZHNMb2dpY0NsYXVzZSA9IChjb25qID09PSAnb3InKSB8fCAoKChfcmVmID0gdGhpcy5jb25zdHJhaW50TG9naWMpICE9IG51bGwgPyBfcmVmLmxlbmd0aCA6IHZvaWQgMCkgPiAwKTtcbiAgICAgIG5ld0NvbkxlbiA9IHRoaXMuY29uc3RyYWludHMubGVuZ3RoO1xuICAgICAgb2xkTG9naWMgPSB0aGlzLmNvbnN0cmFpbnRMb2dpYztcbiAgICAgIGlmIChuZWVkc0xvZ2ljQ2xhdXNlKSB7XG4gICAgICAgIG5ld0xvZ2ljID0gbmV3Q29uTGVuID09PSAyID8gXCJcIiArIENPREVTWzBdICsgXCIgXCIgKyBjb25qICsgXCIgXCIgKyBDT0RFU1sxXSA6IChsb2dpYyA9IHRoaXMuY29uc3RyYWludExvZ2ljLCBsb2dpYyB8fCAobG9naWMgPSAoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBfaSwgX3JlZjEsIF9yZXN1bHRzO1xuICAgICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgICAgZm9yIChpID0gX2kgPSAwLCBfcmVmMSA9IG5ld0NvbkxlbiAtIDI7IDAgPD0gX3JlZjEgPyBfaSA8PSBfcmVmMSA6IF9pID49IF9yZWYxOyBpID0gMCA8PSBfcmVmMSA/ICsrX2kgOiAtLV9pKSB7XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKENPREVTW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgICB9KSgpKS5qb2luKCcgYW5kICcpKSwgXCIoXCIgKyBsb2dpYyArIFwiKSBcIiArIGNvbmogKyBcIiBcIiArIENPREVTW25ld0NvbkxlbiAtIDFdKTtcbiAgICAgICAgdGhpcy5jb25zdHJhaW50TG9naWMgPSBuZXdMb2dpYztcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fX3NpbGVudF9fKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcignYWRkOmNvbnN0cmFpbnQnLCBjb25zdHJhaW50KTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2U6Y29uc3RyYWludHMnKTtcbiAgICAgICAgaWYgKG9sZExvZ2ljICE9PSB0aGlzLmNvbnN0cmFpbnRMb2dpYykge1xuICAgICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlOmxvZ2ljJywgdGhpcy5jb25zdHJhaW50TG9naWMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLmdldFNvcnRpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzdHJpbmdpZnlTb3J0T3JkZXIodGhpcy5zb3J0T3JkZXIpO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuZ2V0Q29uc3RyYWludFhNTCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGMsIHRvU2VyaWFsaXNlO1xuICAgICAgdG9TZXJpYWxpc2UgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICAgIF9yZWYgPSB0aGlzLmNvbnN0cmFpbnRzO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBjID0gX3JlZltfaV07XG4gICAgICAgICAgaWYgKChjLnR5cGUgPT0gbnVsbCkgfHwgdGhpcy5pc0luUXVlcnkoYy5wYXRoKSkge1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChjKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgIGlmICh0b1NlcmlhbGlzZS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGNvbmNhdE1hcChjb25TdHIpKGNvbmNhdE1hcChpZCkocGFydGl0aW9uKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICByZXR1cm4gYy50eXBlICE9IG51bGw7XG4gICAgICAgIH0pKHRvU2VyaWFsaXNlKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuZ2V0Sm9pblhNTCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHAsIHMsIHN0cnM7XG4gICAgICBzdHJzID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICAgIF9yZWYgPSB0aGlzLmpvaW5zO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKHAgaW4gX3JlZikge1xuICAgICAgICAgIHMgPSBfcmVmW3BdO1xuICAgICAgICAgIGlmICh0aGlzLmlzSW5RdWVyeShwKSAmJiBzID09PSAnT1VURVInKSB7XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKFwiPGpvaW4gcGF0aD1cXFwiXCIgKyBwICsgXCJcXFwiIHN0eWxlPVxcXCJPVVRFUlxcXCIvPlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgIHJldHVybiBzdHJzLmpvaW4oJycpO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUudG9YTUwgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhdHRycywgaGVhZEF0dHJzLCBrLCB2O1xuICAgICAgYXR0cnMgPSB7XG4gICAgICAgIG1vZGVsOiB0aGlzLm1vZGVsLm5hbWUsXG4gICAgICAgIHZpZXc6IHRoaXMudmlld3Muam9pbignICcpLFxuICAgICAgICBzb3J0T3JkZXI6IHRoaXMuZ2V0U29ydGluZygpLFxuICAgICAgICBjb25zdHJhaW50TG9naWM6IHRoaXMuY29uc3RyYWludExvZ2ljXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMubmFtZSAhPSBudWxsKSB7XG4gICAgICAgIGF0dHJzLm5hbWUgPSB0aGlzLm5hbWU7XG4gICAgICB9XG4gICAgICBoZWFkQXR0cnMgPSAoKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX3Jlc3VsdHM7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoayBpbiBhdHRycykge1xuICAgICAgICAgIHYgPSBhdHRyc1trXTtcbiAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChrICsgJz1cIicgKyB2ICsgJ1wiJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH0pKCkpLmpvaW4oJyAnKTtcbiAgICAgIHJldHVybiBcIjxxdWVyeSBcIiArIGhlYWRBdHRycyArIFwiID5cIiArICh0aGlzLmdldEpvaW5YTUwoKSkgKyAodGhpcy5nZXRDb25zdHJhaW50WE1MKCkpICsgXCI8L3F1ZXJ5PlwiO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYywgZGlyZWN0aW9uLCBwYXRoLCBzdHlsZSwgdjtcbiAgICAgIHJldHVybiBub1VuZGVmVmFscyh7XG4gICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgdGl0bGU6IHRoaXMudGl0bGUsXG4gICAgICAgIGNvbW1lbnQ6IHRoaXMuY29tbWVudCxcbiAgICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXG4gICAgICAgIGNvbnN0cmFpbnRMb2dpYzogdGhpcy5jb25zdHJhaW50TG9naWMsXG4gICAgICAgIGZyb206IHRoaXMucm9vdCxcbiAgICAgICAgc2VsZWN0OiAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgICAgICBfcmVmID0gdGhpcy52aWV3cztcbiAgICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgICAgdiA9IF9yZWZbX2ldO1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChoZWFkTGVzcyh2KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgICAgfSkuY2FsbCh0aGlzKSxcbiAgICAgICAgb3JkZXJCeTogKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBfaSwgX2xlbiwgX3JlZiwgX3JlZjEsIF9yZXN1bHRzO1xuICAgICAgICAgIF9yZWYgPSB0aGlzLnNvcnRPcmRlcjtcbiAgICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgICAgX3JlZjEgPSBfcmVmW19pXSwgcGF0aCA9IF9yZWYxLnBhdGgsIGRpcmVjdGlvbiA9IF9yZWYxLmRpcmVjdGlvbjtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICBwYXRoOiBoZWFkTGVzcyhwYXRoKSxcbiAgICAgICAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICAgIH0pLmNhbGwodGhpcyksXG4gICAgICAgIGpvaW5zOiAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIF9yZWYsIF9yZXN1bHRzO1xuICAgICAgICAgIF9yZWYgPSB0aGlzLmpvaW5zO1xuICAgICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgICAgZm9yIChwYXRoIGluIF9yZWYpIHtcbiAgICAgICAgICAgIHN0eWxlID0gX3JlZltwYXRoXTtcbiAgICAgICAgICAgIGlmIChzdHlsZSA9PT0gJ09VVEVSJykge1xuICAgICAgICAgICAgICBfcmVzdWx0cy5wdXNoKGhlYWRMZXNzKHBhdGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgICB9KS5jYWxsKHRoaXMpLFxuICAgICAgICB3aGVyZTogKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICAgICAgX3JlZiA9IHRoaXMuY29uc3RyYWludHM7XG4gICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICAgIGMgPSBfcmVmW19pXTtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2goY29uVG9KU09OKGMpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgICB9KS5jYWxsKHRoaXMpXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLmZldGNoQ29kZSA9IGZ1bmN0aW9uKGxhbmcsIGNiKSB7XG4gICAgICB2YXIgcmVxO1xuICAgICAgcmVxID0ge1xuICAgICAgICBxdWVyeTogdGhpcy50b1hNTCgpLFxuICAgICAgICBsYW5nOiBsYW5nXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHdpdGhDQihjYiwgdGhpcy5zZXJ2aWNlLnBvc3QoJ3F1ZXJ5L2NvZGUnLCByZXEpLnRoZW4odGhpcy5zZXJ2aWNlLlZFUklGSUVSKS50aGVuKGdldCgnY29kZScpKSk7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5zZXROYW1lID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbihuYW1lLCBjYikge1xuICAgICAgcmV0dXJuIFJFUVVJUkVTX1ZFUlNJT04odGhpcy5zZXJ2aWNlLCAxNiwgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgcmVxLCBfcmVmO1xuICAgICAgICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKG5hbWUpKSB7XG4gICAgICAgICAgICBfcmVmID0gW251bGwsIG5hbWVdLCBuYW1lID0gX3JlZlswXSwgY2IgPSBfcmVmWzFdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBfdGhpcy5zZXROYW1lKG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXEgPSB7XG4gICAgICAgICAgICB0eXBlOiAnUFVUJyxcbiAgICAgICAgICAgIHBhdGg6ICd1c2VyL3F1ZXJpZXMnLFxuICAgICAgICAgICAgZGF0YTogX3RoaXMudG9YTUwoKSxcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24veG1sJyxcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbidcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiB3aXRoQ0IoY2IsIF90aGlzLnNlcnZpY2UuYXV0aG9yaXNlKHJlcSkpLnRoZW4oZnVuY3Rpb24oYXV0aGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuc2VydmljZS5kb1JlcShhdXRoZWQpO1xuICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3AucXVlcmllcztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLnN0b3JlID0gZnVuY3Rpb24obmFtZSwgY2IpIHtcbiAgICAgIHJldHVybiBSRVFVSVJFU19WRVJTSU9OKHRoaXMuc2VydmljZSwgMTYsIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGdldE5hbWUsIHJlcSwgdXBkYXRlTmFtZSwgX3JlZjtcbiAgICAgICAgICBpZiAodXRpbHMuaXNGdW5jdGlvbihuYW1lKSkge1xuICAgICAgICAgICAgX3JlZiA9IFtudWxsLCBuYW1lXSwgbmFtZSA9IF9yZWZbMF0sIGNiID0gX3JlZlsxXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgX3RoaXMuc2V0TmFtZShuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBkYXRlTmFtZSA9IGZ1bmN0aW9uKGVyciwgbmFtZSkge1xuICAgICAgICAgICAgaWYgKGVyciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZXROYW1lKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgZ2V0TmFtZSA9IHV0aWxzLmNvbXBvc2UoZ2V0KF90aGlzLm5hbWUpLCBnZXQoJ3F1ZXJpZXMnKSk7XG4gICAgICAgICAgcmVxID0ge1xuICAgICAgICAgICAgdHlwZTogJ1BPU1QnLFxuICAgICAgICAgICAgcGF0aDogJ3VzZXIvcXVlcmllcycsXG4gICAgICAgICAgICBkYXRhOiBfdGhpcy50b1hNTCgpLFxuICAgICAgICAgICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi94bWwnLFxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJ1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHdpdGhDQihjYiwgdXBkYXRlTmFtZSwgX3RoaXMuc2VydmljZS5hdXRob3Jpc2UocmVxKSkudGhlbihmdW5jdGlvbihhdXRoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZXJ2aWNlLmRvUmVxKGF1dGhlZCk7XG4gICAgICAgICAgfSkudGhlbihnZXROYW1lKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLnNhdmVBc1RlbXBsYXRlID0gZnVuY3Rpb24obmFtZSwgY2IpIHtcbiAgICAgIHJldHVybiBSRVFVSVJFU19WRVJTSU9OKHRoaXMuc2VydmljZSwgMTYsIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHJlcSwgX3JlZjtcbiAgICAgICAgICBpZiAodXRpbHMuaXNGdW5jdGlvbihuYW1lKSkge1xuICAgICAgICAgICAgX3JlZiA9IFtudWxsLCBuYW1lXSwgbmFtZSA9IF9yZWZbMF0sIGNiID0gX3JlZlsxXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgX3RoaXMuc2V0TmFtZShuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFfdGhpcy5uYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUZW1wbGF0ZXMgbXVzdCBoYXZlIGEgbmFtZVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVxID0ge1xuICAgICAgICAgICAgdHlwZTogJ1BPU1QnLFxuICAgICAgICAgICAgcGF0aDogJ3RlbXBsYXRlcycsXG4gICAgICAgICAgICBkYXRhOiBcIjx0ZW1wbGF0ZSBcIiArIChjb25BdHRycyhfdGhpcywgWyduYW1lJywgJ3RpdGxlJywgJ2NvbW1lbnQnXSkpICsgXCI+XCIgKyAoX3RoaXMudG9YTUwoKSkgKyBcIjwvdGVtcGxhdGU+XCIsXG4gICAgICAgICAgICBjb250ZW50VHlwZTogJ2FwcGxpY2F0aW9uL3htbCcsXG4gICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gd2l0aENCKGNiLCBfdGhpcy5zZXJ2aWNlLmF1dGhvcmlzZShyZXEpLnRoZW4oZnVuY3Rpb24oYXV0aGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuc2VydmljZS5kb1JlcShhdXRoZWQpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLmdldENvZGVVUkkgPSBmdW5jdGlvbihsYW5nKSB7XG4gICAgICB2YXIgcmVxLCBfcmVmO1xuICAgICAgcmVxID0ge1xuICAgICAgICBxdWVyeTogdGhpcy50b1hNTCgpLFxuICAgICAgICBsYW5nOiBsYW5nLFxuICAgICAgICBmb3JtYXQ6ICd0ZXh0J1xuICAgICAgfTtcbiAgICAgIGlmICgoKF9yZWYgPSB0aGlzLnNlcnZpY2UpICE9IG51bGwgPyBfcmVmLnRva2VuIDogdm9pZCAwKSAhPSBudWxsKSB7XG4gICAgICAgIHJlcS50b2tlbiA9IHRoaXMuc2VydmljZS50b2tlbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIlwiICsgdGhpcy5zZXJ2aWNlLnJvb3QgKyBcInF1ZXJ5L2NvZGU/XCIgKyAodG9RdWVyeVN0cmluZyhyZXEpKTtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLmdldEV4cG9ydFVSSSA9IGZ1bmN0aW9uKGZvcm1hdCwgb3B0aW9ucykge1xuICAgICAgdmFyIHJlcSwgX3JlZjtcbiAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICBmb3JtYXQgPSAndGFiJztcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKF9faW5kZXhPZi5jYWxsKFF1ZXJ5LkJJT19GT1JNQVRTLCBmb3JtYXQpID49IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbXCJnZXRcIiArIChmb3JtYXQudG9VcHBlckNhc2UoKSkgKyBcIlVSSVwiXShvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJlcSA9IG1lcmdlKG9wdGlvbnMsIHtcbiAgICAgICAgcXVlcnk6IHRoaXMudG9YTUwoKSxcbiAgICAgICAgZm9ybWF0OiBmb3JtYXRcbiAgICAgIH0pO1xuICAgICAgaWYgKCgoX3JlZiA9IHRoaXMuc2VydmljZSkgIT0gbnVsbCA/IF9yZWYudG9rZW4gOiB2b2lkIDApICE9IG51bGwpIHtcbiAgICAgICAgcmVxLnRva2VuID0gdGhpcy5zZXJ2aWNlLnRva2VuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiXCIgKyB0aGlzLnNlcnZpY2Uucm9vdCArIFwicXVlcnkvcmVzdWx0cz9cIiArICh0b1F1ZXJ5U3RyaW5nKHJlcSkpO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUubmVlZHNBdXRoZW50aWNhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHV0aWxzLmFueSh0aGlzLmNvbnN0cmFpbnRzLCBmdW5jdGlvbihjKSB7XG4gICAgICAgIHZhciBfcmVmO1xuICAgICAgICByZXR1cm4gKF9yZWYgPSBjLm9wKSA9PT0gJ05PVCBJTicgfHwgX3JlZiA9PT0gJ0lOJztcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuZmV0Y2hRSUQgPSBmdW5jdGlvbihjYikge1xuICAgICAgcmV0dXJuIHdpdGhDQihjYiwgdGhpcy5zZXJ2aWNlLnBvc3QoJ3F1ZXJpZXMnLCB7XG4gICAgICAgIHF1ZXJ5OiB0aGlzLnRvWE1MKClcbiAgICAgIH0pLnRoZW4oZ2V0KCdpZCcpKSk7XG4gICAgfTtcblxuICAgIGFkZFBJID0gZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIHAuYXBwZW5kKCdwcmltYXJ5SWRlbnRpZmllcicpLnRvU3RyaW5nKCk7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5fX2Jpb19yZXEgPSBmdW5jdGlvbih0eXBlcywgbikge1xuICAgICAgdmFyIGlzU3VpdGFibGUsIHRvUnVuO1xuICAgICAgdG9SdW4gPSB0aGlzLm1ha2VMaXN0UXVlcnkoKTtcbiAgICAgIGlzU3VpdGFibGUgPSBmdW5jdGlvbihwKSB7XG4gICAgICAgIHJldHVybiB1dGlscy5hbnkodHlwZXMsIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICByZXR1cm4gcC5pc2EodCk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHRvUnVuLnZpZXdzID0gdXRpbHMudGFrZShuKSgoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICAgIF9yZWYgPSB0aGlzLmdldFZpZXdOb2RlcygpO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBuID0gX3JlZltfaV07XG4gICAgICAgICAgaWYgKGlzU3VpdGFibGUobikpIHtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2goYWRkUEkobikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KS5jYWxsKHRoaXMpKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHF1ZXJ5OiB0b1J1bi50b1hNTCgpLFxuICAgICAgICBmb3JtYXQ6ICd0ZXh0J1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLl9mYXN0YV9yZXEgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fYmlvX3JlcShbXCJTZXF1ZW5jZUZlYXR1cmVcIiwgJ1Byb3RlaW4nXSwgMSk7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5fZ2ZmM19yZXEgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fYmlvX3JlcShbJ1NlcXVlbmNlRmVhdHVyZSddKTtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLl9iZWRfcmVxID0gUXVlcnkucHJvdG90eXBlLl9nZmYzX3JlcTtcblxuICAgIHJldHVybiBRdWVyeTtcblxuICB9KSgpO1xuXG4gIHVuaW9uID0gZm9sZChmdW5jdGlvbih4cywgeXMpIHtcbiAgICByZXR1cm4geHMuY29uY2F0KHlzKTtcbiAgfSk7XG5cbiAgUXVlcnkucHJvdG90eXBlLnRvU3RyaW5nID0gUXVlcnkucHJvdG90eXBlLnRvWE1MO1xuXG4gIFF1ZXJ5LkFUVFJJQlVURV9PUFMgPSB1bmlvbihbUXVlcnkuQVRUUklCVVRFX1ZBTFVFX09QUywgUXVlcnkuTVVMVElWQUxVRV9PUFMsIFF1ZXJ5Lk5VTExfT1BTXSk7XG5cbiAgUXVlcnkuUkVGRVJFTkNFX09QUyA9IHVuaW9uKFtRdWVyeS5URVJOQVJZX09QUywgUXVlcnkuTE9PUF9PUFMsIFF1ZXJ5LkxJU1RfT1BTXSk7XG5cbiAgYmlvVXJpQXJncyA9IGZ1bmN0aW9uKHJlcU1ldGgsIGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob3B0cywgY2IpIHtcbiAgICAgIHZhciBlbnN1cmVBdHRyLCBvYmosIHJlcSwgdiwgX3JlZjtcbiAgICAgIGlmIChvcHRzID09IG51bGwpIHtcbiAgICAgICAgb3B0cyA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKGNiID09IG51bGwpIHtcbiAgICAgICAgY2IgPSBmdW5jdGlvbigpIHt9O1xuICAgICAgfVxuICAgICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24ob3B0cykpIHtcbiAgICAgICAgX3JlZiA9IFt7fSwgb3B0c10sIG9wdHMgPSBfcmVmWzBdLCBjYiA9IF9yZWZbMV07XG4gICAgICB9XG4gICAgICBlbnN1cmVBdHRyID0gKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgdmFyIHBhdGg7XG4gICAgICAgICAgcGF0aCA9IF90aGlzLmdldFBhdGhJbmZvKHApO1xuICAgICAgICAgIGlmIChwYXRoLmlzQXR0cmlidXRlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0aC5hcHBlbmQoJ2lkJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSkodGhpcyk7XG4gICAgICBpZiAoKG9wdHMgIT0gbnVsbCA/IG9wdHMudmlldyA6IHZvaWQgMCkgIT0gbnVsbCkge1xuICAgICAgICBvcHRzLnZpZXcgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgICAgICAgX3JlZjEgPSBvcHRzLnZpZXc7XG4gICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgICB2ID0gX3JlZjFbX2ldO1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaCh0aGlzLmdldFBhdGhJbmZvKHYpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgICBvYmogPSBvcHRzW1wiZXhwb3J0XCJdICE9IG51bGwgPyB0aGlzLnNlbGVjdFByZXNlcnZpbmdJbXBsaWVkQ29uc3RyYWludHMob3B0c1tcImV4cG9ydFwiXS5tYXAoZW5zdXJlQXR0cikpIDogdGhpcztcbiAgICAgIHJlcSA9IG1lcmdlKG9ialtyZXFNZXRoXSgpLCBvcHRzKTtcbiAgICAgIHJldHVybiBmLmNhbGwob2JqLCByZXEsIGNiKTtcbiAgICB9O1xuICB9O1xuXG4gIF9yZWYgPSBRdWVyeS5CSU9fRk9STUFUUztcbiAgX2ZuID0gZnVuY3Rpb24oZikge1xuICAgIHZhciBnZXRNZXRoLCByZXFNZXRoLCB1cmlNZXRoO1xuICAgIHJlcU1ldGggPSBcIl9cIiArIGYgKyBcIl9yZXFcIjtcbiAgICBnZXRNZXRoID0gXCJnZXRcIiArIChmLnRvVXBwZXJDYXNlKCkpO1xuICAgIHVyaU1ldGggPSBnZXRNZXRoICsgXCJVUklcIjtcbiAgICBRdWVyeS5wcm90b3R5cGVbZ2V0TWV0aF0gPSBiaW9VcmlBcmdzKHJlcU1ldGgsIGZ1bmN0aW9uKHJlcSwgY2IpIHtcbiAgICAgIHJldHVybiB3aXRoQ0IoY2IsIHRoaXMuc2VydmljZS5wb3N0KCdxdWVyeS9yZXN1bHRzLycgKyBmLCByZXEpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gUXVlcnkucHJvdG90eXBlW3VyaU1ldGhdID0gYmlvVXJpQXJncyhyZXFNZXRoLCBmdW5jdGlvbihyZXEsIGNiKSB7XG4gICAgICBpZiAodGhpcy5zZXJ2aWNlLnRva2VuICE9IG51bGwpIHtcbiAgICAgICAgcmVxLnRva2VuID0gdGhpcy5zZXJ2aWNlLnRva2VuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiXCIgKyB0aGlzLnNlcnZpY2Uucm9vdCArIFwicXVlcnkvcmVzdWx0cy9cIiArIGYgKyBcIj9cIiArICh0b1F1ZXJ5U3RyaW5nKHJlcSkpO1xuICAgIH0pO1xuICB9O1xuICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICBmID0gX3JlZltfaV07XG4gICAgX2ZuKGYpO1xuICB9XG5cbiAgX2dldF9kYXRhX2ZldGNoZXIgPSBmdW5jdGlvbihzZXJ2ZXJfZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2JzLCBwYWdlLCB4LCBfcmVmMTtcbiAgICAgIHBhZ2UgPSBhcmd1bWVudHNbMF0sIGNicyA9IDIgPD0gYXJndW1lbnRzLmxlbmd0aCA/IF9fc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpIDogW107XG4gICAgICBpZiAodGhpcy5zZXJ2aWNlW3NlcnZlcl9mbl0pIHtcbiAgICAgICAgaWYgKHBhZ2UgPT0gbnVsbCkge1xuICAgICAgICAgIHBhZ2UgPSB7fTtcbiAgICAgICAgfSBlbHNlIGlmICh1dGlscy5pc0Z1bmN0aW9uKHBhZ2UpKSB7XG4gICAgICAgICAgcGFnZSA9IHt9O1xuICAgICAgICAgIGNicyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBfaiwgX2xlbjEsIF9yZXN1bHRzO1xuICAgICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IGFyZ3VtZW50cy5sZW5ndGg7IF9qIDwgX2xlbjE7IF9qKyspIHtcbiAgICAgICAgICAgICAgeCA9IGFyZ3VtZW50c1tfal07XG4gICAgICAgICAgICAgIF9yZXN1bHRzLnB1c2goeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICAgICAgfSkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBwYWdlID0gbm9VbmRlZlZhbHMobWVyZ2Uoe1xuICAgICAgICAgIHN0YXJ0OiB0aGlzLnN0YXJ0LFxuICAgICAgICAgIHNpemU6IHRoaXMubWF4Um93c1xuICAgICAgICB9LCBwYWdlKSk7XG4gICAgICAgIHJldHVybiAoX3JlZjEgPSB0aGlzLnNlcnZpY2UpW3NlcnZlcl9mbl0uYXBwbHkoX3JlZjEsIFt0aGlzLCBwYWdlXS5jb25jYXQoX19zbGljZS5jYWxsKGNicykpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlcnZpY2UgZG9lcyBub3QgcHJvdmlkZSAnXCIgKyBzZXJ2ZXJfZm4gKyBcIicuXCIpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgZm9yIChfaiA9IDAsIF9sZW4xID0gUkVTVUxUU19NRVRIT0RTLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgIG10aCA9IFJFU1VMVFNfTUVUSE9EU1tfal07XG4gICAgUXVlcnkucHJvdG90eXBlW210aF0gPSBfZ2V0X2RhdGFfZmV0Y2hlcihtdGgpO1xuICB9XG5cbiAgRXZlbnRzLm1peGluKFF1ZXJ5LnByb3RvdHlwZSk7XG5cbiAgUXVlcnkucHJvdG90eXBlLmVtaXQgPSBRdWVyeS5wcm90b3R5cGUudHJpZ2dlcjtcblxuICBRdWVyeS5wcm90b3R5cGUuYmluZCA9IFF1ZXJ5LnByb3RvdHlwZS5vbjtcblxuICBpbnRlcm1pbmUuUXVlcnkgPSBRdWVyeTtcblxufSkuY2FsbCh0aGlzKTtcblxufSx7XCIuL3V0aWxcIjoxNSxcIi4veG1sXCI6MTcsXCJiYWNrYm9uZS1ldmVudHMtc3RhbmRhbG9uZVwiOjIxfV0sMTA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgQUxXQVlTX0FVVEgsIENMQVNTS0VZUywgQ0xBU1NLRVlfUEFUSCwgREVGQVVMVF9FUlJPUl9IQU5ETEVSLCBERUZBVUxUX1BST1RPQ09MLCBFTlJJQ0hNRU5UX1BBVEgsIEhBU19QUk9UT0NPTCwgSEFTX1NVRkZJWCwgSURSZXNvbHV0aW9uSm9iLCBJRF9SRVNPTFVUSU9OX1BBVEgsIExJU1RTX1BBVEgsIExJU1RfT1BFUkFUSU9OX1BBVEhTLCBMSVNUX1BJUEUsIExpc3QsIE1PREVMUywgTU9ERUxfUEFUSCwgTW9kZWwsIE5FRURTX0FVVEgsIE5PX0FVVEgsIFBBVEhfVkFMVUVTX1BBVEgsIFBSRUZfUEFUSCwgUHJvbWlzZSwgUVVFUllfUkVTVUxUU19QQVRILCBRVUlDS1NFQVJDSF9QQVRILCBRdWVyeSwgUkVMRUFTRVMsIFJFTEVBU0VfUEFUSCwgUkVRVUlSRVNfVkVSU0lPTiwgU1VCVFJBQ1RfUEFUSCwgU1VGRklYLCBTVU1NQVJZRklFTERTX1BBVEgsIFNVTU1BUllfRklFTERTLCBTZXJ2aWNlLCBUQUJMRV9ST1dfUEFUSCwgVEVNUExBVEVTX1BBVEgsIFRPX05BTUVTLCBVU0VSX1RPS0VOUywgVXNlciwgVkVSU0lPTlMsIFZFUlNJT05fUEFUSCwgV0hPQU1JX1BBVEgsIFdJREdFVFMsIFdJREdFVFNfUEFUSCwgV0lUSF9PQkpfUEFUSCwgZGVqb2luLCBlcnJvciwgZ2V0LCBnZXRMaXN0RmluZGVyLCBodHRwLCBpbnZva2UsIG1hcCwgbWVyZ2UsIHAsIHNldCwgc3VjY2VzcywgdG9fcXVlcnlfc3RyaW5nLCB1dGlscywgdmVyc2lvbiwgd2l0aENCLCBfZ2V0X29yX2ZldGNoLCBfaSwgX2osIF9sZW4sIF9sZW4xLCBfcmVmLCBfcmVmMSxcbiAgICBfX2JpbmQgPSBmdW5jdGlvbihmbiwgbWUpeyByZXR1cm4gZnVuY3Rpb24oKXsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9LFxuICAgIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxuICAgIF9fc2xpY2UgPSBbXS5zbGljZTtcblxuICBQcm9taXNlID0gX2RlcmVxXygnLi9wcm9taXNlJyk7XG5cbiAgTW9kZWwgPSBfZGVyZXFfKCcuL21vZGVsJykuTW9kZWw7XG5cbiAgUXVlcnkgPSBfZGVyZXFfKCcuL3F1ZXJ5JykuUXVlcnk7XG5cbiAgTGlzdCA9IF9kZXJlcV8oJy4vbGlzdHMnKS5MaXN0O1xuXG4gIFVzZXIgPSBfZGVyZXFfKCcuL3VzZXInKS5Vc2VyO1xuXG4gIElEUmVzb2x1dGlvbkpvYiA9IF9kZXJlcV8oJy4vaWQtcmVzb2x1dGlvbi1qb2InKS5JRFJlc29sdXRpb25Kb2I7XG5cbiAgdmVyc2lvbiA9IF9kZXJlcV8oJy4vdmVyc2lvbicpO1xuXG4gIHV0aWxzID0gX2RlcmVxXygnLi91dGlsJyk7XG5cbiAgaHR0cCA9IF9kZXJlcV8oJy4vaHR0cCcpO1xuXG4gIHRvX3F1ZXJ5X3N0cmluZyA9IHV0aWxzLnF1ZXJ5c3RyaW5nO1xuXG4gIHdpdGhDQiA9IHV0aWxzLndpdGhDQiwgbWFwID0gdXRpbHMubWFwLCBtZXJnZSA9IHV0aWxzLm1lcmdlLCBnZXQgPSB1dGlscy5nZXQsIHNldCA9IHV0aWxzLnNldCwgaW52b2tlID0gdXRpbHMuaW52b2tlLCBzdWNjZXNzID0gdXRpbHMuc3VjY2VzcywgZXJyb3IgPSB1dGlscy5lcnJvciwgUkVRVUlSRVNfVkVSU0lPTiA9IHV0aWxzLlJFUVVJUkVTX1ZFUlNJT04sIGRlam9pbiA9IHV0aWxzLmRlam9pbjtcblxuICBWRVJTSU9OUyA9IHt9O1xuXG4gIENMQVNTS0VZUyA9IHt9O1xuXG4gIFJFTEVBU0VTID0ge307XG5cbiAgTU9ERUxTID0ge307XG5cbiAgU1VNTUFSWV9GSUVMRFMgPSB7fTtcblxuICBXSURHRVRTID0ge307XG5cbiAgREVGQVVMVF9QUk9UT0NPTCA9IFwiaHR0cDovL1wiO1xuXG4gIFZFUlNJT05fUEFUSCA9IFwidmVyc2lvblwiO1xuXG4gIFRFTVBMQVRFU19QQVRIID0gXCJ0ZW1wbGF0ZXNcIjtcblxuICBSRUxFQVNFX1BBVEggPSBcInZlcnNpb24vcmVsZWFzZVwiO1xuXG4gIENMQVNTS0VZX1BBVEggPSBcImNsYXNza2V5c1wiO1xuXG4gIExJU1RTX1BBVEggPSBcImxpc3RzXCI7XG5cbiAgTU9ERUxfUEFUSCA9IFwibW9kZWxcIjtcblxuICBTVU1NQVJZRklFTERTX1BBVEggPSBcInN1bW1hcnlmaWVsZHNcIjtcblxuICBRVUVSWV9SRVNVTFRTX1BBVEggPSBcInF1ZXJ5L3Jlc3VsdHNcIjtcblxuICBRVUlDS1NFQVJDSF9QQVRIID0gXCJzZWFyY2hcIjtcblxuICBXSURHRVRTX1BBVEggPSBcIndpZGdldHNcIjtcblxuICBFTlJJQ0hNRU5UX1BBVEggPSBcImxpc3QvZW5yaWNobWVudFwiO1xuXG4gIFdJVEhfT0JKX1BBVEggPSBcImxpc3Rzd2l0aG9iamVjdFwiO1xuXG4gIExJU1RfT1BFUkFUSU9OX1BBVEhTID0ge1xuICAgIHVuaW9uOiBcImxpc3RzL3VuaW9uXCIsXG4gICAgaW50ZXJzZWN0aW9uOiBcImxpc3RzL2ludGVyc2VjdFwiLFxuICAgIGRpZmZlcmVuY2U6IFwibGlzdHMvZGlmZlwiXG4gIH07XG5cbiAgU1VCVFJBQ1RfUEFUSCA9ICdsaXN0cy9zdWJ0cmFjdCc7XG5cbiAgV0hPQU1JX1BBVEggPSBcInVzZXIvd2hvYW1pXCI7XG5cbiAgVEFCTEVfUk9XX1BBVEggPSBRVUVSWV9SRVNVTFRTX1BBVEggKyAnL3RhYmxlcm93cyc7XG5cbiAgUFJFRl9QQVRIID0gJ3VzZXIvcHJlZmVyZW5jZXMnO1xuXG4gIFBBVEhfVkFMVUVTX1BBVEggPSAncGF0aC92YWx1ZXMnO1xuXG4gIFVTRVJfVE9LRU5TID0gJ3VzZXIvdG9rZW5zJztcblxuICBJRF9SRVNPTFVUSU9OX1BBVEggPSAnaWRzJztcblxuICBOT19BVVRIID0ge307XG5cbiAgX3JlZiA9IFtWRVJTSU9OX1BBVEgsIFJFTEVBU0VfUEFUSCwgQ0xBU1NLRVlfUEFUSCwgV0lER0VUU19QQVRILCBNT0RFTF9QQVRILCBTVU1NQVJZRklFTERTX1BBVEgsIFFVSUNLU0VBUkNIX1BBVEgsIFBBVEhfVkFMVUVTX1BBVEhdO1xuICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICBwID0gX3JlZltfaV07XG4gICAgTk9fQVVUSFtwXSA9IHRydWU7XG4gIH1cblxuICBBTFdBWVNfQVVUSCA9IHt9O1xuXG4gIF9yZWYxID0gW1dIT0FNSV9QQVRILCBQUkVGX1BBVEgsIExJU1RfT1BFUkFUSU9OX1BBVEhTLCBTVUJUUkFDVF9QQVRILCBXSVRIX09CSl9QQVRILCBFTlJJQ0hNRU5UX1BBVEgsIFRFTVBMQVRFU19QQVRILCBVU0VSX1RPS0VOU107XG4gIGZvciAoX2ogPSAwLCBfbGVuMSA9IF9yZWYxLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgIHAgPSBfcmVmMVtfal07XG4gICAgQUxXQVlTX0FVVEhbcF0gPSB0cnVlO1xuICB9XG5cbiAgTkVFRFNfQVVUSCA9IGZ1bmN0aW9uKHBhdGgsIHEpIHtcbiAgICBpZiAoTk9fQVVUSFtwYXRoXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoQUxXQVlTX0FVVEhbcGF0aF0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIShxICE9IG51bGwgPyBxLm5lZWRzQXV0aGVudGljYXRpb24gOiB2b2lkIDApKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHEubmVlZHNBdXRoZW50aWNhdGlvbigpO1xuICAgIH1cbiAgfTtcblxuICBIQVNfUFJPVE9DT0wgPSAvXmh0dHBzPzpcXC9cXC8vaTtcblxuICBIQVNfU1VGRklYID0gL3NlcnZpY2VcXC8/JC9pO1xuXG4gIFNVRkZJWCA9IFwiL3NlcnZpY2UvXCI7XG5cbiAgREVGQVVMVF9FUlJPUl9IQU5ETEVSID0gZnVuY3Rpb24oZSkge1xuICAgIHZhciBmLCBfcmVmMjtcbiAgICBmID0gKF9yZWYyID0gY29uc29sZS5lcnJvcikgIT0gbnVsbCA/IF9yZWYyIDogY29uc29sZS5sb2c7XG4gICAgcmV0dXJuIGYoZSk7XG4gIH07XG5cbiAgX2dldF9vcl9mZXRjaCA9IGZ1bmN0aW9uKHByb3BOYW1lLCBzdG9yZSwgcGF0aCwga2V5LCBjYikge1xuICAgIHZhciBvcHRzLCBwcm9taXNlLCByb290LCB1c2VDYWNoZSwgdmFsdWU7XG4gICAgcm9vdCA9IHRoaXMucm9vdCwgdXNlQ2FjaGUgPSB0aGlzLnVzZUNhY2hlO1xuICAgIHByb21pc2UgPSB0aGlzW3Byb3BOYW1lXSAhPSBudWxsID8gdGhpc1twcm9wTmFtZV0gOiB0aGlzW3Byb3BOYW1lXSA9IHVzZUNhY2hlICYmICh2YWx1ZSA9IHN0b3JlW3Jvb3RdKSA/IHN1Y2Nlc3ModmFsdWUpIDogKG9wdHMgPSB7XG4gICAgICB0eXBlOiAnR0VUJyxcbiAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGZvcm1hdDogJ2pzb24nXG4gICAgICB9XG4gICAgfSwgdGhpcy5kb1JlcShtZXJnZShvcHRzLCB7XG4gICAgICB1cmw6IHRoaXMucm9vdCArIHBhdGhcbiAgICB9KSkudGhlbihmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gc3RvcmVbcm9vdF0gPSB4W2tleV07XG4gICAgfSkpO1xuICAgIHJldHVybiB3aXRoQ0IoY2IsIHByb21pc2UpO1xuICB9O1xuXG4gIGdldExpc3RGaW5kZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGxpc3RzKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBsaXN0O1xuICAgICAgICBpZiAobGlzdCA9IHV0aWxzLmZpbmQobGlzdHMsIGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgICByZXR1cm4gbC5uYW1lID09PSBuYW1lO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKGxpc3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiByZWplY3QoXCJMaXN0IFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgbm90IGZvdW5kIGFtb25nOiBcIiArIChsaXN0cy5tYXAoZ2V0KCduYW1lJykpKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG5cbiAgTElTVF9QSVBFID0gZnVuY3Rpb24oc2VydmljZSwgcHJvcCkge1xuICAgIGlmIChwcm9wID09IG51bGwpIHtcbiAgICAgIHByb3AgPSAnbGlzdE5hbWUnO1xuICAgIH1cbiAgICByZXR1cm4gdXRpbHMuY29tcG9zZShzZXJ2aWNlLmZldGNoTGlzdCwgZ2V0KHByb3ApKTtcbiAgfTtcblxuICBUT19OQU1FUyA9IGZ1bmN0aW9uKHhzKSB7XG4gICAgdmFyIHgsIF9rLCBfbGVuMiwgX3JlZjIsIF9yZWYzLCBfcmVzdWx0cztcbiAgICBpZiAoeHMgPT0gbnVsbCkge1xuICAgICAgeHMgPSBbXTtcbiAgICB9XG4gICAgX3JlZjIgPSAodXRpbHMuaXNBcnJheSh4cykgPyB4cyA6IFt4c10pO1xuICAgIF9yZXN1bHRzID0gW107XG4gICAgZm9yIChfayA9IDAsIF9sZW4yID0gX3JlZjIubGVuZ3RoOyBfayA8IF9sZW4yOyBfaysrKSB7XG4gICAgICB4ID0gX3JlZjJbX2tdO1xuICAgICAgX3Jlc3VsdHMucHVzaCgoX3JlZjMgPSB4Lm5hbWUpICE9IG51bGwgPyBfcmVmMyA6IHgpO1xuICAgIH1cbiAgICByZXR1cm4gX3Jlc3VsdHM7XG4gIH07XG5cbiAgU2VydmljZSA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgRklWRV9NSU4sIGNoZWNrTmFtZVBhcmFtLCBnZXROZXdVc2VyVG9rZW4sIGxvYWRRLCBwYXRoVmFsdWVzUmVxLCB0b01hcEJ5TmFtZTtcblxuICAgIFNlcnZpY2UucHJvdG90eXBlLmRvUmVxID0gaHR0cC5kb1JlcTtcblxuICAgIGZ1bmN0aW9uIFNlcnZpY2UoX2FyZykge1xuICAgICAgdmFyIG5vQ2FjaGU7XG4gICAgICB0aGlzLnJvb3QgPSBfYXJnLnJvb3QsIHRoaXMudG9rZW4gPSBfYXJnLnRva2VuLCB0aGlzLmVycm9ySGFuZGxlciA9IF9hcmcuZXJyb3JIYW5kbGVyLCB0aGlzLkRFQlVHID0gX2FyZy5ERUJVRywgdGhpcy5oZWxwID0gX2FyZy5oZWxwLCBub0NhY2hlID0gX2FyZy5ub0NhY2hlO1xuICAgICAgdGhpcy5jb25uZWN0QXMgPSBfX2JpbmQodGhpcy5jb25uZWN0QXMsIHRoaXMpO1xuICAgICAgdGhpcy5jcmVhdGVMaXN0ID0gX19iaW5kKHRoaXMuY3JlYXRlTGlzdCwgdGhpcyk7XG4gICAgICB0aGlzLnJlc29sdmVJZHMgPSBfX2JpbmQodGhpcy5yZXNvbHZlSWRzLCB0aGlzKTtcbiAgICAgIHRoaXMudGVtcGxhdGVRdWVyeSA9IF9fYmluZCh0aGlzLnRlbXBsYXRlUXVlcnksIHRoaXMpO1xuICAgICAgdGhpcy5zYXZlZFF1ZXJ5ID0gX19iaW5kKHRoaXMuc2F2ZWRRdWVyeSwgdGhpcyk7XG4gICAgICB0aGlzLnF1ZXJ5ID0gX19iaW5kKHRoaXMucXVlcnksIHRoaXMpO1xuICAgICAgdGhpcy5mZXRjaFJlbGVhc2UgPSBfX2JpbmQodGhpcy5mZXRjaFJlbGVhc2UsIHRoaXMpO1xuICAgICAgdGhpcy5mZXRjaENsYXNzS2V5cyA9IF9fYmluZCh0aGlzLmZldGNoQ2xhc3NLZXlzLCB0aGlzKTtcbiAgICAgIHRoaXMuZmV0Y2hWZXJzaW9uID0gX19iaW5kKHRoaXMuZmV0Y2hWZXJzaW9uLCB0aGlzKTtcbiAgICAgIHRoaXMuZmV0Y2hTdW1tYXJ5RmllbGRzID0gX19iaW5kKHRoaXMuZmV0Y2hTdW1tYXJ5RmllbGRzLCB0aGlzKTtcbiAgICAgIHRoaXMuZmV0Y2hNb2RlbCA9IF9fYmluZCh0aGlzLmZldGNoTW9kZWwsIHRoaXMpO1xuICAgICAgdGhpcy5mZXRjaFdpZGdldE1hcCA9IF9fYmluZCh0aGlzLmZldGNoV2lkZ2V0TWFwLCB0aGlzKTtcbiAgICAgIHRoaXMuZmV0Y2hXaWRnZXRzID0gX19iaW5kKHRoaXMuZmV0Y2hXaWRnZXRzLCB0aGlzKTtcbiAgICAgIHRoaXMuY29tcGxlbWVudCA9IF9fYmluZCh0aGlzLmNvbXBsZW1lbnQsIHRoaXMpO1xuICAgICAgdGhpcy5mZXRjaExpc3RzQ29udGFpbmluZyA9IF9fYmluZCh0aGlzLmZldGNoTGlzdHNDb250YWluaW5nLCB0aGlzKTtcbiAgICAgIHRoaXMuZmV0Y2hMaXN0ID0gX19iaW5kKHRoaXMuZmV0Y2hMaXN0LCB0aGlzKTtcbiAgICAgIHRoaXMuZmluZExpc3RzID0gX19iaW5kKHRoaXMuZmluZExpc3RzLCB0aGlzKTtcbiAgICAgIHRoaXMuZmV0Y2hMaXN0cyA9IF9fYmluZCh0aGlzLmZldGNoTGlzdHMsIHRoaXMpO1xuICAgICAgdGhpcy5mZXRjaFRlbXBsYXRlcyA9IF9fYmluZCh0aGlzLmZldGNoVGVtcGxhdGVzLCB0aGlzKTtcbiAgICAgIHRoaXMudGFibGVSb3dzID0gX19iaW5kKHRoaXMudGFibGVSb3dzLCB0aGlzKTtcbiAgICAgIHRoaXMudmFsdWVzID0gX19iaW5kKHRoaXMudmFsdWVzLCB0aGlzKTtcbiAgICAgIHRoaXMucm93cyA9IF9fYmluZCh0aGlzLnJvd3MsIHRoaXMpO1xuICAgICAgdGhpcy5yZWNvcmRzID0gX19iaW5kKHRoaXMucmVjb3JkcywgdGhpcyk7XG4gICAgICB0aGlzLnRhYmxlID0gX19iaW5kKHRoaXMudGFibGUsIHRoaXMpO1xuICAgICAgdGhpcy5wYXRoVmFsdWVzID0gX19iaW5kKHRoaXMucGF0aFZhbHVlcywgdGhpcyk7XG4gICAgICB0aGlzLmZldGNoVXNlciA9IF9fYmluZCh0aGlzLmZldGNoVXNlciwgdGhpcyk7XG4gICAgICB0aGlzLndob2FtaSA9IF9fYmluZCh0aGlzLndob2FtaSwgdGhpcyk7XG4gICAgICB0aGlzLmZpbmRCeUlkID0gX19iaW5kKHRoaXMuZmluZEJ5SWQsIHRoaXMpO1xuICAgICAgdGhpcy5jb3VudCA9IF9fYmluZCh0aGlzLmNvdW50LCB0aGlzKTtcbiAgICAgIHRoaXMuZW5yaWNobWVudCA9IF9fYmluZCh0aGlzLmVucmljaG1lbnQsIHRoaXMpO1xuICAgICAgaWYgKHRoaXMucm9vdCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHNlcnZpY2Ugcm9vdCBwcm92aWRlZC4gVGhpcyBpcyByZXF1aXJlZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghSEFTX1BST1RPQ09MLnRlc3QodGhpcy5yb290KSkge1xuICAgICAgICB0aGlzLnJvb3QgPSBERUZBVUxUX1BST1RPQ09MICsgdGhpcy5yb290O1xuICAgICAgfVxuICAgICAgaWYgKCFIQVNfU1VGRklYLnRlc3QodGhpcy5yb290KSkge1xuICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLnJvb3QgKyBTVUZGSVg7XG4gICAgICB9XG4gICAgICB0aGlzLnJvb3QgPSB0aGlzLnJvb3QucmVwbGFjZSgvaWNlJC8sIFwiaWNlL1wiKTtcbiAgICAgIGlmICh0aGlzLmVycm9ySGFuZGxlciA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuZXJyb3JIYW5kbGVyID0gREVGQVVMVF9FUlJPUl9IQU5ETEVSO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaGVscCA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuaGVscCA9ICduby5oZWxwLmF2YWlsYWJsZUBkZXYubnVsbCc7XG4gICAgICB9XG4gICAgICB0aGlzLnVzZUNhY2hlID0gIW5vQ2FjaGU7XG4gICAgICB0aGlzLmdldEZvcm1hdCA9IChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oaW50ZW5kZWQpIHtcbiAgICAgICAgICBpZiAoaW50ZW5kZWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgaW50ZW5kZWQgPSAnanNvbic7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpbnRlbmRlZDtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpO1xuICAgIH1cblxuICAgIFNlcnZpY2UucHJvdG90eXBlLnBvc3QgPSBmdW5jdGlvbihwYXRoLCBkYXRhKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYWtlUmVxdWVzdCgnUE9TVCcsIHBhdGgsIGRhdGEpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihwYXRoLCBkYXRhKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYWtlUmVxdWVzdCgnR0VUJywgcGF0aCwgZGF0YSk7XG4gICAgfTtcblxuICAgIFNlcnZpY2UucHJvdG90eXBlLm1ha2VSZXF1ZXN0ID0gZnVuY3Rpb24obWV0aG9kLCBwYXRoLCBkYXRhLCBjYiwgaW5kaXYpIHtcbiAgICAgIHZhciBkYXRhVHlwZSwgZXJyQmFjaywgb3B0cywgdGltZW91dCwgX3JlZjIsIF9yZWYzLCBfcmVmNDtcbiAgICAgIGlmIChtZXRob2QgPT0gbnVsbCkge1xuICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgIH1cbiAgICAgIGlmIChwYXRoID09IG51bGwpIHtcbiAgICAgICAgcGF0aCA9ICcnO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEgPT0gbnVsbCkge1xuICAgICAgICBkYXRhID0ge307XG4gICAgICB9XG4gICAgICBpZiAoY2IgPT0gbnVsbCkge1xuICAgICAgICBjYiA9IChmdW5jdGlvbigpIHt9KTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmRpdiA9PSBudWxsKSB7XG4gICAgICAgIGluZGl2ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodXRpbHMuaXNBcnJheShjYikpIHtcbiAgICAgICAgX3JlZjIgPSBjYiwgY2IgPSBfcmVmMlswXSwgZXJyQmFjayA9IF9yZWYyWzFdO1xuICAgICAgfVxuICAgICAgaWYgKHV0aWxzLmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgZGF0YSA9IHV0aWxzLnBhaXJzVG9PYmooZGF0YSk7XG4gICAgICB9XG4gICAgICBpZiAoZXJyQmFjayA9PSBudWxsKSB7XG4gICAgICAgIGVyckJhY2sgPSB0aGlzLmVycm9ySGFuZGxlcjtcbiAgICAgIH1cbiAgICAgIGRhdGEgPSB1dGlscy5jb3B5KGRhdGEpO1xuICAgICAgZGF0YVR5cGUgPSB0aGlzLmdldEZvcm1hdChkYXRhLmZvcm1hdCk7XG4gICAgICBpZiAoIWh0dHAuc3VwcG9ydHMobWV0aG9kKSkge1xuICAgICAgICBfcmVmMyA9IFttZXRob2QsIGh0dHAuZ2V0TWV0aG9kKG1ldGhvZCldLCBkYXRhLm1ldGhvZCA9IF9yZWYzWzBdLCBtZXRob2QgPSBfcmVmM1sxXTtcbiAgICAgIH1cbiAgICAgIG9wdHMgPSB7XG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIGRhdGFUeXBlOiBkYXRhVHlwZSxcbiAgICAgICAgc3VjY2VzczogY2IsXG4gICAgICAgIGVycm9yOiBlcnJCYWNrLFxuICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICB0eXBlOiBtZXRob2RcbiAgICAgIH07XG4gICAgICBpZiAoZGF0YS5hdXRoICE9IG51bGwpIHtcbiAgICAgICAgb3B0cy5hdXRoID0gZGF0YS5hdXRoO1xuICAgICAgICBkZWxldGUgb3B0cy5kYXRhLmF1dGg7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YS5oZWFkZXJzICE9IG51bGwpIHtcbiAgICAgICAgb3B0cy5oZWFkZXJzID0gdXRpbHMuY29weShkYXRhLmhlYWRlcnMpO1xuICAgICAgICBkZWxldGUgb3B0cy5kYXRhLmhlYWRlcnM7XG4gICAgICB9XG4gICAgICBpZiAodGltZW91dCA9IChfcmVmNCA9IGRhdGEudGltZW91dCkgIT0gbnVsbCA/IF9yZWY0IDogdGhpcy50aW1lb3V0KSB7XG4gICAgICAgIG9wdHMudGltZW91dCA9IHRpbWVvdXQ7XG4gICAgICAgIGRlbGV0ZSBkYXRhLnRpbWVvdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5hdXRob3Jpc2Uob3B0cykudGhlbigoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGF1dGhlZCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5kb1JlcShhdXRoZWQsIGluZGl2KTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUuYXV0aG9yaXNlID0gZnVuY3Rpb24ocmVxKSB7XG4gICAgICByZXR1cm4gdGhpcy5mZXRjaFZlcnNpb24oKS50aGVuKChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odmVyc2lvbikge1xuICAgICAgICAgIHZhciBvcHRzLCBwYXRoQWRkaXRpb25zLCBfcmVmMjtcbiAgICAgICAgICBvcHRzID0gdXRpbHMuY29weShyZXEpO1xuICAgICAgICAgIGlmIChvcHRzLmhlYWRlcnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0cy5oZWFkZXJzID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIG9wdHMudXJsID0gX3RoaXMucm9vdCArIG9wdHMucGF0aDtcbiAgICAgICAgICBwYXRoQWRkaXRpb25zID0gW107XG4gICAgICAgICAgaWYgKHZlcnNpb24gPCAxNCkge1xuICAgICAgICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2Ygb3B0cy5kYXRhKSB7XG4gICAgICAgICAgICAgIHBhdGhBZGRpdGlvbnMucHVzaChbJ2Zvcm1hdCcsIG9wdHMuZGF0YVR5cGVdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9wdHMuZGF0YS5mb3JtYXQgPSBvcHRzLmRhdGFUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKF90aGlzLnRva2VuICE9IG51bGwpICYmIE5FRURTX0FVVEgocmVxLnBhdGgsIChfcmVmMiA9IG9wdHMuZGF0YSkgIT0gbnVsbCA/IF9yZWYyLnF1ZXJ5IDogdm9pZCAwKSkge1xuICAgICAgICAgICAgaWYgKHZlcnNpb24gPj0gMTQpIHtcbiAgICAgICAgICAgICAgb3B0cy5oZWFkZXJzLkF1dGhvcml6YXRpb24gPSBcIlRva2VuIFwiICsgX3RoaXMudG9rZW47XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCdzdHJpbmcnID09PSB0eXBlb2Ygb3B0cy5kYXRhKSB7XG4gICAgICAgICAgICAgIHBhdGhBZGRpdGlvbnMucHVzaChbJ3Rva2VuJywgX3RoaXMudG9rZW5dKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9wdHMuZGF0YS50b2tlbiA9IF90aGlzLnRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGF0aEFkZGl0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG9wdHMudXJsICs9ICc/JyArIHRvX3F1ZXJ5X3N0cmluZyhwYXRoQWRkaXRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG9wdHM7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgfTtcblxuICAgIFNlcnZpY2UucHJvdG90eXBlLmVucmljaG1lbnQgPSBmdW5jdGlvbihvcHRzLCBjYikge1xuICAgICAgcmV0dXJuIFJFUVVJUkVTX1ZFUlNJT04odGhpcywgOCwgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgcmVxO1xuICAgICAgICAgIHJlcSA9IG1lcmdlKHtcbiAgICAgICAgICAgIG1heHA6IDAuMDUsXG4gICAgICAgICAgICBjb3JyZWN0aW9uOiAnSG9sbS1Cb25mZXJyb25pJ1xuICAgICAgICAgIH0sIG9wdHMpO1xuICAgICAgICAgIHJldHVybiB3aXRoQ0IoY2IsIF90aGlzLmdldChFTlJJQ0hNRU5UX1BBVEgsIHJlcSkudGhlbihnZXQoJ3Jlc3VsdHMnKSkpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5zZWFyY2ggPSBmdW5jdGlvbihvcHRpb25zLCBjYikge1xuICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG4gICAgICBpZiAoY2IgPT0gbnVsbCkge1xuICAgICAgICBjYiA9IChmdW5jdGlvbigpIHt9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBSRVFVSVJFU19WRVJTSU9OKHRoaXMsIDksIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGssIHJlcSwgdiwgX3JlZjI7XG4gICAgICAgICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24ob3B0aW9ucykpIHtcbiAgICAgICAgICAgIF9yZWYyID0gW29wdGlvbnMsIHt9XSwgY2IgPSBfcmVmMlswXSwgb3B0aW9ucyA9IF9yZWYyWzFdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXEgPSB7XG4gICAgICAgICAgICAgIHE6IG9wdGlvbnNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcSA9IHtcbiAgICAgICAgICAgICAgcTogb3B0aW9ucy5xXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChrIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgaWYgKCFfX2hhc1Byb3AuY2FsbChvcHRpb25zLCBrKSkgY29udGludWU7XG4gICAgICAgICAgICAgIHYgPSBvcHRpb25zW2tdO1xuICAgICAgICAgICAgICBpZiAoayAhPT0gJ3EnKSB7XG4gICAgICAgICAgICAgICAgcmVxW1wiZmFjZXRfXCIgKyBrXSA9IHY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHdpdGhDQihjYiwgX3RoaXMucG9zdChRVUlDS1NFQVJDSF9QQVRILCByZXEpKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUubWFrZVBhdGggPSBmdW5jdGlvbihwYXRoLCBzdWJjbGFzc2VzLCBjYikge1xuICAgICAgaWYgKHN1YmNsYXNzZXMgPT0gbnVsbCkge1xuICAgICAgICBzdWJjbGFzc2VzID0ge307XG4gICAgICB9XG4gICAgICBpZiAoY2IgPT0gbnVsbCkge1xuICAgICAgICBjYiA9IChmdW5jdGlvbigpIHt9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3aXRoQ0IoY2IsIHRoaXMuZmV0Y2hNb2RlbCgpLnRoZW4oZnVuY3Rpb24obSkge1xuICAgICAgICByZXR1cm4gbS5tYWtlUGF0aChwYXRoLCBzdWJjbGFzc2VzKTtcbiAgICAgIH0pKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbihxLCBjYikge1xuICAgICAgdmFyIHByb21pc2UsIHJlcTtcbiAgICAgIGlmIChjYiA9PSBudWxsKSB7XG4gICAgICAgIGNiID0gKGZ1bmN0aW9uKCkge30pO1xuICAgICAgfVxuICAgICAgcHJvbWlzZSA9ICFxID8gZXJyb3IoXCJOb3QgZW5vdWdoIGFyZ3VtZW50c1wiKSA6IHEudG9QYXRoU3RyaW5nICE9IG51bGwgPyAocCA9IHEuaXNDbGFzcygpID8gcS5hcHBlbmQoJ2lkJykgOiBxLCB0aGlzLnBhdGhWYWx1ZXMocCwgJ2NvdW50JykpIDogcS50b1hNTCAhPSBudWxsID8gKHJlcSA9IHtcbiAgICAgICAgcXVlcnk6IHEsXG4gICAgICAgIGZvcm1hdDogJ2pzb25jb3VudCdcbiAgICAgIH0sIHRoaXMucG9zdChRVUVSWV9SRVNVTFRTX1BBVEgsIHJlcSkudGhlbihnZXQoJ2NvdW50JykpKSA6IHR5cGVvZiBxID09PSAnc3RyaW5nJyA/IHRoaXMuZmV0Y2hNb2RlbCgpLnRoZW4oKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihtKSB7XG4gICAgICAgICAgdmFyIGU7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5jb3VudChtLm1ha2VQYXRoKHEpKTtcbiAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMucXVlcnkoe1xuICAgICAgICAgICAgICBzZWxlY3Q6IFtxXVxuICAgICAgICAgICAgfSkudGhlbihfdGhpcy5jb3VudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpIDogdGhpcy5xdWVyeShxKS50aGVuKHRoaXMuY291bnQpO1xuICAgICAgcmV0dXJuIHdpdGhDQihjYiwgcHJvbWlzZSk7XG4gICAgfTtcblxuICAgIFNlcnZpY2UucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24odHlwZSwgaWQsIGZpZWxkcywgY2IpIHtcbiAgICAgIHZhciBwcm9taXNlLCBfcmVmMjtcbiAgICAgIGlmIChmaWVsZHMgPT0gbnVsbCkge1xuICAgICAgICBmaWVsZHMgPSBbJyoqJ107XG4gICAgICB9XG4gICAgICBpZiAoY2IgPT0gbnVsbCkge1xuICAgICAgICBjYiA9IChmdW5jdGlvbigpIHt9KTtcbiAgICAgIH1cbiAgICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKGZpZWxkcykpIHtcbiAgICAgICAgX3JlZjIgPSBbWycqKiddLCBmaWVsZHNdLCBmaWVsZHMgPSBfcmVmMlswXSwgY2IgPSBfcmVmMlsxXTtcbiAgICAgIH1cbiAgICAgIHByb21pc2UgPSB0aGlzLnF1ZXJ5KHtcbiAgICAgICAgZnJvbTogdHlwZSxcbiAgICAgICAgc2VsZWN0OiBmaWVsZHMsXG4gICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgaWQ6IGlkXG4gICAgICAgIH1cbiAgICAgIH0pLnRoZW4oZGVqb2luKS50aGVuKGludm9rZSgncmVjb3JkcycpKS50aGVuKGdldCgwKSk7XG4gICAgICByZXR1cm4gd2l0aENCKGNiLCBwcm9taXNlKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUubG9va3VwID0gZnVuY3Rpb24odHlwZSwgdGVybSwgY29udGV4dCwgY2IpIHtcbiAgICAgIHZhciBwcm9taXNlLCBfcmVmMjtcbiAgICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKGNvbnRleHQpKSB7XG4gICAgICAgIF9yZWYyID0gW251bGwsIGNvbnRleHRdLCBjb250ZXh0ID0gX3JlZjJbMF0sIGNiID0gX3JlZjJbMV07XG4gICAgICB9XG4gICAgICBwcm9taXNlID0gdGhpcy5xdWVyeSh7XG4gICAgICAgIGZyb206IHR5cGUsXG4gICAgICAgIHNlbGVjdDogWycqKiddLFxuICAgICAgICB3aGVyZTogW1t0eXBlLCAnTE9PS1VQJywgdGVybSwgY29udGV4dF1dXG4gICAgICB9KS50aGVuKGRlam9pbikudGhlbihpbnZva2UoJ3JlY29yZHMnKSk7XG4gICAgICByZXR1cm4gd2l0aENCKGNiLCBwcm9taXNlKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKHR5cGUsIHRlcm0sIGNvbnRleHQsIGNiKSB7XG4gICAgICB2YXIgX3JlZjI7XG4gICAgICBpZiAodXRpbHMuaXNGdW5jdGlvbihjb250ZXh0KSkge1xuICAgICAgICBfcmVmMiA9IFtudWxsLCBjb250ZXh0XSwgY29udGV4dCA9IF9yZWYyWzBdLCBjYiA9IF9yZWYyWzFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdpdGhDQihjYiwgdGhpcy5sb29rdXAodHlwZSwgdGVybSwgY29udGV4dCkudGhlbihmdW5jdGlvbihmb3VuZCkge1xuICAgICAgICBpZiAoKGZvdW5kID09IG51bGwpIHx8IGZvdW5kLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBlcnJvcihcIk5vdGhpbmcgZm91bmRcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoZm91bmQubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHJldHVybiBlcnJvcihcIk11bHRpcGxlIGl0ZW1zIGZvdW5kOiBcIiArIChmb3VuZC5zbGljZSgwLCAzKSkgKyBcIi4uLlwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc3VjY2Vzcyhmb3VuZFswXSk7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUud2hvYW1pID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgIHJldHVybiBSRVFVSVJFU19WRVJTSU9OKHRoaXMsIDksIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHdpdGhDQihjYiwgX3RoaXMuZ2V0KFdIT0FNSV9QQVRIKS50aGVuKGdldCgndXNlcicpKS50aGVuKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVXNlcihfdGhpcywgeCk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5mZXRjaFVzZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmdzO1xuICAgICAgYXJncyA9IDEgPD0gYXJndW1lbnRzLmxlbmd0aCA/IF9fc2xpY2UuY2FsbChhcmd1bWVudHMsIDApIDogW107XG4gICAgICByZXR1cm4gdGhpcy53aG9hbWkuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfTtcblxuICAgIHBhdGhWYWx1ZXNSZXEgPSBmdW5jdGlvbihmb3JtYXQsIHBhdGgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZvcm1hdDogZm9ybWF0LFxuICAgICAgICBwYXRoOiBTdHJpbmcocGF0aCksXG4gICAgICAgIHR5cGVDb25zdHJhaW50czogSlNPTi5zdHJpbmdpZnkocGF0aC5zdWJjbGFzc2VzKVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUucGF0aFZhbHVlcyA9IGZ1bmN0aW9uKHBhdGgsIHR5cGVDb25zdHJhaW50cywgY2IpIHtcbiAgICAgIGlmICh0eXBlQ29uc3RyYWludHMgPT0gbnVsbCkge1xuICAgICAgICB0eXBlQ29uc3RyYWludHMgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBSRVFVSVJFU19WRVJTSU9OKHRoaXMsIDYsIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGUsIGZvcm1hdCwgcHJvbWlzZSwgd2FudGVkLCBfcmVmMjtcbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVDb25zdHJhaW50cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHdhbnRlZCA9IHR5cGVDb25zdHJhaW50cztcbiAgICAgICAgICAgIHR5cGVDb25zdHJhaW50cyA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodXRpbHMuaXNGdW5jdGlvbih0eXBlQ29uc3RyYWludHMpKSB7XG4gICAgICAgICAgICBfcmVmMiA9IFtjYiwgdHlwZUNvbnN0cmFpbnRzXSwgdHlwZUNvbnN0cmFpbnRzID0gX3JlZjJbMF0sIGNiID0gX3JlZjJbMV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh3YW50ZWQgIT09ICdjb3VudCcpIHtcbiAgICAgICAgICAgIHdhbnRlZCA9ICdyZXN1bHRzJztcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9ybWF0ID0gd2FudGVkID09PSAnY291bnQnID8gJ2pzb25jb3VudCcgOiAnanNvbic7XG4gICAgICAgICAgcHJvbWlzZSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBfcmVmMztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoTW9kZWwoKS50aGVuKGludm9rZSgnbWFrZVBhdGgnLCBwYXRoLCAoX3JlZjMgPSBwYXRoLnN1YmNsYXNzZXMpICE9IG51bGwgPyBfcmVmMyA6IHR5cGVDb25zdHJhaW50cykpLnRoZW4oZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoVmFsdWVzUmVxKGZvcm1hdCwgcGF0aCk7XG4gICAgICAgICAgICAgIH0pLnRoZW4oKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHJlcSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnBvc3QoUEFUSF9WQUxVRVNfUEFUSCwgcmVxKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9KSh0aGlzKSkudGhlbihnZXQod2FudGVkKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLmNhbGwoX3RoaXMpO1xuICAgICAgICAgIHJldHVybiB3aXRoQ0IoY2IsIHByb21pc2UpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5kb1BhZ2VkUmVxdWVzdCA9IGZ1bmN0aW9uKHEsIHBhdGgsIHBhZ2UsIGZvcm1hdCwgY2IpIHtcbiAgICAgIHZhciByZXEsIF9yZWYyO1xuICAgICAgaWYgKHBhZ2UgPT0gbnVsbCkge1xuICAgICAgICBwYWdlID0ge307XG4gICAgICB9XG4gICAgICBpZiAoY2IgPT0gbnVsbCkge1xuICAgICAgICBjYiA9IChmdW5jdGlvbigpIHt9KTtcbiAgICAgIH1cbiAgICAgIGlmIChxLnRvWE1MICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24ocGFnZSkpIHtcbiAgICAgICAgICBfcmVmMiA9IFtwYWdlLCB7fV0sIGNiID0gX3JlZjJbMF0sIHBhZ2UgPSBfcmVmMlsxXTtcbiAgICAgICAgfVxuICAgICAgICByZXEgPSBtZXJnZShwYWdlLCB7XG4gICAgICAgICAgcXVlcnk6IHEsXG4gICAgICAgICAgZm9ybWF0OiBmb3JtYXRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB3aXRoQ0IoY2IsIHRoaXMucG9zdChwYXRoLCByZXEpLnRoZW4oZ2V0KCdyZXN1bHRzJykpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5KHEpLnRoZW4oKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHF1ZXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuZG9QYWdlZFJlcXVlc3QocXVlcnksIHBhdGgsIHBhZ2UsIGZvcm1hdCwgY2IpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUudGFibGUgPSBmdW5jdGlvbihxLCBwYWdlLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuZG9QYWdlZFJlcXVlc3QocSwgUVVFUllfUkVTVUxUU19QQVRILCBwYWdlLCAnanNvbnRhYmxlJywgY2IpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5yZWNvcmRzID0gZnVuY3Rpb24ocSwgcGFnZSwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLmRvUGFnZWRSZXF1ZXN0KHEsIFFVRVJZX1JFU1VMVFNfUEFUSCwgcGFnZSwgJ2pzb25vYmplY3RzJywgY2IpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5yb3dzID0gZnVuY3Rpb24ocSwgcGFnZSwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLmRvUGFnZWRSZXF1ZXN0KHEsIFFVRVJZX1JFU1VMVFNfUEFUSCwgcGFnZSwgJ2pzb24nLCBjYik7XG4gICAgfTtcblxuICAgIFNlcnZpY2UucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKHEsIG9wdHMsIGNiKSB7XG4gICAgICB2YXIgcmVzcCwgX3JlZjI7XG4gICAgICBpZiAodXRpbHMuaXNGdW5jdGlvbihvcHRzKSkge1xuICAgICAgICBfcmVmMiA9IFtvcHRzLCBjYl0sIGNiID0gX3JlZjJbMF0sIG9wdHMgPSBfcmVmMlsxXTtcbiAgICAgIH1cbiAgICAgIHJlc3AgPSBxID09IG51bGwgPyBlcnJvcihcIk5vIHF1ZXJ5IHRlcm0gc3VwcGxpZWRcIikgOiAocS5kZXNjcmlwdG9ycyAhPSBudWxsKSB8fCB0eXBlb2YgcSA9PT0gJ3N0cmluZycgPyB0aGlzLnBhdGhWYWx1ZXMocSwgb3B0cykudGhlbihtYXAoZ2V0KCd2YWx1ZScpKSkgOiBxLnRvWE1MICE9IG51bGwgPyBxLnZpZXdzLmxlbmd0aCAhPT0gMSA/IGVycm9yKFwiRXhwZWN0ZWQgb25lIGNvbHVtbiwgZ290IFwiICsgcS52aWV3cy5sZW5ndGgpIDogdGhpcy5yb3dzKHEsIG9wdHMpLnRoZW4obWFwKGdldCgwKSkpIDogdGhpcy5xdWVyeShxKS50aGVuKChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ocXVlcnkpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMudmFsdWVzKHF1ZXJ5LCBvcHRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICAgIHJldHVybiB3aXRoQ0IoY2IsIHJlc3ApO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS50YWJsZVJvd3MgPSBmdW5jdGlvbihxLCBwYWdlLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuZG9QYWdlZFJlcXVlc3QocSwgVEFCTEVfUk9XX1BBVEgsIHBhZ2UsICdqc29uJywgY2IpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5mZXRjaFRlbXBsYXRlcyA9IGZ1bmN0aW9uKGNiKSB7XG4gICAgICByZXR1cm4gd2l0aENCKGNiLCB0aGlzLmdldChURU1QTEFURVNfUEFUSCkudGhlbihnZXQoJ3RlbXBsYXRlcycpKSk7XG4gICAgfTtcblxuICAgIFNlcnZpY2UucHJvdG90eXBlLmZldGNoTGlzdHMgPSBmdW5jdGlvbihjYikge1xuICAgICAgcmV0dXJuIHRoaXMuZmluZExpc3RzKCcnLCBjYik7XG4gICAgfTtcblxuICAgIFNlcnZpY2UucHJvdG90eXBlLmZpbmRMaXN0cyA9IGZ1bmN0aW9uKG5hbWUsIGNiKSB7XG4gICAgICBpZiAobmFtZSA9PSBudWxsKSB7XG4gICAgICAgIG5hbWUgPSAnJztcbiAgICAgIH1cbiAgICAgIGlmIChjYiA9PSBudWxsKSB7XG4gICAgICAgIGNiID0gKGZ1bmN0aW9uKCkge30pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hWZXJzaW9uKCkudGhlbigoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICB2YXIgZm47XG4gICAgICAgICAgcmV0dXJuIHdpdGhDQihjYiwgbmFtZSAmJiB2IDwgMTMgPyBlcnJvcihcIkZpbmRpbmcgbGlzdHMgYnkgbmFtZSBvbiB0aGUgc2VydmVyIHJlcXVpcmVzIHZlcnNpb24gMTMuIFRoaXMgaXMgb25seSBcIiArIHYpIDogKGZuID0gZnVuY3Rpb24obHMpIHtcbiAgICAgICAgICAgIHZhciBkYXRhLCBfaywgX2xlbjIsIF9yZXN1bHRzO1xuICAgICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoX2sgPSAwLCBfbGVuMiA9IGxzLmxlbmd0aDsgX2sgPCBfbGVuMjsgX2srKykge1xuICAgICAgICAgICAgICBkYXRhID0gbHNbX2tdO1xuICAgICAgICAgICAgICBfcmVzdWx0cy5wdXNoKG5ldyBMaXN0KGRhdGEsIF90aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICAgICAgfSwgX3RoaXMuZ2V0KExJU1RTX1BBVEgsIHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgICB9KS50aGVuKGdldCgnbGlzdHMnKSkudGhlbihmbikpKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUuZmV0Y2hMaXN0ID0gZnVuY3Rpb24obmFtZSwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLmZldGNoVmVyc2lvbigpLnRoZW4oKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIHdpdGhDQihjYiwgdiA8IDEzID8gX3RoaXMuZmluZExpc3RzKCkudGhlbihnZXRMaXN0RmluZGVyKG5hbWUpKSA6IF90aGlzLmZpbmRMaXN0cyhuYW1lKS50aGVuKGdldCgwKSkpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5mZXRjaExpc3RzQ29udGFpbmluZyA9IGZ1bmN0aW9uKG9wdHMsIGNiKSB7XG4gICAgICB2YXIgZm47XG4gICAgICBmbiA9IChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oeHMpIHtcbiAgICAgICAgICB2YXIgeCwgX2ssIF9sZW4yLCBfcmVzdWx0cztcbiAgICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICAgIGZvciAoX2sgPSAwLCBfbGVuMiA9IHhzLmxlbmd0aDsgX2sgPCBfbGVuMjsgX2srKykge1xuICAgICAgICAgICAgeCA9IHhzW19rXTtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2gobmV3IExpc3QoeCwgX3RoaXMpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcyk7XG4gICAgICByZXR1cm4gd2l0aENCKGNiLCB0aGlzLmdldChXSVRIX09CSl9QQVRILCBvcHRzKS50aGVuKGdldCgnbGlzdHMnKSkudGhlbihmbikpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5jb21iaW5lTGlzdHMgPSBmdW5jdGlvbihvcGVyYXRpb24sIG9wdGlvbnMsIGNiKSB7XG4gICAgICB2YXIgZGVzY3JpcHRpb24sIGxpc3RzLCBuYW1lLCByZXEsIHRhZ3MsIF9yZWYyO1xuICAgICAgX3JlZjIgPSBtZXJnZSh7XG4gICAgICAgIGxpc3RzOiBbXSxcbiAgICAgICAgdGFnczogW11cbiAgICAgIH0sIG9wdGlvbnMpLCBuYW1lID0gX3JlZjIubmFtZSwgbGlzdHMgPSBfcmVmMi5saXN0cywgdGFncyA9IF9yZWYyLnRhZ3MsIGRlc2NyaXB0aW9uID0gX3JlZjIuZGVzY3JpcHRpb247XG4gICAgICByZXEgPSB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvblxuICAgICAgfTtcbiAgICAgIGlmIChyZXEuZGVzY3JpcHRpb24gPT0gbnVsbCkge1xuICAgICAgICByZXEuZGVzY3JpcHRpb24gPSBcIlwiICsgb3BlcmF0aW9uICsgXCIgb2YgXCIgKyAobGlzdHMuam9pbignLCAnKSk7XG4gICAgICB9XG4gICAgICByZXEudGFncyA9IHRhZ3Muam9pbignOycpO1xuICAgICAgcmVxLmxpc3RzID0gbGlzdHMuam9pbignOycpO1xuICAgICAgcmV0dXJuIHdpdGhDQihjYiwgdGhpcy5nZXQoTElTVF9PUEVSQVRJT05fUEFUSFNbb3BlcmF0aW9uXSwgcmVxKS50aGVuKExJU1RfUElQRSh0aGlzKSkpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tYmluZUxpc3RzLmFwcGx5KHRoaXMsIFsndW5pb24nXS5jb25jYXQoX19zbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUuaW50ZXJzZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21iaW5lTGlzdHMuYXBwbHkodGhpcywgWydpbnRlcnNlY3Rpb24nXS5jb25jYXQoX19zbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUuZGlmZiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tYmluZUxpc3RzLmFwcGx5KHRoaXMsIFsnZGlmZmVyZW5jZSddLmNvbmNhdChfX3NsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5jb21wbGVtZW50ID0gZnVuY3Rpb24ob3B0aW9ucywgY2IpIHtcbiAgICAgIHZhciBkZWZhdWx0RGVzYywgZGVzY3JpcHRpb24sIGV4Y2x1ZGUsIGZyb20sIGxpc3RzLCBuYW1lLCByZWZlcmVuY2VzLCByZXEsIHRhZ3M7XG4gICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChjYiA9PSBudWxsKSB7XG4gICAgICAgIGNiID0gZnVuY3Rpb24oKSB7fTtcbiAgICAgIH1cbiAgICAgIGZyb20gPSBvcHRpb25zLmZyb20sIGV4Y2x1ZGUgPSBvcHRpb25zLmV4Y2x1ZGUsIG5hbWUgPSBvcHRpb25zLm5hbWUsIGRlc2NyaXB0aW9uID0gb3B0aW9ucy5kZXNjcmlwdGlvbiwgdGFncyA9IG9wdGlvbnMudGFncztcbiAgICAgIGRlZmF1bHREZXNjID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBcIlJlbGF0aXZlIGNvbXBsZW1lbnQgb2YgXCIgKyAobGlzdHMuam9pbignIGFuZCAnKSkgKyBcIiBpbiBcIiArIChyZWZlcmVuY2VzLmpvaW4oJyBhbmQgJykpO1xuICAgICAgfTtcbiAgICAgIHJlZmVyZW5jZXMgPSBUT19OQU1FUyhmcm9tKTtcbiAgICAgIGxpc3RzID0gVE9fTkFNRVMoZXhjbHVkZSk7XG4gICAgICBpZiAobmFtZSA9PSBudWxsKSB7XG4gICAgICAgIG5hbWUgPSBkZWZhdWx0RGVzYygpO1xuICAgICAgfVxuICAgICAgaWYgKGRlc2NyaXB0aW9uID09IG51bGwpIHtcbiAgICAgICAgZGVzY3JpcHRpb24gPSBkZWZhdWx0RGVzYygpO1xuICAgICAgfVxuICAgICAgaWYgKHRhZ3MgPT0gbnVsbCkge1xuICAgICAgICB0YWdzID0gW107XG4gICAgICB9XG4gICAgICByZXEgPSB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcbiAgICAgICAgdGFnczogdGFncyxcbiAgICAgICAgbGlzdHM6IGxpc3RzLFxuICAgICAgICByZWZlcmVuY2VzOiByZWZlcmVuY2VzXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHdpdGhDQihjYiwgdGhpcy5wb3N0KFNVQlRSQUNUX1BBVEgsIHJlcSkudGhlbihMSVNUX1BJUEUodGhpcykpKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUuZmV0Y2hXaWRnZXRzID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgIHJldHVybiBSRVFVSVJFU19WRVJTSU9OKHRoaXMsIDgsIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIF9nZXRfb3JfZmV0Y2guY2FsbChfdGhpcywgJ3dpZGdldHMnLCBXSURHRVRTLCBXSURHRVRTX1BBVEgsICd3aWRnZXRzJywgY2IpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH07XG5cbiAgICB0b01hcEJ5TmFtZSA9IHV0aWxzLm9tYXAoZnVuY3Rpb24odykge1xuICAgICAgcmV0dXJuIFt3Lm5hbWUsIHddO1xuICAgIH0pO1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUuZmV0Y2hXaWRnZXRNYXAgPSBmdW5jdGlvbihjYikge1xuICAgICAgcmV0dXJuIFJFUVVJUkVTX1ZFUlNJT04odGhpcywgOCwgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gd2l0aENCKGNiLCAoX3RoaXMuX193bWFwX18gIT0gbnVsbCA/IF90aGlzLl9fd21hcF9fIDogX3RoaXMuX193bWFwX18gPSBfdGhpcy5mZXRjaFdpZGdldHMoKS50aGVuKHRvTWFwQnlOYW1lKSkpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5mZXRjaE1vZGVsID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgIHZhciByZXQ7XG4gICAgICByZXQgPSBfZ2V0X29yX2ZldGNoLmNhbGwodGhpcywgJ21vZGVsJywgTU9ERUxTLCBNT0RFTF9QQVRILCAnbW9kZWwnKS50aGVuKE1vZGVsLmxvYWQpLnRoZW4oc2V0KHtcbiAgICAgICAgc2VydmljZTogdGhpc1xuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIHdpdGhDQihjYiwgcmV0KTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUuZmV0Y2hTdW1tYXJ5RmllbGRzID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgIHJldHVybiBfZ2V0X29yX2ZldGNoLmNhbGwodGhpcywgJ3N1bW1hcnlGaWVsZHMnLCBTVU1NQVJZX0ZJRUxEUywgU1VNTUFSWUZJRUxEU19QQVRILCAnY2xhc3NlcycsIGNiKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUuZmV0Y2hWZXJzaW9uID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgIHJldHVybiBfZ2V0X29yX2ZldGNoLmNhbGwodGhpcywgJ3ZlcnNpb24nLCBWRVJTSU9OUywgVkVSU0lPTl9QQVRILCAndmVyc2lvbicsIGNiKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUuZmV0Y2hDbGFzc0tleXMgPSBmdW5jdGlvbihjYikge1xuICAgICAgcmV0dXJuIF9nZXRfb3JfZmV0Y2guY2FsbCh0aGlzLCAnY2xhc3NrZXlzJywgQ0xBU1NLRVlTLCBDTEFTU0tFWV9QQVRILCAnY2xhc3NlcycsIGNiKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUuZmV0Y2hSZWxlYXNlID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgIHJldHVybiBfZ2V0X29yX2ZldGNoLmNhbGwodGhpcywgJ3JlbGVhc2UnLCBSRUxFQVNFUywgUkVMRUFTRV9QQVRILCAndmVyc2lvbicsIGNiKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbihvcHRpb25zLCBjYikge1xuICAgICAgdmFyIGJ1aWxkUXVlcnk7XG4gICAgICBidWlsZFF1ZXJ5ID0gKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihfYXJnKSB7XG4gICAgICAgICAgdmFyIG1vZGVsLCBzdW1tYXJ5RmllbGRzO1xuICAgICAgICAgIG1vZGVsID0gX2FyZ1swXSwgc3VtbWFyeUZpZWxkcyA9IF9hcmdbMV07XG4gICAgICAgICAgcmV0dXJuIG5ldyBRdWVyeShvcHRpb25zLCBfdGhpcywge1xuICAgICAgICAgICAgbW9kZWw6IG1vZGVsLFxuICAgICAgICAgICAgc3VtbWFyeUZpZWxkczogc3VtbWFyeUZpZWxkc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcyk7XG4gICAgICByZXR1cm4gd2l0aENCKGNiLCB1dGlscy5wYXJhbGxlbCh0aGlzLmZldGNoTW9kZWwoKSwgdGhpcy5mZXRjaFN1bW1hcnlGaWVsZHMoKSkudGhlbihidWlsZFF1ZXJ5KSk7XG4gICAgfTtcblxuICAgIGxvYWRRID0gZnVuY3Rpb24oc2VydmljZSwgbmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHEpIHtcbiAgICAgICAgaWYgKCFxKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yKFwiTm8gcXVlcnkgZm91bmQgY2FsbGVkIFwiICsgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlcnZpY2UucXVlcnkocSk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjaGVja05hbWVQYXJhbSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gc3VjY2VzcygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBlcnJvcihcIk5hbWUgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVycm9yKFwiTmFtZSBub3QgcHJvdmlkZWRcIik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFNlcnZpY2UucHJvdG90eXBlLnNhdmVkUXVlcnkgPSBmdW5jdGlvbihuYW1lLCBjYikge1xuICAgICAgcmV0dXJuIFJFUVVJUkVTX1ZFUlNJT04odGhpcywgMTYsIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGNoZWNrTmFtZVBhcmFtKG5hbWUpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gd2l0aENCKGNiLCBfdGhpcy5nZXQoJ3VzZXIvcXVlcmllcycsIHtcbiAgICAgICAgICAgICAgZmlsdGVyOiBuYW1lXG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHIucXVlcmllc1tuYW1lXTtcbiAgICAgICAgICAgIH0pLnRoZW4obG9hZFEoX3RoaXMsIG5hbWUpKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgfTtcblxuICAgIFNlcnZpY2UucHJvdG90eXBlLnRlbXBsYXRlUXVlcnkgPSBmdW5jdGlvbihuYW1lLCBjYikge1xuICAgICAgcmV0dXJuIGNoZWNrTmFtZVBhcmFtKG5hbWUpLnRoZW4oKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gd2l0aENCKGNiLCBfdGhpcy5mZXRjaFRlbXBsYXRlcygpLnRoZW4oZ2V0KG5hbWUpKS50aGVuKHNldCgndHlwZScsICdURU1QTEFURScpKS50aGVuKGxvYWRRKF90aGlzLCBuYW1lKSkpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5tYW5hZ2VVc2VyUHJlZmVyZW5jZXMgPSBmdW5jdGlvbihtZXRob2QsIGRhdGEsIGNiKSB7XG4gICAgICByZXR1cm4gUkVRVUlSRVNfVkVSU0lPTih0aGlzLCAxMSwgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gd2l0aENCKGNiLCBfdGhpcy5tYWtlUmVxdWVzdChtZXRob2QsIFBSRUZfUEFUSCwgZGF0YSkudGhlbihnZXQoJ3ByZWZlcmVuY2VzJykpKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUucmVzb2x2ZUlkcyA9IGZ1bmN0aW9uKG9wdHMsIGNiKSB7XG4gICAgICByZXR1cm4gUkVRVUlSRVNfVkVSU0lPTih0aGlzLCAxMCwgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgcmVxO1xuICAgICAgICAgIHJlcSA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdQT1NUJyxcbiAgICAgICAgICAgIHVybDogX3RoaXMucm9vdCArIElEX1JFU09MVVRJT05fUEFUSCxcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICBkYXRhOiBKU09OLnN0cmluZ2lmeShvcHRzKSxcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbidcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiB3aXRoQ0IoY2IsIF90aGlzLmRvUmVxKHJlcSkudGhlbihnZXQoJ3VpZCcpKS50aGVuKElEUmVzb2x1dGlvbkpvYi5jcmVhdGUoX3RoaXMpKSk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgfTtcblxuICAgIFNlcnZpY2UucHJvdG90eXBlLnJlc29sdXRpb25Kb2IgPSBmdW5jdGlvbihpZCkge1xuICAgICAgcmV0dXJuIElEUmVzb2x1dGlvbkpvYi5jcmVhdGUodGhpcykoaWQpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5jcmVhdGVMaXN0ID0gZnVuY3Rpb24ob3B0cywgaWRzLCBjYikge1xuICAgICAgdmFyIGFkanVzdCwgcmVxO1xuICAgICAgaWYgKG9wdHMgPT0gbnVsbCkge1xuICAgICAgICBvcHRzID0ge307XG4gICAgICB9XG4gICAgICBpZiAoaWRzID09IG51bGwpIHtcbiAgICAgICAgaWRzID0gJyc7XG4gICAgICB9XG4gICAgICBpZiAoY2IgPT0gbnVsbCkge1xuICAgICAgICBjYiA9IGZ1bmN0aW9uKCkge307XG4gICAgICB9XG4gICAgICBhZGp1c3QgPSAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICByZXR1cm4gbWVyZ2UoeCwge1xuICAgICAgICAgICAgdG9rZW46IF90aGlzLnRva2VuLFxuICAgICAgICAgICAgdGFnczogb3B0cy50YWdzIHx8IFtdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKTtcbiAgICAgIHJlcSA9IHtcbiAgICAgICAgZGF0YTogdXRpbHMuaXNBcnJheShpZHMpID8gaWRzLm1hcChmdW5jdGlvbih4KSB7XG4gICAgICAgICAgcmV0dXJuIFwiXFxcIlwiICsgeCArIFwiXFxcIlwiO1xuICAgICAgICB9KS5qb2luKFwiXFxuXCIpIDogaWRzLFxuICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICB1cmw6IFwiXCIgKyB0aGlzLnJvb3QgKyBcImxpc3RzP1wiICsgKHRvX3F1ZXJ5X3N0cmluZyhhZGp1c3Qob3B0cykpKSxcbiAgICAgICAgdHlwZTogJ1BPU1QnLFxuICAgICAgICBjb250ZW50VHlwZTogJ3RleHQvcGxhaW4nXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHdpdGhDQihjYiwgdGhpcy5kb1JlcShyZXEpLnRoZW4oTElTVF9QSVBFKHRoaXMpKSk7XG4gICAgfTtcblxuICAgIGdldE5ld1VzZXJUb2tlbiA9IGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgIHJldHVybiByZXNwLnVzZXIudGVtcG9yYXJ5VG9rZW47XG4gICAgfTtcblxuICAgIFNlcnZpY2UucHJvdG90eXBlLmNvbm5lY3RBcyA9IGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgICByZXR1cm4gU2VydmljZS5jb25uZWN0KG1lcmdlKHRoaXMsIHtcbiAgICAgICAgdG9rZW46IHRva2VuLFxuICAgICAgICBub0NhY2hlOiAhdGhpcy51c2VDYWNoZVxuICAgICAgfSkpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uKG5hbWUsIHBhc3N3b3JkLCBjYikge1xuICAgICAgcmV0dXJuIFJFUVVJUkVTX1ZFUlNJT04odGhpcywgOSwgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gd2l0aENCKGNiLCBfdGhpcy5wb3N0KCd1c2VycycsIHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBwYXNzd29yZDogcGFzc3dvcmRcbiAgICAgICAgICB9KS50aGVuKGdldE5ld1VzZXJUb2tlbikudGhlbihfdGhpcy5jb25uZWN0QXMpKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuXG4gICAgRklWRV9NSU4gPSA1ICogNjA7XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5nZXREZXJlZ2lzdHJhdGlvblRva2VuID0gZnVuY3Rpb24odmFsaWRpdHksIGNiKSB7XG4gICAgICBpZiAodmFsaWRpdHkgPT0gbnVsbCkge1xuICAgICAgICB2YWxpZGl0eSA9IEZJVkVfTUlOO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFJFUVVJUkVTX1ZFUlNJT04odGhpcywgMTYsIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHByb21pc2U7XG4gICAgICAgICAgcHJvbWlzZSA9IF90aGlzLnRva2VuICE9IG51bGwgPyBfdGhpcy5wb3N0KCd1c2VyL2RlcmVnaXN0cmF0aW9uJywge1xuICAgICAgICAgICAgdmFsaWRpdHk6IHZhbGlkaXR5XG4gICAgICAgICAgfSkudGhlbihnZXQoJ3Rva2VuJykpIDogZXJyb3IoXCJOb3QgcmVnaXN0ZXJlZFwiKTtcbiAgICAgICAgICByZXR1cm4gd2l0aENCKGNiLCBwcm9taXNlKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUuZGVyZWdpc3RlciA9IGZ1bmN0aW9uKHRva2VuLCBjYikge1xuICAgICAgcmV0dXJuIFJFUVVJUkVTX1ZFUlNJT04odGhpcywgMTYsIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHdpdGhDQihjYiwgX3RoaXMubWFrZVJlcXVlc3QoJ0RFTEVURScsICd1c2VyJywge1xuICAgICAgICAgICAgZGVyZWdpc3RyYXRpb25Ub2tlbjogdG9rZW4sXG4gICAgICAgICAgICBmb3JtYXQ6ICd4bWwnXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5sb2dpbiA9IGZ1bmN0aW9uKG5hbWUsIHBhc3N3b3JkLCBjYikge1xuICAgICAgcmV0dXJuIFJFUVVJUkVTX1ZFUlNJT04odGhpcywgOSwgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYXV0aDtcbiAgICAgICAgICBhdXRoID0gXCJcIiArIG5hbWUgKyBcIjpcIiArIHBhc3N3b3JkO1xuICAgICAgICAgIHJldHVybiB3aXRoQ0IoY2IsIF90aGlzLmxvZ291dCgpLnRoZW4oZnVuY3Rpb24oc2VydmljZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlcnZpY2UuZ2V0KCd1c2VyL3Rva2VuJywge1xuICAgICAgICAgICAgICBhdXRoOiBhdXRoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KSkudGhlbihnZXQoJ3Rva2VuJykpLnRoZW4oX3RoaXMuY29ubmVjdEFzKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUubG9nb3V0ID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgIHJldHVybiB3aXRoQ0IoY2IsIHN1Y2Nlc3ModGhpcy5jb25uZWN0QXMoKSkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2VydmljZTtcblxuICB9KSgpO1xuXG4gIFNlcnZpY2UucHJvdG90eXBlLnJvd0J5Um93ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MsIGYsIHE7XG4gICAgcSA9IGFyZ3VtZW50c1swXSwgYXJncyA9IDIgPD0gYXJndW1lbnRzLmxlbmd0aCA/IF9fc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpIDogW107XG4gICAgZiA9IGh0dHAuaXRlclJlcSgnUE9TVCcsIFFVRVJZX1JFU1VMVFNfUEFUSCwgJ2pzb24nKTtcbiAgICBpZiAocS50b1hNTCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5xdWVyeShxKS50aGVuKChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ocXVlcnkpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMucm93QnlSb3cuYXBwbHkoX3RoaXMsIFtxdWVyeV0uY29uY2F0KF9fc2xpY2UuY2FsbChhcmdzKSkpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH1cbiAgfTtcblxuICBTZXJ2aWNlLnByb3RvdHlwZS5lYWNoUm93ID0gU2VydmljZS5wcm90b3R5cGUucm93QnlSb3c7XG5cbiAgU2VydmljZS5wcm90b3R5cGUucmVjb3JkQnlSZWNvcmQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncywgZiwgcTtcbiAgICBxID0gYXJndW1lbnRzWzBdLCBhcmdzID0gMiA8PSBhcmd1bWVudHMubGVuZ3RoID8gX19zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkgOiBbXTtcbiAgICBmID0gaHR0cC5pdGVyUmVxKCdQT1NUJywgUVVFUllfUkVTVUxUU19QQVRILCAnanNvbm9iamVjdHMnKTtcbiAgICBpZiAocS50b1hNTCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5xdWVyeShxKS50aGVuKChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ocXVlcnkpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMucmVjb3JkQnlSZWNvcmQuYXBwbHkoX3RoaXMsIFtxdWVyeV0uY29uY2F0KF9fc2xpY2UuY2FsbChhcmdzKSkpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH1cbiAgfTtcblxuICBTZXJ2aWNlLnByb3RvdHlwZS5lYWNoUmVjb3JkID0gU2VydmljZS5wcm90b3R5cGUucmVjb3JkQnlSZWNvcmQ7XG5cbiAgU2VydmljZS5wcm90b3R5cGUudW5pb24gPSBTZXJ2aWNlLnByb3RvdHlwZS5tZXJnZTtcblxuICBTZXJ2aWNlLnByb3RvdHlwZS5kaWZmZXJlbmNlID0gU2VydmljZS5wcm90b3R5cGUuZGlmZjtcblxuICBTZXJ2aWNlLnByb3RvdHlwZS5zeW1tZXRyaWNEaWZmZXJlbmNlID0gU2VydmljZS5wcm90b3R5cGUuZGlmZjtcblxuICBTZXJ2aWNlLnByb3RvdHlwZS5yZWxhdGl2ZUNvbXBsZW1lbnQgPSBTZXJ2aWNlLnByb3RvdHlwZS5jb21wbGVtZW50O1xuXG4gIFNlcnZpY2UucHJvdG90eXBlLnN1YnRyYWN0ID0gU2VydmljZS5wcm90b3R5cGUuY29tcGxlbWVudDtcblxuICBTZXJ2aWNlLmZsdXNoQ2FjaGVzID0gZnVuY3Rpb24oKSB7XG4gICAgTU9ERUxTID0ge307XG4gICAgVkVSU0lPTlMgPSB7fTtcbiAgICBSRUxFQVNFUyA9IHt9O1xuICAgIENMQVNTS0VZUyA9IHt9O1xuICAgIFNVTU1BUllfRklFTERTID0ge307XG4gICAgcmV0dXJuIFdJREdFVFMgPSB7fTtcbiAgfTtcblxuICBTZXJ2aWNlLmNvbm5lY3QgPSBmdW5jdGlvbihvcHRzKSB7XG4gICAgaWYgKChvcHRzICE9IG51bGwgPyBvcHRzLnJvb3QgOiB2b2lkIDApID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgb3B0aW9ucyBwcm92aWRlZDogXCIgKyAoSlNPTi5zdHJpbmdpZnkob3B0cykpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTZXJ2aWNlKG9wdHMpO1xuICB9O1xuXG4gIGV4cG9ydHMuU2VydmljZSA9IFNlcnZpY2U7XG5cbiAgZXhwb3J0cy5Nb2RlbCA9IE1vZGVsO1xuXG4gIGV4cG9ydHMuUXVlcnkgPSBRdWVyeTtcblxuICBleHBvcnRzLnV0aWxzID0gdXRpbHM7XG5cbiAgZXhwb3J0cy5WRVJTSU9OID0gdmVyc2lvbi5WRVJTSU9OO1xuXG4gIGV4cG9ydHMuaW1qcyA9IHZlcnNpb247XG5cbn0pLmNhbGwodGhpcyk7XG5cbn0se1wiLi9odHRwXCI6MyxcIi4vaWQtcmVzb2x1dGlvbi1qb2JcIjo0LFwiLi9saXN0c1wiOjUsXCIuL21vZGVsXCI6NixcIi4vcHJvbWlzZVwiOjgsXCIuL3F1ZXJ5XCI6OSxcIi4vdXNlclwiOjE0LFwiLi91dGlsXCI6MTUsXCIuL3ZlcnNpb25cIjoxNn1dLDExOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbihmdW5jdGlvbigpIHtcbiAgdmFyIEZha2VEb21QYXJzZXI7XG5cbiAgZXhwb3J0cy5ET01QYXJzZXIgPSBnbG9iYWwuRE9NUGFyc2VyICE9IG51bGwgPyBnbG9iYWwuRE9NUGFyc2VyIDogRmFrZURvbVBhcnNlciA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBGYWtlRG9tUGFyc2VyKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRE9NUGFyc2VyIGlzIG5vdCBhdmFpbGFibGVcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIEZha2VEb21QYXJzZXI7XG5cbiAgfSkoKTtcblxufSkuY2FsbCh0aGlzKTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHt9XSwxMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBIQVNfQ09OU09MRSwgSEFTX0pTT04sIE5PVF9FTlVNLCBoYXNEb250RW51bUJ1ZywgaGFzT3duUHJvcGVydHksIGhlYWQsIG0sIHNjcmlwdCwgX2ZuLCBfaSwgX2xlbiwgX3JlZjtcblxuICBIQVNfQ09OU09MRSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJztcblxuICBIQVNfSlNPTiA9IHR5cGVvZiBKU09OICE9PSAndW5kZWZpbmVkJztcblxuICBOT1RfRU5VTSA9IFsndG9TdHJpbmcnLCAndG9Mb2NhbGVTdHJpbmcnLCAndmFsdWVPZicsICdoYXNPd25Qcm9wZXJ0eScsICdpc1Byb3RvdHlwZU9mJywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJ2NvbnN0cnVjdG9yJ107XG5cbiAgaWYgKCFIQVNfSlNPTikge1xuICAgIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgIHNjcmlwdC5zcmMgPSAnaHR0cDovL2Nkbi5pbnRlcm1pbmUub3JnL2pzL2pzb24zLzMuMi4yL2pzb24zLm1pbi5qcyc7XG4gICAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgICBoZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gIH1cblxuICBpZiAoT2JqZWN0LmtleXMgPT0gbnVsbCkge1xuICAgIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgICBoYXNEb250RW51bUJ1ZyA9ICF7XG4gICAgICB0b1N0cmluZzogbnVsbFxuICAgIH0ucHJvcGVydHlJc0VudW1lcmFibGUoXCJ0b1N0cmluZ1wiKTtcbiAgICBPYmplY3Qua2V5cyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgIHZhciBrZXlzLCBuYW1lLCBub25FbnVtLCBfaSwgX2xlbjtcbiAgICAgIGlmICh0eXBlb2YgbyAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbyAhPT0gXCJcIiB8fCBvID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3Qua2V5cyBjYWxsZWQgb24gYSBub24tb2JqZWN0XCIpO1xuICAgICAgfVxuICAgICAga2V5cyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9yZXN1bHRzO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKG5hbWUgaW4gbykge1xuICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIG5hbWUpKSB7XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KSgpO1xuICAgICAgaWYgKGhhc0RvbnRFbnVtQnVnKSB7XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gTk9UX0VOVU0ubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBub25FbnVtID0gTk9UX0VOVU1bX2ldO1xuICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIG5vbkVudW0pKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2gobm9uRW51bSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ga2V5cztcbiAgICB9O1xuICB9XG5cbiAgaWYgKEFycmF5LnByb3RvdHlwZS5tYXAgPT0gbnVsbCkge1xuICAgIEFycmF5LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbihmKSB7XG4gICAgICB2YXIgeCwgX2ksIF9sZW4sIF9yZXN1bHRzO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gdGhpcy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICB4ID0gdGhpc1tfaV07XG4gICAgICAgIF9yZXN1bHRzLnB1c2goZih4KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChBcnJheS5wcm90b3R5cGUuZmlsdGVyID09IG51bGwpIHtcbiAgICBBcnJheS5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24oZikge1xuICAgICAgdmFyIHgsIF9pLCBfbGVuLCBfcmVzdWx0cztcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IHRoaXMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgeCA9IHRoaXNbX2ldO1xuICAgICAgICBpZiAoZih4KSkge1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2goeCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuICB9XG5cbiAgaWYgKEFycmF5LnByb3RvdHlwZS5yZWR1Y2UgPT0gbnVsbCkge1xuICAgIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbihmLCBpbml0VmFsdWUpIHtcbiAgICAgIHZhciByZXQsIHgsIHhzLCBfaSwgX2xlbjtcbiAgICAgIHhzID0gdGhpcy5zbGljZSgpO1xuICAgICAgcmV0ID0gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyB4cy5wb3AoKSA6IGluaXRWYWx1ZTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0geHMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgeCA9IHhzW19pXTtcbiAgICAgICAgcmV0ID0gZihyZXQsIHgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICB9XG5cbiAgaWYgKEFycmF5LnByb3RvdHlwZS5mb3JFYWNoID09IG51bGwpIHtcbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGYsIGN0eCkge1xuICAgICAgdmFyIGksIHgsIF9pLCBfbGVuLCBfcmVzdWx0cztcbiAgICAgIGlmICghZikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBmdW5jdGlvbiBwcm92aWRlZFwiKTtcbiAgICAgIH1cbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKGkgPSBfaSA9IDAsIF9sZW4gPSB0aGlzLmxlbmd0aDsgX2kgPCBfbGVuOyBpID0gKytfaSkge1xuICAgICAgICB4ID0gdGhpc1tpXTtcbiAgICAgICAgX3Jlc3VsdHMucHVzaChmLmNhbGwoY3R4ICE9IG51bGwgPyBjdHggOiB0aGlzLCB4LCBpLCB0aGlzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcbiAgfVxuXG4gIGlmICghSEFTX0NPTlNPTEUpIHtcbiAgICB0aGlzLmNvbnNvbGUgPSB7XG4gICAgICBsb2c6IChmdW5jdGlvbigpIHt9KSxcbiAgICAgIGVycm9yOiAoZnVuY3Rpb24oKSB7fSksXG4gICAgICBkZWJ1ZzogKGZ1bmN0aW9uKCkge30pXG4gICAgfTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cgIT09IG51bGwpIHtcbiAgICAgIHdpbmRvdy5jb25zb2xlID0gdGhpcy5jb25zb2xlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjb25zb2xlLmxvZyA9PSBudWxsKSB7XG4gICAgY29uc29sZS5sb2cgPSBmdW5jdGlvbigpIHt9O1xuICB9XG5cbiAgaWYgKGNvbnNvbGUuZXJyb3IgPT0gbnVsbCkge1xuICAgIGNvbnNvbGUuZXJyb3IgPSBmdW5jdGlvbigpIHt9O1xuICB9XG5cbiAgaWYgKGNvbnNvbGUuZGVidWcgPT0gbnVsbCkge1xuICAgIGNvbnNvbGUuZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuICB9XG5cbiAgaWYgKGNvbnNvbGUubG9nLmFwcGx5ID09IG51bGwpIHtcbiAgICBjb25zb2xlLmxvZyhcIllvdXIgY29uc29sZSBuZWVkcyBwYXRjaGluZy5cIik7XG4gICAgX3JlZiA9IFsnbG9nJywgJ2Vycm9yJywgJ2RlYnVnJ107XG4gICAgX2ZuID0gZnVuY3Rpb24obSkge1xuICAgICAgdmFyIG9sZE07XG4gICAgICBvbGRNID0gY29uc29sZVttXTtcbiAgICAgIHJldHVybiBjb25zb2xlW21dID0gZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gb2xkTShhcmdzKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIG0gPSBfcmVmW19pXTtcbiAgICAgIF9mbihtKTtcbiAgICB9XG4gIH1cblxufSkuY2FsbCh0aGlzKTtcblxufSx7fV0sMTM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgUHJvbWlzZSwgbWVyZ2UsIHByb3BlcnRpZXMsXG4gICAgX19iaW5kID0gZnVuY3Rpb24oZm4sIG1lKXsgcmV0dXJuIGZ1bmN0aW9uKCl7IHJldHVybiBmbi5hcHBseShtZSwgYXJndW1lbnRzKTsgfTsgfTtcblxuICBtZXJnZSA9IGZ1bmN0aW9uKHNyYywgZGVzdCkge1xuICAgIHZhciBrLCB2LCBfcmVzdWx0cztcbiAgICBfcmVzdWx0cyA9IFtdO1xuICAgIGZvciAoayBpbiBzcmMpIHtcbiAgICAgIHYgPSBzcmNba107XG4gICAgICBfcmVzdWx0cy5wdXNoKGRlc3Rba10gPSB2KTtcbiAgICB9XG4gICAgcmV0dXJuIF9yZXN1bHRzO1xuICB9O1xuXG4gIFByb21pc2UgPSBfZGVyZXFfKCcuL3Byb21pc2UnKTtcblxuICBwcm9wZXJ0aWVzID0gWydhdHRyaWJ1dGVzJywgJ3JlZmVyZW5jZXMnLCAnY29sbGVjdGlvbnMnXTtcblxuICBleHBvcnRzLlRhYmxlID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFRhYmxlKG9wdHMsIG1vZGVsKSB7XG4gICAgICB2YXIgYywgcHJvcCwgXywgX2ksIF9sZW4sIF9yZWYsIF9yZWYxO1xuICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgICAgdGhpcy5nZXREaXNwbGF5TmFtZSA9IF9fYmluZCh0aGlzLmdldERpc3BsYXlOYW1lLCB0aGlzKTtcbiAgICAgIHRoaXMubmFtZSA9IG9wdHMubmFtZSwgdGhpcy50YWdzID0gb3B0cy50YWdzLCB0aGlzLmRpc3BsYXlOYW1lID0gb3B0cy5kaXNwbGF5TmFtZSwgdGhpcy5hdHRyaWJ1dGVzID0gb3B0cy5hdHRyaWJ1dGVzLCB0aGlzLnJlZmVyZW5jZXMgPSBvcHRzLnJlZmVyZW5jZXMsIHRoaXMuY29sbGVjdGlvbnMgPSBvcHRzLmNvbGxlY3Rpb25zO1xuICAgICAgdGhpcy5maWVsZHMgPSB7fTtcbiAgICAgIHRoaXMuX19wYXJlbnRzX18gPSAoX3JlZiA9IG9wdHNbJ2V4dGVuZHMnXSkgIT0gbnVsbCA/IF9yZWYgOiBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gcHJvcGVydGllcy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBwcm9wID0gcHJvcGVydGllc1tfaV07XG4gICAgICAgIGlmICh0aGlzW3Byb3BdID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYWQgbW9kZWwgZGF0YTogbWlzc2luZyBcIiArIHByb3ApO1xuICAgICAgICB9XG4gICAgICAgIG1lcmdlKHRoaXNbcHJvcF0sIHRoaXMuZmllbGRzKTtcbiAgICAgIH1cbiAgICAgIF9yZWYxID0gdGhpcy5jb2xsZWN0aW9ucztcbiAgICAgIGZvciAoXyBpbiBfcmVmMSkge1xuICAgICAgICBjID0gX3JlZjFbX107XG4gICAgICAgIGMuaXNDb2xsZWN0aW9uID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBUYWJsZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBuLCBfO1xuICAgICAgcmV0dXJuIFwiW1RhYmxlIG5hbWU9XCIgKyB0aGlzLm5hbWUgKyBcIiwgZmllbGRzPVtcIiArICgoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfcmVmLCBfcmVzdWx0cztcbiAgICAgICAgX3JlZiA9IHRoaXMuZmllbGRzO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKG4gaW4gX3JlZikge1xuICAgICAgICAgIF8gPSBfcmVmW25dO1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2gobik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSkuY2FsbCh0aGlzKSkgKyBcIl1dXCI7XG4gICAgfTtcblxuICAgIFRhYmxlLnByb3RvdHlwZS5wYXJlbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3JlZjtcbiAgICAgIHJldHVybiAoKF9yZWYgPSB0aGlzLl9fcGFyZW50c19fKSAhPSBudWxsID8gX3JlZiA6IFtdKS5zbGljZSgpO1xuICAgIH07XG5cbiAgICBUYWJsZS5wcm90b3R5cGUuZ2V0RGlzcGxheU5hbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGlmIChfdGhpcy5tb2RlbCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShfdGhpcy5tb2RlbC5tYWtlUGF0aChfdGhpcy5uYW1lKS5nZXREaXNwbGF5TmFtZSgpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ21vZGVsIG5vdCBzZXQgLSBjYW5ub3QgbWFrZSBwYXRoJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRhYmxlO1xuXG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG5cbn0se1wiLi9wcm9taXNlXCI6OH1dLDE0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbigpIHtcbiAgdmFyIGFueSwgZG9fcHJlZl9yZXEsIGVycm9yLCBnZXQsIGlzRnVuY3Rpb24sIHdpdGhDQiwgX3JlZixcbiAgICBfX2JpbmQgPSBmdW5jdGlvbihmbiwgbWUpeyByZXR1cm4gZnVuY3Rpb24oKXsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9O1xuXG4gIF9yZWYgPSBfZGVyZXFfKCcuL3V0aWwnKSwgd2l0aENCID0gX3JlZi53aXRoQ0IsIGdldCA9IF9yZWYuZ2V0LCBpc0Z1bmN0aW9uID0gX3JlZi5pc0Z1bmN0aW9uLCBhbnkgPSBfcmVmLmFueSwgZXJyb3IgPSBfcmVmLmVycm9yO1xuXG4gIGRvX3ByZWZfcmVxID0gZnVuY3Rpb24odXNlciwgZGF0YSwgbWV0aG9kLCBjYikge1xuICAgIHJldHVybiB1c2VyLnNlcnZpY2UubWFuYWdlVXNlclByZWZlcmVuY2VzKG1ldGhvZCwgZGF0YSwgY2IpLnRoZW4oZnVuY3Rpb24ocHJlZnMpIHtcbiAgICAgIHJldHVybiB1c2VyLnByZWZlcmVuY2VzID0gcHJlZnM7XG4gICAgfSk7XG4gIH07XG5cbiAgZXhwb3J0cy5Vc2VyID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFVzZXIoc2VydmljZSwgX2FyZykge1xuICAgICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcbiAgICAgIHRoaXMudXNlcm5hbWUgPSBfYXJnLnVzZXJuYW1lLCB0aGlzLnByZWZlcmVuY2VzID0gX2FyZy5wcmVmZXJlbmNlcztcbiAgICAgIHRoaXMucmVmcmVzaCA9IF9fYmluZCh0aGlzLnJlZnJlc2gsIHRoaXMpO1xuICAgICAgdGhpcy5jbGVhclByZWZlcmVuY2VzID0gX19iaW5kKHRoaXMuY2xlYXJQcmVmZXJlbmNlcywgdGhpcyk7XG4gICAgICB0aGlzLmNsZWFyUHJlZmVyZW5jZSA9IF9fYmluZCh0aGlzLmNsZWFyUHJlZmVyZW5jZSwgdGhpcyk7XG4gICAgICB0aGlzLnNldFByZWZlcmVuY2VzID0gX19iaW5kKHRoaXMuc2V0UHJlZmVyZW5jZXMsIHRoaXMpO1xuICAgICAgdGhpcy5zZXRQcmVmZXJlbmNlID0gX19iaW5kKHRoaXMuc2V0UHJlZmVyZW5jZSwgdGhpcyk7XG4gICAgICB0aGlzLmhhc1ByZWZlcmVuY2VzID0gdGhpcy5wcmVmZXJlbmNlcyAhPSBudWxsO1xuICAgICAgaWYgKHRoaXMucHJlZmVyZW5jZXMgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnByZWZlcmVuY2VzID0ge307XG4gICAgICB9XG4gICAgfVxuXG4gICAgVXNlci5wcm90b3R5cGUuc2V0UHJlZmVyZW5jZSA9IGZ1bmN0aW9uKGtleSwgdmFsdWUsIGNiKSB7XG4gICAgICB2YXIgZGF0YSwgX3JlZjE7XG4gICAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgX3JlZjEgPSBbbnVsbCwgdmFsdWVdLCB2YWx1ZSA9IF9yZWYxWzBdLCBjYiA9IF9yZWYxWzFdO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGRhdGEgPSB7fTtcbiAgICAgICAgZGF0YVtrZXldID0gdmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgZGF0YSA9IGtleTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB3aXRoQ0IoY2IsIGVycm9yKFwiSW5jb3JyZWN0IGFyZ3VtZW50cyB0byBzZXRQcmVmZXJlbmNlXCIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnNldFByZWZlcmVuY2VzKGRhdGEsIGNiKTtcbiAgICB9O1xuXG4gICAgVXNlci5wcm90b3R5cGUuc2V0UHJlZmVyZW5jZXMgPSBmdW5jdGlvbihwcmVmcywgY2IpIHtcbiAgICAgIHJldHVybiBkb19wcmVmX3JlcSh0aGlzLCBwcmVmcywgJ1BPU1QnLCBjYik7XG4gICAgfTtcblxuICAgIFVzZXIucHJvdG90eXBlLmNsZWFyUHJlZmVyZW5jZSA9IGZ1bmN0aW9uKGtleSwgY2IpIHtcbiAgICAgIHJldHVybiBkb19wcmVmX3JlcSh0aGlzLCB7XG4gICAgICAgIGtleToga2V5XG4gICAgICB9LCAnREVMRVRFJywgY2IpO1xuICAgIH07XG5cbiAgICBVc2VyLnByb3RvdHlwZS5jbGVhclByZWZlcmVuY2VzID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgIHJldHVybiBkb19wcmVmX3JlcSh0aGlzLCB7fSwgJ0RFTEVURScsIGNiKTtcbiAgICB9O1xuXG4gICAgVXNlci5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uKGNiKSB7XG4gICAgICByZXR1cm4gZG9fcHJlZl9yZXEodGhpcywge30sICdHRVQnLCBjYik7XG4gICAgfTtcblxuICAgIFVzZXIucHJvdG90eXBlLmNyZWF0ZVRva2VuID0gZnVuY3Rpb24odHlwZSwgbWVzc2FnZSwgY2IpIHtcbiAgICAgIHZhciBfcmVmMSwgX3JlZjI7XG4gICAgICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgICAgIHR5cGUgPSAnZGF5JztcbiAgICAgIH1cbiAgICAgIGlmICgoY2IgPT0gbnVsbCkgJiYgYW55KFt0eXBlLCBtZXNzYWdlXSwgaXNGdW5jdGlvbikpIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odHlwZSkpIHtcbiAgICAgICAgICBfcmVmMSA9IFtudWxsLCBudWxsLCB0eXBlXSwgdHlwZSA9IF9yZWYxWzBdLCBtZXNzYWdlID0gX3JlZjFbMV0sIGNiID0gX3JlZjFbMl07XG4gICAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihtZXNzYWdlKSkge1xuICAgICAgICAgIF9yZWYyID0gW251bGwsIG1lc3NhZ2VdLCBtZXNzYWdlID0gX3JlZjJbMF0sIGNiID0gX3JlZjJbMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB3aXRoQ0IoY2IsIHRoaXMuc2VydmljZS5wb3N0KCd1c2VyL3Rva2VucycsIHtcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgICAgfSkudGhlbihnZXQoJ3Rva2VuJykpKTtcbiAgICB9O1xuXG4gICAgVXNlci5wcm90b3R5cGUuZmV0Y2hDdXJyZW50VG9rZW5zID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgIHJldHVybiB3aXRoQ0IoY2IsIHRoaXMuc2VydmljZS5nZXQoJ3VzZXIvdG9rZW5zJykudGhlbihnZXQoJ3Rva2VucycpKSk7XG4gICAgfTtcblxuICAgIFVzZXIucHJvdG90eXBlLnJldm9rZUFsbFRva2VucyA9IGZ1bmN0aW9uKGNiKSB7XG4gICAgICByZXR1cm4gd2l0aENCKGNiLCB0aGlzLnNlcnZpY2UubWFrZVJlcXVlc3QoJ0RFTEVURScsICd1c2VyL3Rva2VucycpKTtcbiAgICB9O1xuXG4gICAgVXNlci5wcm90b3R5cGUucmV2b2tlVG9rZW4gPSBmdW5jdGlvbih0b2tlbiwgY2IpIHtcbiAgICAgIHJldHVybiB3aXRoQ0IoY2IsIHRoaXMuc2VydmljZS5tYWtlUmVxdWVzdCgnREVMRVRFJywgXCJ1c2VyL3Rva2Vucy9cIiArIHRva2VuKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBVc2VyO1xuXG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG5cbn0se1wiLi91dGlsXCI6MTV9XSwxNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBQcm9taXNlLCBSRVFVSVJFUywgY29tcCwgY3VycnksIGVuY29kZSwgZW50aXRpZXMsIGVycm9yLCBmbGF0dGVuLCBmb2xkLCBpZCwgaW52b2tlLCBpbnZva2VXaXRoLCBpc0FycmF5LCBtZXJnZSwgcGFpckZvbGQsIHFzRnJvbUxpc3QsIHJvb3QsIHN1Y2Nlc3MsIHRoZW5Gb2xkLCBfcmVmLFxuICAgIF9fc2xpY2UgPSBbXS5zbGljZSxcbiAgICBfX2luZGV4T2YgPSBbXS5pbmRleE9mIHx8IGZ1bmN0aW9uKGl0ZW0pIHsgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykgeyBpZiAoaSBpbiB0aGlzICYmIHRoaXNbaV0gPT09IGl0ZW0pIHJldHVybiBpOyB9IHJldHVybiAtMTsgfSxcbiAgICBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICBQcm9taXNlID0gX2RlcmVxXygnLi9wcm9taXNlJyk7XG5cbiAgcm9vdCA9IGV4cG9ydHM7XG5cbiAgcm9vdC5kZWZlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkZWZlcnJlZDtcbiAgICBkZWZlcnJlZCA9IHt9O1xuICAgIGRlZmVycmVkLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGRlZmVycmVkLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgcmV0dXJuIGRlZmVycmVkLnJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQ7XG4gIH07XG5cbiAgZW5jb2RlID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHgpKTtcbiAgfTtcblxuICBxc0Zyb21MaXN0ID0gZnVuY3Rpb24ocGFpcnMpIHtcbiAgICB2YXIgcGFpcjtcbiAgICByZXR1cm4gKChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfaSwgX2xlbiwgX3Jlc3VsdHM7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBwYWlycy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBwYWlyID0gcGFpcnNbX2ldO1xuICAgICAgICBfcmVzdWx0cy5wdXNoKHBhaXIubWFwKGVuY29kZSkuam9pbignPScpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9KSgpKS5qb2luKCcmJyk7XG4gIH07XG5cbiAgcm9vdC5xdWVyeXN0cmluZyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBrLCBwLCBwYWlycywgc3ViTGlzdCwgc3YsIHY7XG4gICAgaWYgKCFvYmopIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgcGFpcnMgPSBvYmouc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFpcnMgPSBbXTtcbiAgICAgIGZvciAoayBpbiBvYmopIHtcbiAgICAgICAgdiA9IG9ialtrXTtcbiAgICAgICAgaWYgKGlzQXJyYXkodikpIHtcbiAgICAgICAgICBzdWJMaXN0ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVzdWx0cztcbiAgICAgICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IHYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICAgICAgc3YgPSB2W19pXTtcbiAgICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChbaywgc3ZdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgICAgICB9KSgpO1xuICAgICAgICAgIHBhaXJzID0gcGFpcnMuY29uY2F0KHN1Ykxpc3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhaXJzLnB1c2goW2ssIHZdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcXNGcm9tTGlzdCgoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX2ksIF9sZW4sIF9yZXN1bHRzO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gcGFpcnMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgcCA9IHBhaXJzW19pXTtcbiAgICAgICAgaWYgKHBbMV0gIT0gbnVsbCkge1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2gocCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9KSgpKTtcbiAgfTtcblxuICByb290LmN1cnJ5ID0gY3VycnkgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncywgZjtcbiAgICBmID0gYXJndW1lbnRzWzBdLCBhcmdzID0gMiA8PSBhcmd1bWVudHMubGVuZ3RoID8gX19zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkgOiBbXTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVzdDtcbiAgICAgIHJlc3QgPSAxIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBfX3NsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSA6IFtdO1xuICAgICAgcmV0dXJuIGYuYXBwbHkobnVsbCwgYXJncy5jb25jYXQocmVzdCkpO1xuICAgIH07XG4gIH07XG5cbiAgcm9vdC5lcnJvciA9IGVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihfLCByZWplY3QpIHtcbiAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKGUpKTtcbiAgICB9KTtcbiAgfTtcblxuICByb290LnN1Y2Nlc3MgPSBzdWNjZXNzID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCBfKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZSh4KTtcbiAgICB9KTtcbiAgfTtcblxuICByb290LnBhcmFsbGVsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHByb21pc2VzO1xuICAgIHByb21pc2VzID0gMSA8PSBhcmd1bWVudHMubGVuZ3RoID8gX19zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkgOiBbXTtcbiAgICBpZiAocHJvbWlzZXMubGVuZ3RoID09PSAxICYmICghcHJvbWlzZXNbMF0udGhlbikgJiYgcHJvbWlzZXNbMF0ubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXNbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIH1cbiAgfTtcblxuICByb290LndpdGhDQiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBmLCBmcywgb25FcnIsIG9uU3VjYywgcCwgX2ksIF9qLCBfbGVuO1xuICAgIGZzID0gMiA8PSBhcmd1bWVudHMubGVuZ3RoID8gX19zbGljZS5jYWxsKGFyZ3VtZW50cywgMCwgX2kgPSBhcmd1bWVudHMubGVuZ3RoIC0gMSkgOiAoX2kgPSAwLCBbXSksIHAgPSBhcmd1bWVudHNbX2krK107XG4gICAgZm9yIChfaiA9IDAsIF9sZW4gPSBmcy5sZW5ndGg7IF9qIDwgX2xlbjsgX2orKykge1xuICAgICAgZiA9IGZzW19qXTtcbiAgICAgIGlmICghKGYgIT0gbnVsbCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBvblN1Y2MgPSBjdXJyeShmLCBudWxsKTtcbiAgICAgIG9uRXJyID0gZjtcbiAgICAgIHAudGhlbihvblN1Y2MsIG9uRXJyKTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH07XG5cbiAgcm9vdC5mb2xkID0gZm9sZCA9IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oaW5pdCwgeHMpIHtcbiAgICAgIHZhciBrLCByZXQsIHY7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB4cyA9IChpbml0ICE9IG51bGwgPyBpbml0LnNsaWNlKCkgOiB2b2lkIDApIHx8IGluaXQ7XG4gICAgICAgIGluaXQgPSAoeHMgIT0gbnVsbCA/IHhzLnNoaWZ0KCkgOiB2b2lkIDApIHx8IHt9O1xuICAgICAgfVxuICAgICAgaWYgKHhzID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwieHMgaXMgbnVsbFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh4cy5yZWR1Y2UgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4geHMucmVkdWNlKGYsIGluaXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gaW5pdDtcbiAgICAgICAgZm9yIChrIGluIHhzKSB7XG4gICAgICAgICAgdiA9IHhzW2tdO1xuICAgICAgICAgIHJldCA9IHJldCAhPSBudWxsID8gZihyZXQsIGssIHYpIDoge1xuICAgICAgICAgICAgazogdlxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIHJvb3QudGFrZSA9IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeHMpIHtcbiAgICAgIGlmIChuICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHhzLnNsaWNlKDAsICsobiAtIDEpICsgMSB8fCA5ZTkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHhzLnNsaWNlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICByb290LmZpbHRlciA9IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeHMpIHtcbiAgICAgIHZhciB4LCBfaSwgX2xlbiwgX3Jlc3VsdHM7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSB4cy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICB4ID0geHNbX2ldO1xuICAgICAgICBpZiAoZih4KSkge1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2goeCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuICB9O1xuXG4gIHJvb3QudW5pcUJ5ID0gZnVuY3Rpb24oZiwgeHMpIHtcbiAgICB2YXIgaywga2V5cywgdmFsdWVzLCB4LCBfaSwgX2xlbjtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGN1cnJ5KHJvb3QudW5pcUJ5LCBmKTtcbiAgICB9XG4gICAga2V5cyA9IFtdO1xuICAgIHZhbHVlcyA9IFtdO1xuICAgIGlmICh4cyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IHhzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICB4ID0geHNbX2ldO1xuICAgICAgayA9IGYoeCk7XG4gICAgICBpZiAoX19pbmRleE9mLmNhbGwoa2V5cywgaykgPCAwKSB7XG4gICAgICAgIGtleXMucHVzaChrKTtcbiAgICAgICAgdmFsdWVzLnB1c2goeCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH07XG5cbiAgcm9vdC5maW5kID0gZnVuY3Rpb24oeHMsIGYpIHtcbiAgICB2YXIgeCwgX2ksIF9sZW47XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGYgPSB4cztcbiAgICAgIHJldHVybiBmdW5jdGlvbih4cykge1xuICAgICAgICByZXR1cm4gcm9vdC5maW5kKHhzLCBmKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGZvciAoX2kgPSAwLCBfbGVuID0geHMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIHggPSB4c1tfaV07XG4gICAgICBpZiAoZih4KSkge1xuICAgICAgICByZXR1cm4geDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgaXNBcnJheSA9IChfcmVmID0gQXJyYXkuaXNBcnJheSkgIT0gbnVsbCA/IF9yZWYgOiBmdW5jdGlvbih4cykge1xuICAgIHJldHVybiAoKHhzICE9IG51bGwgPyB4cy5zcGxpY2UgOiB2b2lkIDApICE9IG51bGwpICYmICgoeHMgIT0gbnVsbCA/IHhzLnB1c2ggOiB2b2lkIDApICE9IG51bGwpICYmICgoeHMgIT0gbnVsbCA/IHhzLnBvcCA6IHZvaWQgMCkgIT0gbnVsbCkgJiYgKCh4cyAhPSBudWxsID8geHMuc2xpY2UgOiB2b2lkIDApICE9IG51bGwpO1xuICB9O1xuXG4gIHJvb3QuaXNBcnJheSA9IGlzQXJyYXk7XG5cbiAgcm9vdC5pc0Z1bmN0aW9uID0gdHlwZW9mIC8uLyAhPT0gJ2Z1bmN0aW9uJyA/IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4gdHlwZW9mIGYgPT09ICdmdW5jdGlvbic7XG4gIH0gOiBmdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuIChmICE9IG51bGwpICYmIChmLmNhbGwgIT0gbnVsbCkgJiYgKGYuYXBwbHkgIT0gbnVsbCkgJiYgZi50b1N0cmluZygpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuICB9O1xuXG4gIGVudGl0aWVzID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyZhcG9zOydcbiAgfTtcblxuICByb290LmVzY2FwZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHZhciBjb2RlLCBpLCByZXQsIHdpdGhFbnRpdGllcywgX2ksIF9yZWYxO1xuICAgIGlmIChzdHIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB3aXRoRW50aXRpZXMgPSBTdHJpbmcoc3RyKS5yZXBsYWNlKC9bJjw+XCInXS9nLCBmdW5jdGlvbihlbnRpdHkpIHtcbiAgICAgIHJldHVybiBlbnRpdGllc1tlbnRpdHldO1xuICAgIH0pO1xuICAgIHJldCA9IFtdO1xuICAgIGZvciAoaSA9IF9pID0gMCwgX3JlZjEgPSB3aXRoRW50aXRpZXMubGVuZ3RoOyAwIDw9IF9yZWYxID8gX2kgPD0gX3JlZjEgOiBfaSA+PSBfcmVmMTsgaSA9IDAgPD0gX3JlZjEgPyArK19pIDogLS1faSkge1xuICAgICAgY29kZSA9IHdpdGhFbnRpdGllcy5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYgKGNvZGUgPiAyNTYpIHtcbiAgICAgICAgcmV0LnB1c2goXCImI1wiICsgY29kZSArIFwiO1wiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldC5wdXNoKHdpdGhFbnRpdGllcy5jaGFyQXQoaSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0LmpvaW4oJycpO1xuICB9O1xuXG4gIHJvb3Qub21hcCA9IGZ1bmN0aW9uKGYpIHtcbiAgICB2YXIgbWVyZ2VyO1xuICAgIG1lcmdlciA9IGZvbGQoZnVuY3Rpb24oYSwgb2xkaywgb2xkdikge1xuICAgICAgdmFyIG5ld2ssIG5ld3YsIF9yZWYxO1xuICAgICAgX3JlZjEgPSBmKG9sZGssIG9sZHYpLCBuZXdrID0gX3JlZjFbMF0sIG5ld3YgPSBfcmVmMVsxXTtcbiAgICAgIGlmIChpc0FycmF5KG5ld3YpKSB7XG4gICAgICAgIG5ld3YgPSBuZXd2LnNsaWNlKCk7XG4gICAgICB9XG4gICAgICBhW25ld2tdID0gbmV3djtcbiAgICAgIHJldHVybiBhO1xuICAgIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbih4cykge1xuICAgICAgcmV0dXJuIG1lcmdlcih7fSwgeHMpO1xuICAgIH07XG4gIH07XG5cbiAgcm9vdC5jb3B5ID0gcm9vdC5vbWFwKGZ1bmN0aW9uKGssIHYpIHtcbiAgICByZXR1cm4gW2ssIHZdO1xuICB9KTtcblxuICByb290LnBhcnRpdGlvbiA9IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeHMpIHtcbiAgICAgIHZhciBkaXZpZGU7XG4gICAgICBkaXZpZGUgPSBmb2xkKGZ1bmN0aW9uKF9hcmcsIHgpIHtcbiAgICAgICAgdmFyIGZhbHNlcywgdHJ1ZXM7XG4gICAgICAgIHRydWVzID0gX2FyZ1swXSwgZmFsc2VzID0gX2FyZ1sxXTtcbiAgICAgICAgaWYgKGYoeCkpIHtcbiAgICAgICAgICByZXR1cm4gW3RydWVzLmNvbmNhdChbeF0pLCBmYWxzZXNdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbdHJ1ZXMsIGZhbHNlcy5jb25jYXQoW3hdKV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGRpdmlkZShbW10sIFtdXSwgeHMpO1xuICAgIH07XG4gIH07XG5cbiAgcm9vdC5pZCA9IGlkID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB4O1xuICB9O1xuXG4gIHJvb3QuY29uY2F0TWFwID0gZnVuY3Rpb24oZikge1xuICAgIHJldHVybiBmdW5jdGlvbih4cykge1xuICAgICAgdmFyIGZ4LCByZXQsIHgsIF9pLCBfbGVuO1xuICAgICAgcmV0ID0gdm9pZCAwO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSB4cy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICB4ID0geHNbX2ldO1xuICAgICAgICBmeCA9IGYoeCk7XG4gICAgICAgIHJldCA9IHJldCA9PT0gdm9pZCAwID8gZnggOiB0eXBlb2YgcmV0ID09PSAnbnVtYmVyJyA/IHJldCArIGZ4IDogcmV0LmNvbmNhdCAhPSBudWxsID8gcmV0LmNvbmNhdChmeCkgOiBtZXJnZShyZXQsIGZ4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgfTtcblxuICByb290Lm1hcCA9IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4gaW52b2tlKCdtYXAnLCBmKTtcbiAgfTtcblxuICBjb21wID0gZm9sZChmdW5jdGlvbihmLCBnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3M7XG4gICAgICBhcmdzID0gMSA8PSBhcmd1bWVudHMubGVuZ3RoID8gX19zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkgOiBbXTtcbiAgICAgIHJldHVybiBmKGcuYXBwbHkobnVsbCwgYXJncykpO1xuICAgIH07XG4gIH0pO1xuXG4gIHJvb3QuY29tcG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBmcztcbiAgICBmcyA9IDEgPD0gYXJndW1lbnRzLmxlbmd0aCA/IF9fc2xpY2UuY2FsbChhcmd1bWVudHMsIDApIDogW107XG4gICAgcmV0dXJuIGNvbXAoZnMpO1xuICB9O1xuXG4gIHJvb3QuZmxhdE1hcCA9IHJvb3QuY29uY2F0TWFwO1xuXG4gIHJvb3QuZGlmZmVyZW5jZSA9IGZ1bmN0aW9uKHhzLCByZW1vdmUpIHtcbiAgICB2YXIgeCwgX2ksIF9sZW4sIF9yZXN1bHRzO1xuICAgIF9yZXN1bHRzID0gW107XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSB4cy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgeCA9IHhzW19pXTtcbiAgICAgIGlmIChfX2luZGV4T2YuY2FsbChyZW1vdmUsIHgpIDwgMCkge1xuICAgICAgICBfcmVzdWx0cy5wdXNoKHgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX3Jlc3VsdHM7XG4gIH07XG5cbiAgcm9vdC5zdHJpbmdMaXN0ID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICh0eXBlb2YgeCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBbeF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfTtcblxuICByb290LmZsYXR0ZW4gPSBmbGF0dGVuID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJldCwgeCwgeHMsIHh4LCBfaSwgX2osIF9sZW4sIF9sZW4xLCBfcmVmMTtcbiAgICB4cyA9IDEgPD0gYXJndW1lbnRzLmxlbmd0aCA/IF9fc2xpY2UuY2FsbChhcmd1bWVudHMsIDApIDogW107XG4gICAgcmV0ID0gW107XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSB4cy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgeCA9IHhzW19pXTtcbiAgICAgIGlmIChpc0FycmF5KHgpKSB7XG4gICAgICAgIF9yZWYxID0gZmxhdHRlbi5hcHBseShudWxsLCB4KTtcbiAgICAgICAgZm9yIChfaiA9IDAsIF9sZW4xID0gX3JlZjEubGVuZ3RoOyBfaiA8IF9sZW4xOyBfaisrKSB7XG4gICAgICAgICAgeHggPSBfcmVmMVtfal07XG4gICAgICAgICAgcmV0LnB1c2goeHgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQucHVzaCh4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICByb290LnN1bSA9IHJvb3QuY29uY2F0TWFwKGlkKTtcblxuICByb290Lm1lcmdlID0gbWVyZ2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaywgbmV3T2JqLCBvLCBvYmpzLCB2LCBfaSwgX2xlbjtcbiAgICBvYmpzID0gMSA8PSBhcmd1bWVudHMubGVuZ3RoID8gX19zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkgOiBbXTtcbiAgICBuZXdPYmogPSB7fTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IG9ianMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIG8gPSBvYmpzW19pXTtcbiAgICAgIGZvciAoayBpbiBvKSB7XG4gICAgICAgIGlmICghX19oYXNQcm9wLmNhbGwobywgaykpIGNvbnRpbnVlO1xuICAgICAgICB2ID0gb1trXTtcbiAgICAgICAgbmV3T2JqW2tdID0gdjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld09iajtcbiAgfTtcblxuICByb290LmFueSA9IGZ1bmN0aW9uKHhzLCBmKSB7XG4gICAgdmFyIHgsIF9pLCBfbGVuO1xuICAgIGlmIChmID09IG51bGwpIHtcbiAgICAgIGYgPSBpZDtcbiAgICB9XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSB4cy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgeCA9IHhzW19pXTtcbiAgICAgIGlmIChmKHgpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgcm9vdC5pbnZva2UgPSBpbnZva2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncywgbmFtZTtcbiAgICBuYW1lID0gYXJndW1lbnRzWzBdLCBhcmdzID0gMiA8PSBhcmd1bWVudHMubGVuZ3RoID8gX19zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkgOiBbXTtcbiAgICByZXR1cm4gaW52b2tlV2l0aChuYW1lLCBhcmdzKTtcbiAgfTtcblxuICByb290Lmludm9rZVdpdGggPSBpbnZva2VXaXRoID0gZnVuY3Rpb24obmFtZSwgYXJncywgY3R4KSB7XG4gICAgaWYgKGFyZ3MgPT0gbnVsbCkge1xuICAgICAgYXJncyA9IFtdO1xuICAgIH1cbiAgICBpZiAoY3R4ID09IG51bGwpIHtcbiAgICAgIGN0eCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbihvKSB7XG4gICAgICBpZiAobyA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIG1ldGhvZCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIG9mIG51bGxcIik7XG4gICAgICB9XG4gICAgICBpZiAoIW9bbmFtZV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgdW5kZWZpbmVkIG1ldGhvZCBcXFwiXCIgKyBuYW1lICsgXCIgb2YgXCIgKyBvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvW25hbWVdLmFwcGx5KGN0eCB8fCBvLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIHJvb3QuZ2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmpbbmFtZV07XG4gICAgfTtcbiAgfTtcblxuICByb290LnNldCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgdmFyIGssIHY7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBvYmpbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoayBpbiBuYW1lKSB7XG4gICAgICAgICAgaWYgKCFfX2hhc1Byb3AuY2FsbChuYW1lLCBrKSkgY29udGludWU7XG4gICAgICAgICAgdiA9IG5hbWVba107XG4gICAgICAgICAgb2JqW2tdID0gdjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICB9O1xuXG4gIFJFUVVJUkVTID0gZnVuY3Rpb24ocmVxdWlyZWQsIGdvdCkge1xuICAgIHJldHVybiBcIlRoaXMgc2VydmljZSByZXF1aXJlcyBhIHNlcnZpY2UgYXQgdmVyc2lvbiBcIiArIHJlcXVpcmVkICsgXCIgb3IgYWJvdmUuIFRoaXMgb25lIGlzIGF0IFwiICsgZ290O1xuICB9O1xuXG4gIHJvb3QuUkVRVUlSRVNfVkVSU0lPTiA9IGZ1bmN0aW9uKHMsIG4sIGYpIHtcbiAgICByZXR1cm4gcy5mZXRjaFZlcnNpb24oKS50aGVuKGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICh2ID49IG4pIHtcbiAgICAgICAgcmV0dXJuIGYoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBlcnJvcihSRVFVSVJFUyhuLCB2KSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgcm9vdC5kZWpvaW4gPSBmdW5jdGlvbihxKSB7XG4gICAgdmFyIHBhcnRzLCB2aWV3LCBfaSwgX2xlbiwgX3JlZjE7XG4gICAgX3JlZjEgPSBxLnZpZXdzO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIHZpZXcgPSBfcmVmMVtfaV07XG4gICAgICBwYXJ0cyA9IHZpZXcuc3BsaXQoJy4nKTtcbiAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAyKSB7XG4gICAgICAgIHEuYWRkSm9pbihwYXJ0cy5zbGljZSgxLCAtMSkuam9pbignLicpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHE7XG4gIH07XG5cbiAgdGhlbkZvbGQgPSBmb2xkKGZ1bmN0aW9uKHAsIGYpIHtcbiAgICByZXR1cm4gcC50aGVuKGYpO1xuICB9KTtcblxuICByb290LnNlcXVlbmNlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZucztcbiAgICBmbnMgPSAxIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBfX3NsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSA6IFtdO1xuICAgIHJldHVybiB0aGVuRm9sZChzdWNjZXNzKCksIGZucyk7XG4gIH07XG5cbiAgcGFpckZvbGQgPSBmb2xkKGZ1bmN0aW9uKG8sIF9hcmcpIHtcbiAgICB2YXIgaywgdjtcbiAgICBrID0gX2FyZ1swXSwgdiA9IF9hcmdbMV07XG4gICAgaWYgKG9ba10gIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGtleTogXCIgKyBrKTtcbiAgICB9XG4gICAgb1trXSA9IHY7XG4gICAgcmV0dXJuIG87XG4gIH0pO1xuXG4gIHJvb3QucGFpcnNUb09iaiA9IGZ1bmN0aW9uKHBhaXJzKSB7XG4gICAgcmV0dXJuIHBhaXJGb2xkKHt9LCBwYWlycyk7XG4gIH07XG5cbn0pLmNhbGwodGhpcyk7XG5cbn0se1wiLi9wcm9taXNlXCI6OH1dLDE2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbigpIHtcbiAgZXhwb3J0cy5WRVJTSU9OID0gJzMuMTMuMCc7XG5cbn0pLmNhbGwodGhpcyk7XG5cbn0se31dLDE3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbigpIHtcbiAgdmFyIERPTVBhcnNlciwgc2FuaXRpemU7XG5cbiAgRE9NUGFyc2VyID0gX2RlcmVxXygneG1sZG9tJykuRE9NUGFyc2VyO1xuXG4gIHNhbml0aXplID0gZnVuY3Rpb24oeG1sKSB7XG4gICAgeG1sID0geG1sLnJlcGxhY2UoL15cXHMqL2csICcnKTtcbiAgICB4bWwgPSB4bWwucmVwbGFjZSgvXFxzJC9nLCAnJyk7XG4gICAgaWYgKHhtbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB4bWw7XG4gICAgfSBlbHNlIGlmICh4bWxbeG1sLmxlbmd0aCAtIDFdICE9PSAnPicpIHtcbiAgICAgIHJldHVybiB4bWwgKyAnPic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB4bWw7XG4gICAgfVxuICB9O1xuXG4gIGV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbih4bWwpIHtcbiAgICB2YXIgZG9tLCBwYXJzZXI7XG4gICAgaWYgKHR5cGVvZiB4bWwgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBhIHN0cmluZyAtIGdvdCBcIiArIHhtbCk7XG4gICAgfVxuICAgIHhtbCA9IHNhbml0aXplKHhtbCk7XG4gICAgaWYgKCF4bWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGNvbnRlbnQgLSBnb3QgZW1wdHkgc3RyaW5nXCIpO1xuICAgIH1cbiAgICBkb20gPSAoZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgICAgIHJldHVybiBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHhtbCwgJ3RleHQveG1sJyk7XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgfSkoKTtcbiAgICBpZiAoKCFkb20pIHx8ICghZG9tLmRvY3VtZW50RWxlbWVudCkgfHwgZG9tLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdwYXJzZXJlcnJvcicpLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBYTUw6IFwiICsgeG1sKTtcbiAgICB9XG4gICAgcmV0dXJuIGRvbTtcbiAgfTtcblxufSkuY2FsbCh0aGlzKTtcblxufSx7XCJ4bWxkb21cIjoxMX1dLDE4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxCdWZmZXIpe1xuXG5cbnZhciBQYXJzZXIgPSBfZGVyZXFfKCdqc29ucGFyc2UnKVxuICAsIHRocm91Z2ggPSBfZGVyZXFfKCd0aHJvdWdoJylcblxuLypcblxuICB0aGUgdmFsdWUgb2YgdGhpcy5zdGFjayB0aGF0IGNyZWF0aW9uaXgncyBqc29ucGFyc2UgaGFzIGlzIHdlaXJkLlxuXG4gIGl0IG1ha2VzIHRoaXMgY29kZSB1Z2x5LCBidXQgaGlzIHByb2JsZW0gaXMgd2F5IGhhcmRlciB0aGF0IG1pbmUsXG4gIHNvIGknbGwgZm9yZ2l2ZSBoaW0uXG5cbiovXG5cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAocGF0aCwgbWFwKSB7XG5cbiAgdmFyIHBhcnNlciA9IG5ldyBQYXJzZXIoKVxuICB2YXIgc3RyZWFtID0gdGhyb3VnaChmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBpZignc3RyaW5nJyA9PT0gdHlwZW9mIGNodW5rKVxuICAgICAgY2h1bmsgPSBuZXcgQnVmZmVyKGNodW5rKVxuICAgIHBhcnNlci53cml0ZShjaHVuaylcbiAgfSxcbiAgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZihkYXRhKVxuICAgICAgc3RyZWFtLndyaXRlKGRhdGEpXG4gICAgc3RyZWFtLnF1ZXVlKG51bGwpXG4gIH0pXG5cbiAgaWYoJ3N0cmluZycgPT09IHR5cGVvZiBwYXRoKVxuICAgIHBhdGggPSBwYXRoLnNwbGl0KCcuJykubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoZSA9PT0gJyonKVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgZWxzZSBpZiAoZSA9PT0gJycpIC8vICcuLicuc3BsaXQoJy4nKSByZXR1cm5zIGFuIGVtcHR5IHN0cmluZ1xuICAgICAgICByZXR1cm4ge3JlY3Vyc2U6IHRydWV9XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBlXG4gICAgfSlcblxuXG4gIHZhciBjb3VudCA9IDAsIF9rZXlcbiAgaWYoIXBhdGggfHwgIXBhdGgubGVuZ3RoKVxuICAgIHBhdGggPSBudWxsXG5cbiAgcGFyc2VyLm9uVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoIXRoaXMucm9vdClcbiAgICAgIHN0cmVhbS5yb290ID0gdmFsdWVcblxuICAgIGlmKCEgcGF0aCkgcmV0dXJuXG5cbiAgICB2YXIgaSA9IDAgLy8gaXRlcmF0ZXMgb24gcGF0aFxuICAgIHZhciBqICA9IDAgLy8gaXRlcmF0ZXMgb24gc3RhY2tcbiAgICB3aGlsZSAoaSA8IHBhdGgubGVuZ3RoKSB7XG4gICAgICB2YXIga2V5ID0gcGF0aFtpXVxuICAgICAgdmFyIGNcbiAgICAgIGorK1xuXG4gICAgICBpZiAoa2V5ICYmICFrZXkucmVjdXJzZSkge1xuICAgICAgICBjID0gKGogPT09IHRoaXMuc3RhY2subGVuZ3RoKSA/IHRoaXMgOiB0aGlzLnN0YWNrW2pdXG4gICAgICAgIGlmICghYykgcmV0dXJuXG4gICAgICAgIGlmICghIGNoZWNrKGtleSwgYy5rZXkpKSByZXR1cm5cbiAgICAgICAgaSsrXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpKytcbiAgICAgICAgdmFyIG5leHRLZXkgPSBwYXRoW2ldXG4gICAgICAgIGlmICghIG5leHRLZXkpIHJldHVyblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGMgPSAoaiA9PT0gdGhpcy5zdGFjay5sZW5ndGgpID8gdGhpcyA6IHRoaXMuc3RhY2tbal1cbiAgICAgICAgICBpZiAoIWMpIHJldHVyblxuICAgICAgICAgIGlmIChjaGVjayhuZXh0S2V5LCBjLmtleSkpIHsgaSsrOyBicmVha31cbiAgICAgICAgICBqKytcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaiAhPT0gdGhpcy5zdGFjay5sZW5ndGgpIHJldHVyblxuXG4gICAgY291bnQgKytcbiAgICB2YXIgYWN0dWFsUGF0aCA9IHRoaXMuc3RhY2suc2xpY2UoMSkubWFwKGZ1bmN0aW9uKGVsZW1lbnQpIHsgcmV0dXJuIGVsZW1lbnQua2V5IH0pLmNvbmNhdChbdGhpcy5rZXldKVxuICAgIHZhciBkYXRhID0gdGhpcy52YWx1ZVt0aGlzLmtleV1cbiAgICBpZihudWxsICE9IGRhdGEpXG4gICAgICBpZihudWxsICE9IChkYXRhID0gbWFwID8gbWFwKGRhdGEsIGFjdHVhbFBhdGgpIDogZGF0YSkpXG4gICAgICAgIHN0cmVhbS5xdWV1ZShkYXRhKVxuICAgIGRlbGV0ZSB0aGlzLnZhbHVlW3RoaXMua2V5XVxuICB9XG4gIHBhcnNlci5fb25Ub2tlbiA9IHBhcnNlci5vblRva2VuO1xuXG4gIHBhcnNlci5vblRva2VuID0gZnVuY3Rpb24gKHRva2VuLCB2YWx1ZSkge1xuICAgIHBhcnNlci5fb25Ub2tlbih0b2tlbiwgdmFsdWUpO1xuICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKHN0cmVhbS5yb290KSB7XG4gICAgICAgIGlmKCFwYXRoKVxuICAgICAgICAgIHN0cmVhbS5xdWV1ZShzdHJlYW0ucm9vdClcbiAgICAgICAgc3RyZWFtLmVtaXQoJ3Jvb3QnLCBzdHJlYW0ucm9vdCwgY291bnQpXG4gICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgc3RyZWFtLnJvb3QgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHBhcnNlci5vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycilcbiAgfVxuXG5cbiAgcmV0dXJuIHN0cmVhbVxufVxuXG5mdW5jdGlvbiBjaGVjayAoeCwgeSkge1xuICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB4KVxuICAgIHJldHVybiB5ID09IHhcbiAgZWxzZSBpZiAoeCAmJiAnZnVuY3Rpb24nID09PSB0eXBlb2YgeC5leGVjKVxuICAgIHJldHVybiB4LmV4ZWMoeSlcbiAgZWxzZSBpZiAoJ2Jvb2xlYW4nID09PSB0eXBlb2YgeClcbiAgICByZXR1cm4geFxuICBlbHNlIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgeClcbiAgICByZXR1cm4geCh5KVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZXhwb3J0cy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAob3AsIHNlcCwgY2wsIGluZGVudCkge1xuICBpbmRlbnQgPSBpbmRlbnQgfHwgMFxuICBpZiAob3AgPT09IGZhbHNlKXtcbiAgICBvcCA9ICcnXG4gICAgc2VwID0gJ1xcbidcbiAgICBjbCA9ICcnXG4gIH0gZWxzZSBpZiAob3AgPT0gbnVsbCkge1xuXG4gICAgb3AgPSAnW1xcbidcbiAgICBzZXAgPSAnXFxuLFxcbidcbiAgICBjbCA9ICdcXG5dXFxuJ1xuXG4gIH1cblxuICAvL2Vsc2UsIHdoYXQgZXZlciB5b3UgbGlrZVxuXG4gIHZhciBzdHJlYW1cbiAgICAsIGZpcnN0ID0gdHJ1ZVxuICAgICwgYW55RGF0YSA9IGZhbHNlXG4gIHN0cmVhbSA9IHRocm91Z2goZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBhbnlEYXRhID0gdHJ1ZVxuICAgIHZhciBqc29uID0gSlNPTi5zdHJpbmdpZnkoZGF0YSwgbnVsbCwgaW5kZW50KVxuICAgIGlmKGZpcnN0KSB7IGZpcnN0ID0gZmFsc2UgOyBzdHJlYW0ucXVldWUob3AgKyBqc29uKX1cbiAgICBlbHNlIHN0cmVhbS5xdWV1ZShzZXAgKyBqc29uKVxuICB9LFxuICBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGlmKCFhbnlEYXRhKVxuICAgICAgc3RyZWFtLnF1ZXVlKG9wKVxuICAgIHN0cmVhbS5xdWV1ZShjbClcbiAgICBzdHJlYW0ucXVldWUobnVsbClcbiAgfSlcblxuICByZXR1cm4gc3RyZWFtXG59XG5cbmV4cG9ydHMuc3RyaW5naWZ5T2JqZWN0ID0gZnVuY3Rpb24gKG9wLCBzZXAsIGNsLCBpbmRlbnQpIHtcbiAgaW5kZW50ID0gaW5kZW50IHx8IDBcbiAgaWYgKG9wID09PSBmYWxzZSl7XG4gICAgb3AgPSAnJ1xuICAgIHNlcCA9ICdcXG4nXG4gICAgY2wgPSAnJ1xuICB9IGVsc2UgaWYgKG9wID09IG51bGwpIHtcblxuICAgIG9wID0gJ3tcXG4nXG4gICAgc2VwID0gJ1xcbixcXG4nXG4gICAgY2wgPSAnXFxufVxcbidcblxuICB9XG5cbiAgLy9lbHNlLCB3aGF0IGV2ZXIgeW91IGxpa2VcblxuICB2YXIgZmlyc3QgPSB0cnVlXG4gICAgLCBhbnlEYXRhID0gZmFsc2VcbiAgc3RyZWFtID0gdGhyb3VnaChmdW5jdGlvbiAoZGF0YSkge1xuICAgIGFueURhdGEgPSB0cnVlXG4gICAgdmFyIGpzb24gPSBKU09OLnN0cmluZ2lmeShkYXRhWzBdKSArICc6JyArIEpTT04uc3RyaW5naWZ5KGRhdGFbMV0sIG51bGwsIGluZGVudClcbiAgICBpZihmaXJzdCkgeyBmaXJzdCA9IGZhbHNlIDsgdGhpcy5xdWV1ZShvcCArIGpzb24pfVxuICAgIGVsc2UgdGhpcy5xdWV1ZShzZXAgKyBqc29uKVxuICB9LFxuICBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGlmKCFhbnlEYXRhKSB0aGlzLnF1ZXVlKG9wKVxuICAgIHRoaXMucXVldWUoY2wpXG5cbiAgICB0aGlzLnF1ZXVlKG51bGwpXG4gIH0pXG5cbiAgcmV0dXJuIHN0cmVhbVxufVxuXG5pZighbW9kdWxlLnBhcmVudCAmJiBwcm9jZXNzLnRpdGxlICE9PSAnYnJvd3NlcicpIHtcbiAgcHJvY2Vzcy5zdGRpblxuICAgIC5waXBlKGV4cG9ydHMucGFyc2UocHJvY2Vzcy5hcmd2WzJdKSlcbiAgICAucGlwZShleHBvcnRzLnN0cmluZ2lmeSgnWycsICcsXFxuJywgJ11cXG4nLCAyKSlcbiAgICAucGlwZShwcm9jZXNzLnN0ZG91dClcbn1cblxufSkuY2FsbCh0aGlzLF9kZXJlcV8oXCIvaG9tZS9hbGV4L3Byb2plY3RzL2phdmFzY3JpcHQvaW1qcy9ub2RlX21vZHVsZXMvaW5zZXJ0LW1vZHVsZS1nbG9iYWxzL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcIiksX2RlcmVxXyhcImJ1ZmZlclwiKS5CdWZmZXIpXG59LHtcIi9ob21lL2FsZXgvcHJvamVjdHMvamF2YXNjcmlwdC9pbWpzL25vZGVfbW9kdWxlcy9pbnNlcnQtbW9kdWxlLWdsb2JhbHMvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1wiOjU1LFwiYnVmZmVyXCI6MjMsXCJqc29ucGFyc2VcIjoxOSxcInRocm91Z2hcIjo1Nn1dLDE5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoQnVmZmVyKXtcbi8qZ2xvYmFsIEJ1ZmZlciovXG4vLyBOYW1lZCBjb25zdGFudHMgd2l0aCB1bmlxdWUgaW50ZWdlciB2YWx1ZXNcbnZhciBDID0ge307XG4vLyBUb2tlbnNcbnZhciBMRUZUX0JSQUNFICAgID0gQy5MRUZUX0JSQUNFICAgID0gMHgxO1xudmFyIFJJR0hUX0JSQUNFICAgPSBDLlJJR0hUX0JSQUNFICAgPSAweDI7XG52YXIgTEVGVF9CUkFDS0VUICA9IEMuTEVGVF9CUkFDS0VUICA9IDB4MztcbnZhciBSSUdIVF9CUkFDS0VUID0gQy5SSUdIVF9CUkFDS0VUID0gMHg0O1xudmFyIENPTE9OICAgICAgICAgPSBDLkNPTE9OICAgICAgICAgPSAweDU7XG52YXIgQ09NTUEgICAgICAgICA9IEMuQ09NTUEgICAgICAgICA9IDB4NjtcbnZhciBUUlVFICAgICAgICAgID0gQy5UUlVFICAgICAgICAgID0gMHg3O1xudmFyIEZBTFNFICAgICAgICAgPSBDLkZBTFNFICAgICAgICAgPSAweDg7XG52YXIgTlVMTCAgICAgICAgICA9IEMuTlVMTCAgICAgICAgICA9IDB4OTtcbnZhciBTVFJJTkcgICAgICAgID0gQy5TVFJJTkcgICAgICAgID0gMHhhO1xudmFyIE5VTUJFUiAgICAgICAgPSBDLk5VTUJFUiAgICAgICAgPSAweGI7XG4vLyBUb2tlbml6ZXIgU3RhdGVzXG52YXIgU1RBUlQgICA9IEMuU1RBUlQgICA9IDB4MTE7XG52YXIgVFJVRTEgICA9IEMuVFJVRTEgICA9IDB4MjE7XG52YXIgVFJVRTIgICA9IEMuVFJVRTIgICA9IDB4MjI7XG52YXIgVFJVRTMgICA9IEMuVFJVRTMgICA9IDB4MjM7XG52YXIgRkFMU0UxICA9IEMuRkFMU0UxICA9IDB4MzE7XG52YXIgRkFMU0UyICA9IEMuRkFMU0UyICA9IDB4MzI7XG52YXIgRkFMU0UzICA9IEMuRkFMU0UzICA9IDB4MzM7XG52YXIgRkFMU0U0ICA9IEMuRkFMU0U0ICA9IDB4MzQ7XG52YXIgTlVMTDEgICA9IEMuTlVMTDEgICA9IDB4NDE7XG52YXIgTlVMTDIgICA9IEMuTlVMTDMgICA9IDB4NDI7XG52YXIgTlVMTDMgICA9IEMuTlVMTDIgICA9IDB4NDM7XG52YXIgTlVNQkVSMSA9IEMuTlVNQkVSMSA9IDB4NTE7XG52YXIgTlVNQkVSMiA9IEMuTlVNQkVSMiA9IDB4NTI7XG52YXIgTlVNQkVSMyA9IEMuTlVNQkVSMyA9IDB4NTM7XG52YXIgTlVNQkVSNCA9IEMuTlVNQkVSNCA9IDB4NTQ7XG52YXIgTlVNQkVSNSA9IEMuTlVNQkVSNSA9IDB4NTU7XG52YXIgTlVNQkVSNiA9IEMuTlVNQkVSNiA9IDB4NTY7XG52YXIgTlVNQkVSNyA9IEMuTlVNQkVSNyA9IDB4NTc7XG52YXIgTlVNQkVSOCA9IEMuTlVNQkVSOCA9IDB4NTg7XG52YXIgU1RSSU5HMSA9IEMuU1RSSU5HMSA9IDB4NjE7XG52YXIgU1RSSU5HMiA9IEMuU1RSSU5HMiA9IDB4NjI7XG52YXIgU1RSSU5HMyA9IEMuU1RSSU5HMyA9IDB4NjM7XG52YXIgU1RSSU5HNCA9IEMuU1RSSU5HNCA9IDB4NjQ7XG52YXIgU1RSSU5HNSA9IEMuU1RSSU5HNSA9IDB4NjU7XG52YXIgU1RSSU5HNiA9IEMuU1RSSU5HNiA9IDB4NjY7XG4vLyBQYXJzZXIgU3RhdGVzXG52YXIgVkFMVUUgICA9IEMuVkFMVUUgICA9IDB4NzE7XG52YXIgS0VZICAgICA9IEMuS0VZICAgICA9IDB4NzI7XG4vLyBQYXJzZXIgTW9kZXNcbnZhciBPQkpFQ1QgID0gQy5PQkpFQ1QgID0gMHg4MTtcbnZhciBBUlJBWSAgID0gQy5BUlJBWSAgID0gMHg4MjtcblxuLy8gU2xvdyBjb2RlIHRvIHN0cmluZyBjb252ZXJ0ZXIgKG9ubHkgdXNlZCB3aGVuIHRocm93aW5nIHN5bnRheCBlcnJvcnMpXG5mdW5jdGlvbiB0b2tuYW0oY29kZSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKEMpO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKENba2V5XSA9PT0gY29kZSkgeyByZXR1cm4ga2V5OyB9XG4gIH1cbiAgcmV0dXJuIGNvZGUgJiYgKFwiMHhcIiArIGNvZGUudG9TdHJpbmcoMTYpKTtcbn1cblxuXG5mdW5jdGlvbiBQYXJzZXIoKSB7XG4gIHRoaXMudFN0YXRlID0gU1RBUlQ7XG4gIHRoaXMudmFsdWUgPSB1bmRlZmluZWQ7XG5cbiAgdGhpcy5zdHJpbmcgPSB1bmRlZmluZWQ7IC8vIHN0cmluZyBkYXRhXG4gIHRoaXMudW5pY29kZSA9IHVuZGVmaW5lZDsgLy8gdW5pY29kZSBlc2NhcGVzXG5cbiAgLy8gRm9yIG51bWJlciBwYXJzaW5nXG4gIHRoaXMubmVnYXRpdmUgPSB1bmRlZmluZWQ7XG4gIHRoaXMubWFnbmF0dWRlID0gdW5kZWZpbmVkO1xuICB0aGlzLnBvc2l0aW9uID0gdW5kZWZpbmVkO1xuICB0aGlzLmV4cG9uZW50ID0gdW5kZWZpbmVkO1xuICB0aGlzLm5lZ2F0aXZlRXhwb25lbnQgPSB1bmRlZmluZWQ7XG4gIFxuICB0aGlzLmtleSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5tb2RlID0gdW5kZWZpbmVkO1xuICB0aGlzLnN0YWNrID0gW107XG4gIHRoaXMuc3RhdGUgPSBWQUxVRTtcbiAgdGhpcy5ieXRlc19yZW1haW5pbmcgPSAwOyAvLyBudW1iZXIgb2YgYnl0ZXMgcmVtYWluaW5nIGluIG11bHRpIGJ5dGUgdXRmOCBjaGFyIHRvIHJlYWQgYWZ0ZXIgc3BsaXQgYm91bmRhcnlcbiAgdGhpcy5ieXRlc19pbl9zZXF1ZW5jZSA9IDA7IC8vIGJ5dGVzIGluIG11bHRpIGJ5dGUgdXRmOCBjaGFyIHRvIHJlYWRcbiAgdGhpcy50ZW1wX2J1ZmZzID0geyBcIjJcIjogbmV3IEJ1ZmZlcigyKSwgXCIzXCI6IG5ldyBCdWZmZXIoMyksIFwiNFwiOiBuZXcgQnVmZmVyKDQpIH07IC8vIGZvciByZWJ1aWxkaW5nIGNoYXJzIHNwbGl0IGJlZm9yZSBib3VuZGFyeSBpcyByZWFjaGVkXG59XG52YXIgcHJvdG8gPSBQYXJzZXIucHJvdG90eXBlO1xucHJvdG8uY2hhckVycm9yID0gZnVuY3Rpb24gKGJ1ZmZlciwgaSkge1xuICB0aGlzLm9uRXJyb3IobmV3IEVycm9yKFwiVW5leHBlY3RlZCBcIiArIEpTT04uc3RyaW5naWZ5KFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmZmVyW2ldKSkgKyBcIiBhdCBwb3NpdGlvbiBcIiArIGkgKyBcIiBpbiBzdGF0ZSBcIiArIHRva25hbSh0aGlzLnRTdGF0ZSkpKTtcbn07XG5wcm90by5vbkVycm9yID0gZnVuY3Rpb24gKGVycikgeyB0aHJvdyBlcnI7IH07XG5wcm90by53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgaWYgKHR5cGVvZiBidWZmZXIgPT09IFwic3RyaW5nXCIpIGJ1ZmZlciA9IG5ldyBCdWZmZXIoYnVmZmVyKTtcbiAgLy9wcm9jZXNzLnN0ZG91dC53cml0ZShcIklucHV0OiBcIik7XG4gIC8vY29uc29sZS5kaXIoYnVmZmVyLnRvU3RyaW5nKCkpO1xuICB2YXIgbjtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBidWZmZXIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHRoaXMudFN0YXRlID09PSBTVEFSVCl7XG4gICAgICBuID0gYnVmZmVyW2ldO1xuICAgICAgaWYobiA9PT0gMHg3Yil7IHRoaXMub25Ub2tlbihMRUZUX0JSQUNFLCBcIntcIik7IC8vIHtcbiAgICAgIH1lbHNlIGlmKG4gPT09IDB4N2QpeyB0aGlzLm9uVG9rZW4oUklHSFRfQlJBQ0UsIFwifVwiKTsgLy8gfVxuICAgICAgfWVsc2UgaWYobiA9PT0gMHg1Yil7IHRoaXMub25Ub2tlbihMRUZUX0JSQUNLRVQsIFwiW1wiKTsgLy8gW1xuICAgICAgfWVsc2UgaWYobiA9PT0gMHg1ZCl7IHRoaXMub25Ub2tlbihSSUdIVF9CUkFDS0VULCBcIl1cIik7IC8vIF1cbiAgICAgIH1lbHNlIGlmKG4gPT09IDB4M2EpeyB0aGlzLm9uVG9rZW4oQ09MT04sIFwiOlwiKTsgIC8vIDpcbiAgICAgIH1lbHNlIGlmKG4gPT09IDB4MmMpeyB0aGlzLm9uVG9rZW4oQ09NTUEsIFwiLFwiKTsgLy8gLFxuICAgICAgfWVsc2UgaWYobiA9PT0gMHg3NCl7IHRoaXMudFN0YXRlID0gVFJVRTE7ICAvLyB0XG4gICAgICB9ZWxzZSBpZihuID09PSAweDY2KXsgdGhpcy50U3RhdGUgPSBGQUxTRTE7ICAvLyBmXG4gICAgICB9ZWxzZSBpZihuID09PSAweDZlKXsgdGhpcy50U3RhdGUgPSBOVUxMMTsgLy8gblxuICAgICAgfWVsc2UgaWYobiA9PT0gMHgyMil7IHRoaXMuc3RyaW5nID0gXCJcIjsgdGhpcy50U3RhdGUgPSBTVFJJTkcxOyAvLyBcIlxuICAgICAgfWVsc2UgaWYobiA9PT0gMHgyZCl7IHRoaXMubmVnYXRpdmUgPSB0cnVlOyB0aGlzLnRTdGF0ZSA9IE5VTUJFUjE7IC8vIC1cbiAgICAgIH1lbHNlIGlmKG4gPT09IDB4MzApeyB0aGlzLm1hZ25hdHVkZSA9IDA7IHRoaXMudFN0YXRlID0gTlVNQkVSMjsgLy8gMFxuICAgICAgfWVsc2V7XG4gICAgICAgIGlmIChuID4gMHgzMCAmJiBuIDwgMHg0MCkgeyAvLyAxLTlcbiAgICAgICAgICB0aGlzLm1hZ25hdHVkZSA9IG4gLSAweDMwOyB0aGlzLnRTdGF0ZSA9IE5VTUJFUjM7XG4gICAgICAgIH0gZWxzZSBpZiAobiA9PT0gMHgyMCB8fCBuID09PSAweDA5IHx8IG4gPT09IDB4MGEgfHwgbiA9PT0gMHgwZCkge1xuICAgICAgICAgIC8vIHdoaXRlc3BhY2VcbiAgICAgICAgfSBlbHNlIHsgdGhpcy5jaGFyRXJyb3IoYnVmZmVyLCBpKTsgfVxuICAgICAgfVxuICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gU1RSSU5HMSl7IC8vIEFmdGVyIG9wZW4gcXVvdGVcbiAgICAgIG4gPSBidWZmZXJbaV07IC8vIGdldCBjdXJyZW50IGJ5dGUgZnJvbSBidWZmZXJcbiAgICAgIC8vIGNoZWNrIGZvciBjYXJyeSBvdmVyIG9mIGEgbXVsdGkgYnl0ZSBjaGFyIHNwbGl0IGJldHdlZW4gZGF0YSBjaHVua3NcbiAgICAgIC8vICYgZmlsbCB0ZW1wIGJ1ZmZlciBpdCB3aXRoIHN0YXJ0IG9mIHRoaXMgZGF0YSBjaHVuayB1cCB0byB0aGUgYm91bmRhcnkgbGltaXQgc2V0IGluIHRoZSBsYXN0IGl0ZXJhdGlvblxuICAgICAgaWYgKHRoaXMuYnl0ZXNfcmVtYWluaW5nID4gMCkge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuYnl0ZXNfcmVtYWluaW5nOyBqKyspIHtcbiAgICAgICAgICB0aGlzLnRlbXBfYnVmZnNbdGhpcy5ieXRlc19pbl9zZXF1ZW5jZV1bdGhpcy5ieXRlc19pbl9zZXF1ZW5jZSAtIHRoaXMuYnl0ZXNfcmVtYWluaW5nICsgal0gPSBidWZmZXJbal07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdHJpbmcgKz0gdGhpcy50ZW1wX2J1ZmZzW3RoaXMuYnl0ZXNfaW5fc2VxdWVuY2VdLnRvU3RyaW5nKCk7XG4gICAgICAgIHRoaXMuYnl0ZXNfaW5fc2VxdWVuY2UgPSB0aGlzLmJ5dGVzX3JlbWFpbmluZyA9IDA7XG4gICAgICAgIGkgPSBpICsgaiAtIDE7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuYnl0ZXNfcmVtYWluaW5nID09PSAwICYmIG4gPj0gMTI4KSB7IC8vIGVsc2UgaWYgbm8gcmVtYWluZGVyIGJ5dGVzIGNhcnJpZWQgb3ZlciwgcGFyc2UgbXVsdGkgYnl0ZSAoPj0xMjgpIGNoYXJzIG9uZSBhdCBhIHRpbWVcbiAgICAgICAgaWYgKChuID49IDE5NCkgJiYgKG4gPD0gMjIzKSkgdGhpcy5ieXRlc19pbl9zZXF1ZW5jZSA9IDI7XG4gICAgICAgIGlmICgobiA+PSAyMjQpICYmIChuIDw9IDIzOSkpIHRoaXMuYnl0ZXNfaW5fc2VxdWVuY2UgPSAzO1xuICAgICAgICBpZiAoKG4gPj0gMjQwKSAmJiAobiA8PSAyNDQpKSB0aGlzLmJ5dGVzX2luX3NlcXVlbmNlID0gNDtcbiAgICAgICAgaWYgKCh0aGlzLmJ5dGVzX2luX3NlcXVlbmNlICsgaSkgPiBidWZmZXIubGVuZ3RoKSB7IC8vIGlmIGJ5dGVzIG5lZWRlZCB0byBjb21wbGV0ZSBjaGFyIGZhbGwgb3V0c2lkZSBidWZmZXIgbGVuZ3RoLCB3ZSBoYXZlIGEgYm91bmRhcnkgc3BsaXRcbiAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8PSAoYnVmZmVyLmxlbmd0aCAtIDEgLSBpKTsgaysrKSB7XG4gICAgICAgICAgICB0aGlzLnRlbXBfYnVmZnNbdGhpcy5ieXRlc19pbl9zZXF1ZW5jZV1ba10gPSBidWZmZXJbaSArIGtdOyAvLyBmaWxsIHRlbXAgYnVmZmVyIG9mIGNvcnJlY3Qgc2l6ZSB3aXRoIGJ5dGVzIGF2YWlsYWJsZSBpbiB0aGlzIGNodW5rXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYnl0ZXNfcmVtYWluaW5nID0gKGkgKyB0aGlzLmJ5dGVzX2luX3NlcXVlbmNlKSAtIGJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgaSA9IGJ1ZmZlci5sZW5ndGggLSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3RyaW5nICs9IGJ1ZmZlci5zbGljZShpLCAoaSArIHRoaXMuYnl0ZXNfaW5fc2VxdWVuY2UpKS50b1N0cmluZygpO1xuICAgICAgICAgIGkgPSBpICsgdGhpcy5ieXRlc19pbl9zZXF1ZW5jZSAtIDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobiA9PT0gMHgyMikgeyB0aGlzLnRTdGF0ZSA9IFNUQVJUOyB0aGlzLm9uVG9rZW4oU1RSSU5HLCB0aGlzLnN0cmluZyk7IHRoaXMuc3RyaW5nID0gdW5kZWZpbmVkOyB9XG4gICAgICBlbHNlIGlmIChuID09PSAweDVjKSB7IHRoaXMudFN0YXRlID0gU1RSSU5HMjsgfVxuICAgICAgZWxzZSBpZiAobiA+PSAweDIwKSB7IHRoaXMuc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobik7IH1cbiAgICAgIGVsc2UgeyB0aGlzLmNoYXJFcnJvcihidWZmZXIsIGkpOyB9XG4gICAgfWVsc2UgaWYgKHRoaXMudFN0YXRlID09PSBTVFJJTkcyKXsgLy8gQWZ0ZXIgYmFja3NsYXNoXG4gICAgICBuID0gYnVmZmVyW2ldO1xuICAgICAgaWYobiA9PT0gMHgyMil7IHRoaXMuc3RyaW5nICs9IFwiXFxcIlwiOyB0aGlzLnRTdGF0ZSA9IFNUUklORzE7XG4gICAgICB9ZWxzZSBpZihuID09PSAweDVjKXsgdGhpcy5zdHJpbmcgKz0gXCJcXFxcXCI7IHRoaXMudFN0YXRlID0gU1RSSU5HMTsgXG4gICAgICB9ZWxzZSBpZihuID09PSAweDJmKXsgdGhpcy5zdHJpbmcgKz0gXCJcXC9cIjsgdGhpcy50U3RhdGUgPSBTVFJJTkcxOyBcbiAgICAgIH1lbHNlIGlmKG4gPT09IDB4NjIpeyB0aGlzLnN0cmluZyArPSBcIlxcYlwiOyB0aGlzLnRTdGF0ZSA9IFNUUklORzE7IFxuICAgICAgfWVsc2UgaWYobiA9PT0gMHg2Nil7IHRoaXMuc3RyaW5nICs9IFwiXFxmXCI7IHRoaXMudFN0YXRlID0gU1RSSU5HMTsgXG4gICAgICB9ZWxzZSBpZihuID09PSAweDZlKXsgdGhpcy5zdHJpbmcgKz0gXCJcXG5cIjsgdGhpcy50U3RhdGUgPSBTVFJJTkcxOyBcbiAgICAgIH1lbHNlIGlmKG4gPT09IDB4NzIpeyB0aGlzLnN0cmluZyArPSBcIlxcclwiOyB0aGlzLnRTdGF0ZSA9IFNUUklORzE7IFxuICAgICAgfWVsc2UgaWYobiA9PT0gMHg3NCl7IHRoaXMuc3RyaW5nICs9IFwiXFx0XCI7IHRoaXMudFN0YXRlID0gU1RSSU5HMTsgXG4gICAgICB9ZWxzZSBpZihuID09PSAweDc1KXsgdGhpcy51bmljb2RlID0gXCJcIjsgdGhpcy50U3RhdGUgPSBTVFJJTkczO1xuICAgICAgfWVsc2V7IFxuICAgICAgICB0aGlzLmNoYXJFcnJvcihidWZmZXIsIGkpOyBcbiAgICAgIH1cbiAgICB9ZWxzZSBpZiAodGhpcy50U3RhdGUgPT09IFNUUklORzMgfHwgdGhpcy50U3RhdGUgPT09IFNUUklORzQgfHwgdGhpcy50U3RhdGUgPT09IFNUUklORzUgfHwgdGhpcy50U3RhdGUgPT09IFNUUklORzYpeyAvLyB1bmljb2RlIGhleCBjb2Rlc1xuICAgICAgbiA9IGJ1ZmZlcltpXTtcbiAgICAgIC8vIDAtOSBBLUYgYS1mXG4gICAgICBpZiAoKG4gPj0gMHgzMCAmJiBuIDwgMHg0MCkgfHwgKG4gPiAweDQwICYmIG4gPD0gMHg0NikgfHwgKG4gPiAweDYwICYmIG4gPD0gMHg2NikpIHtcbiAgICAgICAgdGhpcy51bmljb2RlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobik7XG4gICAgICAgIGlmICh0aGlzLnRTdGF0ZSsrID09PSBTVFJJTkc2KSB7XG4gICAgICAgICAgdGhpcy5zdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludCh0aGlzLnVuaWNvZGUsIDE2KSk7XG4gICAgICAgICAgdGhpcy51bmljb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHRoaXMudFN0YXRlID0gU1RSSU5HMTsgXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2hhckVycm9yKGJ1ZmZlciwgaSk7XG4gICAgICB9XG4gICAgfWVsc2UgaWYgKHRoaXMudFN0YXRlID09PSBOVU1CRVIxKXsgLy8gYWZ0ZXIgbWludXNcbiAgICAgIG4gPSBidWZmZXJbaV07XG4gICAgICBpZiAobiA9PT0gMHgzMCkgeyB0aGlzLm1hZ25hdHVkZSA9IDA7IHRoaXMudFN0YXRlID0gTlVNQkVSMjsgfVxuICAgICAgZWxzZSBpZiAobiA+IDB4MzAgJiYgbiA8IDB4NDApIHsgdGhpcy5tYWduYXR1ZGUgPSBuIC0gMHgzMDsgdGhpcy50U3RhdGUgPSBOVU1CRVIzOyB9XG4gICAgICBlbHNlIHsgdGhpcy5jaGFyRXJyb3IoYnVmZmVyLCBpKTsgfVxuICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gTlVNQkVSMil7IC8vICogQWZ0ZXIgaW5pdGlhbCB6ZXJvXG4gICAgICBuID0gYnVmZmVyW2ldO1xuICAgICAgaWYobiA9PT0gMHgyZSl7IC8vIC5cbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IDAuMTsgdGhpcy50U3RhdGUgPSBOVU1CRVI0O1xuICAgICAgfWVsc2UgaWYobiA9PT0gMHg2NSB8fCAgbiA9PT0gMHg0NSl7IC8vIGUvRVxuICAgICAgICB0aGlzLmV4cG9uZW50ID0gMDsgdGhpcy50U3RhdGUgPSBOVU1CRVI2O1xuICAgICAgfWVsc2V7XG4gICAgICAgIHRoaXMudFN0YXRlID0gU1RBUlQ7XG4gICAgICAgIHRoaXMub25Ub2tlbihOVU1CRVIsIDApO1xuICAgICAgICB0aGlzLm1hZ25hdHVkZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5uZWdhdGl2ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gTlVNQkVSMyl7IC8vICogQWZ0ZXIgZGlnaXQgKGJlZm9yZSBwZXJpb2QpXG4gICAgICBuID0gYnVmZmVyW2ldO1xuICAgICAgaWYobiA9PT0gMHgyZSl7IC8vIC5cbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IDAuMTsgdGhpcy50U3RhdGUgPSBOVU1CRVI0O1xuICAgICAgfWVsc2UgaWYobiA9PT0gMHg2NSB8fCBuID09PSAweDQ1KXsgLy8gZS9FXG4gICAgICAgIHRoaXMuZXhwb25lbnQgPSAwOyB0aGlzLnRTdGF0ZSA9IE5VTUJFUjY7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgaWYgKG4gPj0gMHgzMCAmJiBuIDwgMHg0MCkgeyB0aGlzLm1hZ25hdHVkZSA9IHRoaXMubWFnbmF0dWRlICogMTAgKyBuIC0gMHgzMDsgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLnRTdGF0ZSA9IFNUQVJUOyBcbiAgICAgICAgICBpZiAodGhpcy5uZWdhdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5tYWduYXR1ZGUgPSAtdGhpcy5tYWduYXR1ZGU7XG4gICAgICAgICAgICB0aGlzLm5lZ2F0aXZlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm9uVG9rZW4oTlVNQkVSLCB0aGlzLm1hZ25hdHVkZSk7IFxuICAgICAgICAgIHRoaXMubWFnbmF0dWRlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gTlVNQkVSNCl7IC8vIEFmdGVyIHBlcmlvZFxuICAgICAgbiA9IGJ1ZmZlcltpXTtcbiAgICAgIGlmIChuID49IDB4MzAgJiYgbiA8IDB4NDApIHsgLy8gMC05XG4gICAgICAgIHRoaXMubWFnbmF0dWRlICs9IHRoaXMucG9zaXRpb24gKiAobiAtIDB4MzApO1xuICAgICAgICB0aGlzLnBvc2l0aW9uIC89IDEwO1xuICAgICAgICB0aGlzLnRTdGF0ZSA9IE5VTUJFUjU7IFxuICAgICAgfSBlbHNlIHsgdGhpcy5jaGFyRXJyb3IoYnVmZmVyLCBpKTsgfVxuICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gTlVNQkVSNSl7IC8vICogQWZ0ZXIgZGlnaXQgKGFmdGVyIHBlcmlvZClcbiAgICAgIG4gPSBidWZmZXJbaV07XG4gICAgICBpZiAobiA+PSAweDMwICYmIG4gPCAweDQwKSB7IC8vIDAtOVxuICAgICAgICB0aGlzLm1hZ25hdHVkZSArPSB0aGlzLnBvc2l0aW9uICogKG4gLSAweDMwKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiAvPSAxMDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG4gPT09IDB4NjUgfHwgbiA9PT0gMHg0NSkgeyB0aGlzLmV4cG9uZW50ID0gMDsgdGhpcy50U3RhdGUgPSBOVU1CRVI2OyB9IC8vIEUvZVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMudFN0YXRlID0gU1RBUlQ7IFxuICAgICAgICBpZiAodGhpcy5uZWdhdGl2ZSkge1xuICAgICAgICAgIHRoaXMubWFnbmF0dWRlID0gLXRoaXMubWFnbmF0dWRlO1xuICAgICAgICAgIHRoaXMubmVnYXRpdmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vblRva2VuKE5VTUJFUiwgdGhpcy5uZWdhdGl2ZSA/IC10aGlzLm1hZ25hdHVkZSA6IHRoaXMubWFnbmF0dWRlKTsgXG4gICAgICAgIHRoaXMubWFnbmF0dWRlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICBpLS07IFxuICAgICAgfVxuICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gTlVNQkVSNil7IC8vIEFmdGVyIEVcbiAgICAgIG4gPSBidWZmZXJbaV07XG4gICAgICBpZiAobiA9PT0gMHgyYiB8fCBuID09PSAweDJkKSB7IC8vICsvLVxuICAgICAgICBpZiAobiA9PT0gMHgyZCkgeyB0aGlzLm5lZ2F0aXZlRXhwb25lbnQgPSB0cnVlOyB9XG4gICAgICAgIHRoaXMudFN0YXRlID0gTlVNQkVSNztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG4gPj0gMHgzMCAmJiBuIDwgMHg0MCkge1xuICAgICAgICB0aGlzLmV4cG9uZW50ID0gdGhpcy5leHBvbmVudCAqIDEwICsgKG4gLSAweDMwKTtcbiAgICAgICAgdGhpcy50U3RhdGUgPSBOVU1CRVI4O1xuICAgICAgfVxuICAgICAgZWxzZSB7IHRoaXMuY2hhckVycm9yKGJ1ZmZlciwgaSk7IH0gIFxuICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gTlVNQkVSNyl7IC8vIEFmdGVyICsvLVxuICAgICAgbiA9IGJ1ZmZlcltpXTtcbiAgICAgIGlmIChuID49IDB4MzAgJiYgbiA8IDB4NDApIHsgLy8gMC05XG4gICAgICAgIHRoaXMuZXhwb25lbnQgPSB0aGlzLmV4cG9uZW50ICogMTAgKyAobiAtIDB4MzApO1xuICAgICAgICB0aGlzLnRTdGF0ZSA9IE5VTUJFUjg7XG4gICAgICB9XG4gICAgICBlbHNlIHsgdGhpcy5jaGFyRXJyb3IoYnVmZmVyLCBpKTsgfSAgXG4gICAgfWVsc2UgaWYgKHRoaXMudFN0YXRlID09PSBOVU1CRVI4KXsgLy8gKiBBZnRlciBkaWdpdCAoYWZ0ZXIgKy8tKVxuICAgICAgbiA9IGJ1ZmZlcltpXTtcbiAgICAgIGlmIChuID49IDB4MzAgJiYgbiA8IDB4NDApIHsgLy8gMC05XG4gICAgICAgIHRoaXMuZXhwb25lbnQgPSB0aGlzLmV4cG9uZW50ICogMTAgKyAobiAtIDB4MzApO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLm5lZ2F0aXZlRXhwb25lbnQpIHtcbiAgICAgICAgICB0aGlzLmV4cG9uZW50ID0gLXRoaXMuZXhwb25lbnQ7XG4gICAgICAgICAgdGhpcy5uZWdhdGl2ZUV4cG9uZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFnbmF0dWRlICo9IE1hdGgucG93KDEwLCB0aGlzLmV4cG9uZW50KTtcbiAgICAgICAgdGhpcy5leHBvbmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRoaXMubmVnYXRpdmUpIHsgXG4gICAgICAgICAgdGhpcy5tYWduYXR1ZGUgPSAtdGhpcy5tYWduYXR1ZGU7XG4gICAgICAgICAgdGhpcy5uZWdhdGl2ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRTdGF0ZSA9IFNUQVJUO1xuICAgICAgICB0aGlzLm9uVG9rZW4oTlVNQkVSLCB0aGlzLm1hZ25hdHVkZSk7XG4gICAgICAgIHRoaXMubWFnbmF0dWRlID0gdW5kZWZpbmVkO1xuICAgICAgICBpLS07IFxuICAgICAgfSBcbiAgICB9ZWxzZSBpZiAodGhpcy50U3RhdGUgPT09IFRSVUUxKXsgLy8gclxuICAgICAgaWYgKGJ1ZmZlcltpXSA9PT0gMHg3MikgeyB0aGlzLnRTdGF0ZSA9IFRSVUUyOyB9XG4gICAgICBlbHNlIHsgdGhpcy5jaGFyRXJyb3IoYnVmZmVyLCBpKTsgfVxuICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gVFJVRTIpeyAvLyB1XG4gICAgICBpZiAoYnVmZmVyW2ldID09PSAweDc1KSB7IHRoaXMudFN0YXRlID0gVFJVRTM7IH1cbiAgICAgIGVsc2UgeyB0aGlzLmNoYXJFcnJvcihidWZmZXIsIGkpOyB9XG4gICAgfWVsc2UgaWYgKHRoaXMudFN0YXRlID09PSBUUlVFMyl7IC8vIGVcbiAgICAgIGlmIChidWZmZXJbaV0gPT09IDB4NjUpIHsgdGhpcy50U3RhdGUgPSBTVEFSVDsgdGhpcy5vblRva2VuKFRSVUUsIHRydWUpOyB9XG4gICAgICBlbHNlIHsgdGhpcy5jaGFyRXJyb3IoYnVmZmVyLCBpKTsgfVxuICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gRkFMU0UxKXsgLy8gYVxuICAgICAgaWYgKGJ1ZmZlcltpXSA9PT0gMHg2MSkgeyB0aGlzLnRTdGF0ZSA9IEZBTFNFMjsgfVxuICAgICAgZWxzZSB7IHRoaXMuY2hhckVycm9yKGJ1ZmZlciwgaSk7IH1cbiAgICB9ZWxzZSBpZiAodGhpcy50U3RhdGUgPT09IEZBTFNFMil7IC8vIGxcbiAgICAgIGlmIChidWZmZXJbaV0gPT09IDB4NmMpIHsgdGhpcy50U3RhdGUgPSBGQUxTRTM7IH1cbiAgICAgIGVsc2UgeyB0aGlzLmNoYXJFcnJvcihidWZmZXIsIGkpOyB9XG4gICAgfWVsc2UgaWYgKHRoaXMudFN0YXRlID09PSBGQUxTRTMpeyAvLyBzXG4gICAgICBpZiAoYnVmZmVyW2ldID09PSAweDczKSB7IHRoaXMudFN0YXRlID0gRkFMU0U0OyB9XG4gICAgICBlbHNlIHsgdGhpcy5jaGFyRXJyb3IoYnVmZmVyLCBpKTsgfVxuICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gRkFMU0U0KXsgLy8gZVxuICAgICAgaWYgKGJ1ZmZlcltpXSA9PT0gMHg2NSkgeyB0aGlzLnRTdGF0ZSA9IFNUQVJUOyB0aGlzLm9uVG9rZW4oRkFMU0UsIGZhbHNlKTsgfVxuICAgICAgZWxzZSB7IHRoaXMuY2hhckVycm9yKGJ1ZmZlciwgaSk7IH1cbiAgICB9ZWxzZSBpZiAodGhpcy50U3RhdGUgPT09IE5VTEwxKXsgLy8gdVxuICAgICAgaWYgKGJ1ZmZlcltpXSA9PT0gMHg3NSkgeyB0aGlzLnRTdGF0ZSA9IE5VTEwyOyB9XG4gICAgICBlbHNlIHsgdGhpcy5jaGFyRXJyb3IoYnVmZmVyLCBpKTsgfVxuICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gTlVMTDIpeyAvLyBsXG4gICAgICBpZiAoYnVmZmVyW2ldID09PSAweDZjKSB7IHRoaXMudFN0YXRlID0gTlVMTDM7IH1cbiAgICAgIGVsc2UgeyB0aGlzLmNoYXJFcnJvcihidWZmZXIsIGkpOyB9XG4gICAgfWVsc2UgaWYgKHRoaXMudFN0YXRlID09PSBOVUxMMyl7IC8vIGxcbiAgICAgIGlmIChidWZmZXJbaV0gPT09IDB4NmMpIHsgdGhpcy50U3RhdGUgPSBTVEFSVDsgdGhpcy5vblRva2VuKE5VTEwsIG51bGwpOyB9XG4gICAgICBlbHNlIHsgdGhpcy5jaGFyRXJyb3IoYnVmZmVyLCBpKTsgfVxuICAgIH1cbiAgfVxufTtcbnByb3RvLm9uVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4sIHZhbHVlKSB7XG4gIC8vIE92ZXJyaWRlIHRoaXMgdG8gZ2V0IGV2ZW50c1xufTtcblxucHJvdG8ucGFyc2VFcnJvciA9IGZ1bmN0aW9uICh0b2tlbiwgdmFsdWUpIHtcbiAgdGhpcy5vbkVycm9yKG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgXCIgKyB0b2tuYW0odG9rZW4pICsgKHZhbHVlID8gKFwiKFwiICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgXCIpXCIpIDogXCJcIikgKyBcIiBpbiBzdGF0ZSBcIiArIHRva25hbSh0aGlzLnN0YXRlKSkpO1xufTtcbnByb3RvLm9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7IHRocm93IGVycjsgfTtcbnByb3RvLnB1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc3RhY2sucHVzaCh7dmFsdWU6IHRoaXMudmFsdWUsIGtleTogdGhpcy5rZXksIG1vZGU6IHRoaXMubW9kZX0pO1xufTtcbnByb3RvLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgdmFyIHBhcmVudCA9IHRoaXMuc3RhY2sucG9wKCk7XG4gIHRoaXMudmFsdWUgPSBwYXJlbnQudmFsdWU7XG4gIHRoaXMua2V5ID0gcGFyZW50LmtleTtcbiAgdGhpcy5tb2RlID0gcGFyZW50Lm1vZGU7XG4gIHRoaXMuZW1pdCh2YWx1ZSk7XG4gIGlmICghdGhpcy5tb2RlKSB7IHRoaXMuc3RhdGUgPSBWQUxVRTsgfVxufTtcbnByb3RvLmVtaXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgaWYgKHRoaXMubW9kZSkgeyB0aGlzLnN0YXRlID0gQ09NTUE7IH1cbiAgdGhpcy5vblZhbHVlKHZhbHVlKTtcbn07XG5wcm90by5vblZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIC8vIE92ZXJyaWRlIG1lXG59OyAgXG5wcm90by5vblRva2VuID0gZnVuY3Rpb24gKHRva2VuLCB2YWx1ZSkge1xuICAvL2NvbnNvbGUubG9nKFwiT25Ub2tlbjogc3RhdGU9JXMgdG9rZW49JXMgJXNcIiwgdG9rbmFtKHRoaXMuc3RhdGUpLCB0b2tuYW0odG9rZW4pLCB2YWx1ZT9KU09OLnN0cmluZ2lmeSh2YWx1ZSk6XCJcIik7XG4gIGlmKHRoaXMuc3RhdGUgPT09IFZBTFVFKXtcbiAgICBpZih0b2tlbiA9PT0gU1RSSU5HIHx8IHRva2VuID09PSBOVU1CRVIgfHwgdG9rZW4gPT09IFRSVUUgfHwgdG9rZW4gPT09IEZBTFNFIHx8IHRva2VuID09PSBOVUxMKXtcbiAgICAgIGlmICh0aGlzLnZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWVbdGhpcy5rZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQodmFsdWUpOyAgXG4gICAgfWVsc2UgaWYodG9rZW4gPT09IExFRlRfQlJBQ0Upe1xuICAgICAgdGhpcy5wdXNoKCk7XG4gICAgICBpZiAodGhpcy52YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZVt0aGlzLmtleV0gPSB7fTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB7fTtcbiAgICAgIH1cbiAgICAgIHRoaXMua2V5ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5zdGF0ZSA9IEtFWTtcbiAgICAgIHRoaXMubW9kZSA9IE9CSkVDVDtcbiAgICB9ZWxzZSBpZih0b2tlbiA9PT0gTEVGVF9CUkFDS0VUKXtcbiAgICAgIHRoaXMucHVzaCgpO1xuICAgICAgaWYgKHRoaXMudmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudmFsdWVbdGhpcy5rZXldID0gW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnZhbHVlID0gW107XG4gICAgICB9XG4gICAgICB0aGlzLmtleSA9IDA7XG4gICAgICB0aGlzLm1vZGUgPSBBUlJBWTtcbiAgICAgIHRoaXMuc3RhdGUgPSBWQUxVRTtcbiAgICB9ZWxzZSBpZih0b2tlbiA9PT0gUklHSFRfQlJBQ0Upe1xuICAgICAgaWYgKHRoaXMubW9kZSA9PT0gT0JKRUNUKSB7XG4gICAgICAgIHRoaXMucG9wKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhcnNlRXJyb3IodG9rZW4sIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9ZWxzZSBpZih0b2tlbiA9PT0gUklHSFRfQlJBQ0tFVCl7XG4gICAgICBpZiAodGhpcy5tb2RlID09PSBBUlJBWSkge1xuICAgICAgICB0aGlzLnBvcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXJzZUVycm9yKHRva2VuLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfWVsc2V7XG4gICAgICB0aGlzLnBhcnNlRXJyb3IodG9rZW4sIHZhbHVlKTtcbiAgICB9XG4gIH1lbHNlIGlmKHRoaXMuc3RhdGUgPT09IEtFWSl7XG4gICAgaWYgKHRva2VuID09PSBTVFJJTkcpIHtcbiAgICAgIHRoaXMua2V5ID0gdmFsdWU7XG4gICAgICB0aGlzLnN0YXRlID0gQ09MT047XG4gICAgfSBlbHNlIGlmICh0b2tlbiA9PT0gUklHSFRfQlJBQ0UpIHtcbiAgICAgIHRoaXMucG9wKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFyc2VFcnJvcih0b2tlbiwgdmFsdWUpO1xuICAgIH1cbiAgfWVsc2UgaWYodGhpcy5zdGF0ZSA9PT0gQ09MT04pe1xuICAgIGlmICh0b2tlbiA9PT0gQ09MT04pIHsgdGhpcy5zdGF0ZSA9IFZBTFVFOyB9XG4gICAgZWxzZSB7IHRoaXMucGFyc2VFcnJvcih0b2tlbiwgdmFsdWUpOyB9XG4gIH1lbHNlIGlmKHRoaXMuc3RhdGUgPT09IENPTU1BKXtcbiAgICBpZiAodG9rZW4gPT09IENPTU1BKSB7IFxuICAgICAgaWYgKHRoaXMubW9kZSA9PT0gQVJSQVkpIHsgdGhpcy5rZXkrKzsgdGhpcy5zdGF0ZSA9IFZBTFVFOyB9XG4gICAgICBlbHNlIGlmICh0aGlzLm1vZGUgPT09IE9CSkVDVCkgeyB0aGlzLnN0YXRlID0gS0VZOyB9XG5cbiAgICB9IGVsc2UgaWYgKHRva2VuID09PSBSSUdIVF9CUkFDS0VUICYmIHRoaXMubW9kZSA9PT0gQVJSQVkgfHwgdG9rZW4gPT09IFJJR0hUX0JSQUNFICYmIHRoaXMubW9kZSA9PT0gT0JKRUNUKSB7XG4gICAgICB0aGlzLnBvcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhcnNlRXJyb3IodG9rZW4sIHZhbHVlKTtcbiAgICB9XG4gIH1lbHNle1xuICAgIHRoaXMucGFyc2VFcnJvcih0b2tlbiwgdmFsdWUpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNlcjtcblxufSkuY2FsbCh0aGlzLF9kZXJlcV8oXCJidWZmZXJcIikuQnVmZmVyKVxufSx7XCJidWZmZXJcIjoyM31dLDIwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogU3RhbmRhbG9uZSBleHRyYWN0aW9uIG9mIEJhY2tib25lLkV2ZW50cywgbm8gZXh0ZXJuYWwgZGVwZW5kZW5jeSByZXF1aXJlZC5cbiAqIERlZ3JhZGVzIG5pY2VseSB3aGVuIEJhY2tvbmUvdW5kZXJzY29yZSBhcmUgYWxyZWFkeSBhdmFpbGFibGUgaW4gdGhlIGN1cnJlbnRcbiAqIGdsb2JhbCBjb250ZXh0LlxuICpcbiAqIE5vdGUgdGhhdCBkb2NzIHN1Z2dlc3QgdG8gdXNlIHVuZGVyc2NvcmUncyBgXy5leHRlbmQoKWAgbWV0aG9kIHRvIGFkZCBFdmVudHNcbiAqIHN1cHBvcnQgdG8gc29tZSBnaXZlbiBvYmplY3QuIEEgYG1peGluKClgIG1ldGhvZCBoYXMgYmVlbiBhZGRlZCB0byB0aGUgRXZlbnRzXG4gKiBwcm90b3R5cGUgdG8gYXZvaWQgdXNpbmcgdW5kZXJzY29yZSBmb3IgdGhhdCBzb2xlIHB1cnBvc2U6XG4gKlxuICogICAgIHZhciBteUV2ZW50RW1pdHRlciA9IEJhY2tib25lRXZlbnRzLm1peGluKHt9KTtcbiAqXG4gKiBPciBmb3IgYSBmdW5jdGlvbiBjb25zdHJ1Y3RvcjpcbiAqXG4gKiAgICAgZnVuY3Rpb24gTXlDb25zdHJ1Y3Rvcigpe31cbiAqICAgICBNeUNvbnN0cnVjdG9yLnByb3RvdHlwZS5mb28gPSBmdW5jdGlvbigpe31cbiAqICAgICBCYWNrYm9uZUV2ZW50cy5taXhpbihNeUNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gKlxuICogKGMpIDIwMDktMjAxMyBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgSW5jLlxuICogKGMpIDIwMTMgTmljb2xhcyBQZXJyaWF1bHRcbiAqL1xuLyogZ2xvYmFsIGV4cG9ydHM6dHJ1ZSwgZGVmaW5lLCBtb2R1bGUgKi9cbihmdW5jdGlvbigpIHtcbiAgdmFyIHJvb3QgPSB0aGlzLFxuICAgICAgYnJlYWtlciA9IHt9LFxuICAgICAgbmF0aXZlRm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLFxuICAgICAgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxuICAgICAgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UsXG4gICAgICBpZENvdW50ZXIgPSAwO1xuXG4gIC8vIFJldHVybnMgYSBwYXJ0aWFsIGltcGxlbWVudGF0aW9uIG1hdGNoaW5nIHRoZSBtaW5pbWFsIEFQSSBzdWJzZXQgcmVxdWlyZWRcbiAgLy8gYnkgQmFja2JvbmUuRXZlbnRzXG4gIGZ1bmN0aW9uIG1pbmlzY29yZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2V5czogT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIgfHwgb2JqID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleXMoKSBjYWxsZWQgb24gYSBub24tb2JqZWN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXksIGtleXMgPSBbXTtcbiAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBrZXlzW2tleXMubGVuZ3RoXSA9IGtleTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgICB9LFxuXG4gICAgICB1bmlxdWVJZDogZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgICAgIHZhciBpZCA9ICsraWRDb3VudGVyICsgJyc7XG4gICAgICAgIHJldHVybiBwcmVmaXggPyBwcmVmaXggKyBpZCA6IGlkO1xuICAgICAgfSxcblxuICAgICAgaGFzOiBmdW5jdGlvbihvYmosIGtleSkge1xuICAgICAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG4gICAgICB9LFxuXG4gICAgICBlYWNoOiBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBpZiAobmF0aXZlRm9yRWFjaCAmJiBvYmouZm9yRWFjaCA9PT0gbmF0aXZlRm9yRWFjaCkge1xuICAgICAgICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICAgICAgfSBlbHNlIGlmIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopID09PSBicmVha2VyKSByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhcyhvYmosIGtleSkpIHtcbiAgICAgICAgICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2tleV0sIGtleSwgb2JqKSA9PT0gYnJlYWtlcikgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgb25jZTogZnVuY3Rpb24oZnVuYykge1xuICAgICAgICB2YXIgcmFuID0gZmFsc2UsIG1lbW87XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAocmFuKSByZXR1cm4gbWVtbztcbiAgICAgICAgICByYW4gPSB0cnVlO1xuICAgICAgICAgIG1lbW8gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgZnVuYyA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHZhciBfID0gbWluaXNjb3JlKCksIEV2ZW50cztcblxuICAvLyBCYWNrYm9uZS5FdmVudHNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gQSBtb2R1bGUgdGhhdCBjYW4gYmUgbWl4ZWQgaW4gdG8gKmFueSBvYmplY3QqIGluIG9yZGVyIHRvIHByb3ZpZGUgaXQgd2l0aFxuICAvLyBjdXN0b20gZXZlbnRzLiBZb3UgbWF5IGJpbmQgd2l0aCBgb25gIG9yIHJlbW92ZSB3aXRoIGBvZmZgIGNhbGxiYWNrXG4gIC8vIGZ1bmN0aW9ucyB0byBhbiBldmVudDsgYHRyaWdnZXJgLWluZyBhbiBldmVudCBmaXJlcyBhbGwgY2FsbGJhY2tzIGluXG4gIC8vIHN1Y2Nlc3Npb24uXG4gIC8vXG4gIC8vICAgICB2YXIgb2JqZWN0ID0ge307XG4gIC8vICAgICBfLmV4dGVuZChvYmplY3QsIEJhY2tib25lLkV2ZW50cyk7XG4gIC8vICAgICBvYmplY3Qub24oJ2V4cGFuZCcsIGZ1bmN0aW9uKCl7IGFsZXJ0KCdleHBhbmRlZCcpOyB9KTtcbiAgLy8gICAgIG9iamVjdC50cmlnZ2VyKCdleHBhbmQnKTtcbiAgLy9cbiAgRXZlbnRzID0ge1xuXG4gICAgLy8gQmluZCBhbiBldmVudCB0byBhIGBjYWxsYmFja2AgZnVuY3Rpb24uIFBhc3NpbmcgYFwiYWxsXCJgIHdpbGwgYmluZFxuICAgIC8vIHRoZSBjYWxsYmFjayB0byBhbGwgZXZlbnRzIGZpcmVkLlxuICAgIG9uOiBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgaWYgKCFldmVudHNBcGkodGhpcywgJ29uJywgbmFtZSwgW2NhbGxiYWNrLCBjb250ZXh0XSkgfHwgIWNhbGxiYWNrKSByZXR1cm4gdGhpcztcbiAgICAgIHRoaXMuX2V2ZW50cyB8fCAodGhpcy5fZXZlbnRzID0ge30pO1xuICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50c1tuYW1lXSB8fCAodGhpcy5fZXZlbnRzW25hbWVdID0gW10pO1xuICAgICAgZXZlbnRzLnB1c2goe2NhbGxiYWNrOiBjYWxsYmFjaywgY29udGV4dDogY29udGV4dCwgY3R4OiBjb250ZXh0IHx8IHRoaXN9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBCaW5kIGFuIGV2ZW50IHRvIG9ubHkgYmUgdHJpZ2dlcmVkIGEgc2luZ2xlIHRpbWUuIEFmdGVyIHRoZSBmaXJzdCB0aW1lXG4gICAgLy8gdGhlIGNhbGxiYWNrIGlzIGludm9rZWQsIGl0IHdpbGwgYmUgcmVtb3ZlZC5cbiAgICBvbmNlOiBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgaWYgKCFldmVudHNBcGkodGhpcywgJ29uY2UnLCBuYW1lLCBbY2FsbGJhY2ssIGNvbnRleHRdKSB8fCAhY2FsbGJhY2spIHJldHVybiB0aGlzO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIG9uY2UgPSBfLm9uY2UoZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYub2ZmKG5hbWUsIG9uY2UpO1xuICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG4gICAgICBvbmNlLl9jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgcmV0dXJuIHRoaXMub24obmFtZSwgb25jZSwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSBvbmUgb3IgbWFueSBjYWxsYmFja3MuIElmIGBjb250ZXh0YCBpcyBudWxsLCByZW1vdmVzIGFsbFxuICAgIC8vIGNhbGxiYWNrcyB3aXRoIHRoYXQgZnVuY3Rpb24uIElmIGBjYWxsYmFja2AgaXMgbnVsbCwgcmVtb3ZlcyBhbGxcbiAgICAvLyBjYWxsYmFja3MgZm9yIHRoZSBldmVudC4gSWYgYG5hbWVgIGlzIG51bGwsIHJlbW92ZXMgYWxsIGJvdW5kXG4gICAgLy8gY2FsbGJhY2tzIGZvciBhbGwgZXZlbnRzLlxuICAgIG9mZjogZnVuY3Rpb24obmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgIHZhciByZXRhaW4sIGV2LCBldmVudHMsIG5hbWVzLCBpLCBsLCBqLCBrO1xuICAgICAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIWV2ZW50c0FwaSh0aGlzLCAnb2ZmJywgbmFtZSwgW2NhbGxiYWNrLCBjb250ZXh0XSkpIHJldHVybiB0aGlzO1xuICAgICAgaWYgKCFuYW1lICYmICFjYWxsYmFjayAmJiAhY29udGV4dCkge1xuICAgICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIG5hbWVzID0gbmFtZSA/IFtuYW1lXSA6IF8ua2V5cyh0aGlzLl9ldmVudHMpO1xuICAgICAgZm9yIChpID0gMCwgbCA9IG5hbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgIGlmIChldmVudHMgPSB0aGlzLl9ldmVudHNbbmFtZV0pIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHNbbmFtZV0gPSByZXRhaW4gPSBbXTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sgfHwgY29udGV4dCkge1xuICAgICAgICAgICAgZm9yIChqID0gMCwgayA9IGV2ZW50cy5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgICAgZXYgPSBldmVudHNbal07XG4gICAgICAgICAgICAgIGlmICgoY2FsbGJhY2sgJiYgY2FsbGJhY2sgIT09IGV2LmNhbGxiYWNrICYmIGNhbGxiYWNrICE9PSBldi5jYWxsYmFjay5fY2FsbGJhY2spIHx8XG4gICAgICAgICAgICAgICAgICAoY29udGV4dCAmJiBjb250ZXh0ICE9PSBldi5jb250ZXh0KSkge1xuICAgICAgICAgICAgICAgIHJldGFpbi5wdXNoKGV2KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJldGFpbi5sZW5ndGgpIGRlbGV0ZSB0aGlzLl9ldmVudHNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFRyaWdnZXIgb25lIG9yIG1hbnkgZXZlbnRzLCBmaXJpbmcgYWxsIGJvdW5kIGNhbGxiYWNrcy4gQ2FsbGJhY2tzIGFyZVxuICAgIC8vIHBhc3NlZCB0aGUgc2FtZSBhcmd1bWVudHMgYXMgYHRyaWdnZXJgIGlzLCBhcGFydCBmcm9tIHRoZSBldmVudCBuYW1lXG4gICAgLy8gKHVubGVzcyB5b3UncmUgbGlzdGVuaW5nIG9uIGBcImFsbFwiYCwgd2hpY2ggd2lsbCBjYXVzZSB5b3VyIGNhbGxiYWNrIHRvXG4gICAgLy8gcmVjZWl2ZSB0aGUgdHJ1ZSBuYW1lIG9mIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgYXJndW1lbnQpLlxuICAgIHRyaWdnZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIGlmICghdGhpcy5fZXZlbnRzKSByZXR1cm4gdGhpcztcbiAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgaWYgKCFldmVudHNBcGkodGhpcywgJ3RyaWdnZXInLCBuYW1lLCBhcmdzKSkgcmV0dXJuIHRoaXM7XG4gICAgICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzW25hbWVdO1xuICAgICAgdmFyIGFsbEV2ZW50cyA9IHRoaXMuX2V2ZW50cy5hbGw7XG4gICAgICBpZiAoZXZlbnRzKSB0cmlnZ2VyRXZlbnRzKGV2ZW50cywgYXJncyk7XG4gICAgICBpZiAoYWxsRXZlbnRzKSB0cmlnZ2VyRXZlbnRzKGFsbEV2ZW50cywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBUZWxsIHRoaXMgb2JqZWN0IHRvIHN0b3AgbGlzdGVuaW5nIHRvIGVpdGhlciBzcGVjaWZpYyBldmVudHMgLi4uIG9yXG4gICAgLy8gdG8gZXZlcnkgb2JqZWN0IGl0J3MgY3VycmVudGx5IGxpc3RlbmluZyB0by5cbiAgICBzdG9wTGlzdGVuaW5nOiBmdW5jdGlvbihvYmosIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgICAgaWYgKCFsaXN0ZW5lcnMpIHJldHVybiB0aGlzO1xuICAgICAgdmFyIGRlbGV0ZUxpc3RlbmVyID0gIW5hbWUgJiYgIWNhbGxiYWNrO1xuICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0JykgY2FsbGJhY2sgPSB0aGlzO1xuICAgICAgaWYgKG9iaikgKGxpc3RlbmVycyA9IHt9KVtvYmouX2xpc3RlbmVySWRdID0gb2JqO1xuICAgICAgZm9yICh2YXIgaWQgaW4gbGlzdGVuZXJzKSB7XG4gICAgICAgIGxpc3RlbmVyc1tpZF0ub2ZmKG5hbWUsIGNhbGxiYWNrLCB0aGlzKTtcbiAgICAgICAgaWYgKGRlbGV0ZUxpc3RlbmVyKSBkZWxldGUgdGhpcy5fbGlzdGVuZXJzW2lkXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICB9O1xuXG4gIC8vIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHNwbGl0IGV2ZW50IHN0cmluZ3MuXG4gIHZhciBldmVudFNwbGl0dGVyID0gL1xccysvO1xuXG4gIC8vIEltcGxlbWVudCBmYW5jeSBmZWF0dXJlcyBvZiB0aGUgRXZlbnRzIEFQSSBzdWNoIGFzIG11bHRpcGxlIGV2ZW50XG4gIC8vIG5hbWVzIGBcImNoYW5nZSBibHVyXCJgIGFuZCBqUXVlcnktc3R5bGUgZXZlbnQgbWFwcyBge2NoYW5nZTogYWN0aW9ufWBcbiAgLy8gaW4gdGVybXMgb2YgdGhlIGV4aXN0aW5nIEFQSS5cbiAgdmFyIGV2ZW50c0FwaSA9IGZ1bmN0aW9uKG9iaiwgYWN0aW9uLCBuYW1lLCByZXN0KSB7XG4gICAgaWYgKCFuYW1lKSByZXR1cm4gdHJ1ZTtcblxuICAgIC8vIEhhbmRsZSBldmVudCBtYXBzLlxuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBuYW1lKSB7XG4gICAgICAgIG9ialthY3Rpb25dLmFwcGx5KG9iaiwgW2tleSwgbmFtZVtrZXldXS5jb25jYXQocmVzdCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBzcGFjZSBzZXBhcmF0ZWQgZXZlbnQgbmFtZXMuXG4gICAgaWYgKGV2ZW50U3BsaXR0ZXIudGVzdChuYW1lKSkge1xuICAgICAgdmFyIG5hbWVzID0gbmFtZS5zcGxpdChldmVudFNwbGl0dGVyKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbmFtZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG9ialthY3Rpb25dLmFwcGx5KG9iaiwgW25hbWVzW2ldXS5jb25jYXQocmVzdCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIEEgZGlmZmljdWx0LXRvLWJlbGlldmUsIGJ1dCBvcHRpbWl6ZWQgaW50ZXJuYWwgZGlzcGF0Y2ggZnVuY3Rpb24gZm9yXG4gIC8vIHRyaWdnZXJpbmcgZXZlbnRzLiBUcmllcyB0byBrZWVwIHRoZSB1c3VhbCBjYXNlcyBzcGVlZHkgKG1vc3QgaW50ZXJuYWxcbiAgLy8gQmFja2JvbmUgZXZlbnRzIGhhdmUgMyBhcmd1bWVudHMpLlxuICB2YXIgdHJpZ2dlckV2ZW50cyA9IGZ1bmN0aW9uKGV2ZW50cywgYXJncykge1xuICAgIHZhciBldiwgaSA9IC0xLCBsID0gZXZlbnRzLmxlbmd0aCwgYTEgPSBhcmdzWzBdLCBhMiA9IGFyZ3NbMV0sIGEzID0gYXJnc1syXTtcbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4KTsgcmV0dXJuO1xuICAgICAgY2FzZSAxOiB3aGlsZSAoKytpIDwgbCkgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5jYWxsKGV2LmN0eCwgYTEpOyByZXR1cm47XG4gICAgICBjYXNlIDI6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4LCBhMSwgYTIpOyByZXR1cm47XG4gICAgICBjYXNlIDM6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4LCBhMSwgYTIsIGEzKTsgcmV0dXJuO1xuICAgICAgZGVmYXVsdDogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suYXBwbHkoZXYuY3R4LCBhcmdzKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGxpc3Rlbk1ldGhvZHMgPSB7bGlzdGVuVG86ICdvbicsIGxpc3RlblRvT25jZTogJ29uY2UnfTtcblxuICAvLyBJbnZlcnNpb24tb2YtY29udHJvbCB2ZXJzaW9ucyBvZiBgb25gIGFuZCBgb25jZWAuIFRlbGwgKnRoaXMqIG9iamVjdCB0b1xuICAvLyBsaXN0ZW4gdG8gYW4gZXZlbnQgaW4gYW5vdGhlciBvYmplY3QgLi4uIGtlZXBpbmcgdHJhY2sgb2Ygd2hhdCBpdCdzXG4gIC8vIGxpc3RlbmluZyB0by5cbiAgXy5lYWNoKGxpc3Rlbk1ldGhvZHMsIGZ1bmN0aW9uKGltcGxlbWVudGF0aW9uLCBtZXRob2QpIHtcbiAgICBFdmVudHNbbWV0aG9kXSA9IGZ1bmN0aW9uKG9iaiwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnMgfHwgKHRoaXMuX2xpc3RlbmVycyA9IHt9KTtcbiAgICAgIHZhciBpZCA9IG9iai5fbGlzdGVuZXJJZCB8fCAob2JqLl9saXN0ZW5lcklkID0gXy51bmlxdWVJZCgnbCcpKTtcbiAgICAgIGxpc3RlbmVyc1tpZF0gPSBvYmo7XG4gICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSBjYWxsYmFjayA9IHRoaXM7XG4gICAgICBvYmpbaW1wbGVtZW50YXRpb25dKG5hbWUsIGNhbGxiYWNrLCB0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIEFsaWFzZXMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICBFdmVudHMuYmluZCAgID0gRXZlbnRzLm9uO1xuICBFdmVudHMudW5iaW5kID0gRXZlbnRzLm9mZjtcblxuICAvLyBNaXhpbiB1dGlsaXR5XG4gIEV2ZW50cy5taXhpbiA9IGZ1bmN0aW9uKHByb3RvKSB7XG4gICAgdmFyIGV4cG9ydHMgPSBbJ29uJywgJ29uY2UnLCAnb2ZmJywgJ3RyaWdnZXInLCAnc3RvcExpc3RlbmluZycsICdsaXN0ZW5UbycsXG4gICAgICAgICAgICAgICAgICAgJ2xpc3RlblRvT25jZScsICdiaW5kJywgJ3VuYmluZCddO1xuICAgIF8uZWFjaChleHBvcnRzLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICBwcm90b1tuYW1lXSA9IHRoaXNbbmFtZV07XG4gICAgfSwgdGhpcyk7XG4gICAgcmV0dXJuIHByb3RvO1xuICB9O1xuXG4gIC8vIEV4cG9ydCBFdmVudHMgYXMgQmFja2JvbmVFdmVudHMgZGVwZW5kaW5nIG9uIGN1cnJlbnQgY29udGV4dFxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEV2ZW50cztcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50cztcbiAgICB9XG4gICAgZXhwb3J0cy5CYWNrYm9uZUV2ZW50cyA9IEV2ZW50cztcbiAgfSBlbHNlIHtcbiAgICByb290LkJhY2tib25lRXZlbnRzID0gRXZlbnRzO1xuICB9XG59KSh0aGlzKTtcblxufSx7fV0sMjE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBfZGVyZXFfKCcuL2JhY2tib25lLWV2ZW50cy1zdGFuZGFsb25lJyk7XG5cbn0se1wiLi9iYWNrYm9uZS1ldmVudHMtc3RhbmRhbG9uZVwiOjIwfV0sMjI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4vKiFcbiAqIEBvdmVydmlldyBlczYtcHJvbWlzZSAtIGEgdGlueSBpbXBsZW1lbnRhdGlvbiBvZiBQcm9taXNlcy9BKy5cbiAqIEBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDE0IFllaHVkYSBLYXR6LCBUb20gRGFsZSwgU3RlZmFuIFBlbm5lciBhbmQgY29udHJpYnV0b3JzIChDb252ZXJzaW9uIHRvIEVTNiBBUEkgYnkgSmFrZSBBcmNoaWJhbGQpXG4gKiBAbGljZW5zZSAgIExpY2Vuc2VkIHVuZGVyIE1JVCBsaWNlbnNlXG4gKiAgICAgICAgICAgIFNlZSBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vamFrZWFyY2hpYmFsZC9lczYtcHJvbWlzZS9tYXN0ZXIvTElDRU5TRVxuICogQHZlcnNpb24gICAyLjAuMVxuICovXG5cbihmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGZ1bmN0aW9uICQkdXRpbHMkJG9iamVjdE9yRnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJCR1dGlscyQkaXNGdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJCR1dGlscyQkaXNNYXliZVRoZW5hYmxlKHgpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgJCR1dGlscyQkX2lzQXJyYXk7XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkpIHtcbiAgICAgICQkdXRpbHMkJF9pc0FycmF5ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICQkdXRpbHMkJF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbiAgICB9XG5cbiAgICB2YXIgJCR1dGlscyQkaXNBcnJheSA9ICQkdXRpbHMkJF9pc0FycmF5O1xuICAgIHZhciAkJHV0aWxzJCRub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpOyB9O1xuICAgIGZ1bmN0aW9uICQkdXRpbHMkJEYoKSB7IH1cblxuICAgIHZhciAkJHV0aWxzJCRvX2NyZWF0ZSA9IChPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZWNvbmQgYXJndW1lbnQgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgfVxuICAgICAgJCR1dGlscyQkRi5wcm90b3R5cGUgPSBvO1xuICAgICAgcmV0dXJuIG5ldyAkJHV0aWxzJCRGKCk7XG4gICAgfSk7XG5cbiAgICB2YXIgJCRhc2FwJCRsZW4gPSAwO1xuXG4gICAgdmFyICQkYXNhcCQkZGVmYXVsdCA9IGZ1bmN0aW9uIGFzYXAoY2FsbGJhY2ssIGFyZykge1xuICAgICAgJCRhc2FwJCRxdWV1ZVskJGFzYXAkJGxlbl0gPSBjYWxsYmFjaztcbiAgICAgICQkYXNhcCQkcXVldWVbJCRhc2FwJCRsZW4gKyAxXSA9IGFyZztcbiAgICAgICQkYXNhcCQkbGVuICs9IDI7XG4gICAgICBpZiAoJCRhc2FwJCRsZW4gPT09IDIpIHtcbiAgICAgICAgLy8gSWYgbGVuIGlzIDEsIHRoYXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHNjaGVkdWxlIGFuIGFzeW5jIGZsdXNoLlxuICAgICAgICAvLyBJZiBhZGRpdGlvbmFsIGNhbGxiYWNrcyBhcmUgcXVldWVkIGJlZm9yZSB0aGUgcXVldWUgaXMgZmx1c2hlZCwgdGhleVxuICAgICAgICAvLyB3aWxsIGJlIHByb2Nlc3NlZCBieSB0aGlzIGZsdXNoIHRoYXQgd2UgYXJlIHNjaGVkdWxpbmcuXG4gICAgICAgICQkYXNhcCQkc2NoZWR1bGVGbHVzaCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgJCRhc2FwJCRicm93c2VyR2xvYmFsID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSA/IHdpbmRvdyA6IHt9O1xuICAgIHZhciAkJGFzYXAkJEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyID0gJCRhc2FwJCRicm93c2VyR2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgJCRhc2FwJCRicm93c2VyR2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG5cbiAgICAvLyB0ZXN0IGZvciB3ZWIgd29ya2VyIGJ1dCBub3QgaW4gSUUxMFxuICAgIHZhciAkJGFzYXAkJGlzV29ya2VyID0gdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgdHlwZW9mIGltcG9ydFNjcmlwdHMgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICB0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnO1xuXG4gICAgLy8gbm9kZVxuICAgIGZ1bmN0aW9uICQkYXNhcCQkdXNlTmV4dFRpY2soKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soJCRhc2FwJCRmbHVzaCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uICQkYXNhcCQkdXNlTXV0YXRpb25PYnNlcnZlcigpIHtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHZhciBvYnNlcnZlciA9IG5ldyAkJGFzYXAkJEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKCQkYXNhcCQkZmx1c2gpO1xuICAgICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgICBvYnNlcnZlci5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBub2RlLmRhdGEgPSAoaXRlcmF0aW9ucyA9ICsraXRlcmF0aW9ucyAlIDIpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyB3ZWIgd29ya2VyXG4gICAgZnVuY3Rpb24gJCRhc2FwJCR1c2VNZXNzYWdlQ2hhbm5lbCgpIHtcbiAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9ICQkYXNhcCQkZmx1c2g7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkJGFzYXAkJHVzZVNldFRpbWVvdXQoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHNldFRpbWVvdXQoJCRhc2FwJCRmbHVzaCwgMSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciAkJGFzYXAkJHF1ZXVlID0gbmV3IEFycmF5KDEwMDApO1xuXG4gICAgZnVuY3Rpb24gJCRhc2FwJCRmbHVzaCgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJCRhc2FwJCRsZW47IGkrPTIpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gJCRhc2FwJCRxdWV1ZVtpXTtcbiAgICAgICAgdmFyIGFyZyA9ICQkYXNhcCQkcXVldWVbaSsxXTtcblxuICAgICAgICBjYWxsYmFjayhhcmcpO1xuXG4gICAgICAgICQkYXNhcCQkcXVldWVbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICQkYXNhcCQkcXVldWVbaSsxXSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgJCRhc2FwJCRsZW4gPSAwO1xuICAgIH1cblxuICAgIHZhciAkJGFzYXAkJHNjaGVkdWxlRmx1c2g7XG5cbiAgICAvLyBEZWNpZGUgd2hhdCBhc3luYyBtZXRob2QgdG8gdXNlIHRvIHRyaWdnZXJpbmcgcHJvY2Vzc2luZyBvZiBxdWV1ZWQgY2FsbGJhY2tzOlxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYge30udG9TdHJpbmcuY2FsbChwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nKSB7XG4gICAgICAkJGFzYXAkJHNjaGVkdWxlRmx1c2ggPSAkJGFzYXAkJHVzZU5leHRUaWNrKCk7XG4gICAgfSBlbHNlIGlmICgkJGFzYXAkJEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgICAkJGFzYXAkJHNjaGVkdWxlRmx1c2ggPSAkJGFzYXAkJHVzZU11dGF0aW9uT2JzZXJ2ZXIoKTtcbiAgICB9IGVsc2UgaWYgKCQkYXNhcCQkaXNXb3JrZXIpIHtcbiAgICAgICQkYXNhcCQkc2NoZWR1bGVGbHVzaCA9ICQkYXNhcCQkdXNlTWVzc2FnZUNoYW5uZWwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJCRhc2FwJCRzY2hlZHVsZUZsdXNoID0gJCRhc2FwJCR1c2VTZXRUaW1lb3V0KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJCQkaW50ZXJuYWwkJG5vb3AoKSB7fVxuICAgIHZhciAkJCRpbnRlcm5hbCQkUEVORElORyAgID0gdm9pZCAwO1xuICAgIHZhciAkJCRpbnRlcm5hbCQkRlVMRklMTEVEID0gMTtcbiAgICB2YXIgJCQkaW50ZXJuYWwkJFJFSkVDVEVEICA9IDI7XG4gICAgdmFyICQkJGludGVybmFsJCRHRVRfVEhFTl9FUlJPUiA9IG5ldyAkJCRpbnRlcm5hbCQkRXJyb3JPYmplY3QoKTtcblxuICAgIGZ1bmN0aW9uICQkJGludGVybmFsJCRzZWxmRnVsbGZpbGxtZW50KCkge1xuICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJZb3UgY2Fubm90IHJlc29sdmUgYSBwcm9taXNlIHdpdGggaXRzZWxmXCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uICQkJGludGVybmFsJCRjYW5ub3RSZXR1cm5Pd24oKSB7XG4gICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcignQSBwcm9taXNlcyBjYWxsYmFjayBjYW5ub3QgcmV0dXJuIHRoYXQgc2FtZSBwcm9taXNlLicpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJCQkaW50ZXJuYWwkJGdldFRoZW4ocHJvbWlzZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbjtcbiAgICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgJCQkaW50ZXJuYWwkJEdFVF9USEVOX0VSUk9SLmVycm9yID0gZXJyb3I7XG4gICAgICAgIHJldHVybiAkJCRpbnRlcm5hbCQkR0VUX1RIRU5fRVJST1I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJCQkaW50ZXJuYWwkJHRyeVRoZW4odGhlbiwgdmFsdWUsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uICQkJGludGVybmFsJCRoYW5kbGVGb3JlaWduVGhlbmFibGUocHJvbWlzZSwgdGhlbmFibGUsIHRoZW4pIHtcbiAgICAgICAkJGFzYXAkJGRlZmF1bHQoZnVuY3Rpb24ocHJvbWlzZSkge1xuICAgICAgICB2YXIgc2VhbGVkID0gZmFsc2U7XG4gICAgICAgIHZhciBlcnJvciA9ICQkJGludGVybmFsJCR0cnlUaGVuKHRoZW4sIHRoZW5hYmxlLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIGlmIChzZWFsZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgc2VhbGVkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAodGhlbmFibGUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAkJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICQkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICAgIGlmIChzZWFsZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgc2VhbGVkID0gdHJ1ZTtcblxuICAgICAgICAgICQkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICAgICAgfSwgJ1NldHRsZTogJyArIChwcm9taXNlLl9sYWJlbCB8fCAnIHVua25vd24gcHJvbWlzZScpKTtcblxuICAgICAgICBpZiAoIXNlYWxlZCAmJiBlcnJvcikge1xuICAgICAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICAgICAgJCQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0sIHByb21pc2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uICQkJGludGVybmFsJCRoYW5kbGVPd25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSkge1xuICAgICAgaWYgKHRoZW5hYmxlLl9zdGF0ZSA9PT0gJCQkaW50ZXJuYWwkJEZVTEZJTExFRCkge1xuICAgICAgICAkJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCB0aGVuYWJsZS5fcmVzdWx0KTtcbiAgICAgIH0gZWxzZSBpZiAocHJvbWlzZS5fc3RhdGUgPT09ICQkJGludGVybmFsJCRSRUpFQ1RFRCkge1xuICAgICAgICAkJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHRoZW5hYmxlLl9yZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJCQkaW50ZXJuYWwkJHN1YnNjcmliZSh0aGVuYWJsZSwgdW5kZWZpbmVkLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICQkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgICAgJCQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkJCRpbnRlcm5hbCQkaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlKSB7XG4gICAgICBpZiAobWF5YmVUaGVuYWJsZS5jb25zdHJ1Y3RvciA9PT0gcHJvbWlzZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAkJCRpbnRlcm5hbCQkaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdGhlbiA9ICQkJGludGVybmFsJCRnZXRUaGVuKG1heWJlVGhlbmFibGUpO1xuXG4gICAgICAgIGlmICh0aGVuID09PSAkJCRpbnRlcm5hbCQkR0VUX1RIRU5fRVJST1IpIHtcbiAgICAgICAgICAkJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsICQkJGludGVybmFsJCRHRVRfVEhFTl9FUlJPUi5lcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAodGhlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgJCQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoJCR1dGlscyQkaXNGdW5jdGlvbih0aGVuKSkge1xuICAgICAgICAgICQkJGludGVybmFsJCRoYW5kbGVGb3JlaWduVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSwgdGhlbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJCQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSkge1xuICAgICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgICAgICQkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgJCQkaW50ZXJuYWwkJHNlbGZGdWxsZmlsbG1lbnQoKSk7XG4gICAgICB9IGVsc2UgaWYgKCQkdXRpbHMkJG9iamVjdE9yRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICQkJGludGVybmFsJCRoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICQkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkJCRpbnRlcm5hbCQkcHVibGlzaFJlamVjdGlvbihwcm9taXNlKSB7XG4gICAgICBpZiAocHJvbWlzZS5fb25lcnJvcikge1xuICAgICAgICBwcm9taXNlLl9vbmVycm9yKHByb21pc2UuX3Jlc3VsdCk7XG4gICAgICB9XG5cbiAgICAgICQkJGludGVybmFsJCRwdWJsaXNoKHByb21pc2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uICQkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIHZhbHVlKSB7XG4gICAgICBpZiAocHJvbWlzZS5fc3RhdGUgIT09ICQkJGludGVybmFsJCRQRU5ESU5HKSB7IHJldHVybjsgfVxuXG4gICAgICBwcm9taXNlLl9yZXN1bHQgPSB2YWx1ZTtcbiAgICAgIHByb21pc2UuX3N0YXRlID0gJCQkaW50ZXJuYWwkJEZVTEZJTExFRDtcblxuICAgICAgaWYgKHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJCRhc2FwJCRkZWZhdWx0KCQkJGludGVybmFsJCRwdWJsaXNoLCBwcm9taXNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHJlYXNvbikge1xuICAgICAgaWYgKHByb21pc2UuX3N0YXRlICE9PSAkJCRpbnRlcm5hbCQkUEVORElORykgeyByZXR1cm47IH1cbiAgICAgIHByb21pc2UuX3N0YXRlID0gJCQkaW50ZXJuYWwkJFJFSkVDVEVEO1xuICAgICAgcHJvbWlzZS5fcmVzdWx0ID0gcmVhc29uO1xuXG4gICAgICAkJGFzYXAkJGRlZmF1bHQoJCQkaW50ZXJuYWwkJHB1Ymxpc2hSZWplY3Rpb24sIHByb21pc2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uICQkJGludGVybmFsJCRzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pIHtcbiAgICAgIHZhciBzdWJzY3JpYmVycyA9IHBhcmVudC5fc3Vic2NyaWJlcnM7XG4gICAgICB2YXIgbGVuZ3RoID0gc3Vic2NyaWJlcnMubGVuZ3RoO1xuXG4gICAgICBwYXJlbnQuX29uZXJyb3IgPSBudWxsO1xuXG4gICAgICBzdWJzY3JpYmVyc1tsZW5ndGhdID0gY2hpbGQ7XG4gICAgICBzdWJzY3JpYmVyc1tsZW5ndGggKyAkJCRpbnRlcm5hbCQkRlVMRklMTEVEXSA9IG9uRnVsZmlsbG1lbnQ7XG4gICAgICBzdWJzY3JpYmVyc1tsZW5ndGggKyAkJCRpbnRlcm5hbCQkUkVKRUNURURdICA9IG9uUmVqZWN0aW9uO1xuXG4gICAgICBpZiAobGVuZ3RoID09PSAwICYmIHBhcmVudC5fc3RhdGUpIHtcbiAgICAgICAgJCRhc2FwJCRkZWZhdWx0KCQkJGludGVybmFsJCRwdWJsaXNoLCBwYXJlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uICQkJGludGVybmFsJCRwdWJsaXNoKHByb21pc2UpIHtcbiAgICAgIHZhciBzdWJzY3JpYmVycyA9IHByb21pc2UuX3N1YnNjcmliZXJzO1xuICAgICAgdmFyIHNldHRsZWQgPSBwcm9taXNlLl9zdGF0ZTtcblxuICAgICAgaWYgKHN1YnNjcmliZXJzLmxlbmd0aCA9PT0gMCkgeyByZXR1cm47IH1cblxuICAgICAgdmFyIGNoaWxkLCBjYWxsYmFjaywgZGV0YWlsID0gcHJvbWlzZS5fcmVzdWx0O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnNjcmliZXJzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIGNoaWxkID0gc3Vic2NyaWJlcnNbaV07XG4gICAgICAgIGNhbGxiYWNrID0gc3Vic2NyaWJlcnNbaSArIHNldHRsZWRdO1xuXG4gICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICQkJGludGVybmFsJCRpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBjaGlsZCwgY2FsbGJhY2ssIGRldGFpbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2soZGV0YWlsKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwcm9taXNlLl9zdWJzY3JpYmVycy5sZW5ndGggPSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uICQkJGludGVybmFsJCRFcnJvck9iamVjdCgpIHtcbiAgICAgIHRoaXMuZXJyb3IgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciAkJCRpbnRlcm5hbCQkVFJZX0NBVENIX0VSUk9SID0gbmV3ICQkJGludGVybmFsJCRFcnJvck9iamVjdCgpO1xuXG4gICAgZnVuY3Rpb24gJCQkaW50ZXJuYWwkJHRyeUNhdGNoKGNhbGxiYWNrLCBkZXRhaWwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhkZXRhaWwpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICQkJGludGVybmFsJCRUUllfQ0FUQ0hfRVJST1IuZXJyb3IgPSBlO1xuICAgICAgICByZXR1cm4gJCQkaW50ZXJuYWwkJFRSWV9DQVRDSF9FUlJPUjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkJCRpbnRlcm5hbCQkaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgcHJvbWlzZSwgY2FsbGJhY2ssIGRldGFpbCkge1xuICAgICAgdmFyIGhhc0NhbGxiYWNrID0gJCR1dGlscyQkaXNGdW5jdGlvbihjYWxsYmFjayksXG4gICAgICAgICAgdmFsdWUsIGVycm9yLCBzdWNjZWVkZWQsIGZhaWxlZDtcblxuICAgICAgaWYgKGhhc0NhbGxiYWNrKSB7XG4gICAgICAgIHZhbHVlID0gJCQkaW50ZXJuYWwkJHRyeUNhdGNoKGNhbGxiYWNrLCBkZXRhaWwpO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJCQkaW50ZXJuYWwkJFRSWV9DQVRDSF9FUlJPUikge1xuICAgICAgICAgIGZhaWxlZCA9IHRydWU7XG4gICAgICAgICAgZXJyb3IgPSB2YWx1ZS5lcnJvcjtcbiAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3VjY2VlZGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgICAgICAgICQkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgJCQkaW50ZXJuYWwkJGNhbm5vdFJldHVybk93bigpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBkZXRhaWw7XG4gICAgICAgIHN1Y2NlZWRlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gJCQkaW50ZXJuYWwkJFBFTkRJTkcpIHtcbiAgICAgICAgLy8gbm9vcFxuICAgICAgfSBlbHNlIGlmIChoYXNDYWxsYmFjayAmJiBzdWNjZWVkZWQpIHtcbiAgICAgICAgJCQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChmYWlsZWQpIHtcbiAgICAgICAgJCQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgICB9IGVsc2UgaWYgKHNldHRsZWQgPT09ICQkJGludGVybmFsJCRGVUxGSUxMRUQpIHtcbiAgICAgICAgJCQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChzZXR0bGVkID09PSAkJCRpbnRlcm5hbCQkUkVKRUNURUQpIHtcbiAgICAgICAgJCQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJCQkaW50ZXJuYWwkJGluaXRpYWxpemVQcm9taXNlKHByb21pc2UsIHJlc29sdmVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXNvbHZlcihmdW5jdGlvbiByZXNvbHZlUHJvbWlzZSh2YWx1ZSl7XG4gICAgICAgICAgJCQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICB9LCBmdW5jdGlvbiByZWplY3RQcm9taXNlKHJlYXNvbikge1xuICAgICAgICAgICQkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgJCQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkJCRlbnVtZXJhdG9yJCRtYWtlU2V0dGxlZFJlc3VsdChzdGF0ZSwgcG9zaXRpb24sIHZhbHVlKSB7XG4gICAgICBpZiAoc3RhdGUgPT09ICQkJGludGVybmFsJCRGVUxGSUxMRUQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGF0ZTogJ2Z1bGZpbGxlZCcsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXRlOiAncmVqZWN0ZWQnLFxuICAgICAgICAgIHJlYXNvbjogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkJCRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yKENvbnN0cnVjdG9yLCBpbnB1dCwgYWJvcnRPblJlamVjdCwgbGFiZWwpIHtcbiAgICAgIHRoaXMuX2luc3RhbmNlQ29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcjtcbiAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3RvcigkJCRpbnRlcm5hbCQkbm9vcCwgbGFiZWwpO1xuICAgICAgdGhpcy5fYWJvcnRPblJlamVjdCA9IGFib3J0T25SZWplY3Q7XG5cbiAgICAgIGlmICh0aGlzLl92YWxpZGF0ZUlucHV0KGlucHV0KSkge1xuICAgICAgICB0aGlzLl9pbnB1dCAgICAgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5sZW5ndGggICAgID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICB0aGlzLl9yZW1haW5pbmcgPSBpbnB1dC5sZW5ndGg7XG5cbiAgICAgICAgdGhpcy5faW5pdCgpO1xuXG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICQkJGludGVybmFsJCRmdWxmaWxsKHRoaXMucHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMubGVuZ3RoIHx8IDA7XG4gICAgICAgICAgdGhpcy5fZW51bWVyYXRlKCk7XG4gICAgICAgICAgaWYgKHRoaXMuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICAgICAgJCQkaW50ZXJuYWwkJGZ1bGZpbGwodGhpcy5wcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJCQkaW50ZXJuYWwkJHJlamVjdCh0aGlzLnByb21pc2UsIHRoaXMuX3ZhbGlkYXRpb25FcnJvcigpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAkJCRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yLnByb3RvdHlwZS5fdmFsaWRhdGVJbnB1dCA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICByZXR1cm4gJCR1dGlscyQkaXNBcnJheShpbnB1dCk7XG4gICAgfTtcblxuICAgICQkJGVudW1lcmF0b3IkJEVudW1lcmF0b3IucHJvdG90eXBlLl92YWxpZGF0aW9uRXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0FycmF5IE1ldGhvZHMgbXVzdCBiZSBwcm92aWRlZCBhbiBBcnJheScpO1xuICAgIH07XG5cbiAgICAkJCRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fcmVzdWx0ID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICB9O1xuXG4gICAgdmFyICQkJGVudW1lcmF0b3IkJGRlZmF1bHQgPSAkJCRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yO1xuXG4gICAgJCQkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX2VudW1lcmF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxlbmd0aCAgPSB0aGlzLmxlbmd0aDtcbiAgICAgIHZhciBwcm9taXNlID0gdGhpcy5wcm9taXNlO1xuICAgICAgdmFyIGlucHV0ICAgPSB0aGlzLl9pbnB1dDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IHByb21pc2UuX3N0YXRlID09PSAkJCRpbnRlcm5hbCQkUEVORElORyAmJiBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5fZWFjaEVudHJ5KGlucHV0W2ldLCBpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgJCQkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX2VhY2hFbnRyeSA9IGZ1bmN0aW9uKGVudHJ5LCBpKSB7XG4gICAgICB2YXIgYyA9IHRoaXMuX2luc3RhbmNlQ29uc3RydWN0b3I7XG4gICAgICBpZiAoJCR1dGlscyQkaXNNYXliZVRoZW5hYmxlKGVudHJ5KSkge1xuICAgICAgICBpZiAoZW50cnkuY29uc3RydWN0b3IgPT09IGMgJiYgZW50cnkuX3N0YXRlICE9PSAkJCRpbnRlcm5hbCQkUEVORElORykge1xuICAgICAgICAgIGVudHJ5Ll9vbmVycm9yID0gbnVsbDtcbiAgICAgICAgICB0aGlzLl9zZXR0bGVkQXQoZW50cnkuX3N0YXRlLCBpLCBlbnRyeS5fcmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl93aWxsU2V0dGxlQXQoYy5yZXNvbHZlKGVudHJ5KSwgaSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuICAgICAgICB0aGlzLl9yZXN1bHRbaV0gPSB0aGlzLl9tYWtlUmVzdWx0KCQkJGludGVybmFsJCRGVUxGSUxMRUQsIGksIGVudHJ5KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgJCQkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX3NldHRsZWRBdCA9IGZ1bmN0aW9uKHN0YXRlLCBpLCB2YWx1ZSkge1xuICAgICAgdmFyIHByb21pc2UgPSB0aGlzLnByb21pc2U7XG5cbiAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSA9PT0gJCQkaW50ZXJuYWwkJFBFTkRJTkcpIHtcbiAgICAgICAgdGhpcy5fcmVtYWluaW5nLS07XG5cbiAgICAgICAgaWYgKHRoaXMuX2Fib3J0T25SZWplY3QgJiYgc3RhdGUgPT09ICQkJGludGVybmFsJCRSRUpFQ1RFRCkge1xuICAgICAgICAgICQkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3Jlc3VsdFtpXSA9IHRoaXMuX21ha2VSZXN1bHQoc3RhdGUsIGksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICQkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgICQkJGVudW1lcmF0b3IkJEVudW1lcmF0b3IucHJvdG90eXBlLl9tYWtlUmVzdWx0ID0gZnVuY3Rpb24oc3RhdGUsIGksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcblxuICAgICQkJGVudW1lcmF0b3IkJEVudW1lcmF0b3IucHJvdG90eXBlLl93aWxsU2V0dGxlQXQgPSBmdW5jdGlvbihwcm9taXNlLCBpKSB7XG4gICAgICB2YXIgZW51bWVyYXRvciA9IHRoaXM7XG5cbiAgICAgICQkJGludGVybmFsJCRzdWJzY3JpYmUocHJvbWlzZSwgdW5kZWZpbmVkLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBlbnVtZXJhdG9yLl9zZXR0bGVkQXQoJCQkaW50ZXJuYWwkJEZVTEZJTExFRCwgaSwgdmFsdWUpO1xuICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgIGVudW1lcmF0b3IuX3NldHRsZWRBdCgkJCRpbnRlcm5hbCQkUkVKRUNURUQsIGksIHJlYXNvbik7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyICQkcHJvbWlzZSRhbGwkJGRlZmF1bHQgPSBmdW5jdGlvbiBhbGwoZW50cmllcywgbGFiZWwpIHtcbiAgICAgIHJldHVybiBuZXcgJCQkZW51bWVyYXRvciQkZGVmYXVsdCh0aGlzLCBlbnRyaWVzLCB0cnVlIC8qIGFib3J0IG9uIHJlamVjdCAqLywgbGFiZWwpLnByb21pc2U7XG4gICAgfTtcblxuICAgIHZhciAkJHByb21pc2UkcmFjZSQkZGVmYXVsdCA9IGZ1bmN0aW9uIHJhY2UoZW50cmllcywgbGFiZWwpIHtcbiAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gICAgICB2YXIgcHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3RvcigkJCRpbnRlcm5hbCQkbm9vcCwgbGFiZWwpO1xuXG4gICAgICBpZiAoISQkdXRpbHMkJGlzQXJyYXkoZW50cmllcykpIHtcbiAgICAgICAgJCQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGFuIGFycmF5IHRvIHJhY2UuJykpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbmd0aCA9IGVudHJpZXMubGVuZ3RoO1xuXG4gICAgICBmdW5jdGlvbiBvbkZ1bGZpbGxtZW50KHZhbHVlKSB7XG4gICAgICAgICQkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25SZWplY3Rpb24ocmVhc29uKSB7XG4gICAgICAgICQkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IHByb21pc2UuX3N0YXRlID09PSAkJCRpbnRlcm5hbCQkUEVORElORyAmJiBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgJCQkaW50ZXJuYWwkJHN1YnNjcmliZShDb25zdHJ1Y3Rvci5yZXNvbHZlKGVudHJpZXNbaV0pLCB1bmRlZmluZWQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcblxuICAgIHZhciAkJHByb21pc2UkcmVzb2x2ZSQkZGVmYXVsdCA9IGZ1bmN0aW9uIHJlc29sdmUob2JqZWN0LCBsYWJlbCkge1xuICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgICAgIGlmIChvYmplY3QgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0LmNvbnN0cnVjdG9yID09PSBDb25zdHJ1Y3Rvcikge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3RvcigkJCRpbnRlcm5hbCQkbm9vcCwgbGFiZWwpO1xuICAgICAgJCQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgb2JqZWN0KTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG5cbiAgICB2YXIgJCRwcm9taXNlJHJlamVjdCQkZGVmYXVsdCA9IGZ1bmN0aW9uIHJlamVjdChyZWFzb24sIGxhYmVsKSB7XG4gICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcbiAgICAgIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKCQkJGludGVybmFsJCRub29wLCBsYWJlbCk7XG4gICAgICAkJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuXG4gICAgdmFyICQkZXM2JHByb21pc2UkcHJvbWlzZSQkY291bnRlciA9IDA7XG5cbiAgICBmdW5jdGlvbiAkJGVzNiRwcm9taXNlJHByb21pc2UkJG5lZWRzUmVzb2x2ZXIoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGEgcmVzb2x2ZXIgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBwcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJCRlczYkcHJvbWlzZSRwcm9taXNlJCRuZWVkc05ldygpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdQcm9taXNlJzogUGxlYXNlIHVzZSB0aGUgJ25ldycgb3BlcmF0b3IsIHRoaXMgb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuXG4gICAgdmFyICQkZXM2JHByb21pc2UkcHJvbWlzZSQkZGVmYXVsdCA9ICQkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZTtcblxuICAgIC8qKlxuICAgICAgUHJvbWlzZSBvYmplY3RzIHJlcHJlc2VudCB0aGUgZXZlbnR1YWwgcmVzdWx0IG9mIGFuIGFzeW5jaHJvbm91cyBvcGVyYXRpb24uIFRoZVxuICAgICAgcHJpbWFyeSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCBhIHByb21pc2UgaXMgdGhyb3VnaCBpdHMgYHRoZW5gIG1ldGhvZCwgd2hpY2hcbiAgICAgIHJlZ2lzdGVycyBjYWxsYmFja3MgdG8gcmVjZWl2ZSBlaXRoZXIgYSBwcm9taXNl4oCZcyBldmVudHVhbCB2YWx1ZSBvciB0aGUgcmVhc29uXG4gICAgICB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cblxuICAgICAgVGVybWlub2xvZ3lcbiAgICAgIC0tLS0tLS0tLS0tXG5cbiAgICAgIC0gYHByb21pc2VgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB3aXRoIGEgYHRoZW5gIG1ldGhvZCB3aG9zZSBiZWhhdmlvciBjb25mb3JtcyB0byB0aGlzIHNwZWNpZmljYXRpb24uXG4gICAgICAtIGB0aGVuYWJsZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHRoYXQgZGVmaW5lcyBhIGB0aGVuYCBtZXRob2QuXG4gICAgICAtIGB2YWx1ZWAgaXMgYW55IGxlZ2FsIEphdmFTY3JpcHQgdmFsdWUgKGluY2x1ZGluZyB1bmRlZmluZWQsIGEgdGhlbmFibGUsIG9yIGEgcHJvbWlzZSkuXG4gICAgICAtIGBleGNlcHRpb25gIGlzIGEgdmFsdWUgdGhhdCBpcyB0aHJvd24gdXNpbmcgdGhlIHRocm93IHN0YXRlbWVudC5cbiAgICAgIC0gYHJlYXNvbmAgaXMgYSB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aHkgYSBwcm9taXNlIHdhcyByZWplY3RlZC5cbiAgICAgIC0gYHNldHRsZWRgIHRoZSBmaW5hbCByZXN0aW5nIHN0YXRlIG9mIGEgcHJvbWlzZSwgZnVsZmlsbGVkIG9yIHJlamVjdGVkLlxuXG4gICAgICBBIHByb21pc2UgY2FuIGJlIGluIG9uZSBvZiB0aHJlZSBzdGF0ZXM6IHBlbmRpbmcsIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQuXG5cbiAgICAgIFByb21pc2VzIHRoYXQgYXJlIGZ1bGZpbGxlZCBoYXZlIGEgZnVsZmlsbG1lbnQgdmFsdWUgYW5kIGFyZSBpbiB0aGUgZnVsZmlsbGVkXG4gICAgICBzdGF0ZS4gIFByb21pc2VzIHRoYXQgYXJlIHJlamVjdGVkIGhhdmUgYSByZWplY3Rpb24gcmVhc29uIGFuZCBhcmUgaW4gdGhlXG4gICAgICByZWplY3RlZCBzdGF0ZS4gIEEgZnVsZmlsbG1lbnQgdmFsdWUgaXMgbmV2ZXIgYSB0aGVuYWJsZS5cblxuICAgICAgUHJvbWlzZXMgY2FuIGFsc28gYmUgc2FpZCB0byAqcmVzb2x2ZSogYSB2YWx1ZS4gIElmIHRoaXMgdmFsdWUgaXMgYWxzbyBhXG4gICAgICBwcm9taXNlLCB0aGVuIHRoZSBvcmlnaW5hbCBwcm9taXNlJ3Mgc2V0dGxlZCBzdGF0ZSB3aWxsIG1hdGNoIHRoZSB2YWx1ZSdzXG4gICAgICBzZXR0bGVkIHN0YXRlLiAgU28gYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCByZWplY3RzIHdpbGxcbiAgICAgIGl0c2VsZiByZWplY3QsIGFuZCBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpbGxcbiAgICAgIGl0c2VsZiBmdWxmaWxsLlxuXG5cbiAgICAgIEJhc2ljIFVzYWdlOlxuICAgICAgLS0tLS0tLS0tLS0tXG5cbiAgICAgIGBgYGpzXG4gICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAvLyBvbiBzdWNjZXNzXG4gICAgICAgIHJlc29sdmUodmFsdWUpO1xuXG4gICAgICAgIC8vIG9uIGZhaWx1cmVcbiAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICB9KTtcblxuICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIC8vIG9uIGZ1bGZpbGxtZW50XG4gICAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgLy8gb24gcmVqZWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBBZHZhbmNlZCBVc2FnZTpcbiAgICAgIC0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICBQcm9taXNlcyBzaGluZSB3aGVuIGFic3RyYWN0aW5nIGF3YXkgYXN5bmNocm9ub3VzIGludGVyYWN0aW9ucyBzdWNoIGFzXG4gICAgICBgWE1MSHR0cFJlcXVlc3Rgcy5cblxuICAgICAgYGBganNcbiAgICAgIGZ1bmN0aW9uIGdldEpTT04odXJsKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwpO1xuICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBoYW5kbGVyO1xuICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnanNvbic7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICAgICAgeGhyLnNlbmQoKTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSB0aGlzLkRPTkUpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMucmVzcG9uc2UpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ2dldEpTT046IGAnICsgdXJsICsgJ2AgZmFpbGVkIHdpdGggc3RhdHVzOiBbJyArIHRoaXMuc3RhdHVzICsgJ10nKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZ2V0SlNPTignL3Bvc3RzLmpzb24nKS50aGVuKGZ1bmN0aW9uKGpzb24pIHtcbiAgICAgICAgLy8gb24gZnVsZmlsbG1lbnRcbiAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICAvLyBvbiByZWplY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIFVubGlrZSBjYWxsYmFja3MsIHByb21pc2VzIGFyZSBncmVhdCBjb21wb3NhYmxlIHByaW1pdGl2ZXMuXG5cbiAgICAgIGBgYGpzXG4gICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgIGdldEpTT04oJy9wb3N0cycpLFxuICAgICAgICBnZXRKU09OKCcvY29tbWVudHMnKVxuICAgICAgXSkudGhlbihmdW5jdGlvbih2YWx1ZXMpe1xuICAgICAgICB2YWx1ZXNbMF0gLy8gPT4gcG9zdHNKU09OXG4gICAgICAgIHZhbHVlc1sxXSAvLyA9PiBjb21tZW50c0pTT05cblxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgQGNsYXNzIFByb21pc2VcbiAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IHJlc29sdmVyXG4gICAgICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gICAgICBAY29uc3RydWN0b3JcbiAgICAqL1xuICAgIGZ1bmN0aW9uICQkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZShyZXNvbHZlcikge1xuICAgICAgdGhpcy5faWQgPSAkJGVzNiRwcm9taXNlJHByb21pc2UkJGNvdW50ZXIrKztcbiAgICAgIHRoaXMuX3N0YXRlID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fcmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fc3Vic2NyaWJlcnMgPSBbXTtcblxuICAgICAgaWYgKCQkJGludGVybmFsJCRub29wICE9PSByZXNvbHZlcikge1xuICAgICAgICBpZiAoISQkdXRpbHMkJGlzRnVuY3Rpb24ocmVzb2x2ZXIpKSB7XG4gICAgICAgICAgJCRlczYkcHJvbWlzZSRwcm9taXNlJCRuZWVkc1Jlc29sdmVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgJCRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlKSkge1xuICAgICAgICAgICQkZXM2JHByb21pc2UkcHJvbWlzZSQkbmVlZHNOZXcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgICQkJGludGVybmFsJCRpbml0aWFsaXplUHJvbWlzZSh0aGlzLCByZXNvbHZlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgJCRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLmFsbCA9ICQkcHJvbWlzZSRhbGwkJGRlZmF1bHQ7XG4gICAgJCRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLnJhY2UgPSAkJHByb21pc2UkcmFjZSQkZGVmYXVsdDtcbiAgICAkJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UucmVzb2x2ZSA9ICQkcHJvbWlzZSRyZXNvbHZlJCRkZWZhdWx0O1xuICAgICQkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5yZWplY3QgPSAkJHByb21pc2UkcmVqZWN0JCRkZWZhdWx0O1xuXG4gICAgJCRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLnByb3RvdHlwZSA9IHtcbiAgICAgIGNvbnN0cnVjdG9yOiAkJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UsXG5cbiAgICAvKipcbiAgICAgIFRoZSBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLFxuICAgICAgd2hpY2ggcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGVcbiAgICAgIHJlYXNvbiB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cblxuICAgICAgYGBganNcbiAgICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbih1c2VyKXtcbiAgICAgICAgLy8gdXNlciBpcyBhdmFpbGFibGVcbiAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAgIC8vIHVzZXIgaXMgdW5hdmFpbGFibGUsIGFuZCB5b3UgYXJlIGdpdmVuIHRoZSByZWFzb24gd2h5XG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBDaGFpbmluZ1xuICAgICAgLS0tLS0tLS1cblxuICAgICAgVGhlIHJldHVybiB2YWx1ZSBvZiBgdGhlbmAgaXMgaXRzZWxmIGEgcHJvbWlzZS4gIFRoaXMgc2Vjb25kLCAnZG93bnN0cmVhbSdcbiAgICAgIHByb21pc2UgaXMgcmVzb2x2ZWQgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmaXJzdCBwcm9taXNlJ3MgZnVsZmlsbG1lbnRcbiAgICAgIG9yIHJlamVjdGlvbiBoYW5kbGVyLCBvciByZWplY3RlZCBpZiB0aGUgaGFuZGxlciB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuXG4gICAgICBgYGBqc1xuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHJldHVybiB1c2VyLm5hbWU7XG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIHJldHVybiAnZGVmYXVsdCBuYW1lJztcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHVzZXJOYW1lKSB7XG4gICAgICAgIC8vIElmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgdXNlck5hbWVgIHdpbGwgYmUgdGhlIHVzZXIncyBuYW1lLCBvdGhlcndpc2UgaXRcbiAgICAgICAgLy8gd2lsbCBiZSBgJ2RlZmF1bHQgbmFtZSdgXG4gICAgICB9KTtcblxuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgdXNlciwgYnV0IHN0aWxsIHVuaGFwcHknKTtcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jyk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBuZXZlciByZWFjaGVkXG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIC8vIGlmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgcmVhc29uYCB3aWxsIGJlICdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScuXG4gICAgICAgIC8vIElmIGBmaW5kVXNlcmAgcmVqZWN0ZWQsIGByZWFzb25gIHdpbGwgYmUgJ2BmaW5kVXNlcmAgcmVqZWN0ZWQgYW5kIHdlJ3JlIHVuaGFwcHknLlxuICAgICAgfSk7XG4gICAgICBgYGBcbiAgICAgIElmIHRoZSBkb3duc3RyZWFtIHByb21pc2UgZG9lcyBub3Qgc3BlY2lmeSBhIHJlamVjdGlvbiBoYW5kbGVyLCByZWplY3Rpb24gcmVhc29ucyB3aWxsIGJlIHByb3BhZ2F0ZWQgZnVydGhlciBkb3duc3RyZWFtLlxuXG4gICAgICBgYGBqc1xuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBQZWRhZ29naWNhbEV4Y2VwdGlvbignVXBzdHJlYW0gZXJyb3InKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgLy8gVGhlIGBQZWRnYWdvY2lhbEV4Y2VwdGlvbmAgaXMgcHJvcGFnYXRlZCBhbGwgdGhlIHdheSBkb3duIHRvIGhlcmVcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIEFzc2ltaWxhdGlvblxuICAgICAgLS0tLS0tLS0tLS0tXG5cbiAgICAgIFNvbWV0aW1lcyB0aGUgdmFsdWUgeW91IHdhbnQgdG8gcHJvcGFnYXRlIHRvIGEgZG93bnN0cmVhbSBwcm9taXNlIGNhbiBvbmx5IGJlXG4gICAgICByZXRyaWV2ZWQgYXN5bmNocm9ub3VzbHkuIFRoaXMgY2FuIGJlIGFjaGlldmVkIGJ5IHJldHVybmluZyBhIHByb21pc2UgaW4gdGhlXG4gICAgICBmdWxmaWxsbWVudCBvciByZWplY3Rpb24gaGFuZGxlci4gVGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIHRoZW4gYmUgcGVuZGluZ1xuICAgICAgdW50aWwgdGhlIHJldHVybmVkIHByb21pc2UgaXMgc2V0dGxlZC4gVGhpcyBpcyBjYWxsZWQgKmFzc2ltaWxhdGlvbiouXG5cbiAgICAgIGBgYGpzXG4gICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAgICAgLy8gVGhlIHVzZXIncyBjb21tZW50cyBhcmUgbm93IGF2YWlsYWJsZVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgSWYgdGhlIGFzc2ltbGlhdGVkIHByb21pc2UgcmVqZWN0cywgdGhlbiB0aGUgZG93bnN0cmVhbSBwcm9taXNlIHdpbGwgYWxzbyByZWplY3QuXG5cbiAgICAgIGBgYGpzXG4gICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAgICAgLy8gSWYgYGZpbmRDb21tZW50c0J5QXV0aG9yYCBmdWxmaWxscywgd2UnbGwgaGF2ZSB0aGUgdmFsdWUgaGVyZVxuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIHJlamVjdHMsIHdlJ2xsIGhhdmUgdGhlIHJlYXNvbiBoZXJlXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBTaW1wbGUgRXhhbXBsZVxuICAgICAgLS0tLS0tLS0tLS0tLS1cblxuICAgICAgU3luY2hyb25vdXMgRXhhbXBsZVxuXG4gICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBmaW5kUmVzdWx0KCk7XG4gICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgIC8vIGZhaWx1cmVcbiAgICAgIH1cbiAgICAgIGBgYFxuXG4gICAgICBFcnJiYWNrIEV4YW1wbGVcblxuICAgICAgYGBganNcbiAgICAgIGZpbmRSZXN1bHQoZnVuY3Rpb24ocmVzdWx0LCBlcnIpe1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgUHJvbWlzZSBFeGFtcGxlO1xuXG4gICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICBmaW5kUmVzdWx0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgICAgICAvLyBzdWNjZXNzXG4gICAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgICAgICAvLyBmYWlsdXJlXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBBZHZhbmNlZCBFeGFtcGxlXG4gICAgICAtLS0tLS0tLS0tLS0tLVxuXG4gICAgICBTeW5jaHJvbm91cyBFeGFtcGxlXG5cbiAgICAgIGBgYGphdmFzY3JpcHRcbiAgICAgIHZhciBhdXRob3IsIGJvb2tzO1xuXG4gICAgICB0cnkge1xuICAgICAgICBhdXRob3IgPSBmaW5kQXV0aG9yKCk7XG4gICAgICAgIGJvb2tzICA9IGZpbmRCb29rc0J5QXV0aG9yKGF1dGhvcik7XG4gICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgIC8vIGZhaWx1cmVcbiAgICAgIH1cbiAgICAgIGBgYFxuXG4gICAgICBFcnJiYWNrIEV4YW1wbGVcblxuICAgICAgYGBganNcblxuICAgICAgZnVuY3Rpb24gZm91bmRCb29rcyhib29rcykge1xuXG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGZhaWx1cmUocmVhc29uKSB7XG5cbiAgICAgIH1cblxuICAgICAgZmluZEF1dGhvcihmdW5jdGlvbihhdXRob3IsIGVycil7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmaW5kQm9vb2tzQnlBdXRob3IoYXV0aG9yLCBmdW5jdGlvbihib29rcywgZXJyKSB7XG4gICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGZvdW5kQm9va3MoYm9va3MpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgICBmYWlsdXJlKHJlYXNvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgUHJvbWlzZSBFeGFtcGxlO1xuXG4gICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICBmaW5kQXV0aG9yKCkuXG4gICAgICAgIHRoZW4oZmluZEJvb2tzQnlBdXRob3IpLlxuICAgICAgICB0aGVuKGZ1bmN0aW9uKGJvb2tzKXtcbiAgICAgICAgICAvLyBmb3VuZCBib29rc1xuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIEBtZXRob2QgdGhlblxuICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gb25GdWxmaWxsZWRcbiAgICAgIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0ZWRcbiAgICAgIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgICAgIEByZXR1cm4ge1Byb21pc2V9XG4gICAgKi9cbiAgICAgIHRoZW46IGZ1bmN0aW9uKG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzO1xuICAgICAgICB2YXIgc3RhdGUgPSBwYXJlbnQuX3N0YXRlO1xuXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJCQkaW50ZXJuYWwkJEZVTEZJTExFRCAmJiAhb25GdWxmaWxsbWVudCB8fCBzdGF0ZSA9PT0gJCQkaW50ZXJuYWwkJFJFSkVDVEVEICYmICFvblJlamVjdGlvbikge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoaWxkID0gbmV3IHRoaXMuY29uc3RydWN0b3IoJCQkaW50ZXJuYWwkJG5vb3ApO1xuICAgICAgICB2YXIgcmVzdWx0ID0gcGFyZW50Ll9yZXN1bHQ7XG5cbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzW3N0YXRlIC0gMV07XG4gICAgICAgICAgJCRhc2FwJCRkZWZhdWx0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAkJCRpbnRlcm5hbCQkaW52b2tlQ2FsbGJhY2soc3RhdGUsIGNoaWxkLCBjYWxsYmFjaywgcmVzdWx0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkJCRpbnRlcm5hbCQkc3Vic2NyaWJlKHBhcmVudCwgY2hpbGQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH0sXG5cbiAgICAvKipcbiAgICAgIGBjYXRjaGAgaXMgc2ltcGx5IHN1Z2FyIGZvciBgdGhlbih1bmRlZmluZWQsIG9uUmVqZWN0aW9uKWAgd2hpY2ggbWFrZXMgaXQgdGhlIHNhbWVcbiAgICAgIGFzIHRoZSBjYXRjaCBibG9jayBvZiBhIHRyeS9jYXRjaCBzdGF0ZW1lbnQuXG5cbiAgICAgIGBgYGpzXG4gICAgICBmdW5jdGlvbiBmaW5kQXV0aG9yKCl7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGRuJ3QgZmluZCB0aGF0IGF1dGhvcicpO1xuICAgICAgfVxuXG4gICAgICAvLyBzeW5jaHJvbm91c1xuICAgICAgdHJ5IHtcbiAgICAgICAgZmluZEF1dGhvcigpO1xuICAgICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICAgIH1cblxuICAgICAgLy8gYXN5bmMgd2l0aCBwcm9taXNlc1xuICAgICAgZmluZEF1dGhvcigpLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBAbWV0aG9kIGNhdGNoXG4gICAgICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGlvblxuICAgICAgVXNlZnVsIGZvciB0b29saW5nLlxuICAgICAgQHJldHVybiB7UHJvbWlzZX1cbiAgICAqL1xuICAgICAgJ2NhdGNoJzogZnVuY3Rpb24ob25SZWplY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGlvbik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciAkJGVzNiRwcm9taXNlJHBvbHlmaWxsJCRkZWZhdWx0ID0gZnVuY3Rpb24gcG9seWZpbGwoKSB7XG4gICAgICB2YXIgbG9jYWw7XG5cbiAgICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBsb2NhbCA9IGdsb2JhbDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50KSB7XG4gICAgICAgIGxvY2FsID0gd2luZG93O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9jYWwgPSBzZWxmO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXM2UHJvbWlzZVN1cHBvcnQgPVxuICAgICAgICBcIlByb21pc2VcIiBpbiBsb2NhbCAmJlxuICAgICAgICAvLyBTb21lIG9mIHRoZXNlIG1ldGhvZHMgYXJlIG1pc3NpbmcgZnJvbVxuICAgICAgICAvLyBGaXJlZm94L0Nocm9tZSBleHBlcmltZW50YWwgaW1wbGVtZW50YXRpb25zXG4gICAgICAgIFwicmVzb2x2ZVwiIGluIGxvY2FsLlByb21pc2UgJiZcbiAgICAgICAgXCJyZWplY3RcIiBpbiBsb2NhbC5Qcm9taXNlICYmXG4gICAgICAgIFwiYWxsXCIgaW4gbG9jYWwuUHJvbWlzZSAmJlxuICAgICAgICBcInJhY2VcIiBpbiBsb2NhbC5Qcm9taXNlICYmXG4gICAgICAgIC8vIE9sZGVyIHZlcnNpb24gb2YgdGhlIHNwZWMgaGFkIGEgcmVzb2x2ZXIgb2JqZWN0XG4gICAgICAgIC8vIGFzIHRoZSBhcmcgcmF0aGVyIHRoYW4gYSBmdW5jdGlvblxuICAgICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHJlc29sdmU7XG4gICAgICAgICAgbmV3IGxvY2FsLlByb21pc2UoZnVuY3Rpb24ocikgeyByZXNvbHZlID0gcjsgfSk7XG4gICAgICAgICAgcmV0dXJuICQkdXRpbHMkJGlzRnVuY3Rpb24ocmVzb2x2ZSk7XG4gICAgICAgIH0oKSk7XG5cbiAgICAgIGlmICghZXM2UHJvbWlzZVN1cHBvcnQpIHtcbiAgICAgICAgbG9jYWwuUHJvbWlzZSA9ICQkZXM2JHByb21pc2UkcHJvbWlzZSQkZGVmYXVsdDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGVzNiRwcm9taXNlJHVtZCQkRVM2UHJvbWlzZSA9IHtcbiAgICAgICdQcm9taXNlJzogJCRlczYkcHJvbWlzZSRwcm9taXNlJCRkZWZhdWx0LFxuICAgICAgJ3BvbHlmaWxsJzogJCRlczYkcHJvbWlzZSRwb2x5ZmlsbCQkZGVmYXVsdFxuICAgIH07XG5cbiAgICAvKiBnbG9iYWwgZGVmaW5lOnRydWUgbW9kdWxlOnRydWUgd2luZG93OiB0cnVlICovXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lWydhbWQnXSkge1xuICAgICAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gZXM2JHByb21pc2UkdW1kJCRFUzZQcm9taXNlOyB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZVsnZXhwb3J0cyddKSB7XG4gICAgICBtb2R1bGVbJ2V4cG9ydHMnXSA9IGVzNiRwcm9taXNlJHVtZCQkRVM2UHJvbWlzZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpc1snRVM2UHJvbWlzZSddID0gZXM2JHByb21pc2UkdW1kJCRFUzZQcm9taXNlO1xuICAgIH1cbn0pLmNhbGwodGhpcyk7XG59KS5jYWxsKHRoaXMsX2RlcmVxXyhcIi9ob21lL2FsZXgvcHJvamVjdHMvamF2YXNjcmlwdC9pbWpzL25vZGVfbW9kdWxlcy9pbnNlcnQtbW9kdWxlLWdsb2JhbHMvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1wiKSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7XCIvaG9tZS9hbGV4L3Byb2plY3RzL2phdmFzY3JpcHQvaW1qcy9ub2RlX21vZHVsZXMvaW5zZXJ0LW1vZHVsZS1nbG9iYWxzL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcIjo1NX1dLDIzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxudmFyIGJhc2U2NCA9IF9kZXJlcV8oJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IF9kZXJlcV8oJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSBfZGVyZXFfKCdpcy1hcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbnZhciBrTWF4TGVuZ3RoID0gMHgzZmZmZmZmZlxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqIC0gSW1wbGVtZW50YXRpb24gbXVzdCBzdXBwb3J0IGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLlxuICogICBGaXJlZm94IDQtMjkgbGFja2VkIHN1cHBvcnQsIGZpeGVkIGluIEZpcmVmb3ggMzArLlxuICogICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuICpcbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5IHdpbGxcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IHdpbGwgd29yayBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYnVmID0gbmV3IEFycmF5QnVmZmVyKDApXG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KGJ1ZilcbiAgICBhcnIuZm9vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfVxuICAgIHJldHVybiA0MiA9PT0gYXJyLmZvbygpICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIG5ldyBVaW50OEFycmF5KDEpLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59KSgpXG5cbi8qKlxuICogQ2xhc3M6IEJ1ZmZlclxuICogPT09PT09PT09PT09PVxuICpcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgYXJlIGF1Z21lbnRlZFxuICogd2l0aCBmdW5jdGlvbiBwcm9wZXJ0aWVzIGZvciBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgQVBJIGZ1bmN0aW9ucy4gV2UgdXNlXG4gKiBgVWludDhBcnJheWAgc28gdGhhdCBzcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdCByZXR1cm5zXG4gKiBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBCeSBhdWdtZW50aW5nIHRoZSBpbnN0YW5jZXMsIHdlIGNhbiBhdm9pZCBtb2RpZnlpbmcgdGhlIGBVaW50OEFycmF5YFxuICogcHJvdG90eXBlLlxuICovXG5mdW5jdGlvbiBCdWZmZXIgKHN1YmplY3QsIGVuY29kaW5nLCBub1plcm8pIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpXG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybylcblxuICB2YXIgdHlwZSA9IHR5cGVvZiBzdWJqZWN0XG5cbiAgLy8gRmluZCB0aGUgbGVuZ3RoXG4gIHZhciBsZW5ndGhcbiAgaWYgKHR5cGUgPT09ICdudW1iZXInKVxuICAgIGxlbmd0aCA9IHN1YmplY3QgPiAwID8gc3ViamVjdCA+Pj4gMCA6IDBcbiAgZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoZW5jb2RpbmcgPT09ICdiYXNlNjQnKVxuICAgICAgc3ViamVjdCA9IGJhc2U2NGNsZWFuKHN1YmplY3QpXG4gICAgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3ViamVjdCwgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcgJiYgc3ViamVjdCAhPT0gbnVsbCkgeyAvLyBhc3N1bWUgb2JqZWN0IGlzIGFycmF5LWxpa2VcbiAgICBpZiAoc3ViamVjdC50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KHN1YmplY3QuZGF0YSkpXG4gICAgICBzdWJqZWN0ID0gc3ViamVjdC5kYXRhXG4gICAgbGVuZ3RoID0gK3N1YmplY3QubGVuZ3RoID4gMCA/IE1hdGguZmxvb3IoK3N1YmplY3QubGVuZ3RoKSA6IDBcbiAgfSBlbHNlXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbXVzdCBzdGFydCB3aXRoIG51bWJlciwgYnVmZmVyLCBhcnJheSBvciBzdHJpbmcnKVxuXG4gIGlmICh0aGlzLmxlbmd0aCA+IGtNYXhMZW5ndGgpXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcblxuICB2YXIgYnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFByZWZlcnJlZDogUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICBidWYgPSBCdWZmZXIuX2F1Z21lbnQobmV3IFVpbnQ4QXJyYXkobGVuZ3RoKSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIFRISVMgaW5zdGFuY2Ugb2YgQnVmZmVyIChjcmVhdGVkIGJ5IGBuZXdgKVxuICAgIGJ1ZiA9IHRoaXNcbiAgICBidWYubGVuZ3RoID0gbGVuZ3RoXG4gICAgYnVmLl9pc0J1ZmZlciA9IHRydWVcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2Ygc3ViamVjdC5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJykge1xuICAgIC8vIFNwZWVkIG9wdGltaXphdGlvbiAtLSB1c2Ugc2V0IGlmIHdlJ3JlIGNvcHlpbmcgZnJvbSBhIHR5cGVkIGFycmF5XG4gICAgYnVmLl9zZXQoc3ViamVjdClcbiAgfSBlbHNlIGlmIChpc0FycmF5aXNoKHN1YmplY3QpKSB7XG4gICAgLy8gVHJlYXQgYXJyYXktaXNoIG9iamVjdHMgYXMgYSBieXRlIGFycmF5XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuICAgICAgICBidWZbaV0gPSBzdWJqZWN0LnJlYWRVSW50OChpKVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgICAgIGJ1ZltpXSA9ICgoc3ViamVjdFtpXSAlIDI1NikgKyAyNTYpICUgMjU2XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgYnVmLndyaXRlKHN1YmplY3QsIDAsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhbm9aZXJvKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBidWZbaV0gPSAwXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbiAmJiBhW2ldID09PSBiW2ldOyBpKyspIHt9XG4gIGlmIChpICE9PSBsZW4pIHtcbiAgICB4ID0gYVtpXVxuICAgIHkgPSBiW2ldXG4gIH1cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAncmF3JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VzYWdlOiBCdWZmZXIuY29uY2F0KGxpc3RbLCBsZW5ndGhdKScpXG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoMClcbiAgfSBlbHNlIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBsaXN0WzBdXG4gIH1cblxuICB2YXIgaVxuICBpZiAodG90YWxMZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIHRvdGFsTGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0b3RhbExlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHRvdGFsTGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXVxuICAgIGl0ZW0uY29weShidWYsIHBvcylcbiAgICBwb3MgKz0gaXRlbS5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gZnVuY3Rpb24gKHN0ciwgZW5jb2RpbmcpIHtcbiAgdmFyIHJldFxuICBzdHIgPSBzdHIgKyAnJ1xuICBzd2l0Y2ggKGVuY29kaW5nIHx8ICd1dGY4Jykge1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoICogMlxuICAgICAgYnJlYWtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aCA+Pj4gMVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB1dGY4VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gYmFzZTY0VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aFxuICB9XG4gIHJldHVybiByZXRcbn1cblxuLy8gcHJlLXNldCBmb3IgdmFsdWVzIHRoYXQgbWF5IGV4aXN0IGluIHRoZSBmdXR1cmVcbkJ1ZmZlci5wcm90b3R5cGUubGVuZ3RoID0gdW5kZWZpbmVkXG5CdWZmZXIucHJvdG90eXBlLnBhcmVudCA9IHVuZGVmaW5lZFxuXG4vLyB0b1N0cmluZyhlbmNvZGluZywgc3RhcnQ9MCwgZW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPT09IEluZmluaXR5ID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAoZW5kIDw9IHN0YXJ0KSByZXR1cm4gJydcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBiaW5hcnlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChiKSB7XG4gIGlmKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KVxuICAgICAgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKVxufVxuXG4vLyBgZ2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuZ2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy5yZWFkVUludDgob2Zmc2V0KVxufVxuXG4vLyBgc2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodiwgb2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuc2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy53cml0ZVVJbnQ4KHYsIG9mZnNldClcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYnl0ZSA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4oYnl0ZSkpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBieXRlXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gYmluYXJ5V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgsIDIpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBTdXBwb3J0IGJvdGggKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKVxuICAvLyBhbmQgdGhlIGxlZ2FjeSAoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpXG4gIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgaWYgKCFpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2UgeyAgLy8gbGVnYWN5XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZ1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgb2Zmc2V0ID0gbGVuZ3RoXG4gICAgbGVuZ3RoID0gc3dhcFxuICB9XG5cbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKClcblxuICB2YXIgcmV0XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldCA9IGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldCA9IGJpbmFyeVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gdXRmMTZsZVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJlcyA9ICcnXG4gIHZhciB0bXAgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZiAoYnVmW2ldIDw9IDB4N0YpIHtcbiAgICAgIHJlcyArPSBkZWNvZGVVdGY4Q2hhcih0bXApICsgU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gICAgICB0bXAgPSAnJ1xuICAgIH0gZWxzZSB7XG4gICAgICB0bXAgKz0gJyUnICsgYnVmW2ldLnRvU3RyaW5nKDE2KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXMgKyBkZWNvZGVVdGY4Q2hhcih0bXApXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gYmluYXJ5U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICByZXR1cm4gYXNjaWlTbGljZShidWYsIHN0YXJ0LCBlbmQpXG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlbjtcbiAgICBpZiAoc3RhcnQgPCAwKVxuICAgICAgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApXG4gICAgICBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpXG4gICAgZW5kID0gc3RhcnRcblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICByZXR1cm4gQnVmZmVyLl9hdWdtZW50KHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCkpXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICB2YXIgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkLCB0cnVlKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47IGkrKykge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICAgIHJldHVybiBuZXdCdWZcbiAgfVxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMClcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aClcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKVxuICAgIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYnVmZmVyIG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbHVlIGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWVcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWVcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9IHZhbHVlXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWx1ZSBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKHRhcmdldCwgdGFyZ2V0X3N0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzXG5cbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKCF0YXJnZXRfc3RhcnQpIHRhcmdldF9zdGFydCA9IDBcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCBzb3VyY2UubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IFR5cGVFcnJvcignc291cmNlRW5kIDwgc291cmNlU3RhcnQnKVxuICBpZiAodGFyZ2V0X3N0YXJ0IDwgMCB8fCB0YXJnZXRfc3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSBzb3VyY2UubGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gc291cmNlLmxlbmd0aCkgdGhyb3cgbmV3IFR5cGVFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aClcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCA8IGVuZCAtIHN0YXJ0KVxuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgKyBzdGFydFxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0X3N0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuX3NldCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksIHRhcmdldF9zdGFydClcbiAgfVxufVxuXG4vLyBmaWxsKHZhbHVlLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uICh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXZhbHVlKSB2YWx1ZSA9IDBcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kKSBlbmQgPSB0aGlzLmxlbmd0aFxuXG4gIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5kIDwgc3RhcnQnKVxuXG4gIC8vIEZpbGwgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFR5cGVFcnJvcignc3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gdmFsdWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gdXRmOFRvQnl0ZXModmFsdWUudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGBBcnJheUJ1ZmZlcmAgd2l0aCB0aGUgKmNvcGllZCogbWVtb3J5IG9mIHRoZSBidWZmZXIgaW5zdGFuY2UuXG4gKiBBZGRlZCBpbiBOb2RlIDAuMTIuIE9ubHkgYXZhaWxhYmxlIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBBcnJheUJ1ZmZlci5cbiAqL1xuQnVmZmVyLnByb3RvdHlwZS50b0FycmF5QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgICByZXR1cm4gKG5ldyBCdWZmZXIodGhpcykpLmJ1ZmZlclxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgpXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGJ1ZltpXSA9IHRoaXNbaV1cbiAgICAgIH1cbiAgICAgIHJldHVybiBidWYuYnVmZmVyXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0J1ZmZlci50b0FycmF5QnVmZmVyIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJylcbiAgfVxufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBCUCA9IEJ1ZmZlci5wcm90b3R5cGVcblxuLyoqXG4gKiBBdWdtZW50IGEgVWludDhBcnJheSAqaW5zdGFuY2UqIChub3QgdGhlIFVpbnQ4QXJyYXkgY2xhc3MhKSB3aXRoIEJ1ZmZlciBtZXRob2RzXG4gKi9cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLmNvbnN0cnVjdG9yID0gQnVmZmVyXG4gIGFyci5faXNCdWZmZXIgPSB0cnVlXG5cbiAgLy8gc2F2ZSByZWZlcmVuY2UgdG8gb3JpZ2luYWwgVWludDhBcnJheSBnZXQvc2V0IG1ldGhvZHMgYmVmb3JlIG92ZXJ3cml0aW5nXG4gIGFyci5fZ2V0ID0gYXJyLmdldFxuICBhcnIuX3NldCA9IGFyci5zZXRcblxuICAvLyBkZXByZWNhdGVkLCB3aWxsIGJlIHJlbW92ZWQgaW4gbm9kZSAwLjEzK1xuICBhcnIuZ2V0ID0gQlAuZ2V0XG4gIGFyci5zZXQgPSBCUC5zZXRcblxuICBhcnIud3JpdGUgPSBCUC53cml0ZVxuICBhcnIudG9TdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9Mb2NhbGVTdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9KU09OID0gQlAudG9KU09OXG4gIGFyci5lcXVhbHMgPSBCUC5lcXVhbHNcbiAgYXJyLmNvbXBhcmUgPSBCUC5jb21wYXJlXG4gIGFyci5jb3B5ID0gQlAuY29weVxuICBhcnIuc2xpY2UgPSBCUC5zbGljZVxuICBhcnIucmVhZFVJbnQ4ID0gQlAucmVhZFVJbnQ4XG4gIGFyci5yZWFkVUludDE2TEUgPSBCUC5yZWFkVUludDE2TEVcbiAgYXJyLnJlYWRVSW50MTZCRSA9IEJQLnJlYWRVSW50MTZCRVxuICBhcnIucmVhZFVJbnQzMkxFID0gQlAucmVhZFVJbnQzMkxFXG4gIGFyci5yZWFkVUludDMyQkUgPSBCUC5yZWFkVUludDMyQkVcbiAgYXJyLnJlYWRJbnQ4ID0gQlAucmVhZEludDhcbiAgYXJyLnJlYWRJbnQxNkxFID0gQlAucmVhZEludDE2TEVcbiAgYXJyLnJlYWRJbnQxNkJFID0gQlAucmVhZEludDE2QkVcbiAgYXJyLnJlYWRJbnQzMkxFID0gQlAucmVhZEludDMyTEVcbiAgYXJyLnJlYWRJbnQzMkJFID0gQlAucmVhZEludDMyQkVcbiAgYXJyLnJlYWRGbG9hdExFID0gQlAucmVhZEZsb2F0TEVcbiAgYXJyLnJlYWRGbG9hdEJFID0gQlAucmVhZEZsb2F0QkVcbiAgYXJyLnJlYWREb3VibGVMRSA9IEJQLnJlYWREb3VibGVMRVxuICBhcnIucmVhZERvdWJsZUJFID0gQlAucmVhZERvdWJsZUJFXG4gIGFyci53cml0ZVVJbnQ4ID0gQlAud3JpdGVVSW50OFxuICBhcnIud3JpdGVVSW50MTZMRSA9IEJQLndyaXRlVUludDE2TEVcbiAgYXJyLndyaXRlVUludDE2QkUgPSBCUC53cml0ZVVJbnQxNkJFXG4gIGFyci53cml0ZVVJbnQzMkxFID0gQlAud3JpdGVVSW50MzJMRVxuICBhcnIud3JpdGVVSW50MzJCRSA9IEJQLndyaXRlVUludDMyQkVcbiAgYXJyLndyaXRlSW50OCA9IEJQLndyaXRlSW50OFxuICBhcnIud3JpdGVJbnQxNkxFID0gQlAud3JpdGVJbnQxNkxFXG4gIGFyci53cml0ZUludDE2QkUgPSBCUC53cml0ZUludDE2QkVcbiAgYXJyLndyaXRlSW50MzJMRSA9IEJQLndyaXRlSW50MzJMRVxuICBhcnIud3JpdGVJbnQzMkJFID0gQlAud3JpdGVJbnQzMkJFXG4gIGFyci53cml0ZUZsb2F0TEUgPSBCUC53cml0ZUZsb2F0TEVcbiAgYXJyLndyaXRlRmxvYXRCRSA9IEJQLndyaXRlRmxvYXRCRVxuICBhcnIud3JpdGVEb3VibGVMRSA9IEJQLndyaXRlRG91YmxlTEVcbiAgYXJyLndyaXRlRG91YmxlQkUgPSBCUC53cml0ZURvdWJsZUJFXG4gIGFyci5maWxsID0gQlAuZmlsbFxuICBhcnIuaW5zcGVjdCA9IEJQLmluc3BlY3RcbiAgYXJyLnRvQXJyYXlCdWZmZXIgPSBCUC50b0FycmF5QnVmZmVyXG5cbiAgcmV0dXJuIGFyclxufVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS16XS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gaXNBcnJheWlzaCAoc3ViamVjdCkge1xuICByZXR1cm4gaXNBcnJheShzdWJqZWN0KSB8fCBCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkgfHxcbiAgICAgIHN1YmplY3QgJiYgdHlwZW9mIHN1YmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICB0eXBlb2Ygc3ViamVjdC5sZW5ndGggPT09ICdudW1iZXInXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYiA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaWYgKGIgPD0gMHg3Rikge1xuICAgICAgYnl0ZUFycmF5LnB1c2goYilcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YXJ0ID0gaVxuICAgICAgaWYgKGIgPj0gMHhEODAwICYmIGIgPD0gMHhERkZGKSBpKytcbiAgICAgIHZhciBoID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0ci5zbGljZShzdGFydCwgaSsxKSkuc3Vic3RyKDEpLnNwbGl0KCclJylcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaC5sZW5ndGg7IGorKykge1xuICAgICAgICBieXRlQXJyYXkucHVzaChwYXJzZUludChoW2pdLCAxNikpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KHN0cilcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoLCB1bml0U2l6ZSkge1xuICBpZiAodW5pdFNpemUpIGxlbmd0aCAtPSBsZW5ndGggJSB1bml0U2l6ZTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSlcbiAgICAgIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gZGVjb2RlVXRmOENoYXIgKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgweEZGRkQpIC8vIFVURiA4IGludmFsaWQgY2hhclxuICB9XG59XG5cbn0se1wiYmFzZTY0LWpzXCI6MjQsXCJpZWVlNzU0XCI6MjUsXCJpcy1hcnJheVwiOjI2fV0sMjQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIGxvb2t1cCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcblxuOyhmdW5jdGlvbiAoZXhwb3J0cykge1xuXHQndXNlIHN0cmljdCc7XG5cbiAgdmFyIEFyciA9ICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgPyBVaW50OEFycmF5XG4gICAgOiBBcnJheVxuXG5cdHZhciBQTFVTICAgPSAnKycuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0ggID0gJy8nLmNoYXJDb2RlQXQoMClcblx0dmFyIE5VTUJFUiA9ICcwJy5jaGFyQ29kZUF0KDApXG5cdHZhciBMT1dFUiAgPSAnYScuY2hhckNvZGVBdCgwKVxuXHR2YXIgVVBQRVIgID0gJ0EnLmNoYXJDb2RlQXQoMClcblxuXHRmdW5jdGlvbiBkZWNvZGUgKGVsdCkge1xuXHRcdHZhciBjb2RlID0gZWx0LmNoYXJDb2RlQXQoMClcblx0XHRpZiAoY29kZSA9PT0gUExVUylcblx0XHRcdHJldHVybiA2MiAvLyAnKydcblx0XHRpZiAoY29kZSA9PT0gU0xBU0gpXG5cdFx0XHRyZXR1cm4gNjMgLy8gJy8nXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIpXG5cdFx0XHRyZXR1cm4gLTEgLy9ubyBtYXRjaFxuXHRcdGlmIChjb2RlIDwgTlVNQkVSICsgMTApXG5cdFx0XHRyZXR1cm4gY29kZSAtIE5VTUJFUiArIDI2ICsgMjZcblx0XHRpZiAoY29kZSA8IFVQUEVSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIFVQUEVSXG5cdFx0aWYgKGNvZGUgPCBMT1dFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBMT1dFUiArIDI2XG5cdH1cblxuXHRmdW5jdGlvbiBiNjRUb0J5dGVBcnJheSAoYjY0KSB7XG5cdFx0dmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcblxuXHRcdGlmIChiNjQubGVuZ3RoICUgNCA+IDApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG5cdFx0fVxuXG5cdFx0Ly8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcblx0XHQvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG5cdFx0Ly8gcmVwcmVzZW50IG9uZSBieXRlXG5cdFx0Ly8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG5cdFx0Ly8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXHRcdHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cdFx0cGxhY2VIb2xkZXJzID0gJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDIpID8gMiA6ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAxKSA/IDEgOiAwXG5cblx0XHQvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcblx0XHRhcnIgPSBuZXcgQXJyKGI2NC5sZW5ndGggKiAzIC8gNCAtIHBsYWNlSG9sZGVycylcblxuXHRcdC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcblx0XHRsID0gcGxhY2VIb2xkZXJzID4gMCA/IGI2NC5sZW5ndGggLSA0IDogYjY0Lmxlbmd0aFxuXG5cdFx0dmFyIEwgPSAwXG5cblx0XHRmdW5jdGlvbiBwdXNoICh2KSB7XG5cdFx0XHRhcnJbTCsrXSA9IHZcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDE4KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDEyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpIDw8IDYpIHwgZGVjb2RlKGI2NC5jaGFyQXQoaSArIDMpKVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwMDApID4+IDE2KVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwKSA+PiA4KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA+PiA0KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDEwKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDQpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPj4gMilcblx0XHRcdHB1c2goKHRtcCA+PiA4KSAmIDB4RkYpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFyclxuXHR9XG5cblx0ZnVuY3Rpb24gdWludDhUb0Jhc2U2NCAodWludDgpIHtcblx0XHR2YXIgaSxcblx0XHRcdGV4dHJhQnl0ZXMgPSB1aW50OC5sZW5ndGggJSAzLCAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuXHRcdFx0b3V0cHV0ID0gXCJcIixcblx0XHRcdHRlbXAsIGxlbmd0aFxuXG5cdFx0ZnVuY3Rpb24gZW5jb2RlIChudW0pIHtcblx0XHRcdHJldHVybiBsb29rdXAuY2hhckF0KG51bSlcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuXHRcdFx0cmV0dXJuIGVuY29kZShudW0gPj4gMTggJiAweDNGKSArIGVuY29kZShudW0gPj4gMTIgJiAweDNGKSArIGVuY29kZShudW0gPj4gNiAmIDB4M0YpICsgZW5jb2RlKG51bSAmIDB4M0YpXG5cdFx0fVxuXG5cdFx0Ly8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuXHRcdGZvciAoaSA9IDAsIGxlbmd0aCA9IHVpbnQ4Lmxlbmd0aCAtIGV4dHJhQnl0ZXM7IGkgPCBsZW5ndGg7IGkgKz0gMykge1xuXHRcdFx0dGVtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcblx0XHRcdG91dHB1dCArPSB0cmlwbGV0VG9CYXNlNjQodGVtcClcblx0XHR9XG5cblx0XHQvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG5cdFx0c3dpdGNoIChleHRyYUJ5dGVzKSB7XG5cdFx0XHRjYXNlIDE6XG5cdFx0XHRcdHRlbXAgPSB1aW50OFt1aW50OC5sZW5ndGggLSAxXVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPT0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdHRlbXAgPSAodWludDhbdWludDgubGVuZ3RoIC0gMl0gPDwgOCkgKyAodWludDhbdWludDgubGVuZ3RoIC0gMV0pXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAxMClcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA+PiA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgMikgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dFxuXHR9XG5cblx0ZXhwb3J0cy50b0J5dGVBcnJheSA9IGI2NFRvQnl0ZUFycmF5XG5cdGV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IHVpbnQ4VG9CYXNlNjRcbn0odHlwZW9mIGV4cG9ydHMgPT09ICd1bmRlZmluZWQnID8gKHRoaXMuYmFzZTY0anMgPSB7fSkgOiBleHBvcnRzKSlcblxufSx7fV0sMjU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24oYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBuQml0cyA9IC03LFxuICAgICAgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwLFxuICAgICAgZCA9IGlzTEUgPyAtMSA6IDEsXG4gICAgICBzID0gYnVmZmVyW29mZnNldCArIGldO1xuXG4gIGkgKz0gZDtcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgcyA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IGVMZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpO1xuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBlID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSk7XG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pO1xufTtcblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKSxcbiAgICAgIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKSxcbiAgICAgIGQgPSBpc0xFID8gMSA6IC0xLFxuICAgICAgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMDtcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKTtcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMDtcbiAgICBlID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMik7XG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrKztcbiAgICAgIGMgLz0gMjtcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwO1xuICAgICAgZSA9IGVNYXg7XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IDA7XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCk7XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpO1xuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODtcbn07XG5cbn0se31dLDI2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblxuLyoqXG4gKiBpc0FycmF5XG4gKi9cblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIHRvU3RyaW5nXG4gKi9cblxudmFyIHN0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogV2hldGhlciBvciBub3QgdGhlIGdpdmVuIGB2YWxgXG4gKiBpcyBhbiBhcnJheS5cbiAqXG4gKiBleGFtcGxlOlxuICpcbiAqICAgICAgICBpc0FycmF5KFtdKTtcbiAqICAgICAgICAvLyA+IHRydWVcbiAqICAgICAgICBpc0FycmF5KGFyZ3VtZW50cyk7XG4gKiAgICAgICAgLy8gPiBmYWxzZVxuICogICAgICAgIGlzQXJyYXkoJycpO1xuICogICAgICAgIC8vID4gZmFsc2VcbiAqXG4gKiBAcGFyYW0ge21peGVkfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2x9XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5IHx8IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuICEhIHZhbCAmJiAnW29iamVjdCBBcnJheV0nID09IHN0ci5jYWxsKHZhbCk7XG59O1xuXG59LHt9XSwyNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfVxuICAgICAgdGhyb3cgVHlwZUVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LicpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuXG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgdmFyIG07XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSAwO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKGVtaXR0ZXIuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gMTtcbiAgZWxzZVxuICAgIHJldCA9IGVtaXR0ZXIuX2V2ZW50c1t0eXBlXS5sZW5ndGg7XG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5cbn0se31dLDI4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbmlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuXG59LHt9XSwyOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbn0se31dLDMwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qISBodHRwOi8vbXRocy5iZS9wdW55Y29kZSB2MS4yLjQgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsKSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXiAtfl0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvXFx4MkV8XFx1MzAwMnxcXHVGRjBFfFxcdUZGNjEvZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRhcnJheVtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiBhcnJheTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3MuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0cmV0dXJuIG1hcChzdHJpbmcuc3BsaXQocmVnZXhTZXBhcmF0b3JzKSwgZm4pLmpvaW4oJy4nKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyB0byBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5XG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSB0byBVbmljb2RlLiBPbmx5IHRoZVxuXHQgKiBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLCBpLmUuIGl0IGRvZXNuJ3Rcblx0ICogbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBjb252ZXJ0ZWQgdG9cblx0ICogVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIFB1bnljb2RlIGRvbWFpbiBuYW1lIHRvIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShkb21haW4pIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGRvbWFpbiwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgdG8gUHVueWNvZGUuIE9ubHkgdGhlXG5cdCAqIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS4gaXQgZG9lc24ndFxuXHQgKiBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpbiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIHRvIGNvbnZlcnQsIGFzIGEgVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGRvbWFpbikge1xuXHRcdHJldHVybiBtYXBEb21haW4oZG9tYWluLCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS4yLjQnLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmICFmcmVlRXhwb3J0cy5ub2RlVHlwZSkge1xuXHRcdGlmIChmcmVlTW9kdWxlKSB7IC8vIGluIE5vZGUuanMgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHsgLy8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHt9XSwzMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG59LHt9XSwzMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIG1hcCAoeHMsIGYpIHtcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxufSx7fV0sMzM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSBfZGVyZXFfKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IF9kZXJlcV8oJy4vZW5jb2RlJyk7XG5cbn0se1wiLi9kZWNvZGVcIjozMSxcIi4vZW5jb2RlXCI6MzJ9XSwzNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZXJlcV8oXCIuL2xpYi9fc3RyZWFtX2R1cGxleC5qc1wiKVxuXG59LHtcIi4vbGliL19zdHJlYW1fZHVwbGV4LmpzXCI6MzV9XSwzNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICByZXR1cm4ga2V5cztcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IF9kZXJlcV8oJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IF9kZXJlcV8oJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFJlYWRhYmxlID0gX2RlcmVxXygnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSBfZGVyZXFfKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxuZm9yRWFjaChvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSksIGZ1bmN0aW9uKG1ldGhvZCkge1xuICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSlcbiAgICBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbn0pO1xuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSlcbiAgICByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKVxuICAgIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSlcbiAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSlcbiAgICB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbn1cblxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXG4gIC8vIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZClcbiAgICByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcHJvY2Vzcy5uZXh0VGljayh0aGlzLmVuZC5iaW5kKHRoaXMpKTtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaCAoeHMsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmKHhzW2ldLCBpKTtcbiAgfVxufVxuXG59KS5jYWxsKHRoaXMsX2RlcmVxXyhcIi9ob21lL2FsZXgvcHJvamVjdHMvamF2YXNjcmlwdC9pbWpzL25vZGVfbW9kdWxlcy9pbnNlcnQtbW9kdWxlLWdsb2JhbHMvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1wiKSlcbn0se1wiLi9fc3RyZWFtX3JlYWRhYmxlXCI6MzcsXCIuL19zdHJlYW1fd3JpdGFibGVcIjozOSxcIi9ob21lL2FsZXgvcHJvamVjdHMvamF2YXNjcmlwdC9pbWpzL25vZGVfbW9kdWxlcy9pbnNlcnQtbW9kdWxlLWdsb2JhbHMvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1wiOjU1LFwiY29yZS11dGlsLWlzXCI6NDAsXCJpbmhlcml0c1wiOjI4fV0sMzY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xuXG52YXIgVHJhbnNmb3JtID0gX2RlcmVxXygnLi9fc3RyZWFtX3RyYW5zZm9ybScpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBfZGVyZXFfKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSBfZGVyZXFfKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7XG5cbmZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSlcbiAgICByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTtcblxufSx7XCIuL19zdHJlYW1fdHJhbnNmb3JtXCI6MzgsXCJjb3JlLXV0aWwtaXNcIjo0MCxcImluaGVyaXRzXCI6Mjh9XSwzNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaXNBcnJheSA9IF9kZXJlcV8oJ2lzYXJyYXknKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgQnVmZmVyID0gX2RlcmVxXygnYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuXG52YXIgRUUgPSBfZGVyZXFfKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5pZiAoIUVFLmxpc3RlbmVyQ291bnQpIEVFLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBTdHJlYW0gPSBfZGVyZXFfKCdzdHJlYW0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gX2RlcmVxXygnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gX2RlcmVxXygnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyaW5nRGVjb2RlcjtcblxudXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSAoaHdtIHx8IGh3bSA9PT0gMCkgPyBod20gOiAxNiAqIDEwMjQ7XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+fnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICB0aGlzLmJ1ZmZlciA9IFtdO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBmYWxzZTtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gSW4gc3RyZWFtcyB0aGF0IG5ldmVyIGhhdmUgYW55IGRhdGEsIGFuZCBkbyBwdXNoKG51bGwpIHJpZ2h0IGF3YXksXG4gIC8vIHRoZSBjb25zdW1lciBjYW4gbWlzcyB0aGUgJ2VuZCcgZXZlbnQgaWYgdGhleSBkbyBzb21lIEkvTyBiZWZvcmVcbiAgLy8gY29uc3VtaW5nIHRoZSBzdHJlYW0uICBTbywgd2UgZG9uJ3QgZW1pdCgnZW5kJykgdW50aWwgc29tZSByZWFkaW5nXG4gIC8vIGhhcHBlbnMuXG4gIHRoaXMuY2FsbGVkUmVhZCA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWN1YXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG5cblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB3aGVuIHBpcGluZywgd2Ugb25seSBjYXJlIGFib3V0ICdyZWFkYWJsZScgZXZlbnRzIHRoYXQgaGFwcGVuXG4gIC8vIGFmdGVyIHJlYWQoKWluZyBhbGwgdGhlIGJ5dGVzIGFuZCBub3QgZ2V0dGluZyBhbnkgcHVzaGJhY2suXG4gIHRoaXMucmFuT3V0ID0gZmFsc2U7XG5cbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcblxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpXG4gICAgICBTdHJpbmdEZWNvZGVyID0gX2RlcmVxXygnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpXG4gICAgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgY2h1bmsgPSBuZXcgQnVmZmVyKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICBlbmNvZGluZyA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uKGNodW5rKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgJycsIHRydWUpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQpIHtcbiAgdmFyIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfSBlbHNlIGlmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIGlmICghc3RhdGUuZW5kZWQpXG4gICAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgIGlmIChzdGF0ZS5lbmRlZCAmJiAhYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZEVtaXR0ZWQgJiYgYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50Jyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWFkZFRvRnJvbnQgJiYgIWVuY29kaW5nKVxuICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgICAgaWYgKGFkZFRvRnJvbnQpIHtcbiAgICAgICAgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpXG4gICAgICAgIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuXG4gICAgICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xufVxuXG5cblxuLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cbi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lXG4vLyBtb3JlIGJ5dGVzLiAgVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCxcbi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXG4vLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXRcbi8vIG5lZWRSZWFkYWJsZSB3YXMgc2V0LCB0aGVuIHdlIG91Z2h0IHRvIHB1c2ggbW9yZSwgc28gdGhhdCBhbm90aGVyXG4vLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxuZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7XG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiZcbiAgICAgICAgIChzdGF0ZS5uZWVkUmVhZGFibGUgfHxcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8XG4gICAgICAgICAgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbihlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKVxuICAgIFN0cmluZ0RlY29kZXIgPSBfZGVyZXFfKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDEyOE1CXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuZnVuY3Rpb24gcm91bmRVcFRvTmV4dFBvd2VyT2YyKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDJcbiAgICBuLS07XG4gICAgZm9yICh2YXIgcCA9IDE7IHAgPCAzMjsgcCA8PD0gMSkgbiB8PSBuID4+IHA7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpXG4gICAgcmV0dXJuIDA7XG5cbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpXG4gICAgcmV0dXJuIG4gPT09IDAgPyAwIDogMTtcblxuICBpZiAobiA9PT0gbnVsbCB8fCBpc05hTihuKSkge1xuICAgIC8vIG9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmJ1ZmZlci5sZW5ndGgpXG4gICAgICByZXR1cm4gc3RhdGUuYnVmZmVyWzBdLmxlbmd0aDtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG5cbiAgaWYgKG4gPD0gMClcbiAgICByZXR1cm4gMDtcblxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgdGFyZ2V0IGJ1ZmZlciBsZXZlbCxcbiAgLy8gdGhlbiByYWlzZSB0aGUgd2F0ZXIgbWFyay4gIEJ1bXAgdXAgdG8gdGhlIG5leHQgaGlnaGVzdFxuICAvLyBwb3dlciBvZiAyLCB0byBwcmV2ZW50IGluY3JlYXNpbmcgaXQgZXhjZXNzaXZlbHkgaW4gdGlueVxuICAvLyBhbW91bnRzLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspXG4gICAgc3RhdGUuaGlnaFdhdGVyTWFyayA9IHJvdW5kVXBUb05leHRQb3dlck9mMihuKTtcblxuICAvLyBkb24ndCBoYXZlIHRoYXQgbXVjaC4gIHJldHVybiBudWxsLCB1bmxlc3Mgd2UndmUgZW5kZWQuXG4gIGlmIChuID4gc3RhdGUubGVuZ3RoKSB7XG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBuO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihuKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLmNhbGxlZFJlYWQgPSB0cnVlO1xuICB2YXIgbk9yaWcgPSBuO1xuICB2YXIgcmV0O1xuXG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA+IDApXG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJlxuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlICYmXG4gICAgICAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICByZXQgPSBudWxsO1xuXG4gICAgLy8gSW4gY2FzZXMgd2hlcmUgdGhlIGRlY29kZXIgZGlkIG5vdCByZWNlaXZlIGVub3VnaCBkYXRhXG4gICAgLy8gdG8gcHJvZHVjZSBhIGZ1bGwgY2h1bmssIHRoZW4gaW1tZWRpYXRlbHkgcmVjZWl2ZWQgYW5cbiAgICAvLyBFT0YsIHN0YXRlLmJ1ZmZlciB3aWxsIGNvbnRhaW4gWzxCdWZmZXIgPiwgPEJ1ZmZlciAwMCAuLi4+XS5cbiAgICAvLyBob3dNdWNoVG9SZWFkIHdpbGwgc2VlIHRoaXMgYW5kIGNvZXJjZSB0aGUgYW1vdW50IHRvXG4gICAgLy8gcmVhZCB0byB6ZXJvIChiZWNhdXNlIGl0J3MgbG9va2luZyBhdCB0aGUgbGVuZ3RoIG9mIHRoZVxuICAgIC8vIGZpcnN0IDxCdWZmZXIgPiBpbiBzdGF0ZS5idWZmZXIpLCBhbmQgd2UnbGwgZW5kIHVwIGhlcmUuXG4gICAgLy9cbiAgICAvLyBUaGlzIGNhbiBvbmx5IGhhcHBlbiB2aWEgc3RhdGUuZGVjb2RlciAtLSBubyBvdGhlciB2ZW51ZVxuICAgIC8vIGV4aXN0cyBmb3IgcHVzaGluZyBhIHplcm8tbGVuZ3RoIGNodW5rIGludG8gc3RhdGUuYnVmZmVyXG4gICAgLy8gYW5kIHRyaWdnZXJpbmcgdGhpcyBiZWhhdmlvci4gSW4gdGhpcyBjYXNlLCB3ZSByZXR1cm4gb3VyXG4gICAgLy8gcmVtYWluaW5nIGRhdGEgYW5kIGVuZCB0aGUgc3RyZWFtLCBpZiBhcHByb3ByaWF0ZS5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID4gMCAmJiBzdGF0ZS5kZWNvZGVyKSB7XG4gICAgICByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7XG4gICAgICBzdGF0ZS5sZW5ndGggLT0gcmV0Lmxlbmd0aDtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKVxuICAgICAgZW5kUmVhZGFibGUodGhpcyk7XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggLSBuIDw9IHN0YXRlLmhpZ2hXYXRlck1hcmspXG4gICAgZG9SZWFkID0gdHJ1ZTtcblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKVxuICAgIGRvUmVhZCA9IGZhbHNlO1xuXG4gIGlmIChkb1JlYWQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApXG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIElmIF9yZWFkIGNhbGxlZCBpdHMgY2FsbGJhY2sgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2BcbiAgLy8gd2lsbCBiZSBmYWxzZSwgYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZVxuICAvLyBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICBpZiAoZG9SZWFkICYmICFzdGF0ZS5yZWFkaW5nKVxuICAgIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG5cbiAgaWYgKG4gPiAwKVxuICAgIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtcbiAgZWxzZVxuICAgIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH1cblxuICBzdGF0ZS5sZW5ndGggLT0gbjtcblxuICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5lbmRlZClcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIElmIHdlIGhhcHBlbmVkIHRvIHJlYWQoKSBleGFjdGx5IHRoZSByZW1haW5pbmcgYW1vdW50IGluIHRoZVxuICAvLyBidWZmZXIsIGFuZCB0aGUgRU9GIGhhcyBiZWVuIHNlZW4gYXQgdGhpcyBwb2ludCwgdGhlbiBtYWtlIHN1cmVcbiAgLy8gdGhhdCB3ZSBlbWl0ICdlbmQnIG9uIHRoZSB2ZXJ5IG5leHQgdGljay5cbiAgaWYgKHN0YXRlLmVuZGVkICYmICFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICBlbmRSZWFkYWJsZSh0aGlzKTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXIgPSBudWxsO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiZcbiAgICAgICdzdHJpbmcnICE9PSB0eXBlb2YgY2h1bmsgJiZcbiAgICAgIGNodW5rICE9PSBudWxsICYmXG4gICAgICBjaHVuayAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblxuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCBhbmQgd2UgaGF2ZSBzb21lIGRhdGEgbGVmdCwgdGhlbiBlbWl0XG4gIC8vICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApXG4gICAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIGVsc2VcbiAgICBlbmRSZWFkYWJsZShzdHJlYW0pO1xufVxuXG4vLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICBpZiAoc3RhdGUuZW1pdHRlZFJlYWRhYmxlKVxuICAgIHJldHVybjtcblxuICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICBpZiAoc3RhdGUuc3luYylcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICAgIH0pO1xuICBlbHNlXG4gICAgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbn1cblxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiZcbiAgICAgICAgIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7XG4gICAgZWxzZVxuICAgICAgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24obikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiZcbiAgICAgICAgICAgICAgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiZcbiAgICAgICAgICAgICAgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IGNsZWFudXA7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKVxuICAgIHByb2Nlc3MubmV4dFRpY2soZW5kRm4pO1xuICBlbHNlXG4gICAgc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlKSB7XG4gICAgaWYgKHJlYWRhYmxlICE9PSBzcmMpIHJldHVybjtcbiAgICBjbGVhbnVwKCk7XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbilcbiAgICAgIG9uZHJhaW4oKTtcbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKVxuICAgICAgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfVxuICAvLyBUaGlzIGlzIGEgYnJ1dGFsbHkgdWdseSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyXG4gIC8vIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnkgdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuXG4gIGlmICghZGVzdC5fZXZlbnRzIHx8ICFkZXN0Ll9ldmVudHMuZXJyb3IpXG4gICAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgZWxzZSBpZiAoaXNBcnJheShkZXN0Ll9ldmVudHMuZXJyb3IpKVxuICAgIGRlc3QuX2V2ZW50cy5lcnJvci51bnNoaWZ0KG9uZXJyb3IpO1xuICBlbHNlXG4gICAgZGVzdC5fZXZlbnRzLmVycm9yID0gW29uZXJyb3IsIGRlc3QuX2V2ZW50cy5lcnJvcl07XG5cblxuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICAvLyB0aGUgaGFuZGxlciB0aGF0IHdhaXRzIGZvciByZWFkYWJsZSBldmVudHMgYWZ0ZXIgYWxsXG4gICAgLy8gdGhlIGRhdGEgZ2V0cyBzdWNrZWQgb3V0IGluIGZsb3cuXG4gICAgLy8gVGhpcyB3b3VsZCBiZSBlYXNpZXIgdG8gZm9sbG93IHdpdGggYSAub25jZSgpIGhhbmRsZXJcbiAgICAvLyBpbiBmbG93KCksIGJ1dCB0aGF0IGlzIHRvbyBzbG93LlxuICAgIHRoaXMub24oJ3JlYWRhYmxlJywgcGlwZU9uUmVhZGFibGUpO1xuXG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGVzdCA9IHRoaXM7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIHN0YXRlLmF3YWl0RHJhaW4tLTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMClcbiAgICAgIGZsb3coc3JjKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZmxvdyhzcmMpIHtcbiAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgY2h1bms7XG4gIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuXG4gIGZ1bmN0aW9uIHdyaXRlKGRlc3QsIGksIGxpc3QpIHtcbiAgICB2YXIgd3JpdHRlbiA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gd3JpdHRlbikge1xuICAgICAgc3RhdGUuYXdhaXREcmFpbisrO1xuICAgIH1cbiAgfVxuXG4gIHdoaWxlIChzdGF0ZS5waXBlc0NvdW50ICYmIG51bGwgIT09IChjaHVuayA9IHNyYy5yZWFkKCkpKSB7XG5cbiAgICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSlcbiAgICAgIHdyaXRlKHN0YXRlLnBpcGVzLCAwLCBudWxsKTtcbiAgICBlbHNlXG4gICAgICBmb3JFYWNoKHN0YXRlLnBpcGVzLCB3cml0ZSk7XG5cbiAgICBzcmMuZW1pdCgnZGF0YScsIGNodW5rKTtcblxuICAgIC8vIGlmIGFueW9uZSBuZWVkcyBhIGRyYWluLCB0aGVuIHdlIGhhdmUgdG8gd2FpdCBmb3IgdGhhdC5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA+IDApXG4gICAgICByZXR1cm47XG4gIH1cblxuICAvLyBpZiBldmVyeSBkZXN0aW5hdGlvbiB3YXMgdW5waXBlZCwgZWl0aGVyIGJlZm9yZSBlbnRlcmluZyB0aGlzXG4gIC8vIGZ1bmN0aW9uLCBvciBpbiB0aGUgd2hpbGUgbG9vcCwgdGhlbiBzdG9wIGZsb3dpbmcuXG4gIC8vXG4gIC8vIE5COiBUaGlzIGlzIGEgcHJldHR5IHJhcmUgZWRnZSBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkge1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIC8vIGlmIHRoZXJlIHdlcmUgZGF0YSBldmVudCBsaXN0ZW5lcnMgYWRkZWQsIHRoZW4gc3dpdGNoIHRvIG9sZCBtb2RlLlxuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSA+IDApXG4gICAgICBlbWl0RGF0YUV2ZW50cyhzcmMpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGF0IHRoaXMgcG9pbnQsIG5vIG9uZSBuZWVkZWQgYSBkcmFpbiwgc28gd2UganVzdCByYW4gb3V0IG9mIGRhdGFcbiAgLy8gb24gdGhlIG5leHQgcmVhZGFibGUgZXZlbnQsIHN0YXJ0IGl0IG92ZXIgYWdhaW4uXG4gIHN0YXRlLnJhbk91dCA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIHBpcGVPblJlYWRhYmxlKCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5yYW5PdXQpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnJhbk91dCA9IGZhbHNlO1xuICAgIGZsb3codGhpcyk7XG4gIH1cbn1cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24oZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpXG4gICAgICBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcigncmVhZGFibGUnLCBwaXBlT25SZWFkYWJsZSk7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KVxuICAgICAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcigncmVhZGFibGUnLCBwaXBlT25SZWFkYWJsZSk7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGkgPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGkgPT09IC0xKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpLCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSlcbiAgICBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJyAmJiAhdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKVxuICAgIGVtaXREYXRhRXZlbnRzKHRoaXMpO1xuXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJyAmJiB0aGlzLnJlYWRhYmxlKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgdGhpcy5yZWFkKDApO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMsIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICBlbWl0RGF0YUV2ZW50cyh0aGlzKTtcbiAgdGhpcy5yZWFkKDApO1xuICB0aGlzLmVtaXQoJ3Jlc3VtZScpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gIGVtaXREYXRhRXZlbnRzKHRoaXMsIHRydWUpO1xuICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG59O1xuXG5mdW5jdGlvbiBlbWl0RGF0YUV2ZW50cyhzdHJlYW0sIHN0YXJ0UGF1c2VkKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuZmxvd2luZykge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9pc2FhY3MvcmVhZGFibGUtc3RyZWFtL2lzc3Vlcy8xNlxuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHN3aXRjaCB0byBvbGQgbW9kZSBub3cuJyk7XG4gIH1cblxuICB2YXIgcGF1c2VkID0gc3RhcnRQYXVzZWQgfHwgZmFsc2U7XG4gIHZhciByZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGNvbnZlcnQgdG8gYW4gb2xkLXN0eWxlIHN0cmVhbS5cbiAgc3RyZWFtLnJlYWRhYmxlID0gdHJ1ZTtcbiAgc3RyZWFtLnBpcGUgPSBTdHJlYW0ucHJvdG90eXBlLnBpcGU7XG4gIHN0cmVhbS5vbiA9IHN0cmVhbS5hZGRMaXN0ZW5lciA9IFN0cmVhbS5wcm90b3R5cGUub247XG5cbiAgc3RyZWFtLm9uKCdyZWFkYWJsZScsIGZ1bmN0aW9uKCkge1xuICAgIHJlYWRhYmxlID0gdHJ1ZTtcblxuICAgIHZhciBjO1xuICAgIHdoaWxlICghcGF1c2VkICYmIChudWxsICE9PSAoYyA9IHN0cmVhbS5yZWFkKCkpKSlcbiAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgYyk7XG5cbiAgICBpZiAoYyA9PT0gbnVsbCkge1xuICAgICAgcmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgc3RyZWFtLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gICAgcGF1c2VkID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH07XG5cbiAgc3RyZWFtLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgIGlmIChyZWFkYWJsZSlcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICAgICAgfSk7XG4gICAgZWxzZVxuICAgICAgdGhpcy5yZWFkKDApO1xuICAgIHRoaXMuZW1pdCgncmVzdW1lJyk7XG4gIH07XG5cbiAgLy8gbm93IG1ha2UgaXQgc3RhcnQsIGp1c3QgaW4gY2FzZSBpdCBoYWRuJ3QgYWxyZWFkeS5cbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aClcbiAgICAgICAgc2VsZi5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBzZWxmLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpXG4gICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG4gICAgLy9pZiAoc3RhdGUub2JqZWN0TW9kZSAmJiB1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGNodW5rKSlcbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpXG4gICAgICByZXR1cm47XG4gICAgZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSlcbiAgICAgIHJldHVybjtcblxuICAgIHZhciByZXQgPSBzZWxmLnB1c2goY2h1bmspO1xuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIHR5cGVvZiB0aGlzW2ldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uKG1ldGhvZCkgeyByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICB9fShpKTtcbiAgICB9XG4gIH1cblxuICAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG4gIHZhciBldmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG4gIGZvckVhY2goZXZlbnRzLCBmdW5jdGlvbihldikge1xuICAgIHN0cmVhbS5vbihldiwgc2VsZi5lbWl0LmJpbmQoc2VsZiwgZXYpKTtcbiAgfSk7XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgc2VsZi5fcmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHNlbGY7XG59O1xuXG5cblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICB2YXIgbGlzdCA9IHN0YXRlLmJ1ZmZlcjtcbiAgdmFyIGxlbmd0aCA9IHN0YXRlLmxlbmd0aDtcbiAgdmFyIHN0cmluZ01vZGUgPSAhIXN0YXRlLmRlY29kZXI7XG4gIHZhciBvYmplY3RNb2RlID0gISFzdGF0ZS5vYmplY3RNb2RlO1xuICB2YXIgcmV0O1xuXG4gIC8vIG5vdGhpbmcgaW4gdGhlIGxpc3QsIGRlZmluaXRlbHkgZW1wdHkuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gbnVsbDtcblxuICBpZiAobGVuZ3RoID09PSAwKVxuICAgIHJldCA9IG51bGw7XG4gIGVsc2UgaWYgKG9iamVjdE1vZGUpXG4gICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICBlbHNlIGlmICghbiB8fCBuID49IGxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgYXJyYXkuXG4gICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICByZXQgPSBsaXN0LmpvaW4oJycpO1xuICAgIGVsc2VcbiAgICAgIHJldCA9IEJ1ZmZlci5jb25jYXQobGlzdCwgbGVuZ3RoKTtcbiAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBqdXN0IHNvbWUgb2YgaXQuXG4gICAgaWYgKG4gPCBsaXN0WzBdLmxlbmd0aCkge1xuICAgICAgLy8ganVzdCB0YWtlIGEgcGFydCBvZiB0aGUgZmlyc3QgbGlzdCBpdGVtLlxuICAgICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3MuXG4gICAgICB2YXIgYnVmID0gbGlzdFswXTtcbiAgICAgIHJldCA9IGJ1Zi5zbGljZSgwLCBuKTtcbiAgICAgIGxpc3RbMF0gPSBidWYuc2xpY2Uobik7XG4gICAgfSBlbHNlIGlmIChuID09PSBsaXN0WzBdLmxlbmd0aCkge1xuICAgICAgLy8gZmlyc3QgbGlzdCBpcyBhIHBlcmZlY3QgbWF0Y2hcbiAgICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY29tcGxleCBjYXNlLlxuICAgICAgLy8gd2UgaGF2ZSBlbm91Z2ggdG8gY292ZXIgaXQsIGJ1dCBpdCBzcGFucyBwYXN0IHRoZSBmaXJzdCBidWZmZXIuXG4gICAgICBpZiAoc3RyaW5nTW9kZSlcbiAgICAgICAgcmV0ID0gJyc7XG4gICAgICBlbHNlXG4gICAgICAgIHJldCA9IG5ldyBCdWZmZXIobik7XG5cbiAgICAgIHZhciBjID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsICYmIGMgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIGJ1ZiA9IGxpc3RbMF07XG4gICAgICAgIHZhciBjcHkgPSBNYXRoLm1pbihuIC0gYywgYnVmLmxlbmd0aCk7XG5cbiAgICAgICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICAgICAgcmV0ICs9IGJ1Zi5zbGljZSgwLCBjcHkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgYnVmLmNvcHkocmV0LCBjLCAwLCBjcHkpO1xuXG4gICAgICAgIGlmIChjcHkgPCBidWYubGVuZ3RoKVxuICAgICAgICAgIGxpc3RbMF0gPSBidWYuc2xpY2UoY3B5KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcblxuICAgICAgICBjICs9IGNweTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuZFJlYWRhYmxlIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmNhbGxlZFJlYWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICAgICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoICh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YgKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbn0pLmNhbGwodGhpcyxfZGVyZXFfKFwiL2hvbWUvYWxleC9wcm9qZWN0cy9qYXZhc2NyaXB0L2ltanMvbm9kZV9tb2R1bGVzL2luc2VydC1tb2R1bGUtZ2xvYmFscy9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXCIpKVxufSx7XCIvaG9tZS9hbGV4L3Byb2plY3RzL2phdmFzY3JpcHQvaW1qcy9ub2RlX21vZHVsZXMvaW5zZXJ0LW1vZHVsZS1nbG9iYWxzL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcIjo1NSxcImJ1ZmZlclwiOjIzLFwiY29yZS11dGlsLWlzXCI6NDAsXCJldmVudHNcIjoyNyxcImluaGVyaXRzXCI6MjgsXCJpc2FycmF5XCI6MjksXCJzdHJlYW1cIjo0NSxcInN0cmluZ19kZWNvZGVyL1wiOjQ2fV0sMzg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cblxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIER1cGxleCA9IF9kZXJlcV8oJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gX2RlcmVxXygnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gX2RlcmVxXygnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgdGhpcy5hZnRlclRyYW5zZm9ybSA9IGZ1bmN0aW9uKGVyLCBkYXRhKSB7XG4gICAgcmV0dXJuIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpO1xuICB9O1xuXG4gIHRoaXMubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICB0aGlzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuICB0aGlzLndyaXRlY2h1bmsgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuXG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKCFjYilcbiAgICByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdubyB3cml0ZWNiIGluIFRyYW5zZm9ybSBjbGFzcycpKTtcblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdW5kZWZpbmVkKVxuICAgIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIGlmIChjYilcbiAgICBjYihlcik7XG5cbiAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHN0cmVhbS5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKVxuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuXG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlID0gbmV3IFRyYW5zZm9ybVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIHdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdmFyIHN0cmVhbSA9IHRoaXM7XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZmluaXNoJywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiB0aGlzLl9mbHVzaClcbiAgICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uKGVyKSB7XG4gICAgICAgIGRvbmUoc3RyZWFtLCBlcik7XG4gICAgICB9KTtcbiAgICBlbHNlXG4gICAgICBkb25lKHN0cmVhbSk7XG4gIH0pO1xufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fFxuICAgICAgICBycy5uZWVkUmVhZGFibGUgfHxcbiAgICAgICAgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaylcbiAgICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyKSB7XG4gIGlmIChlcilcbiAgICByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIHZhciB3cyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh3cy5sZW5ndGgpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICBpZiAodHMudHJhbnNmb3JtaW5nKVxuICAgIHRocm93IG5ldyBFcnJvcignY2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn1cblxufSx7XCIuL19zdHJlYW1fZHVwbGV4XCI6MzUsXCJjb3JlLXV0aWwtaXNcIjo0MCxcImluaGVyaXRzXCI6Mjh9XSwzOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEJ1ZmZlciA9IF9kZXJlcV8oJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBfZGVyZXFfKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSBfZGVyZXFfKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBTdHJlYW0gPSBfZGVyZXFfKCdzdHJlYW0nKTtcblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gKGh3bSB8fCBod20gPT09IDApID8gaHdtIDogMTYgKiAxMDI0O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfn50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWN1YXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24oZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXIgPSBbXTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIHZhciBEdXBsZXggPSBfZGVyZXFfKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0aG91Z2ggdGhleSdyZSBub3RcbiAgLy8gaW5zdGFuY2VvZiBXcml0YWJsZSwgdGhleSdyZSBpbnN0YW5jZW9mIFJlYWRhYmxlLlxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV3JpdGFibGUpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpXG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUuIE5vdCByZWFkYWJsZS4nKSk7XG59O1xuXG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgIGNiKGVyKTtcbiAgfSk7XG59XG5cbi8vIElmIHdlIGdldCBzb21ldGhpbmcgdGhhdCBpcyBub3QgYSBidWZmZXIsIHN0cmluZywgbnVsbCwgb3IgdW5kZWZpbmVkLFxuLy8gYW5kIHdlJ3JlIG5vdCBpbiBvYmplY3RNb2RlLCB0aGVuIHRoYXQncyBhbiBlcnJvci5cbi8vIE90aGVyd2lzZSBzdHJlYW0gY2h1bmtzIGFyZSBhbGwgY29uc2lkZXJlZCB0byBiZSBvZiBsZW5ndGg9MSwgYW5kIHRoZVxuLy8gd2F0ZXJtYXJrcyBkZXRlcm1pbmUgaG93IG1hbnkgb2JqZWN0cyB0byBrZWVwIGluIHRoZSBidWZmZXIsIHJhdGhlciB0aGFuXG4vLyBob3cgbWFueSBieXRlcyBvciBjaGFyYWN0ZXJzLlxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoY2h1bmspICYmXG4gICAgICAnc3RyaW5nJyAhPT0gdHlwZW9mIGNodW5rICYmXG4gICAgICBjaHVuayAhPT0gbnVsbCAmJlxuICAgICAgY2h1bmsgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICB2YXIgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBjYihlcik7XG4gICAgfSk7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspKVxuICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gIGVsc2UgaWYgKCFlbmNvZGluZylcbiAgICBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKVxuICAgIGNiID0gZnVuY3Rpb24oKSB7fTtcblxuICBpZiAoc3RhdGUuZW5kZWQpXG4gICAgd3JpdGVBZnRlckVuZCh0aGlzLCBzdGF0ZSwgY2IpO1xuICBlbHNlIGlmICh2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKVxuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJlxuICAgICAgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiZcbiAgICAgIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IG5ldyBCdWZmZXIoY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpXG4gICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldClcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nKVxuICAgIHN0YXRlLmJ1ZmZlci5wdXNoKG5ldyBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSk7XG4gIGVsc2VcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICBpZiAoc3luYylcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgY2IoZXIpO1xuICAgIH0pO1xuICBlbHNlXG4gICAgY2IoZXIpO1xuXG4gIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKVxuICAgIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO1xuICBlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlci5sZW5ndGgpXG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcblxuICAgIGlmIChzeW5jKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKVxuICAgIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgY2IoKTtcbiAgaWYgKGZpbmlzaGVkKVxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcblxuICBmb3IgKHZhciBjID0gMDsgYyA8IHN0YXRlLmJ1ZmZlci5sZW5ndGg7IGMrKykge1xuICAgIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcltjXTtcbiAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG5cbiAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICBjKys7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG4gIGlmIChjIDwgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICBzdGF0ZS5idWZmZXIgPSBzdGF0ZS5idWZmZXIuc2xpY2UoYyk7XG4gIGVsc2VcbiAgICBzdGF0ZS5idWZmZXIubGVuZ3RoID0gMDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIGNodW5rICE9PSAndW5kZWZpbmVkJyAmJiBjaHVuayAhPT0gbnVsbClcbiAgICB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpXG4gICAgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIHJldHVybiAoc3RhdGUuZW5kaW5nICYmXG4gICAgICAgICAgc3RhdGUubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgIXN0YXRlLmZpbmlzaGVkICYmXG4gICAgICAgICAgIXN0YXRlLndyaXRpbmcpO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKVxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYik7XG4gICAgZWxzZVxuICAgICAgc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG59XG5cbn0pLmNhbGwodGhpcyxfZGVyZXFfKFwiL2hvbWUvYWxleC9wcm9qZWN0cy9qYXZhc2NyaXB0L2ltanMvbm9kZV9tb2R1bGVzL2luc2VydC1tb2R1bGUtZ2xvYmFscy9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXCIpKVxufSx7XCIuL19zdHJlYW1fZHVwbGV4XCI6MzUsXCIvaG9tZS9hbGV4L3Byb2plY3RzL2phdmFzY3JpcHQvaW1qcy9ub2RlX21vZHVsZXMvaW5zZXJ0LW1vZHVsZS1nbG9iYWxzL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcIjo1NSxcImJ1ZmZlclwiOjIzLFwiY29yZS11dGlsLWlzXCI6NDAsXCJpbmhlcml0c1wiOjI4LFwic3RyZWFtXCI6NDV9XSw0MDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKEJ1ZmZlcil7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKGFyZyk7XG59XG5leHBvcnRzLmlzQnVmZmVyID0gaXNCdWZmZXI7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cbn0pLmNhbGwodGhpcyxfZGVyZXFfKFwiYnVmZmVyXCIpLkJ1ZmZlcilcbn0se1wiYnVmZmVyXCI6MjN9XSw0MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZXJlcV8oXCIuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzXCIpXG5cbn0se1wiLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qc1wiOjM2fV0sNDI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIFN0cmVhbSA9IF9kZXJlcV8oJ3N0cmVhbScpOyAvLyBoYWNrIHRvIGZpeCBhIGNpcmN1bGFyIGRlcGVuZGVuY3kgaXNzdWUgd2hlbiB1c2VkIHdpdGggYnJvd3NlcmlmeVxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gX2RlcmVxXygnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSBTdHJlYW07XG5leHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbmV4cG9ydHMuV3JpdGFibGUgPSBfZGVyZXFfKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5leHBvcnRzLkR1cGxleCA9IF9kZXJlcV8oJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5leHBvcnRzLlRyYW5zZm9ybSA9IF9kZXJlcV8oJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5leHBvcnRzLlBhc3NUaHJvdWdoID0gX2RlcmVxXygnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuXG59LHtcIi4vbGliL19zdHJlYW1fZHVwbGV4LmpzXCI6MzUsXCIuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzXCI6MzYsXCIuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzXCI6MzcsXCIuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qc1wiOjM4LFwiLi9saWIvX3N0cmVhbV93cml0YWJsZS5qc1wiOjM5LFwic3RyZWFtXCI6NDV9XSw0MzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZXJlcV8oXCIuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qc1wiKVxuXG59LHtcIi4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzXCI6Mzh9XSw0NDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZXJlcV8oXCIuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzXCIpXG5cbn0se1wiLi9saWIvX3N0cmVhbV93cml0YWJsZS5qc1wiOjM5fV0sNDU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtO1xuXG52YXIgRUUgPSBfZGVyZXFfKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgaW5oZXJpdHMgPSBfZGVyZXFfKCdpbmhlcml0cycpO1xuXG5pbmhlcml0cyhTdHJlYW0sIEVFKTtcblN0cmVhbS5SZWFkYWJsZSA9IF9kZXJlcV8oJ3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qcycpO1xuU3RyZWFtLldyaXRhYmxlID0gX2RlcmVxXygncmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzJyk7XG5TdHJlYW0uRHVwbGV4ID0gX2RlcmVxXygncmVhZGFibGUtc3RyZWFtL2R1cGxleC5qcycpO1xuU3RyZWFtLlRyYW5zZm9ybSA9IF9kZXJlcV8oJ3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMnKTtcblN0cmVhbS5QYXNzVGhyb3VnaCA9IF9kZXJlcV8oJ3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcycpO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjQueFxuU3RyZWFtLlN0cmVhbSA9IFN0cmVhbTtcblxuXG5cbi8vIG9sZC1zdHlsZSBzdHJlYW1zLiAgTm90ZSB0aGF0IHRoZSBwaXBlIG1ldGhvZCAodGhlIG9ubHkgcmVsZXZhbnRcbi8vIHBhcnQgb2YgdGhpcyBjbGFzcykgaXMgb3ZlcnJpZGRlbiBpbiB0aGUgUmVhZGFibGUgY2xhc3MuXG5cbmZ1bmN0aW9uIFN0cmVhbSgpIHtcbiAgRUUuY2FsbCh0aGlzKTtcbn1cblxuU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgb3B0aW9ucykge1xuICB2YXIgc291cmNlID0gdGhpcztcblxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBpZiAoZGVzdC53cml0YWJsZSkge1xuICAgICAgaWYgKGZhbHNlID09PSBkZXN0LndyaXRlKGNodW5rKSAmJiBzb3VyY2UucGF1c2UpIHtcbiAgICAgICAgc291cmNlLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdkYXRhJywgb25kYXRhKTtcblxuICBmdW5jdGlvbiBvbmRyYWluKCkge1xuICAgIGlmIChzb3VyY2UucmVhZGFibGUgJiYgc291cmNlLnJlc3VtZSkge1xuICAgICAgc291cmNlLnJlc3VtZSgpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgLy8gSWYgdGhlICdlbmQnIG9wdGlvbiBpcyBub3Qgc3VwcGxpZWQsIGRlc3QuZW5kKCkgd2lsbCBiZSBjYWxsZWQgd2hlblxuICAvLyBzb3VyY2UgZ2V0cyB0aGUgJ2VuZCcgb3IgJ2Nsb3NlJyBldmVudHMuICBPbmx5IGRlc3QuZW5kKCkgb25jZS5cbiAgaWYgKCFkZXN0Ll9pc1N0ZGlvICYmICghb3B0aW9ucyB8fCBvcHRpb25zLmVuZCAhPT0gZmFsc2UpKSB7XG4gICAgc291cmNlLm9uKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuICB9XG5cbiAgdmFyIGRpZE9uRW5kID0gZmFsc2U7XG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgaWYgKHR5cGVvZiBkZXN0LmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIGRlc3QuZGVzdHJveSgpO1xuICB9XG5cbiAgLy8gZG9uJ3QgbGVhdmUgZGFuZ2xpbmcgcGlwZXMgd2hlbiB0aGVyZSBhcmUgZXJyb3JzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgY2xlYW51cCgpO1xuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KHRoaXMsICdlcnJvcicpID09PSAwKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkIHN0cmVhbSBlcnJvciBpbiBwaXBlLlxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyByZW1vdmUgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkLlxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuICB9XG5cbiAgc291cmNlLm9uKCdlbmQnLCBjbGVhbnVwKTtcbiAgc291cmNlLm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3Qub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5lbWl0KCdwaXBlJywgc291cmNlKTtcblxuICAvLyBBbGxvdyBmb3IgdW5peC1saWtlIHVzYWdlOiBBLnBpcGUoQikucGlwZShDKVxuICByZXR1cm4gZGVzdDtcbn07XG5cbn0se1wiZXZlbnRzXCI6MjcsXCJpbmhlcml0c1wiOjI4LFwicmVhZGFibGUtc3RyZWFtL2R1cGxleC5qc1wiOjM0LFwicmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzXCI6NDEsXCJyZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanNcIjo0MixcInJlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanNcIjo0MyxcInJlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qc1wiOjQ0fV0sNDY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBCdWZmZXIgPSBfZGVyZXFfKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBpc0J1ZmZlckVuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmdcbiAgfHwgZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgICAgICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgIGNhc2UgJ2hleCc6IGNhc2UgJ3V0ZjgnOiBjYXNlICd1dGYtOCc6IGNhc2UgJ2FzY2lpJzogY2FzZSAnYmluYXJ5JzogY2FzZSAnYmFzZTY0JzogY2FzZSAndWNzMic6IGNhc2UgJ3Vjcy0yJzogY2FzZSAndXRmMTZsZSc6IGNhc2UgJ3V0Zi0xNmxlJzogY2FzZSAncmF3JzogcmV0dXJuIHRydWU7XG4gICAgICAgICBkZWZhdWx0OiByZXR1cm4gZmFsc2U7XG4gICAgICAgfVxuICAgICB9XG5cblxuZnVuY3Rpb24gYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgaWYgKGVuY29kaW5nICYmICFpc0J1ZmZlckVuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgfVxufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuIENFU1UtOCBpcyBoYW5kbGVkIGFzIHBhcnQgb2YgdGhlIFVURi04IGVuY29kaW5nLlxuLy9cbi8vIEBUT0RPIEhhbmRsaW5nIGFsbCBlbmNvZGluZ3MgaW5zaWRlIGEgc2luZ2xlIG9iamVjdCBtYWtlcyBpdCB2ZXJ5IGRpZmZpY3VsdFxuLy8gdG8gcmVhc29uIGFib3V0IHRoaXMgY29kZSwgc28gaXQgc2hvdWxkIGJlIHNwbGl0IHVwIGluIHRoZSBmdXR1cmUuXG4vLyBAVE9ETyBUaGVyZSBzaG91bGQgYmUgYSB1dGY4LXN0cmljdCBlbmNvZGluZyB0aGF0IHJlamVjdHMgaW52YWxpZCBVVEYtOCBjb2RlXG4vLyBwb2ludHMgYXMgdXNlZCBieSBDRVNVLTguXG52YXIgU3RyaW5nRGVjb2RlciA9IGV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSAoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1stX10vLCAnJyk7XG4gIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKTtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICAvLyBDRVNVLTggcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDMtYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIC8vIFVURi0xNiByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMi1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMjtcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIC8vIEJhc2UtNjQgc3RvcmVzIDMgYnl0ZXMgaW4gNCBjaGFycywgYW5kIHBhZHMgdGhlIHJlbWFpbmRlci5cbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHBhc3NUaHJvdWdoV3JpdGU7XG4gICAgICByZXR1cm47XG4gIH1cblxuICAvLyBFbm91Z2ggc3BhY2UgdG8gc3RvcmUgYWxsIGJ5dGVzIG9mIGEgc2luZ2xlIGNoYXJhY3Rlci4gVVRGLTggbmVlZHMgNFxuICAvLyBieXRlcywgYnV0IENFU1UtOCBtYXkgcmVxdWlyZSB1cCB0byA2ICgzIGJ5dGVzIHBlciBzdXJyb2dhdGUpLlxuICB0aGlzLmNoYXJCdWZmZXIgPSBuZXcgQnVmZmVyKDYpO1xuICAvLyBOdW1iZXIgb2YgYnl0ZXMgcmVjZWl2ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXG4gIHRoaXMuY2hhclJlY2VpdmVkID0gMDtcbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIGV4cGVjdGVkIGZvciB0aGUgY3VycmVudCBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgY2hhcmFjdGVyLlxuICB0aGlzLmNoYXJMZW5ndGggPSAwO1xufTtcblxuXG4vLyB3cml0ZSBkZWNvZGVzIHRoZSBnaXZlbiBidWZmZXIgYW5kIHJldHVybnMgaXQgYXMgSlMgc3RyaW5nIHRoYXQgaXNcbi8vIGd1YXJhbnRlZWQgdG8gbm90IGNvbnRhaW4gYW55IHBhcnRpYWwgbXVsdGktYnl0ZSBjaGFyYWN0ZXJzLiBBbnkgcGFydGlhbFxuLy8gY2hhcmFjdGVyIGZvdW5kIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciBpcyBidWZmZXJlZCB1cCwgYW5kIHdpbGwgYmVcbi8vIHJldHVybmVkIHdoZW4gY2FsbGluZyB3cml0ZSBhZ2FpbiB3aXRoIHRoZSByZW1haW5pbmcgYnl0ZXMuXG4vL1xuLy8gTm90ZTogQ29udmVydGluZyBhIEJ1ZmZlciBjb250YWluaW5nIGFuIG9ycGhhbiBzdXJyb2dhdGUgdG8gYSBTdHJpbmdcbi8vIGN1cnJlbnRseSB3b3JrcywgYnV0IGNvbnZlcnRpbmcgYSBTdHJpbmcgdG8gYSBCdWZmZXIgKHZpYSBgbmV3IEJ1ZmZlcmAsIG9yXG4vLyBCdWZmZXIjd3JpdGUpIHdpbGwgcmVwbGFjZSBpbmNvbXBsZXRlIHN1cnJvZ2F0ZXMgd2l0aCB0aGUgdW5pY29kZVxuLy8gcmVwbGFjZW1lbnQgY2hhcmFjdGVyLiBTZWUgaHR0cHM6Ly9jb2RlcmV2aWV3LmNocm9taXVtLm9yZy8xMjExNzMwMDkvIC5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciBjaGFyU3RyID0gJyc7XG4gIC8vIGlmIG91ciBsYXN0IHdyaXRlIGVuZGVkIHdpdGggYW4gaW5jb21wbGV0ZSBtdWx0aWJ5dGUgY2hhcmFjdGVyXG4gIHdoaWxlICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgcmVtYWluaW5nIGJ5dGVzIHRoaXMgYnVmZmVyIGhhcyB0byBvZmZlciBmb3IgdGhpcyBjaGFyXG4gICAgdmFyIGF2YWlsYWJsZSA9IChidWZmZXIubGVuZ3RoID49IHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkKSA/XG4gICAgICAgIHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkIDpcbiAgICAgICAgYnVmZmVyLmxlbmd0aDtcblxuICAgIC8vIGFkZCB0aGUgbmV3IGJ5dGVzIHRvIHRoZSBjaGFyIGJ1ZmZlclxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgdGhpcy5jaGFyUmVjZWl2ZWQsIDAsIGF2YWlsYWJsZSk7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gYXZhaWxhYmxlO1xuXG4gICAgaWYgKHRoaXMuY2hhclJlY2VpdmVkIDwgdGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgICAvLyBzdGlsbCBub3QgZW5vdWdoIGNoYXJzIGluIHRoaXMgYnVmZmVyPyB3YWl0IGZvciBtb3JlIC4uLlxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBieXRlcyBiZWxvbmdpbmcgdG8gdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGZyb20gdGhlIGJ1ZmZlclxuICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShhdmFpbGFibGUsIGJ1ZmZlci5sZW5ndGgpO1xuXG4gICAgLy8gZ2V0IHRoZSBjaGFyYWN0ZXIgdGhhdCB3YXMgc3BsaXRcbiAgICBjaGFyU3RyID0gdGhpcy5jaGFyQnVmZmVyLnNsaWNlKDAsIHRoaXMuY2hhckxlbmd0aCkudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG5cbiAgICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gICAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGNoYXJTdHIubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCArPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgICBjaGFyU3RyID0gJyc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgPSB0aGlzLmNoYXJMZW5ndGggPSAwO1xuXG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIG1vcmUgYnl0ZXMgaW4gdGhpcyBidWZmZXIsIGp1c3QgZW1pdCBvdXIgY2hhclxuICAgIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gY2hhclN0cjtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgYW5kIHNldCBjaGFyTGVuZ3RoIC8gY2hhclJlY2VpdmVkXG4gIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKTtcblxuICB2YXIgZW5kID0gYnVmZmVyLmxlbmd0aDtcbiAgaWYgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGJ1ZmZlciB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXIgYnl0ZXMgd2UgZ290XG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCBidWZmZXIubGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQsIGVuZCk7XG4gICAgZW5kIC09IHRoaXMuY2hhclJlY2VpdmVkO1xuICB9XG5cbiAgY2hhclN0ciArPSBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgZW5kKTtcblxuICB2YXIgZW5kID0gY2hhclN0ci5sZW5ndGggLSAxO1xuICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoZW5kKTtcbiAgLy8gQ0VTVS04OiBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgIHZhciBzaXplID0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgIHRoaXMuY2hhckxlbmd0aCArPSBzaXplO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IHNpemU7XG4gICAgdGhpcy5jaGFyQnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCBzaXplLCAwLCBzaXplKTtcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIDAsIHNpemUpO1xuICAgIHJldHVybiBjaGFyU3RyLnN1YnN0cmluZygwLCBlbmQpO1xuICB9XG5cbiAgLy8gb3IganVzdCBlbWl0IHRoZSBjaGFyU3RyXG4gIHJldHVybiBjaGFyU3RyO1xufTtcblxuLy8gZGV0ZWN0SW5jb21wbGV0ZUNoYXIgZGV0ZXJtaW5lcyBpZiB0aGVyZSBpcyBhbiBpbmNvbXBsZXRlIFVURi04IGNoYXJhY3RlciBhdFxuLy8gdGhlIGVuZCBvZiB0aGUgZ2l2ZW4gYnVmZmVyLiBJZiBzbywgaXQgc2V0cyB0aGlzLmNoYXJMZW5ndGggdG8gdGhlIGJ5dGVcbi8vIGxlbmd0aCB0aGF0IGNoYXJhY3RlciwgYW5kIHNldHMgdGhpcy5jaGFyUmVjZWl2ZWQgdG8gdGhlIG51bWJlciBvZiBieXRlc1xuLy8gdGhhdCBhcmUgYXZhaWxhYmxlIGZvciB0aGlzIGNoYXJhY3Rlci5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmRldGVjdEluY29tcGxldGVDaGFyID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIC8vIGRldGVybWluZSBob3cgbWFueSBieXRlcyB3ZSBoYXZlIHRvIGNoZWNrIGF0IHRoZSBlbmQgb2YgdGhpcyBidWZmZXJcbiAgdmFyIGkgPSAoYnVmZmVyLmxlbmd0aCA+PSAzKSA/IDMgOiBidWZmZXIubGVuZ3RoO1xuXG4gIC8vIEZpZ3VyZSBvdXQgaWYgb25lIG9mIHRoZSBsYXN0IGkgYnl0ZXMgb2Ygb3VyIGJ1ZmZlciBhbm5vdW5jZXMgYW5cbiAgLy8gaW5jb21wbGV0ZSBjaGFyLlxuICBmb3IgKDsgaSA+IDA7IGktLSkge1xuICAgIHZhciBjID0gYnVmZmVyW2J1ZmZlci5sZW5ndGggLSBpXTtcblxuICAgIC8vIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VURi04I0Rlc2NyaXB0aW9uXG5cbiAgICAvLyAxMTBYWFhYWFxuICAgIGlmIChpID09IDEgJiYgYyA+PiA1ID09IDB4MDYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDI7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTEwWFhYWFxuICAgIGlmIChpIDw9IDIgJiYgYyA+PiA0ID09IDB4MEUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDM7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTExMFhYWFxuICAgIGlmIChpIDw9IDMgJiYgYyA+PiAzID09IDB4MUUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBpO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciByZXMgPSAnJztcbiAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoKVxuICAgIHJlcyA9IHRoaXMud3JpdGUoYnVmZmVyKTtcblxuICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQpIHtcbiAgICB2YXIgY3IgPSB0aGlzLmNoYXJSZWNlaXZlZDtcbiAgICB2YXIgYnVmID0gdGhpcy5jaGFyQnVmZmVyO1xuICAgIHZhciBlbmMgPSB0aGlzLmVuY29kaW5nO1xuICAgIHJlcyArPSBidWYuc2xpY2UoMCwgY3IpLnRvU3RyaW5nKGVuYyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gcGFzc1Rocm91Z2hXcml0ZShidWZmZXIpIHtcbiAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMjtcbiAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAyIDogMDtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDM7XG4gIHRoaXMuY2hhckxlbmd0aCA9IHRoaXMuY2hhclJlY2VpdmVkID8gMyA6IDA7XG59XG5cbn0se1wiYnVmZmVyXCI6MjN9XSw0NzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIHB1bnljb2RlID0gX2RlcmVxXygncHVueWNvZGUnKTtcblxuZXhwb3J0cy5wYXJzZSA9IHVybFBhcnNlO1xuZXhwb3J0cy5yZXNvbHZlID0gdXJsUmVzb2x2ZTtcbmV4cG9ydHMucmVzb2x2ZU9iamVjdCA9IHVybFJlc29sdmVPYmplY3Q7XG5leHBvcnRzLmZvcm1hdCA9IHVybEZvcm1hdDtcblxuZXhwb3J0cy5VcmwgPSBVcmw7XG5cbmZ1bmN0aW9uIFVybCgpIHtcbiAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gIHRoaXMuYXV0aCA9IG51bGw7XG4gIHRoaXMuaG9zdCA9IG51bGw7XG4gIHRoaXMucG9ydCA9IG51bGw7XG4gIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICB0aGlzLmhhc2ggPSBudWxsO1xuICB0aGlzLnNlYXJjaCA9IG51bGw7XG4gIHRoaXMucXVlcnkgPSBudWxsO1xuICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbiAgdGhpcy5wYXRoID0gbnVsbDtcbiAgdGhpcy5ocmVmID0gbnVsbDtcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cbiAgICBkZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCddLmNvbmNhdChkZWxpbXMpLFxuXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbJ1xcJyddLmNvbmNhdCh1bndpc2UpLFxuICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4gICAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAgIC8vIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxuICAgIC8vIHRoZW0uXG4gICAgbm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gICAgaG9zdEVuZGluZ0NoYXJzID0gWycvJywgJz8nLCAnIyddLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlthLXowLTlBLVpfLV17MCw2M30kLyxcbiAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFthLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxuICAgIC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxuICAgIHVuc2FmZVByb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICAgIGhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9LFxuICAgIHF1ZXJ5c3RyaW5nID0gX2RlcmVxXygncXVlcnlzdHJpbmcnKTtcblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIGlzT2JqZWN0KHVybCkgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSByZXR1cm4gdXJsO1xuXG4gIHZhciB1ID0gbmV3IFVybDtcbiAgdS5wYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KTtcbiAgcmV0dXJuIHU7XG59XG5cblVybC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICghaXNTdHJpbmcodXJsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICB2YXIgcmVzdCA9IHVybDtcblxuICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcblxuICB2YXIgcHJvdG8gPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgaWYgKHByb3RvKSB7XG4gICAgcHJvdG8gPSBwcm90b1swXTtcbiAgICB2YXIgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5wcm90b2NvbCA9IGxvd2VyUHJvdG87XG4gICAgcmVzdCA9IHJlc3Quc3Vic3RyKHByb3RvLmxlbmd0aCk7XG4gIH1cblxuICAvLyBmaWd1cmUgb3V0IGlmIGl0J3MgZ290IGEgaG9zdFxuICAvLyB1c2VyQHNlcnZlciBpcyAqYWx3YXlzKiBpbnRlcnByZXRlZCBhcyBhIGhvc3RuYW1lLCBhbmQgdXJsXG4gIC8vIHJlc29sdXRpb24gd2lsbCB0cmVhdCAvL2Zvby9iYXIgYXMgaG9zdD1mb28scGF0aD1iYXIgYmVjYXVzZSB0aGF0J3NcbiAgLy8gaG93IHRoZSBicm93c2VyIHJlc29sdmVzIHJlbGF0aXZlIFVSTHMuXG4gIGlmIChzbGFzaGVzRGVub3RlSG9zdCB8fCBwcm90byB8fCByZXN0Lm1hdGNoKC9eXFwvXFwvW15AXFwvXStAW15AXFwvXSsvKSkge1xuICAgIHZhciBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLyc7XG4gICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTtcbiAgICAgIHRoaXMuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcblxuICAgIC8vIHRoZXJlJ3MgYSBob3N0bmFtZS5cbiAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXG4gICAgLy8gY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbiAgICAvLyBVUkxzIGFyZSBvYm5veGlvdXMuXG4gICAgLy9cbiAgICAvLyBleDpcbiAgICAvLyBodHRwOi8vYUBiQGMvID0+IHVzZXI6YUBiIGhvc3Q6Y1xuICAgIC8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcblxuICAgIC8vIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy5cbiAgICAvLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LlxuXG4gICAgLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xuICAgIHZhciBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2YoaG9zdEVuZGluZ0NoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbiAgICAvLyBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cbiAgICB2YXIgYXV0aCwgYXRTaWduO1xuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgLy8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxuICAgICAgLy8gaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cbiAgICAvLyBQdWxsIHRoYXQgb2ZmLlxuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XG4gICAgICB0aGlzLmF1dGggPSBkZWNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGhvc3QgaXMgdGhlIHJlbWFpbmluZyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3Qgbm9uLWhvc3QgY2hhclxuICAgIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cbiAgICAvLyBpZiB3ZSBzdGlsbCBoYXZlIG5vdCBoaXQgaXQsIHRoZW4gdGhlIGVudGlyZSB0aGluZyBpcyBhIGhvc3QuXG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKVxuICAgICAgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xuXG4gICAgdGhpcy5ob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTtcblxuICAgIC8vIHB1bGwgb3V0IHBvcnQuXG4gICAgdGhpcy5wYXJzZUhvc3QoKTtcblxuICAgIC8vIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXG4gICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcblxuICAgIC8vIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdXG4gICAgLy8gYXNzdW1lIHRoYXQgaXQncyBhbiBJUHY2IGFkZHJlc3MuXG4gICAgdmFyIGlwdjZIb3N0bmFtZSA9IHRoaXMuaG9zdG5hbWVbMF0gPT09ICdbJyAmJlxuICAgICAgICB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJztcblxuICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XG4gICAgICAgIGlmICghcGFydCkgY29udGludWU7XG4gICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5XG4gICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7XG4gICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3QgPSAnLycgKyBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ob3N0bmFtZS5sZW5ndGggPiBob3N0bmFtZU1heExlbikge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgLy8gSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueSBjb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgICAgLy8gSXQgb25seSBjb252ZXJ0cyB0aGUgcGFydCBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdFxuICAgICAgLy8gaGFzIG5vbiBBU0NJSSBjaGFyYWN0ZXJzLiBJLmUuIGl0IGRvc2VudCBtYXR0ZXIgaWZcbiAgICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIGluIEFTQ0lJLlxuICAgICAgdmFyIGRvbWFpbkFycmF5ID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgnLicpO1xuICAgICAgdmFyIG5ld091dCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb21haW5BcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcyA9IGRvbWFpbkFycmF5W2ldO1xuICAgICAgICBuZXdPdXQucHVzaChzLm1hdGNoKC9bXkEtWmEtejAtOV8tXS8pID9cbiAgICAgICAgICAgICd4bi0tJyArIHB1bnljb2RlLmVuY29kZShzKSA6IHMpO1xuICAgICAgfVxuICAgICAgdGhpcy5ob3N0bmFtZSA9IG5ld091dC5qb2luKCcuJyk7XG4gICAgfVxuXG4gICAgdmFyIHAgPSB0aGlzLnBvcnQgPyAnOicgKyB0aGlzLnBvcnQgOiAnJztcbiAgICB2YXIgaCA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG4gICAgdGhpcy5ob3N0ID0gaCArIHA7XG4gICAgdGhpcy5ocmVmICs9IHRoaXMuaG9zdDtcblxuICAgIC8vIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbiAgICAvLyB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxuICAgIGlmIChpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnN1YnN0cigxLCB0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgaWYgKHJlc3RbMF0gIT09ICcvJykge1xuICAgICAgICByZXN0ID0gJy8nICsgcmVzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBub3cgcmVzdCBpcyBzZXQgdG8gdGhlIHBvc3QtaG9zdCBzdHVmZi5cbiAgLy8gY2hvcCBvZmYgYW55IGRlbGltIGNoYXJzLlxuICBpZiAoIXVuc2FmZVByb3RvY29sW2xvd2VyUHJvdG9dKSB7XG5cbiAgICAvLyBGaXJzdCwgbWFrZSAxMDAlIHN1cmUgdGhhdCBhbnkgXCJhdXRvRXNjYXBlXCIgY2hhcnMgZ2V0XG4gICAgLy8gZXNjYXBlZCwgZXZlbiBpZiBlbmNvZGVVUklDb21wb25lbnQgZG9lc24ndCB0aGluayB0aGV5XG4gICAgLy8gbmVlZCB0byBiZS5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF1dG9Fc2NhcGUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYWUgPSBhdXRvRXNjYXBlW2ldO1xuICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSk7XG4gICAgICBpZiAoZXNjID09PSBhZSkge1xuICAgICAgICBlc2MgPSBlc2NhcGUoYWUpO1xuICAgICAgfVxuICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcbiAgICB9XG4gIH1cblxuXG4gIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG4gIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoICE9PSAtMSkge1xuICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgIHRoaXMucXVlcnkgPSByZXN0LnN1YnN0cihxbSArIDEpO1xuICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5xdWVyeSk7XG4gICAgfVxuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgLy8gbm8gcXVlcnkgc3RyaW5nLCBidXQgcGFyc2VRdWVyeVN0cmluZyBzdGlsbCByZXF1ZXN0ZWRcbiAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgdGhpcy5wYXRobmFtZSA9IHJlc3Q7XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkge1xuICAgIHZhciBwID0gdGhpcy5wYXRobmFtZSB8fCAnJztcbiAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8ICcnO1xuICAgIHRoaXMucGF0aCA9IHAgKyBzO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIHRoaXMuaHJlZiA9IHRoaXMuZm9ybWF0KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xuZnVuY3Rpb24gdXJsRm9ybWF0KG9iaikge1xuICAvLyBlbnN1cmUgaXQncyBhbiBvYmplY3QsIGFuZCBub3QgYSBzdHJpbmcgdXJsLlxuICAvLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxuICAvLyB0aGlzIHdheSwgeW91IGNhbiBjYWxsIHVybF9mb3JtYXQoKSBvbiBzdHJpbmdzXG4gIC8vIHRvIGNsZWFuIHVwIHBvdGVudGlhbGx5IHdvbmt5IHVybHMuXG4gIGlmIChpc1N0cmluZyhvYmopKSBvYmogPSB1cmxQYXJzZShvYmopO1xuICBpZiAoIShvYmogaW5zdGFuY2VvZiBVcmwpKSByZXR1cm4gVXJsLnByb3RvdHlwZS5mb3JtYXQuY2FsbChvYmopO1xuICByZXR1cm4gb2JqLmZvcm1hdCgpO1xufVxuXG5VcmwucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXV0aCA9IHRoaXMuYXV0aCB8fCAnJztcbiAgaWYgKGF1dGgpIHtcbiAgICBhdXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIGF1dGggPSBhdXRoLnJlcGxhY2UoLyUzQS9pLCAnOicpO1xuICAgIGF1dGggKz0gJ0AnO1xuICB9XG5cbiAgdmFyIHByb3RvY29sID0gdGhpcy5wcm90b2NvbCB8fCAnJyxcbiAgICAgIHBhdGhuYW1lID0gdGhpcy5wYXRobmFtZSB8fCAnJyxcbiAgICAgIGhhc2ggPSB0aGlzLmhhc2ggfHwgJycsXG4gICAgICBob3N0ID0gZmFsc2UsXG4gICAgICBxdWVyeSA9ICcnO1xuXG4gIGlmICh0aGlzLmhvc3QpIHtcbiAgICBob3N0ID0gYXV0aCArIHRoaXMuaG9zdDtcbiAgfSBlbHNlIGlmICh0aGlzLmhvc3RuYW1lKSB7XG4gICAgaG9zdCA9IGF1dGggKyAodGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgPT09IC0xID9cbiAgICAgICAgdGhpcy5ob3N0bmFtZSA6XG4gICAgICAgICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScpO1xuICAgIGlmICh0aGlzLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdGhpcy5wb3J0O1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnF1ZXJ5ICYmXG4gICAgICBpc09iamVjdCh0aGlzLnF1ZXJ5KSAmJlxuICAgICAgT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSk7XG4gIH1cblxuICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgKHF1ZXJ5ICYmICgnPycgKyBxdWVyeSkpIHx8ICcnO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICAvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cbiAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC5cbiAgaWYgKHRoaXMuc2xhc2hlcyB8fFxuICAgICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICB9KTtcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG5cbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIHJldHVybiB0aGlzLnJlc29sdmVPYmplY3QodXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmVPYmplY3QocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmVPYmplY3QgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICBpZiAoaXNTdHJpbmcocmVsYXRpdmUpKSB7XG4gICAgdmFyIHJlbCA9IG5ldyBVcmwoKTtcbiAgICByZWwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKTtcbiAgICByZWxhdGl2ZSA9IHJlbDtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBuZXcgVXJsKCk7XG4gIE9iamVjdC5rZXlzKHRoaXMpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgIHJlc3VsdFtrXSA9IHRoaXNba107XG4gIH0sIHRoaXMpO1xuXG4gIC8vIGhhc2ggaXMgYWx3YXlzIG92ZXJyaWRkZW4sIG5vIG1hdHRlciB3aGF0LlxuICAvLyBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cbiAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gIC8vIGlmIHRoZSByZWxhdGl2ZSB1cmwgaXMgZW1wdHksIHRoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cbiAgaWYgKHJlbGF0aXZlLmhyZWYgPT09ICcnKSB7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAvLyB0YWtlIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZSBwcm90b2NvbCBmcm9tIHJlbGF0aXZlXG4gICAgT2JqZWN0LmtleXMocmVsYXRpdmUpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgaWYgKGsgIT09ICdwcm90b2NvbCcpXG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgIH0pO1xuXG4gICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICBpZiAoc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0gJiZcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGhuYW1lID0gJy8nO1xuICAgIH1cblxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIE9iamVjdC5rZXlzKHJlbGF0aXZlKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICB9KTtcbiAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXN1bHQucHJvdG9jb2wgPSByZWxhdGl2ZS5wcm90b2NvbDtcbiAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIWhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTtcbiAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTtcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9ICcnO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJztcbiAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxQYXRoLmpvaW4oJy8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsYXRpdmUucGF0aG5hbWU7XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8ICcnO1xuICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0O1xuICAgIHJlc3VsdC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQucGF0aG5hbWUgfHwgcmVzdWx0LnNlYXJjaCkge1xuICAgICAgdmFyIHAgPSByZXN1bHQucGF0aG5hbWUgfHwgJyc7XG4gICAgICB2YXIgcyA9IHJlc3VsdC5zZWFyY2ggfHwgJyc7XG4gICAgICByZXN1bHQucGF0aCA9IHAgKyBzO1xuICAgIH1cbiAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBpc1NvdXJjZUFicyA9IChyZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSxcbiAgICAgIGlzUmVsQWJzID0gKFxuICAgICAgICAgIHJlbGF0aXZlLmhvc3QgfHxcbiAgICAgICAgICByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJ1xuICAgICAgKSxcbiAgICAgIG11c3RFbmRBYnMgPSAoaXNSZWxBYnMgfHwgaXNTb3VyY2VBYnMgfHxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5ob3N0ICYmIHJlbGF0aXZlLnBhdGhuYW1lKSksXG4gICAgICByZW1vdmVBbGxEb3RzID0gbXVzdEVuZEFicyxcbiAgICAgIHNyY1BhdGggPSByZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICByZWxQYXRoID0gcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHBzeWNob3RpYyA9IHJlc3VsdC5wcm90b2NvbCAmJiAhc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF07XG5cbiAgLy8gaWYgdGhlIHVybCBpcyBhIG5vbi1zbGFzaGVkIHVybCwgdGhlbiByZWxhdGl2ZVxuICAvLyBsaW5rcyBsaWtlIC4uLy4uIHNob3VsZCBiZSBhYmxlXG4gIC8vIHRvIGNyYXdsIHVwIHRvIHRoZSBob3N0bmFtZSwgYXMgd2VsbC4gIFRoaXMgaXMgc3RyYW5nZS5cbiAgLy8gcmVzdWx0LnByb3RvY29sIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IG5vdy5cbiAgLy8gTGF0ZXIgb24sIHB1dCB0aGUgZmlyc3QgcGF0aCBwYXJ0IGludG8gdGhlIGhvc3QgZmllbGQuXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAnJztcbiAgICByZXN1bHQucG9ydCA9IG51bGw7XG4gICAgaWYgKHJlc3VsdC5ob3N0KSB7XG4gICAgICBpZiAoc3JjUGF0aFswXSA9PT0gJycpIHNyY1BhdGhbMF0gPSByZXN1bHQuaG9zdDtcbiAgICAgIGVsc2Ugc3JjUGF0aC51bnNoaWZ0KHJlc3VsdC5ob3N0KTtcbiAgICB9XG4gICAgcmVzdWx0Lmhvc3QgPSAnJztcbiAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAgIHJlbGF0aXZlLmhvc3RuYW1lID0gbnVsbDtcbiAgICAgIHJlbGF0aXZlLnBvcnQgPSBudWxsO1xuICAgICAgaWYgKHJlbGF0aXZlLmhvc3QpIHtcbiAgICAgICAgaWYgKHJlbFBhdGhbMF0gPT09ICcnKSByZWxQYXRoWzBdID0gcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgZWxzZSByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7XG4gICAgICB9XG4gICAgICByZWxhdGl2ZS5ob3N0ID0gbnVsbDtcbiAgICB9XG4gICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgJiYgKHJlbFBhdGhbMF0gPT09ICcnIHx8IHNyY1BhdGhbMF0gPT09ICcnKTtcbiAgfVxuXG4gIGlmIChpc1JlbEFicykge1xuICAgIC8vIGl0J3MgYWJzb2x1dGUuXG4gICAgcmVzdWx0Lmhvc3QgPSAocmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5ob3N0ID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA6IHJlc3VsdC5ob3N0O1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IChyZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0bmFtZSA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA6IHJlc3VsdC5ob3N0bmFtZTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNyY1BhdGggPSByZWxQYXRoO1xuICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxuICB9IGVsc2UgaWYgKHJlbFBhdGgubGVuZ3RoKSB7XG4gICAgLy8gaXQncyByZWxhdGl2ZVxuICAgIC8vIHRocm93IGF3YXkgdGhlIGV4aXN0aW5nIGZpbGUsIGFuZCB0YWtlIHRoZSBuZXcgcGF0aCBpbnN0ZWFkLlxuICAgIGlmICghc3JjUGF0aCkgc3JjUGF0aCA9IFtdO1xuICAgIHNyY1BhdGgucG9wKCk7XG4gICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gIH0gZWxzZSBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHJlbGF0aXZlLnNlYXJjaCkpIHtcbiAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAvLyBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgIC8vdGhpcyBlc3BlY2lhbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoIWlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICFpc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnNlYXJjaCkge1xuICAgICAgcmVzdWx0LnBhdGggPSAnLycgKyByZXN1bHQuc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXG4gIC8vIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIHZhciBsYXN0ID0gc3JjUGF0aC5zbGljZSgtMSlbMF07XG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gKFxuICAgICAgKHJlc3VsdC5ob3N0IHx8IHJlbGF0aXZlLmhvc3QpICYmIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgfHxcbiAgICAgIGxhc3QgPT09ICcnKTtcblxuICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICBpZiAobGFzdCA9PSAnLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgc3JjUGF0aC51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtdXN0RW5kQWJzICYmIHNyY1BhdGhbMF0gIT09ICcnICYmXG4gICAgICAoIXNyY1BhdGhbMF0gfHwgc3JjUGF0aFswXS5jaGFyQXQoMCkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgKHNyY1BhdGguam9pbignLycpLnN1YnN0cigtMSkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnB1c2goJycpO1xuICB9XG5cbiAgdmFyIGlzQWJzb2x1dGUgPSBzcmNQYXRoWzBdID09PSAnJyB8fFxuICAgICAgKHNyY1BhdGhbMF0gJiYgc3JjUGF0aFswXS5jaGFyQXQoMCkgPT09ICcvJyk7XG5cbiAgLy8gcHV0IHRoZSBob3N0IGJhY2tcbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gaXNBYnNvbHV0ZSA/ICcnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1BhdGgubGVuZ3RoID8gc3JjUGF0aC5zaGlmdCgpIDogJyc7XG4gICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgIC8vdGhpcyBlc3BlY2lhbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgIH1cbiAgfVxuXG4gIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IHJlcXVlc3QuaHR0cFxuICBpZiAoIWlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICFpc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICB9XG4gIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aDtcbiAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBob3N0ID0gdGhpcy5ob3N0O1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7XG59O1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09IFwic3RyaW5nXCI7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuICBhcmcgPT0gbnVsbDtcbn1cblxufSx7XCJwdW55Y29kZVwiOjMwLFwicXVlcnlzdHJpbmdcIjozM31dLDQ4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn1cbn0se31dLDQ5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gX2RlcmVxXygnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IF9kZXJlcV8oJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG59KS5jYWxsKHRoaXMsX2RlcmVxXyhcIi9ob21lL2FsZXgvcHJvamVjdHMvamF2YXNjcmlwdC9pbWpzL25vZGVfbW9kdWxlcy9pbnNlcnQtbW9kdWxlLWdsb2JhbHMvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1wiKSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7XCIuL3N1cHBvcnQvaXNCdWZmZXJcIjo0OCxcIi9ob21lL2FsZXgvcHJvamVjdHMvamF2YXNjcmlwdC9pbWpzL25vZGVfbW9kdWxlcy9pbnNlcnQtbW9kdWxlLWdsb2JhbHMvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1wiOjU1LFwiaW5oZXJpdHNcIjoyOH1dLDUwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBodHRwID0gbW9kdWxlLmV4cG9ydHM7XG52YXIgRXZlbnRFbWl0dGVyID0gX2RlcmVxXygnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIFJlcXVlc3QgPSBfZGVyZXFfKCcuL2xpYi9yZXF1ZXN0Jyk7XG52YXIgdXJsID0gX2RlcmVxXygndXJsJylcblxuaHR0cC5yZXF1ZXN0ID0gZnVuY3Rpb24gKHBhcmFtcywgY2IpIHtcbiAgICBpZiAodHlwZW9mIHBhcmFtcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGFyYW1zID0gdXJsLnBhcnNlKHBhcmFtcylcbiAgICB9XG4gICAgaWYgKCFwYXJhbXMpIHBhcmFtcyA9IHt9O1xuICAgIGlmICghcGFyYW1zLmhvc3QgJiYgIXBhcmFtcy5wb3J0KSB7XG4gICAgICAgIHBhcmFtcy5wb3J0ID0gcGFyc2VJbnQod2luZG93LmxvY2F0aW9uLnBvcnQsIDEwKTtcbiAgICB9XG4gICAgaWYgKCFwYXJhbXMuaG9zdCAmJiBwYXJhbXMuaG9zdG5hbWUpIHtcbiAgICAgICAgcGFyYW1zLmhvc3QgPSBwYXJhbXMuaG9zdG5hbWU7XG4gICAgfVxuXG4gICAgaWYgKCFwYXJhbXMucHJvdG9jb2wpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5zY2hlbWUpIHtcbiAgICAgICAgICAgIHBhcmFtcy5wcm90b2NvbCA9IHBhcmFtcy5zY2hlbWUgKyAnOic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMucHJvdG9jb2wgPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2w7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXBhcmFtcy5ob3N0KSB7XG4gICAgICAgIHBhcmFtcy5ob3N0ID0gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lIHx8IHdpbmRvdy5sb2NhdGlvbi5ob3N0O1xuICAgIH1cbiAgICBpZiAoLzovLnRlc3QocGFyYW1zLmhvc3QpKSB7XG4gICAgICAgIGlmICghcGFyYW1zLnBvcnQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5wb3J0ID0gcGFyYW1zLmhvc3Quc3BsaXQoJzonKVsxXTtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMuaG9zdCA9IHBhcmFtcy5ob3N0LnNwbGl0KCc6JylbMF07XG4gICAgfVxuICAgIGlmICghcGFyYW1zLnBvcnQpIHBhcmFtcy5wb3J0ID0gcGFyYW1zLnByb3RvY29sID09ICdodHRwczonID8gNDQzIDogODA7XG4gICAgXG4gICAgdmFyIHJlcSA9IG5ldyBSZXF1ZXN0KG5ldyB4aHJIdHRwLCBwYXJhbXMpO1xuICAgIGlmIChjYikgcmVxLm9uKCdyZXNwb25zZScsIGNiKTtcbiAgICByZXR1cm4gcmVxO1xufTtcblxuaHR0cC5nZXQgPSBmdW5jdGlvbiAocGFyYW1zLCBjYikge1xuICAgIHBhcmFtcy5tZXRob2QgPSAnR0VUJztcbiAgICB2YXIgcmVxID0gaHR0cC5yZXF1ZXN0KHBhcmFtcywgY2IpO1xuICAgIHJlcS5lbmQoKTtcbiAgICByZXR1cm4gcmVxO1xufTtcblxuaHR0cC5BZ2VudCA9IGZ1bmN0aW9uICgpIHt9O1xuaHR0cC5BZ2VudC5kZWZhdWx0TWF4U29ja2V0cyA9IDQ7XG5cbnZhciB4aHJIdHRwID0gKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyB3aW5kb3cgb2JqZWN0IHByZXNlbnQnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAod2luZG93LlhNTEh0dHBSZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuWE1MSHR0cFJlcXVlc3Q7XG4gICAgfVxuICAgIGVsc2UgaWYgKHdpbmRvdy5BY3RpdmVYT2JqZWN0KSB7XG4gICAgICAgIHZhciBheHMgPSBbXG4gICAgICAgICAgICAnTXN4bWwyLlhNTEhUVFAuNi4wJyxcbiAgICAgICAgICAgICdNc3htbDIuWE1MSFRUUC4zLjAnLFxuICAgICAgICAgICAgJ01pY3Jvc29mdC5YTUxIVFRQJ1xuICAgICAgICBdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgYXggPSBuZXcod2luZG93LkFjdGl2ZVhPYmplY3QpKGF4c1tpXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXhfID0gYXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBheCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXhfO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyh3aW5kb3cuQWN0aXZlWE9iamVjdCkoYXhzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge31cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FqYXggbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhamF4IG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJyk7XG4gICAgfVxufSkoKTtcblxuaHR0cC5TVEFUVVNfQ09ERVMgPSB7XG4gICAgMTAwIDogJ0NvbnRpbnVlJyxcbiAgICAxMDEgOiAnU3dpdGNoaW5nIFByb3RvY29scycsXG4gICAgMTAyIDogJ1Byb2Nlc3NpbmcnLCAgICAgICAgICAgICAgICAgLy8gUkZDIDI1MTgsIG9ic29sZXRlZCBieSBSRkMgNDkxOFxuICAgIDIwMCA6ICdPSycsXG4gICAgMjAxIDogJ0NyZWF0ZWQnLFxuICAgIDIwMiA6ICdBY2NlcHRlZCcsXG4gICAgMjAzIDogJ05vbi1BdXRob3JpdGF0aXZlIEluZm9ybWF0aW9uJyxcbiAgICAyMDQgOiAnTm8gQ29udGVudCcsXG4gICAgMjA1IDogJ1Jlc2V0IENvbnRlbnQnLFxuICAgIDIwNiA6ICdQYXJ0aWFsIENvbnRlbnQnLFxuICAgIDIwNyA6ICdNdWx0aS1TdGF0dXMnLCAgICAgICAgICAgICAgIC8vIFJGQyA0OTE4XG4gICAgMzAwIDogJ011bHRpcGxlIENob2ljZXMnLFxuICAgIDMwMSA6ICdNb3ZlZCBQZXJtYW5lbnRseScsXG4gICAgMzAyIDogJ01vdmVkIFRlbXBvcmFyaWx5JyxcbiAgICAzMDMgOiAnU2VlIE90aGVyJyxcbiAgICAzMDQgOiAnTm90IE1vZGlmaWVkJyxcbiAgICAzMDUgOiAnVXNlIFByb3h5JyxcbiAgICAzMDcgOiAnVGVtcG9yYXJ5IFJlZGlyZWN0JyxcbiAgICA0MDAgOiAnQmFkIFJlcXVlc3QnLFxuICAgIDQwMSA6ICdVbmF1dGhvcml6ZWQnLFxuICAgIDQwMiA6ICdQYXltZW50IFJlcXVpcmVkJyxcbiAgICA0MDMgOiAnRm9yYmlkZGVuJyxcbiAgICA0MDQgOiAnTm90IEZvdW5kJyxcbiAgICA0MDUgOiAnTWV0aG9kIE5vdCBBbGxvd2VkJyxcbiAgICA0MDYgOiAnTm90IEFjY2VwdGFibGUnLFxuICAgIDQwNyA6ICdQcm94eSBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZCcsXG4gICAgNDA4IDogJ1JlcXVlc3QgVGltZS1vdXQnLFxuICAgIDQwOSA6ICdDb25mbGljdCcsXG4gICAgNDEwIDogJ0dvbmUnLFxuICAgIDQxMSA6ICdMZW5ndGggUmVxdWlyZWQnLFxuICAgIDQxMiA6ICdQcmVjb25kaXRpb24gRmFpbGVkJyxcbiAgICA0MTMgOiAnUmVxdWVzdCBFbnRpdHkgVG9vIExhcmdlJyxcbiAgICA0MTQgOiAnUmVxdWVzdC1VUkkgVG9vIExhcmdlJyxcbiAgICA0MTUgOiAnVW5zdXBwb3J0ZWQgTWVkaWEgVHlwZScsXG4gICAgNDE2IDogJ1JlcXVlc3RlZCBSYW5nZSBOb3QgU2F0aXNmaWFibGUnLFxuICAgIDQxNyA6ICdFeHBlY3RhdGlvbiBGYWlsZWQnLFxuICAgIDQxOCA6ICdJXFwnbSBhIHRlYXBvdCcsICAgICAgICAgICAgICAvLyBSRkMgMjMyNFxuICAgIDQyMiA6ICdVbnByb2Nlc3NhYmxlIEVudGl0eScsICAgICAgIC8vIFJGQyA0OTE4XG4gICAgNDIzIDogJ0xvY2tlZCcsICAgICAgICAgICAgICAgICAgICAgLy8gUkZDIDQ5MThcbiAgICA0MjQgOiAnRmFpbGVkIERlcGVuZGVuY3knLCAgICAgICAgICAvLyBSRkMgNDkxOFxuICAgIDQyNSA6ICdVbm9yZGVyZWQgQ29sbGVjdGlvbicsICAgICAgIC8vIFJGQyA0OTE4XG4gICAgNDI2IDogJ1VwZ3JhZGUgUmVxdWlyZWQnLCAgICAgICAgICAgLy8gUkZDIDI4MTdcbiAgICA0MjggOiAnUHJlY29uZGl0aW9uIFJlcXVpcmVkJywgICAgICAvLyBSRkMgNjU4NVxuICAgIDQyOSA6ICdUb28gTWFueSBSZXF1ZXN0cycsICAgICAgICAgIC8vIFJGQyA2NTg1XG4gICAgNDMxIDogJ1JlcXVlc3QgSGVhZGVyIEZpZWxkcyBUb28gTGFyZ2UnLC8vIFJGQyA2NTg1XG4gICAgNTAwIDogJ0ludGVybmFsIFNlcnZlciBFcnJvcicsXG4gICAgNTAxIDogJ05vdCBJbXBsZW1lbnRlZCcsXG4gICAgNTAyIDogJ0JhZCBHYXRld2F5JyxcbiAgICA1MDMgOiAnU2VydmljZSBVbmF2YWlsYWJsZScsXG4gICAgNTA0IDogJ0dhdGV3YXkgVGltZS1vdXQnLFxuICAgIDUwNSA6ICdIVFRQIFZlcnNpb24gTm90IFN1cHBvcnRlZCcsXG4gICAgNTA2IDogJ1ZhcmlhbnQgQWxzbyBOZWdvdGlhdGVzJywgICAgLy8gUkZDIDIyOTVcbiAgICA1MDcgOiAnSW5zdWZmaWNpZW50IFN0b3JhZ2UnLCAgICAgICAvLyBSRkMgNDkxOFxuICAgIDUwOSA6ICdCYW5kd2lkdGggTGltaXQgRXhjZWVkZWQnLFxuICAgIDUxMCA6ICdOb3QgRXh0ZW5kZWQnLCAgICAgICAgICAgICAgIC8vIFJGQyAyNzc0XG4gICAgNTExIDogJ05ldHdvcmsgQXV0aGVudGljYXRpb24gUmVxdWlyZWQnIC8vIFJGQyA2NTg1XG59O1xufSx7XCIuL2xpYi9yZXF1ZXN0XCI6NTEsXCJldmVudHNcIjoyNyxcInVybFwiOjQ3fV0sNTE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIFN0cmVhbSA9IF9kZXJlcV8oJ3N0cmVhbScpO1xudmFyIFJlc3BvbnNlID0gX2RlcmVxXygnLi9yZXNwb25zZScpO1xudmFyIEJhc2U2NCA9IF9kZXJlcV8oJ0Jhc2U2NCcpO1xudmFyIGluaGVyaXRzID0gX2RlcmVxXygnaW5oZXJpdHMnKTtcblxudmFyIFJlcXVlc3QgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh4aHIsIHBhcmFtcykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBzZWxmLnhociA9IHhocjtcbiAgICBzZWxmLmJvZHkgPSBbXTtcbiAgICBcbiAgICBzZWxmLnVyaSA9IChwYXJhbXMucHJvdG9jb2wgfHwgJ2h0dHA6JykgKyAnLy8nXG4gICAgICAgICsgcGFyYW1zLmhvc3RcbiAgICAgICAgKyAocGFyYW1zLnBvcnQgPyAnOicgKyBwYXJhbXMucG9ydCA6ICcnKVxuICAgICAgICArIChwYXJhbXMucGF0aCB8fCAnLycpXG4gICAgO1xuICAgIFxuICAgIGlmICh0eXBlb2YgcGFyYW1zLndpdGhDcmVkZW50aWFscyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcGFyYW1zLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgfVxuXG4gICAgdHJ5IHsgeGhyLndpdGhDcmVkZW50aWFscyA9IHBhcmFtcy53aXRoQ3JlZGVudGlhbHMgfVxuICAgIGNhdGNoIChlKSB7fVxuICAgIFxuICAgIGlmIChwYXJhbXMucmVzcG9uc2VUeXBlKSB0cnkgeyB4aHIucmVzcG9uc2VUeXBlID0gcGFyYW1zLnJlc3BvbnNlVHlwZSB9XG4gICAgY2F0Y2ggKGUpIHt9XG4gICAgXG4gICAgeGhyLm9wZW4oXG4gICAgICAgIHBhcmFtcy5tZXRob2QgfHwgJ0dFVCcsXG4gICAgICAgIHNlbGYudXJpLFxuICAgICAgICB0cnVlXG4gICAgKTtcblxuICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignTmV0d29yayBlcnJvcicpKTtcbiAgICB9O1xuXG4gICAgc2VsZi5faGVhZGVycyA9IHt9O1xuICAgIFxuICAgIGlmIChwYXJhbXMuaGVhZGVycykge1xuICAgICAgICB2YXIga2V5cyA9IG9iamVjdEtleXMocGFyYW1zLmhlYWRlcnMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgaWYgKCFzZWxmLmlzU2FmZVJlcXVlc3RIZWFkZXIoa2V5KSkgY29udGludWU7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJhbXMuaGVhZGVyc1trZXldO1xuICAgICAgICAgICAgc2VsZi5zZXRIZWFkZXIoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYgKHBhcmFtcy5hdXRoKSB7XG4gICAgICAgIC8vYmFzaWMgYXV0aFxuICAgICAgICB0aGlzLnNldEhlYWRlcignQXV0aG9yaXphdGlvbicsICdCYXNpYyAnICsgQmFzZTY0LmJ0b2EocGFyYW1zLmF1dGgpKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzID0gbmV3IFJlc3BvbnNlO1xuICAgIHJlcy5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuZW1pdCgnY2xvc2UnKTtcbiAgICB9KTtcbiAgICBcbiAgICByZXMub24oJ3JlYWR5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLmVtaXQoJ3Jlc3BvbnNlJywgcmVzKTtcbiAgICB9KTtcblxuICAgIHJlcy5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH0pO1xuICAgIFxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEZpeCBmb3IgSUU5IGJ1Z1xuICAgICAgICAvLyBTQ1JJUFQ1NzU6IENvdWxkIG5vdCBjb21wbGV0ZSB0aGUgb3BlcmF0aW9uIGR1ZSB0byBlcnJvciBjMDBjMDIzZlxuICAgICAgICAvLyBJdCBoYXBwZW5zIHdoZW4gYSByZXF1ZXN0IGlzIGFib3J0ZWQsIGNhbGxpbmcgdGhlIHN1Y2Nlc3MgY2FsbGJhY2sgYW55d2F5IHdpdGggcmVhZHlTdGF0ZSA9PT0gNFxuICAgICAgICBpZiAoeGhyLl9fYWJvcnRlZCkgcmV0dXJuO1xuICAgICAgICByZXMuaGFuZGxlKHhocik7XG4gICAgfTtcbn07XG5cbmluaGVyaXRzKFJlcXVlc3QsIFN0cmVhbSk7XG5cblJlcXVlc3QucHJvdG90eXBlLnNldEhlYWRlciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5faGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZVxufTtcblxuUmVxdWVzdC5wcm90b3R5cGUuZ2V0SGVhZGVyID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXVxufTtcblxuUmVxdWVzdC5wcm90b3R5cGUucmVtb3ZlSGVhZGVyID0gZnVuY3Rpb24gKGtleSkge1xuICAgIGRlbGV0ZSB0aGlzLl9oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXVxufTtcblxuUmVxdWVzdC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAocykge1xuICAgIHRoaXMuYm9keS5wdXNoKHMpO1xufTtcblxuUmVxdWVzdC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgdGhpcy54aHIuX19hYm9ydGVkID0gdHJ1ZTtcbiAgICB0aGlzLnhoci5hYm9ydCgpO1xuICAgIHRoaXMuZW1pdCgnY2xvc2UnKTtcbn07XG5cblJlcXVlc3QucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChzKSB7XG4gICAgaWYgKHMgIT09IHVuZGVmaW5lZCkgdGhpcy5ib2R5LnB1c2gocyk7XG5cbiAgICB2YXIga2V5cyA9IG9iamVjdEtleXModGhpcy5faGVhZGVycyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9oZWFkZXJzW2tleV07XG4gICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWx1ZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHRoaXMueGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWx1ZVtqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB0aGlzLnhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsdWUpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYm9keS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy54aHIuc2VuZCgnJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLmJvZHlbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMueGhyLnNlbmQodGhpcy5ib2R5LmpvaW4oJycpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBcnJheSh0aGlzLmJvZHlbMF0pKSB7XG4gICAgICAgIHZhciBib2R5ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBib2R5LnB1c2guYXBwbHkoYm9keSwgdGhpcy5ib2R5W2ldKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnhoci5zZW5kKGJvZHkpO1xuICAgIH1cbiAgICBlbHNlIGlmICgvQXJyYXkvLnRlc3QoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaXMuYm9keVswXSkpKSB7XG4gICAgICAgIHZhciBsZW4gPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGVuICs9IHRoaXMuYm9keVtpXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJvZHkgPSBuZXcodGhpcy5ib2R5WzBdLmNvbnN0cnVjdG9yKShsZW4pO1xuICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLmJvZHlbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBib2R5W2srK10gPSBiW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMueGhyLnNlbmQoYm9keSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzWEhSMkNvbXBhdGlibGUodGhpcy5ib2R5WzBdKSkge1xuICAgICAgICB0aGlzLnhoci5zZW5kKHRoaXMuYm9keVswXSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgYm9keSA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYm9keSArPSB0aGlzLmJvZHlbaV0udG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnhoci5zZW5kKGJvZHkpO1xuICAgIH1cbn07XG5cbi8vIFRha2VuIGZyb20gaHR0cDovL2R4ci5tb3ppbGxhLm9yZy9tb3ppbGxhL21vemlsbGEtY2VudHJhbC9jb250ZW50L2Jhc2Uvc3JjL25zWE1MSHR0cFJlcXVlc3QuY3BwLmh0bWxcblJlcXVlc3QudW5zYWZlSGVhZGVycyA9IFtcbiAgICBcImFjY2VwdC1jaGFyc2V0XCIsXG4gICAgXCJhY2NlcHQtZW5jb2RpbmdcIixcbiAgICBcImFjY2Vzcy1jb250cm9sLXJlcXVlc3QtaGVhZGVyc1wiLFxuICAgIFwiYWNjZXNzLWNvbnRyb2wtcmVxdWVzdC1tZXRob2RcIixcbiAgICBcImNvbm5lY3Rpb25cIixcbiAgICBcImNvbnRlbnQtbGVuZ3RoXCIsXG4gICAgXCJjb29raWVcIixcbiAgICBcImNvb2tpZTJcIixcbiAgICBcImNvbnRlbnQtdHJhbnNmZXItZW5jb2RpbmdcIixcbiAgICBcImRhdGVcIixcbiAgICBcImV4cGVjdFwiLFxuICAgIFwiaG9zdFwiLFxuICAgIFwia2VlcC1hbGl2ZVwiLFxuICAgIFwib3JpZ2luXCIsXG4gICAgXCJyZWZlcmVyXCIsXG4gICAgXCJ0ZVwiLFxuICAgIFwidHJhaWxlclwiLFxuICAgIFwidHJhbnNmZXItZW5jb2RpbmdcIixcbiAgICBcInVwZ3JhZGVcIixcbiAgICBcInVzZXItYWdlbnRcIixcbiAgICBcInZpYVwiXG5dO1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5pc1NhZmVSZXF1ZXN0SGVhZGVyID0gZnVuY3Rpb24gKGhlYWRlck5hbWUpIHtcbiAgICBpZiAoIWhlYWRlck5hbWUpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gaW5kZXhPZihSZXF1ZXN0LnVuc2FmZUhlYWRlcnMsIGhlYWRlck5hbWUudG9Mb3dlckNhc2UoKSkgPT09IC0xO1xufTtcblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgICByZXR1cm4ga2V5cztcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbnZhciBpbmRleE9mID0gZnVuY3Rpb24gKHhzLCB4KSB7XG4gICAgaWYgKHhzLmluZGV4T2YpIHJldHVybiB4cy5pbmRleE9mKHgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufTtcblxudmFyIGlzWEhSMkNvbXBhdGlibGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgcmV0dXJuIHRydWU7XG4gICAgaWYgKHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcgJiYgb2JqIGluc3RhbmNlb2YgRm9ybURhdGEpIHJldHVybiB0cnVlO1xufTtcblxufSx7XCIuL3Jlc3BvbnNlXCI6NTIsXCJCYXNlNjRcIjo1MyxcImluaGVyaXRzXCI6NTQsXCJzdHJlYW1cIjo0NX1dLDUyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBTdHJlYW0gPSBfZGVyZXFfKCdzdHJlYW0nKTtcbnZhciB1dGlsID0gX2RlcmVxXygndXRpbCcpO1xuXG52YXIgUmVzcG9uc2UgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyZXMpIHtcbiAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG59O1xuXG51dGlsLmluaGVyaXRzKFJlc3BvbnNlLCBTdHJlYW0pO1xuXG52YXIgY2FwYWJsZSA9IHtcbiAgICBzdHJlYW1pbmcgOiB0cnVlLFxuICAgIHN0YXR1czIgOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBwYXJzZUhlYWRlcnMgKHJlcykge1xuICAgIHZhciBsaW5lcyA9IHJlcy5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKS5zcGxpdCgvXFxyP1xcbi8pO1xuICAgIHZhciBoZWFkZXJzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgICBpZiAobGluZSA9PT0gJycpIGNvbnRpbnVlO1xuICAgICAgICBcbiAgICAgICAgdmFyIG0gPSBsaW5lLm1hdGNoKC9eKFteOl0rKTpcXHMqKC4qKS8pO1xuICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IG1bMV0udG9Mb3dlckNhc2UoKSwgdmFsdWUgPSBtWzJdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoaGVhZGVyc1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KGhlYWRlcnNba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1trZXldLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1trZXldID0gWyBoZWFkZXJzW2tleV0sIHZhbHVlIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoZWFkZXJzW2xpbmVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGVhZGVycztcbn1cblxuUmVzcG9uc2UucHJvdG90eXBlLmdldFJlc3BvbnNlID0gZnVuY3Rpb24gKHhocikge1xuICAgIHZhciByZXNwVHlwZSA9IFN0cmluZyh4aHIucmVzcG9uc2VUeXBlKS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChyZXNwVHlwZSA9PT0gJ2Jsb2InKSByZXR1cm4geGhyLnJlc3BvbnNlQmxvYiB8fCB4aHIucmVzcG9uc2U7XG4gICAgaWYgKHJlc3BUeXBlID09PSAnYXJyYXlidWZmZXInKSByZXR1cm4geGhyLnJlc3BvbnNlO1xuICAgIHJldHVybiB4aHIucmVzcG9uc2VUZXh0O1xufVxuXG5SZXNwb25zZS5wcm90b3R5cGUuZ2V0SGVhZGVyID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzLmhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldO1xufTtcblxuUmVzcG9uc2UucHJvdG90eXBlLmhhbmRsZSA9IGZ1bmN0aW9uIChyZXMpIHtcbiAgICBpZiAocmVzLnJlYWR5U3RhdGUgPT09IDIgJiYgY2FwYWJsZS5zdGF0dXMyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1c0NvZGUgPSByZXMuc3RhdHVzO1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzID0gcGFyc2VIZWFkZXJzKHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY2FwYWJsZS5zdGF0dXMyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChjYXBhYmxlLnN0YXR1czIpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVhZHknKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChjYXBhYmxlLnN0cmVhbWluZyAmJiByZXMucmVhZHlTdGF0ZSA9PT0gMykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXR1c0NvZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1c0NvZGUgPSByZXMuc3RhdHVzO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVycyA9IHBhcnNlSGVhZGVycyhyZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncmVhZHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7fVxuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXREYXRhKHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY2FwYWJsZS5zdHJlYW1pbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChyZXMucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICBpZiAoIXRoaXMuc3RhdHVzQ29kZSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0dXNDb2RlID0gcmVzLnN0YXR1cztcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVhZHknKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lbWl0RGF0YShyZXMpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHJlcy5lcnJvcikge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHRoaXMuZ2V0UmVzcG9uc2UocmVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB0aGlzLmVtaXQoJ2VuZCcpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5lbWl0KCdjbG9zZScpO1xuICAgIH1cbn07XG5cblJlc3BvbnNlLnByb3RvdHlwZS5fZW1pdERhdGEgPSBmdW5jdGlvbiAocmVzKSB7XG4gICAgdmFyIHJlc3BCb2R5ID0gdGhpcy5nZXRSZXNwb25zZShyZXMpO1xuICAgIGlmIChyZXNwQm9keS50b1N0cmluZygpLm1hdGNoKC9BcnJheUJ1ZmZlci8pKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIG5ldyBVaW50OEFycmF5KHJlc3BCb2R5LCB0aGlzLm9mZnNldCkpO1xuICAgICAgICB0aGlzLm9mZnNldCA9IHJlc3BCb2R5LmJ5dGVMZW5ndGg7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHJlc3BCb2R5Lmxlbmd0aCA+IHRoaXMub2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIHJlc3BCb2R5LnNsaWNlKHRoaXMub2Zmc2V0KSk7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gcmVzcEJvZHkubGVuZ3RoO1xuICAgIH1cbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbn0se1wic3RyZWFtXCI6NDUsXCJ1dGlsXCI6NDl9XSw1MzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG47KGZ1bmN0aW9uICgpIHtcblxuICB2YXIgb2JqZWN0ID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpczsgLy8gIzg6IHdlYiB3b3JrZXJzXG4gIHZhciBjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG5cbiAgZnVuY3Rpb24gSW52YWxpZENoYXJhY3RlckVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB9XG4gIEludmFsaWRDaGFyYWN0ZXJFcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3I7XG4gIEludmFsaWRDaGFyYWN0ZXJFcnJvci5wcm90b3R5cGUubmFtZSA9ICdJbnZhbGlkQ2hhcmFjdGVyRXJyb3InO1xuXG4gIC8vIGVuY29kZXJcbiAgLy8gW2h0dHBzOi8vZ2lzdC5naXRodWIuY29tLzk5OTE2Nl0gYnkgW2h0dHBzOi8vZ2l0aHViLmNvbS9uaWduYWddXG4gIG9iamVjdC5idG9hIHx8IChcbiAgb2JqZWN0LmJ0b2EgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBmb3IgKFxuICAgICAgLy8gaW5pdGlhbGl6ZSByZXN1bHQgYW5kIGNvdW50ZXJcbiAgICAgIHZhciBibG9jaywgY2hhckNvZGUsIGlkeCA9IDAsIG1hcCA9IGNoYXJzLCBvdXRwdXQgPSAnJztcbiAgICAgIC8vIGlmIHRoZSBuZXh0IGlucHV0IGluZGV4IGRvZXMgbm90IGV4aXN0OlxuICAgICAgLy8gICBjaGFuZ2UgdGhlIG1hcHBpbmcgdGFibGUgdG8gXCI9XCJcbiAgICAgIC8vICAgY2hlY2sgaWYgZCBoYXMgbm8gZnJhY3Rpb25hbCBkaWdpdHNcbiAgICAgIGlucHV0LmNoYXJBdChpZHggfCAwKSB8fCAobWFwID0gJz0nLCBpZHggJSAxKTtcbiAgICAgIC8vIFwiOCAtIGlkeCAlIDEgKiA4XCIgZ2VuZXJhdGVzIHRoZSBzZXF1ZW5jZSAyLCA0LCA2LCA4XG4gICAgICBvdXRwdXQgKz0gbWFwLmNoYXJBdCg2MyAmIGJsb2NrID4+IDggLSBpZHggJSAxICogOClcbiAgICApIHtcbiAgICAgIGNoYXJDb2RlID0gaW5wdXQuY2hhckNvZGVBdChpZHggKz0gMy80KTtcbiAgICAgIGlmIChjaGFyQ29kZSA+IDB4RkYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRDaGFyYWN0ZXJFcnJvcihcIididG9hJyBmYWlsZWQ6IFRoZSBzdHJpbmcgdG8gYmUgZW5jb2RlZCBjb250YWlucyBjaGFyYWN0ZXJzIG91dHNpZGUgb2YgdGhlIExhdGluMSByYW5nZS5cIik7XG4gICAgICB9XG4gICAgICBibG9jayA9IGJsb2NrIDw8IDggfCBjaGFyQ29kZTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfSk7XG5cbiAgLy8gZGVjb2RlclxuICAvLyBbaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vMTAyMDM5Nl0gYnkgW2h0dHBzOi8vZ2l0aHViLmNvbS9hdGtdXG4gIG9iamVjdC5hdG9iIHx8IChcbiAgb2JqZWN0LmF0b2IgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoLz0rJC8sICcnKTtcbiAgICBpZiAoaW5wdXQubGVuZ3RoICUgNCA9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZENoYXJhY3RlckVycm9yKFwiJ2F0b2InIGZhaWxlZDogVGhlIHN0cmluZyB0byBiZSBkZWNvZGVkIGlzIG5vdCBjb3JyZWN0bHkgZW5jb2RlZC5cIik7XG4gICAgfVxuICAgIGZvciAoXG4gICAgICAvLyBpbml0aWFsaXplIHJlc3VsdCBhbmQgY291bnRlcnNcbiAgICAgIHZhciBiYyA9IDAsIGJzLCBidWZmZXIsIGlkeCA9IDAsIG91dHB1dCA9ICcnO1xuICAgICAgLy8gZ2V0IG5leHQgY2hhcmFjdGVyXG4gICAgICBidWZmZXIgPSBpbnB1dC5jaGFyQXQoaWR4KyspO1xuICAgICAgLy8gY2hhcmFjdGVyIGZvdW5kIGluIHRhYmxlPyBpbml0aWFsaXplIGJpdCBzdG9yYWdlIGFuZCBhZGQgaXRzIGFzY2lpIHZhbHVlO1xuICAgICAgfmJ1ZmZlciAmJiAoYnMgPSBiYyAlIDQgPyBicyAqIDY0ICsgYnVmZmVyIDogYnVmZmVyLFxuICAgICAgICAvLyBhbmQgaWYgbm90IGZpcnN0IG9mIGVhY2ggNCBjaGFyYWN0ZXJzLFxuICAgICAgICAvLyBjb252ZXJ0IHRoZSBmaXJzdCA4IGJpdHMgdG8gb25lIGFzY2lpIGNoYXJhY3RlclxuICAgICAgICBiYysrICUgNCkgPyBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgyNTUgJiBicyA+PiAoLTIgKiBiYyAmIDYpKSA6IDBcbiAgICApIHtcbiAgICAgIC8vIHRyeSB0byBmaW5kIGNoYXJhY3RlciBpbiB0YWJsZSAoMC02Mywgbm90IGZvdW5kID0+IC0xKVxuICAgICAgYnVmZmVyID0gY2hhcnMuaW5kZXhPZihidWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9KTtcblxufSgpKTtcblxufSx7fV0sNTQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHM9X2RlcmVxXygyOClcbn0se1wiL2hvbWUvYWxleC9wcm9qZWN0cy9qYXZhc2NyaXB0L2ltanMvbm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanNcIjoyOH1dLDU1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnByb2Nlc3MubmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW5TZXRJbW1lZGlhdGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5zZXRJbW1lZGlhdGU7XG4gICAgdmFyIGNhblBvc3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lclxuICAgIDtcblxuICAgIGlmIChjYW5TZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmKSB7IHJldHVybiB3aW5kb3cuc2V0SW1tZWRpYXRlKGYpIH07XG4gICAgfVxuXG4gICAgaWYgKGNhblBvc3QpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gZXYuc291cmNlO1xuICAgICAgICAgICAgaWYgKChzb3VyY2UgPT09IHdpbmRvdyB8fCBzb3VyY2UgPT09IG51bGwpICYmIGV2LmRhdGEgPT09ICdwcm9jZXNzLXRpY2snKSB7XG4gICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICAgICAgcXVldWUucHVzaChmbik7XG4gICAgICAgICAgICB3aW5kb3cucG9zdE1lc3NhZ2UoJ3Byb2Nlc3MtdGljaycsICcqJyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgIH07XG59KSgpO1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufVxuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbn0se31dLDU2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG52YXIgU3RyZWFtID0gX2RlcmVxXygnc3RyZWFtJylcblxuLy8gdGhyb3VnaFxuLy9cbi8vIGEgc3RyZWFtIHRoYXQgZG9lcyBub3RoaW5nIGJ1dCByZS1lbWl0IHRoZSBpbnB1dC5cbi8vIHVzZWZ1bCBmb3IgYWdncmVnYXRpbmcgYSBzZXJpZXMgb2YgY2hhbmdpbmcgYnV0IG5vdCBlbmRpbmcgc3RyZWFtcyBpbnRvIG9uZSBzdHJlYW0pXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHRocm91Z2hcbnRocm91Z2gudGhyb3VnaCA9IHRocm91Z2hcblxuLy9jcmVhdGUgYSByZWFkYWJsZSB3cml0YWJsZSBzdHJlYW0uXG5cbmZ1bmN0aW9uIHRocm91Z2ggKHdyaXRlLCBlbmQsIG9wdHMpIHtcbiAgd3JpdGUgPSB3cml0ZSB8fCBmdW5jdGlvbiAoZGF0YSkgeyB0aGlzLnF1ZXVlKGRhdGEpIH1cbiAgZW5kID0gZW5kIHx8IGZ1bmN0aW9uICgpIHsgdGhpcy5xdWV1ZShudWxsKSB9XG5cbiAgdmFyIGVuZGVkID0gZmFsc2UsIGRlc3Ryb3llZCA9IGZhbHNlLCBidWZmZXIgPSBbXSwgX2VuZGVkID0gZmFsc2VcbiAgdmFyIHN0cmVhbSA9IG5ldyBTdHJlYW0oKVxuICBzdHJlYW0ucmVhZGFibGUgPSBzdHJlYW0ud3JpdGFibGUgPSB0cnVlXG4gIHN0cmVhbS5wYXVzZWQgPSBmYWxzZVxuXG4vLyAgc3RyZWFtLmF1dG9QYXVzZSAgID0gIShvcHRzICYmIG9wdHMuYXV0b1BhdXNlICAgPT09IGZhbHNlKVxuICBzdHJlYW0uYXV0b0Rlc3Ryb3kgPSAhKG9wdHMgJiYgb3B0cy5hdXRvRGVzdHJveSA9PT0gZmFsc2UpXG5cbiAgc3RyZWFtLndyaXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB3cml0ZS5jYWxsKHRoaXMsIGRhdGEpXG4gICAgcmV0dXJuICFzdHJlYW0ucGF1c2VkXG4gIH1cblxuICBmdW5jdGlvbiBkcmFpbigpIHtcbiAgICB3aGlsZShidWZmZXIubGVuZ3RoICYmICFzdHJlYW0ucGF1c2VkKSB7XG4gICAgICB2YXIgZGF0YSA9IGJ1ZmZlci5zaGlmdCgpXG4gICAgICBpZihudWxsID09PSBkYXRhKVxuICAgICAgICByZXR1cm4gc3RyZWFtLmVtaXQoJ2VuZCcpXG4gICAgICBlbHNlXG4gICAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgZGF0YSlcbiAgICB9XG4gIH1cblxuICBzdHJlYW0ucXVldWUgPSBzdHJlYW0ucHVzaCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4vLyAgICBjb25zb2xlLmVycm9yKGVuZGVkKVxuICAgIGlmKF9lbmRlZCkgcmV0dXJuIHN0cmVhbVxuICAgIGlmKGRhdGEgPT0gbnVsbCkgX2VuZGVkID0gdHJ1ZVxuICAgIGJ1ZmZlci5wdXNoKGRhdGEpXG4gICAgZHJhaW4oKVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuXG4gIC8vdGhpcyB3aWxsIGJlIHJlZ2lzdGVyZWQgYXMgdGhlIGZpcnN0ICdlbmQnIGxpc3RlbmVyXG4gIC8vbXVzdCBjYWxsIGRlc3Ryb3kgbmV4dCB0aWNrLCB0byBtYWtlIHN1cmUgd2UncmUgYWZ0ZXIgYW55XG4gIC8vc3RyZWFtIHBpcGVkIGZyb20gaGVyZS5cbiAgLy90aGlzIGlzIG9ubHkgYSBwcm9ibGVtIGlmIGVuZCBpcyBub3QgZW1pdHRlZCBzeW5jaHJvbm91c2x5LlxuICAvL2EgbmljZXIgd2F5IHRvIGRvIHRoaXMgaXMgdG8gbWFrZSBzdXJlIHRoaXMgaXMgdGhlIGxhc3QgbGlzdGVuZXIgZm9yICdlbmQnXG5cbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2VcbiAgICBpZighc3RyZWFtLndyaXRhYmxlICYmIHN0cmVhbS5hdXRvRGVzdHJveSlcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBzdHJlYW0uZGVzdHJveSgpXG4gICAgICB9KVxuICB9KVxuXG4gIGZ1bmN0aW9uIF9lbmQgKCkge1xuICAgIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlXG4gICAgZW5kLmNhbGwoc3RyZWFtKVxuICAgIGlmKCFzdHJlYW0ucmVhZGFibGUgJiYgc3RyZWFtLmF1dG9EZXN0cm95KVxuICAgICAgc3RyZWFtLmRlc3Ryb3koKVxuICB9XG5cbiAgc3RyZWFtLmVuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYoZW5kZWQpIHJldHVyblxuICAgIGVuZGVkID0gdHJ1ZVxuICAgIGlmKGFyZ3VtZW50cy5sZW5ndGgpIHN0cmVhbS53cml0ZShkYXRhKVxuICAgIF9lbmQoKSAvLyB3aWxsIGVtaXQgb3IgcXVldWVcbiAgICByZXR1cm4gc3RyZWFtXG4gIH1cblxuICBzdHJlYW0uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZihkZXN0cm95ZWQpIHJldHVyblxuICAgIGRlc3Ryb3llZCA9IHRydWVcbiAgICBlbmRlZCA9IHRydWVcbiAgICBidWZmZXIubGVuZ3RoID0gMFxuICAgIHN0cmVhbS53cml0YWJsZSA9IHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlXG4gICAgc3RyZWFtLmVtaXQoJ2Nsb3NlJylcbiAgICByZXR1cm4gc3RyZWFtXG4gIH1cblxuICBzdHJlYW0ucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoc3RyZWFtLnBhdXNlZCkgcmV0dXJuXG4gICAgc3RyZWFtLnBhdXNlZCA9IHRydWVcbiAgICByZXR1cm4gc3RyZWFtXG4gIH1cblxuICBzdHJlYW0ucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKHN0cmVhbS5wYXVzZWQpIHtcbiAgICAgIHN0cmVhbS5wYXVzZWQgPSBmYWxzZVxuICAgICAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpXG4gICAgfVxuICAgIGRyYWluKClcbiAgICAvL21heSBoYXZlIGJlY29tZSBwYXVzZWQgYWdhaW4sXG4gICAgLy9hcyBkcmFpbiBlbWl0cyAnZGF0YScuXG4gICAgaWYoIXN0cmVhbS5wYXVzZWQpXG4gICAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuICByZXR1cm4gc3RyZWFtXG59XG5cblxufSkuY2FsbCh0aGlzLF9kZXJlcV8oXCIvaG9tZS9hbGV4L3Byb2plY3RzL2phdmFzY3JpcHQvaW1qcy9ub2RlX21vZHVsZXMvaW5zZXJ0LW1vZHVsZS1nbG9iYWxzL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcIikpXG59LHtcIi9ob21lL2FsZXgvcHJvamVjdHMvamF2YXNjcmlwdC9pbWpzL25vZGVfbW9kdWxlcy9pbnNlcnQtbW9kdWxlLWdsb2JhbHMvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1wiOjU1LFwic3RyZWFtXCI6NDV9XX0se30sWzJdKSgyKVxufSk7XG59KSh3aW5kb3cuaW50ZXJtaW5lKTsiLCJtb2R1bGUuZXhwb3J0cz1be1xuICBcInNlbGVjdG9yXCI6IFwibm9kZVwiLFxuICBcInN0eWxlXCI6IHtcbiAgICBcImNvbnRlbnRcIjogXCJkYXRhKGxhYmVsKVwiXG4gIH1cbn0sIHtcbiAgXCJzZWxlY3RvclwiOiBcIjpzZWxlY3RlZFwiLFxuICBcInN0eWxlXCI6IHtcbiAgICBcInRleHQtb3V0bGluZS1jb2xvclwiOiBcImJsYWNrXCIsXG4gICAgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IFwiZ29sZFwiLFxuICAgIFwiYm9yZGVyLWNvbG9yXCI6IFwiZ29sZFwiLFxuICAgIFwiYm9yZGVyLXdpZHRoXCI6IFwiNXB4XCIsXG4gICAgXCJib3JkZXItc3R5bGVcIjogXCJzb2xpZFwiXG4gIH1cbn0sIHtcbiAgXCJzZWxlY3RvclwiOiBcImVkZ2VcIixcbiAgXCJzdHlsZVwiOiB7XG4gICAgXCJ3aWR0aFwiOiBcIjJweFwiXG4gIH1cbn0sIHtcbiAgXCJzZWxlY3RvclwiOiBcImVkZ2VbaW50ZXJhY3Rpb25UeXBlQD1cXFwiZ2VuZXRpY1xcXCJdXCIsXG4gIFwic3R5bGVcIjoge1xuICAgIFwibGluZS1jb2xvclwiOiBcIiMyYzc5YmVcIlxuICB9XG59LCB7XG4gIFwic2VsZWN0b3JcIjogXCJlZGdlW2ludGVyYWN0aW9uVHlwZUA9XFxcInBoeXNpY2FsXFxcIl1cIixcbiAgXCJzdHlsZVwiOiB7XG4gICAgXCJsaW5lLWNvbG9yXCI6IFwicmVkXCJcbiAgfVxufSwge1xuICBcInNlbGVjdG9yXCI6IFwibm9kZVtpbnRlcmFjdGlvblR5cGVAPVxcXCJnZW5ldGljXFxcIl1cIixcbiAgXCJzdHlsZVwiOiB7XG4gICAgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IFwiIzIyNWY5NVwiXG4gIH1cbn0sIHtcbiAgXCJzZWxlY3RvclwiOiBcIm5vZGVbaW50ZXJhY3Rpb25UeXBlQD1cXFwicGh5c2ljYWxcXFwiXVwiLFxuICBcInN0eWxlXCI6IHtcbiAgICBcImJhY2tncm91bmQtY29sb3JcIjogXCIjYzAwXCJcbiAgfVxufV1cbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpLFxuQ3ltaW5lID0gZnVuY3Rpb24ocmVjb3Jkcykge1xuICB0aGlzLnJlY29yZHMgPSByZWNvcmRzO1xuICBmdW5jdGlvbiB0b05vZGVzQW5kRWRnZXMocmVjb3JkcywgcGFyZW50Tm9kZSl7XG4gICAgdmFyIGQgPSB7XG4gICAgICBub2RlcyA6IFtdLFxuICAgICAgZWRnZXMgOiBbXVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBpIGluIHJlY29yZHMpIHtcbiAgICAgIHZhciB0aGlzTm9kZSwgcm93ID0gcmVjb3Jkc1tpXTtcbiAgICAgIHRoaXNOb2RlID0gcmVjb3JkVG9Ob2RlKHJvdyk7XG5cbiAgICAgIGlmKHJvdy5pbnRlcmFjdGlvbnMpIHtcbiAgICAgICAgLy9yZWN1cnNpdmVseSBtYWtlIHRoZSBpbnRlcmFjdGlvbnMgaW50byBub2RlcyxcbiAgICAgICAgLy9iZWNhdXNlIG5vZGUgZW50aXRpZXMgYXJlIG5lc3RlZCBhdCB0d28gbGV2ZWxzLlxuICAgICAgICBkID0gXy5leHRlbmQoZCwgdG9Ob2Rlc0FuZEVkZ2VzKHJvdy5pbnRlcmFjdGlvbnMsIHRoaXNOb2RlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL2lmIGl0IGRvZXNuJ3QgaGF2ZSBhbiBpbnRlcmFjdGlvbiBsaXN0LCBpdCBwcm9iYWJseSAqaXMqIGFuIGludGVyYWN0aW9uXG4gICAgICAgIC8vYW5kIHRodXMgbmVlZHMgdG8gYmUgYW4gZWRnZVxuICAgICAgICBkLmVkZ2VzLnB1c2goaW50ZXJhY3Rpb25Ub0VkZ2UocGFyZW50Tm9kZSwgdGhpc05vZGUpKTtcbiAgICAgIH1cbiAgICAgIGQubm9kZXMucHVzaCh0aGlzTm9kZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGQ7XG4gIH07XG4gIHZhciByZWNvcmRUb05vZGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIHJldCwgZGF0YSA9IHt9LCBpbnRlcmFjdGlvbjtcbiAgICByZXQgPSBvYmouZ2VuZTIgPyBvYmouZ2VuZTIgOiBvYmo7XG4gICAgaW50ZXJhY3Rpb24gPSBnZXRJbnRlcmFjdGlvbihvYmopO1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzIDogaW50ZXJhY3Rpb24sXG4gICAgICBkYXRhIDoge1xuICAgICAgICBkZXRhaWxzIDogZ2V0RGV0YWlscyhvYmopLFxuICAgICAgICBsYWJlbCAgIDogbmFtZU5vZGUob2JqKSxcbiAgICAgICAgY2xhc3MgICA6IHJldC5jbGFzcyxcbiAgICAgICAgaW50ZXJhY3Rpb25UeXBlIDogaW50ZXJhY3Rpb24sXG4gICAgICAgIHN5bWJvbCAgOiByZXQuc3ltYm9sLFxuICAgICAgICBpZCA6IHJldC5wcmltYXJ5SWRlbnRpZmllciAvL2N5dG9zY2FwZSBuZWVkcyBzdHJpbmdzLCBub3QgaW50c1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgdmFyIGdldERldGFpbHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgZGV0YWlscyA9IG9iai5kZXRhaWxzID8gb2JqLmRldGFpbHNbMF0gOiB7fTtcbiAgICBkZXRhaWxzID0gY29sbGFwc2VBcnJheXMoZGV0YWlscyk7XG4gICAgcmV0dXJuIGRldGFpbHM7XG4gIH0sXG4gIC8qKlxuICAgKiBXaGlsZSBpdCdzIHVzZWZ1bHkgdG8gc2VlIGFycmF5IGluZGljZXMgaWYgdGhlcmUgYXJlIG11bHRpcGxlIGVsZW1lbnRzLFxuICAgKiBUaGVyZSdzIG5vdCBtdWNoIHBvaW50IHNob3dpbmcgYW4gaW5kZXggZm9yIGp1c3Qgb25lIGFycmF5IGVsZW1lbnQuXG4gICAqIFRoaXMgZnVuY3Rpb24gY29sbGFwc2VzIGFycmF5cyB3aXRoIG9ubHkgb25lIG1lbWJlciBhbmQgcmV0dXJucyB0aGUgbWVtYmVyIGluc3RlYWQuXG4gICAqIEBwYXJhbSAge29iamVjdH0gb2JqIGFuIG9iamVjdCB3aXRoIGFycmF5cyBpbiBpdHMgcHJvcGVydGllcy4gQ2FuIGJlIG5lc3RlZC5cbiAgICogQHJldHVybiB7b2JqZWN0fSB0aGUgc2FtZSBvYmplY3QsIGp1c3Qgd2l0aCAxLWxlbmd0aCBhcnJheXMgY29sbGFwc2VkLlxuICAgKi9cbiAgY29sbGFwc2VBcnJheXMgPSBmdW5jdGlvbihvYmope1xuICAgIHZhciByZXQgPSBvYmo7XG4gICAgZm9yICh2YXIgZGV0YWlsIGluIHJldCl7XG4gICAgICB2YXIgdGhlUHJvcCA9IHJldFtkZXRhaWxdO1xuICAgICAgaWYoQXJyYXkuaXNBcnJheSh0aGVQcm9wKSkge1xuICAgICAgICByZXRbZGV0YWlsXSA9ICh0aGVQcm9wLmxlbmd0aCA9PT0gMSkgPyB0aGVQcm9wWzBdIDogdGhlUHJvcDtcbiAgICAgIH0gZWxzZSBpZih0eXBlb2YgdGhlUHJvcCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB0aGVQcm9wID0gY29sbGFwc2VBcnJheXModGhlUHJvcCk7XG4gICAgICB9IC8vIG5vIG5lZWQgZm9yIGEgZmluYWwgZWxzZS4gSnVzdCBsZWF2ZSBzdHJpbmcvaW50IHZhbHVlcyBhcyBpcy5cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcbiAgZ2V0SW50ZXJhY3Rpb24gPSBmdW5jdGlvbihvYmope1xuICAgIHZhciByZXQgPSBcIm1hc3RlclwiO1xuICAgIGlmIChvYmouZGV0YWlscykge1xuICAgICAgcmV0ID0gb2JqLmRldGFpbHNbMF0udHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcbiAgbmFtZU5vZGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqLmdlbmUyICYmIG9iai5nZW5lMi5zeW1ib2wpIHtcbiAgICAgIHJldHVybiBvYmouZ2VuZTIuc3ltYm9sO1xuICAgIH0gZWxzZSBpZiAob2JqLnN5bWJvbCkge1xuICAgICAgcmV0dXJuIG9iai5zeW1ib2w7XG4gICAgfSBlbHNlIGlmIChvYmouZGV0YWlscykge1xuICAgICAgcmV0dXJuIG9iai5kZXRhaWxzWzBdLm5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcIk5BTUUgTUlTU0lOR1wiO1xuICAgIH1cbiAgfSxcbiAgaW50ZXJhY3Rpb25Ub0VkZ2UgPSBmdW5jdGlvbihub2RlLCBub2RlMikge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzIDogbm9kZTIuZGF0YS5kZXRhaWxzLnR5cGUsXG4gICAgICBkYXRhIDoge1xuICAgICAgICBzb3VyY2UgOiBub2RlLmRhdGEuaWQsXG4gICAgICAgIHRhcmdldCA6IG5vZGUyLmRhdGEuaWQsXG4gICAgICAgIGludGVyYWN0aW9uVHlwZSA6IG5vZGUyLmRhdGEuZGV0YWlscy50eXBlXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4gdG9Ob2Rlc0FuZEVkZ2VzKHJlY29yZHMpO1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEN5bWluZTtcbiIsInZhciBjeW1pbmVEYXRhRm9ybWF0dGVyID0gcmVxdWlyZSgnLi9kYXRhRm9ybWF0dGVyJyksXG5pbWpzICAgICAgICAgID0gcmVxdWlyZSgnLi8uLi9ib3dlcl9jb21wb25lbnRzL2ltanMvanMvaW0uanMnKSxcbmN5dG9zY2FwZSAgICAgPSByZXF1aXJlKCdjeXRvc2NhcGUnKSxcbl8gICAgICAgICAgICAgPSByZXF1aXJlKCd1bmRlcnNjb3JlJyksXG5zdHJpbmdzICAgICAgID0gcmVxdWlyZSgnLi9zdHJpbmdzJyksXG5xdWVyeSAgICAgICAgID0gcmVxdWlyZSgnLi9xdWVyeScpLFxuY3ltaW5lRGlzcGxheSA9IHJlcXVpcmUoJy4vdWknKTtcbkVTNlByb21pc2UgICAgPSByZXF1aXJlKCdlczYtcHJvbWlzZScpXG5cbmZ1bmN0aW9uIEN5bWluZShhcmdzKSB7XG5cbiAgdmFyIHVpLFxuICBncmFwaCA9IF8uZXh0ZW5kKHt9LGFyZ3MpO1xuICByZXR1cm4gaW5pdCgpXG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZXJlIGlzIGluZGVlZCBhbiBlbGVtZW50IHRvIGF0dGFjaCB0bywgYW5kIGZhaWxpbmcgdGhhdCB0cmllcyBhIGRlZmF1bHQuXG4gKiBAcmV0dXJuIHtib29sZWFufSB3aGV0aGVyIG9yIG5vdCB3ZSd2ZSBmb3VuZCBhbiBlbGVtZW50IHRvIGF0dGFjaCB0by4gQWxsb3dzIHlvdSB0byBjYW5jZWwgdGhlIHhoclxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHNpbmNlIHRoZXJlJ3Mgbm93aGVyZSB0byByZW5kZXIgaXQgdG8uXG4gKi9cbiAgZnVuY3Rpb24gdmFsaWRhdGVQYXJlbnQoKSB7XG4gICAgaWYoIWdyYXBoLnBhcmVudEVsZW0pe1xuICAgICAgdmFyIGRlZmF1bHRFbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2N5bWluZScpO1xuICAgICAgaWYoZGVmYXVsdEVsZW0pIHtcbiAgICAgICAgZ3JhcGgucGFyZW50RWxlbSA9IGRlZmF1bHRFbGVtO1xuICAgICAgICBjb25zb2xlLmluZm8oc3RyaW5ncy5kZXYubm9QYXJlbnQudXNpbmdEZWZhdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3Ioc3RyaW5ncy5kZXYubm9QYXJlbnQubm9EZWZhdWx0KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlU2VydmljZVJvb3QoKXtcbiAgICBpZihncmFwaC5zZXJ2aWNlKXtcbiAgICAgIHJldHVybiBuZXcgaW1qcy5TZXJ2aWNlKHtcbiAgICAgICAgdG9rZW46IGdyYXBoLnNlcnZpY2UudG9rZW4sXG4gICAgICAgIHJvb3Q6IGdyYXBoLnNlcnZpY2Uucm9vdCxcbiAgICAgICAgZXJyb3JIYW5kbGVyOiBiYWRTZXJ2aWNlRXJyb3JcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgaW5pdEVycm9yKCdub1NlcnZpY2VVcmwnKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwUXVlcnkoKSB7XG4gICAgaWYoZ3JhcGgucXVlcnlPbikge1xuICAgICAgXy5leHRlbmQocXVlcnkud2hlcmVbMF0sZ3JhcGgucXVlcnlPbik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IGluaXRFcnJvcignbm9RdWVyeURhdGEnKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0KCl7XG4gICAgcmV0dXJuIG5ldyBFUzZQcm9taXNlLlByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBpZih2YWxpZGF0ZVBhcmVudCgpKSB7XG4gICAgICB1aSA9IG5ldyBjeW1pbmVEaXNwbGF5KGdyYXBoKTtcbiAgICAgIHZhciBtaW5lID0gdmFsaWRhdGVTZXJ2aWNlUm9vdCgpO1xuICAgICAgICBpZihwcmVwUXVlcnkoKSAmJiBtaW5lKSB7XG4gICAgICAgICAgbWluZS5yZWNvcmRzKHF1ZXJ5KS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBncmFwaC5kYXRhID0gbmV3IGN5bWluZURhdGFGb3JtYXR0ZXIocmVzcG9uc2UpO1xuICAgICAgICAgICAgICB1aS5pbml0KCk7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ3Jlc3BvbnNlOicsIHJlc3BvbnNlLCAnZ3JhcGhkYXRhOicsIGdyYXBoKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHVpLmluaXQoc3RyaW5ncy51c2VyLm5vUmVzdWx0cyk7XG4gICAgICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIHRocm93IHRoaXMgZXJyb3IgdG8gY29uc29sZS5lcnJvciBhbmQgZGlzcGxheSBhIHVzZXItZmFjaW5nIGVycm9yIHRvb1xuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGRldk1lc3NhZ2UgIHRoaXMgc2hvdWxkIGJlIHRoZSBrZXkgdG8gYSBzdHJpbmcgaW4gdGhlIHN0cmluZ3MuZGV2IG9iamVjdC5cbiAgICogQHBhcmFtICB7W3R5cGVdfSB1c2VyTWVzc2FnZSBvcHRpb25hbCAtIHRoaXMgc2hvdWxkIGJlIHRoZSBrZXkgdG8gYSBzdHJpbmcgaW4gdGhlIHN0cmluZ3MudXNlciBvYmplY3QuIElmIG5vdCBzZXQsIGl0IHdpbGwgdXNlIHRoZSBnZW5lcmljIHN0cmluZ3MudXNlci5ub1F1ZXJ5IG1lc3NhZ2UuXG4gICAqL1xuICBmdW5jdGlvbiBpbml0RXJyb3IoZGV2TWVzc2FnZSwgdXNlck1lc3NhZ2Upe1xuICAgIHZhciB1bSA9IHVzZXJNZXNzYWdlID8gdXNlck1lc3NhZ2UgOiBcIm5vUXVlcnlEYXRhXCI7XG4gICAgdWkuaW5pdChzdHJpbmdzLnVzZXJbdW1dKTtcbiAgICBjb25zb2xlLmVycm9yKHN0cmluZ3MuZGV2W2Rldk1lc3NhZ2VdKTtcbiAgfVxufVxuLyoqXG4gKiBoZWxwZXIgbWV0aG9kIGZvciBjYWxsaW5nIHNlcnZpY2VzIGZyb20gaW1qcy4gVXNlZnVsIGJlY2F1c2Ugd2UgY2FuIG9ubHkgcGFzcyBhIHJlZmVyZW5jZSB0byBhIGZ1bmN0dGlvbiAod2l0aG91dCBhcmdzKSB0byBpbWpzLCBzbyBwYXNzaW5nIGluaXRFcnJvciB3b3VsZG4ndCBhbGxvdyB1cyB0byBzZXQgdGhlIGRldiBlcnJvciBtZXNzYWdlLlxuICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXG4gKi9cbmZ1bmN0aW9uIGJhZFNlcnZpY2VFcnJvcihlcnIpe1xuICAgIGNvbnNvbGUubG9nKFwiZXJyb3IgdGhyb3duXCIsIGVycik7XG4gICAgdGhyb3cgbmV3IGluaXRFcnJvcignYmFkU2VydmljZVVybCcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEN5bWluZTtcbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwiR2VuZV9JbnRlcmFjdGlvbnNcIixcbiAgXCJ0aXRsZVwiOiBcIkdlbmUgLS0+IEludGVyYWN0aW9uc1wiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiU2hvdyBhbGwgaW50ZXJhY3Rpb25zIGZvciBhIGdpdmVuIGdlbmUuXCIsXG4gIFwiY29uc3RyYWludExvZ2ljXCI6IFwiQSBhbmQgQlwiLFxuICBcImZyb21cIjogXCJHZW5lXCIsXG4gIFwic2VsZWN0XCI6IFtcbiAgICBcInByaW1hcnlJZGVudGlmaWVyXCIsXG4gICAgXCJzeW1ib2xcIixcbiAgICBcImludGVyYWN0aW9ucy5nZW5lMi5zeW1ib2xcIixcbiAgICBcImludGVyYWN0aW9ucy5nZW5lMi5wcmltYXJ5SWRlbnRpZmllclwiLFxuICAgIFwiaW50ZXJhY3Rpb25zLmRldGFpbHMubmFtZVwiLFxuICAgIFwiaW50ZXJhY3Rpb25zLmRldGFpbHMucm9sZTFcIixcbiAgICBcImludGVyYWN0aW9ucy5kZXRhaWxzLnJvbGUyXCIsXG4gICAgXCJpbnRlcmFjdGlvbnMuZGV0YWlscy50eXBlXCIsXG4gICAgXCJpbnRlcmFjdGlvbnMuZGV0YWlscy5leHBlcmltZW50LmludGVyYWN0aW9uRGV0ZWN0aW9uTWV0aG9kcy5uYW1lXCIsXG4gICAgXCJpbnRlcmFjdGlvbnMuZGV0YWlscy5leHBlcmltZW50LnB1YmxpY2F0aW9uLnB1Yk1lZElkXCIsXG4gICAgXCJpbnRlcmFjdGlvbnMuZGV0YWlscy5yZWxhdGlvbnNoaXBUeXBlLm5hbWVcIixcbiAgICBcImludGVyYWN0aW9ucy5kZXRhaWxzLmRhdGFTZXRzLm5hbWVcIlxuICBdLFxuICBcIm9yZGVyQnlcIjogW1xuICAgIHtcbiAgICAgIFwicGF0aFwiOiBcInN5bWJvbFwiLFxuICAgICAgXCJkaXJlY3Rpb25cIjogXCJBU0NcIlxuICAgIH1cbiAgXSxcbiAgXCJ3aGVyZVwiOiBbXG4gICAge1xuICAgICAgXCJwYXRoXCI6IFwiR2VuZVwiLFxuICAgICAgXCJvcFwiOiBcIkxPT0tVUFwiLFxuICAgICAgXCJjb2RlXCI6IFwiQVwiLFxuICAgICAgXCJlZGl0YWJsZVwiOiB0cnVlLFxuICAgICAgXCJzd2l0Y2hlZFwiOiBcIkxPQ0tFRFwiLFxuICAgICAgXCJzd2l0Y2hhYmxlXCI6IGZhbHNlLFxuICAgIH1cbiAgXVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcInVzZXJcIiA6IHtcbiAgICBcIm5vUmVzdWx0c1wiIDogXCJObyBpbnRlcmFjdGlvbiByZXN1bHRzIGZvciB0aGlzIHF1ZXJ5XCIsXG4gICAgXCJub1F1ZXJ5RGF0YVwiIDogXCJQcm9ibGVtIGxvYWRpbmcgcXVlcnkgcmVzdWx0c1wiXG4gIH0sXG4gIFwiZGV2XCIgOiB7XG4gICAgXCJub1BhcmVudFwiIDoge1xuICAgICAgdXNpbmdEZWZhdWx0IDogXCJDeW1pbmU6IE5vIHBhcmVudCBlbGVtZW50IHNwZWNpZmllZCBmb3IgQ3ltaW5lLiBVc2luZyBkZWZhdWx0ICcjY3ltaW5lXCIsXG4gICAgICBub0RlZmF1bHQgOiBcIkN5bWluZTogTm8gcGFyZW50IGVsZW1lbnQgc3BlY2lmaWVkLCBhbmQgZGVmYXVsdCAnI2N5bWluZScgbm90IGF2YWlsYWJsZS5cIlxuICAgIH0sXG4gICAgXCJub1F1ZXJ5RGF0YVwiIDogXCJDeW1pbmU6IE5vIHF1ZXJ5T24gdmFsdWVzIHN1cHBsaWVkIVwiLFxuICAgIFwibm9TZXJ2aWNlVXJsXCIgOiBcIkN5bWluZTogTm8gc2VydmljZVVybCBkZWZpbmVkLCB1bmFibGUgdG8gcXVlcnkgZm9yIGludGVyYWN0aW9ucy5cIixcbiAgICBcImJhZFNlcnZpY2VVcmxcIiA6IFwiQ3ltaW5lOiBiYWQgc2VydmljZVVybC4gUGxlYXNlIGNoZWNrIGZvciB0eXBvcyBhbmQgY2hlY2sgdGhpcyBob3N0IGlzIHVwLlwiXG4gIH1cbn1cbiIsInZhciBjeW1pbmVIdG1sID0gcmVxdWlyZSgnLi8uLi90ZW1wbGF0ZS9jeXRvbWluZS5odG1sJyksXG5jeVN0eWxlID0gcmVxdWlyZSgnLi9jeXRvc2NhcGVTdHlsZScpO1xudWkgPSBmdW5jdGlvbiAoZ3JhcGgpIHtcbiAgdGhpcy5ncmFwaCA9IGdyYXBoO1xuICB2YXIgY3ksXG4gIGRpc3BsYXkgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGFyZ2V0RWxlbSA9IGdyYXBoLnBhcmVudEVsZW0ucXVlcnlTZWxlY3Rvcignbm9kZURldGFpbHMnKSxcbiAgICBzZXRUaXRsZShub2RlKTtcbiAgICBsaXN0UHJvcGVydGllcyhub2RlKTtcbiAgfSxcbiAgc2V0VGl0bGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciB0aXRsZSA9IGdyYXBoLnBhcmVudEVsZW0ucXVlcnlTZWxlY3RvcignLm5vZGVUaXRsZScpO1xuICAgIHRpdGxlLmlubmVySFRNTCA9IG5vZGUubGFiZWw7XG4gIH0sXG4gIGxpc3RQcm9wZXJ0aWVzID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHZhciBkaXNwbGF5ID0gZXhwYW5kUHJvcGVydHlWYWxzKG5vZGUpLFxuICAgIG9sZE5vZGVJbmZvID0gZ3JhcGgucGFyZW50RWxlbS5xdWVyeVNlbGVjdG9yKCcubm9kZUluZm8nKTtcbiAgICBkaXNwbGF5LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnbm9kZUluZm8nKTtcbiAgICBvbGROb2RlSW5mby5wYXJlbnRFbGVtZW50LnJlcGxhY2VDaGlsZChkaXNwbGF5LCBvbGROb2RlSW5mbyk7XG4gIH0sXG4gIGdldFRlbXBsYXRlID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gY3ltaW5lSHRtbDtcbiAgfSxcbiAgZXhwYW5kUHJvcGVydHlWYWxzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGRpc3BsYXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkbCcpLFxuICAgIGR0VGVtcCwgZGRUZW1wO1xuICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICBkdFRlbXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZHRcIik7XG4gICAgICBkdFRlbXAuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocHJvcCkpO1xuICAgICAgZGRUZW1wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRkXCIpO1xuICAgICAgaWYodHlwZW9mIG9ialtwcm9wXSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBkZFRlbXAuc2V0QXR0cmlidXRlKFwiY2xhc3NcIixcImNoaWxkXCIpO1xuICAgICAgICBkZFRlbXAuYXBwZW5kQ2hpbGQoZXhwYW5kUHJvcGVydHlWYWxzKG9ialtwcm9wXSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGRUZW1wLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG9ialtwcm9wXSkpO1xuICAgICAgfVxuICAgICAgZGlzcGxheS5hcHBlbmRDaGlsZChkdFRlbXApO1xuICAgICAgZGlzcGxheS5hcHBlbmRDaGlsZChkZFRlbXApO1xuICAgIH1cbiAgICByZXR1cm4gZGlzcGxheTtcbiAgfSxcbiAgaW5pdCA9IGZ1bmN0aW9uKGVycm9yTWVzc2FnZSkge1xuICAgIGluaXRIdG1sKCk7XG4gICAgaWYoIWVycm9yTWVzc2FnZSkge1xuICAgICAgaW5pdEdyYXBoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vUmVzdWx0cyhlcnJvck1lc3NhZ2UpO1xuICAgIH1cbiAgfSxcbiAgY29udHJvbHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaGlkZGVuRWxlbXMsXG4gICAgZ2V0Q29udHJvbHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBncmFwaC5wYXJlbnRFbGVtLnF1ZXJ5U2VsZWN0b3IoJy5jb250cm9scycpO1xuICAgIH0sXG4gICAgc2VsZWN0SW50ZXJhY3Rpb25UeXBlID0gZnVuY3Rpb24oZSl7XG4gICAgICB2YXIgZWxlbSA9IGUudGFyZ2V0O1xuICAgICAgaWYoKGVsZW0gIT09IGUuY3VycmVudFRhcmdldCkgJiYgKGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJidXR0b25cIikpIHtcbiAgICAgICAgLy92aXN1YWwgYnV0dG9uIHJlc3BvbnNlXG4gICAgICAgIHJlbW92ZUFsbEJ1dHRvblNlbGVjdGlvbnMoKTtcbiAgICAgICAgdmFyIGVsZW1DbGFzcyA9IGVsZW0uY2xhc3NOYW1lOy8vYXQgdGhpcyBwb2ludCB3ZSd2ZSBzdHJpcHBlZCBzZWxlY3RlZCBvZmYuIFNob3VsZCBvbmx5IGJlIHRoZSB0eXBlLlxuICAgICAgICBhZGRDbGFzcyhlbGVtLCAnc2VsZWN0ZWQnKTtcblxuICAgICAgICAvL2FmZmVjdCB0aGUgZ3JhcGg6XG4gICAgICAgIC8vb2xkIG9uZXMgYmFjazpcbiAgICAgICAgaWYoaGlkZGVuRWxlbXMpIHtcbiAgICAgICAgICBoaWRkZW5FbGVtcy5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy9uZXcgb25lcyBnb25lOlxuICAgICAgICBoaWRkZW5FbGVtcyA9IGN5LmVsZW1lbnRzKCdbaW50ZXJhY3Rpb25UeXBlPVwiJyArIGVsZW1DbGFzcyArICdcIl0nKS5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGxpc3RlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgZ2V0Q29udHJvbHMoKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHNlbGVjdEludGVyYWN0aW9uVHlwZSwgZmFsc2UpO1xuICAgIH0sXG4gICAgYWRkQ2xhc3MgPSBmdW5jdGlvbihlbGVtLCBjbGFzc1RvQWRkKSB7XG4gICAgICBpZiAoIWhhc0NsYXNzKGVsZW0sIGNsYXNzVG9BZGQpKSB7XG4gICAgICAgIGVsZW0uY2xhc3NOYW1lICs9IFwiIFwiICsgY2xhc3NUb0FkZDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbW92ZUNsYXNzID0gZnVuY3Rpb24oZWxlbSwgY2xhc3NUb1JlbW92ZSkge1xuICAgICAgZWxlbS5jbGFzc05hbWUgPSBlbGVtLmNsYXNzTmFtZS5yZXBsYWNlKGNsYXNzVG9SZW1vdmUsIFwiXCIpO1xuICAgIH0sXG4gICAgcmVtb3ZlQWxsQnV0dG9uU2VsZWN0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRoZUJ1dHRvbnMgPSBnZXRDb250cm9scygpLnF1ZXJ5U2VsZWN0b3JBbGwoJ2J1dHRvbicpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGVCdXR0b25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlbW92ZUNsYXNzKHRoZUJ1dHRvbnNbaV0sICcgc2VsZWN0ZWQnKTtcbiAgICAgICAgcmVtb3ZlQ2xhc3ModGhlQnV0dG9uc1tpXSwgJ3NlbGVjdGVkJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGhhc0NsYXNzID0gZnVuY3Rpb24oZWxlbSwgY2xhc3NUb0NoZWNrRm9yKSB7XG4gICAgICB2YXIgY2xhc3NlcyA9IGVsZW0uY2xhc3NOYW1lLnNwbGl0KFwiIFwiKTtcbiAgICAgIHJldHVybiAoY2xhc3Nlcy5pbmRleE9mKGNsYXNzVG9DaGVja0ZvcikgPj0gMCk7XG4gICAgfVxuICAgIHJldHVybiB7bGlzdGVuIDogbGlzdGVufTtcbiAgfSxcbiAgaW5pdEh0bWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgZ3JhcGgucGFyZW50RWxlbS5pbm5lckhUTUwgPSBnZXRUZW1wbGF0ZSgpO1xuICAgIGdyYXBoLnBhcmVudEVsZW0uY2xhc3NOYW1lICs9IFwiIGN5bWluZVwiO1xuICAgIGdyYXBoLnN0YXR1c0JhciA9IGdyYXBoLnBhcmVudEVsZW0ucXVlcnlTZWxlY3RvcignLnN0YXR1cycpO1xuICB9LFxuICBpbml0R3JhcGggPSBmdW5jdGlvbigpIHtcbiAgICBncmFwaC50YXJnZXRFbGVtID0gZ3JhcGgucGFyZW50RWxlbS5xdWVyeVNlbGVjdG9yKCcuY3knKTtcbiAgICB0cnl7XG4gICAgICB2YXIgaW50ZXJhY3Rpb25Db250cm9scyA9IGNvbnRyb2xzKCk7XG4gICAgICBpbnRlcmFjdGlvbkNvbnRyb2xzLmxpc3RlbigpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICB9XG4gICAgLy9tYWtlIHRoZSBncmFwaFxuICAgIGN5ID0gY3l0b3NjYXBlKHtcbiAgICAgIGNvbnRhaW5lcjogZ3JhcGgudGFyZ2V0RWxlbSxcbiAgICAgIGxheW91dDogeyBuYW1lOiAnY29zZSd9LFxuICAgICAgZWxlbWVudHM6IGdyYXBoLmRhdGEsXG4gICAgICBzdHlsZTogY3lTdHlsZSxcblxuICAgICAgcmVhZHk6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHdpbmRvdy5jeSA9IHRoaXM7XG4gICAgICAgIGdyYXBoLnN0YXR1c0Jhci5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vZXZlbnQgbGlzdGVuZXIgZm9yIG5vZGUgdGFwc1xuICAgIGN5Lm9uKCd0YXAnLCAnbm9kZScsIGZ1bmN0aW9uKCl7XG4gICAgICBkaXNwbGF5KHRoaXMuZGF0YSgpKTtcbiAgICB9KTtcblxuICAgIGN5Lm9uKCd0YXAnLCAnZWRnZScsIGZ1bmN0aW9uKCl7XG4gICAgICBkaXNwbGF5KHRoaXMuZGF0YSgpKTtcbiAgICB9KTtcblxuXG4gIH0sXG4gIG5vUmVzdWx0cyA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgZ3JhcGguc3RhdHVzQmFyLmNsYXNzTmFtZSA9IFwic3RhdHVzIG5vLXJlc3VsdHNcIjtcbiAgICBncmFwaC5zdGF0dXNCYXIuaW5uZXJIVE1MID0gbWVzc2FnZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaW5pdDppbml0LFxuICAgIG5vUmVzdWx0czpub1Jlc3VsdHNcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVpO1xuIixudWxsLCJleHBvcnRzLmVuZGlhbm5lc3MgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnTEUnIH07XG5cbmV4cG9ydHMuaG9zdG5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGxvY2F0aW9uLmhvc3RuYW1lXG4gICAgfVxuICAgIGVsc2UgcmV0dXJuICcnO1xufTtcblxuZXhwb3J0cy5sb2FkYXZnID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW10gfTtcblxuZXhwb3J0cy51cHRpbWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwIH07XG5cbmV4cG9ydHMuZnJlZW1lbSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcbn07XG5cbmV4cG9ydHMudG90YWxtZW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7XG59O1xuXG5leHBvcnRzLmNwdXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXSB9O1xuXG5leHBvcnRzLnR5cGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnQnJvd3NlcicgfTtcblxuZXhwb3J0cy5yZWxlYXNlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gbmF2aWdhdG9yLmFwcFZlcnNpb247XG4gICAgfVxuICAgIHJldHVybiAnJztcbn07XG5cbmV4cG9ydHMubmV0d29ya0ludGVyZmFjZXNcbj0gZXhwb3J0cy5nZXROZXR3b3JrSW50ZXJmYWNlc1xuPSBmdW5jdGlvbiAoKSB7IHJldHVybiB7fSB9O1xuXG5leHBvcnRzLmFyY2ggPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnamF2YXNjcmlwdCcgfTtcblxuZXhwb3J0cy5wbGF0Zm9ybSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdicm93c2VyJyB9O1xuXG5leHBvcnRzLnRtcGRpciA9IGV4cG9ydHMudG1wRGlyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnL3RtcCc7XG59O1xuXG5leHBvcnRzLkVPTCA9ICdcXG4nO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIHJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCBhcnJheSB3aXRoIGRpcmVjdG9yeSBuYW1lcyB0aGVyZVxuLy8gbXVzdCBiZSBubyBzbGFzaGVzLCBlbXB0eSBlbGVtZW50cywgb3IgZGV2aWNlIG5hbWVzIChjOlxcKSBpbiB0aGUgYXJyYXlcbi8vIChzbyBhbHNvIG5vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMgLSBpdCBkb2VzIG5vdCBkaXN0aW5ndWlzaFxuLy8gcmVsYXRpdmUgYW5kIGFic29sdXRlIHBhdGhzKVxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXkocGFydHMsIGFsbG93QWJvdmVSb290KSB7XG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYXN0ID0gcGFydHNbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuLy8gU3BsaXQgYSBmaWxlbmFtZSBpbnRvIFtyb290LCBkaXIsIGJhc2VuYW1lLCBleHRdLCB1bml4IHZlcnNpb25cbi8vICdyb290JyBpcyBqdXN0IGEgc2xhc2gsIG9yIG5vdGhpbmcuXG52YXIgc3BsaXRQYXRoUmUgPVxuICAgIC9eKFxcLz98KShbXFxzXFxTXSo/KSgoPzpcXC57MSwyfXxbXlxcL10rP3wpKFxcLlteLlxcL10qfCkpKD86W1xcL10qKSQvO1xudmFyIHNwbGl0UGF0aCA9IGZ1bmN0aW9uKGZpbGVuYW1lKSB7XG4gIHJldHVybiBzcGxpdFBhdGhSZS5leGVjKGZpbGVuYW1lKS5zbGljZSgxKTtcbn07XG5cbi8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzb2x2ZWRQYXRoID0gJycsXG4gICAgICByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICB2YXIgcGF0aCA9IChpID49IDApID8gYXJndW1lbnRzW2ldIDogcHJvY2Vzcy5jd2QoKTtcblxuICAgIC8vIFNraXAgZW1wdHkgYW5kIGludmFsaWQgZW50cmllc1xuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLnJlc29sdmUgbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfSBlbHNlIGlmICghcGF0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmVzb2x2ZWRQYXRoID0gcGF0aCArICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbiAgfVxuXG4gIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcbiAgLy8gaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKCkgZmFpbHMpXG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihyZXNvbHZlZFBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhcmVzb2x2ZWRBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIHJldHVybiAoKHJlc29sdmVkQWJzb2x1dGUgPyAnLycgOiAnJykgKyByZXNvbHZlZFBhdGgpIHx8ICcuJztcbn07XG5cbi8vIHBhdGgubm9ybWFsaXplKHBhdGgpXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCksXG4gICAgICB0cmFpbGluZ1NsYXNoID0gc3Vic3RyKHBhdGgsIC0xKSA9PT0gJy8nO1xuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICBwYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhaXNBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIGlmICghcGF0aCAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHBhdGggPSAnLic7XG4gIH1cbiAgaWYgKHBhdGggJiYgdHJhaWxpbmdTbGFzaCkge1xuICAgIHBhdGggKz0gJy8nO1xuICB9XG5cbiAgcmV0dXJuIChpc0Fic29sdXRlID8gJy8nIDogJycpICsgcGF0aDtcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLyc7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmpvaW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBhdGhzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgcmV0dXJuIGV4cG9ydHMubm9ybWFsaXplKGZpbHRlcihwYXRocywgZnVuY3Rpb24ocCwgaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIHAgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfSkuam9pbignLycpKTtcbn07XG5cblxuLy8gcGF0aC5yZWxhdGl2ZShmcm9tLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVsYXRpdmUgPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICBmcm9tID0gZXhwb3J0cy5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTtcbiAgdG8gPSBleHBvcnRzLnJlc29sdmUodG8pLnN1YnN0cigxKTtcblxuICBmdW5jdGlvbiB0cmltKGFycikge1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgZm9yICg7IHN0YXJ0IDwgYXJyLmxlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKGFycltzdGFydF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgZW5kID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgZm9yICg7IGVuZCA+PSAwOyBlbmQtLSkge1xuICAgICAgaWYgKGFycltlbmRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gW107XG4gICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKTtcbiAgfVxuXG4gIHZhciBmcm9tUGFydHMgPSB0cmltKGZyb20uc3BsaXQoJy8nKSk7XG4gIHZhciB0b1BhcnRzID0gdHJpbSh0by5zcGxpdCgnLycpKTtcblxuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oZnJvbVBhcnRzLmxlbmd0aCwgdG9QYXJ0cy5sZW5ndGgpO1xuICB2YXIgc2FtZVBhcnRzTGVuZ3RoID0gbGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGZyb21QYXJ0c1tpXSAhPT0gdG9QYXJ0c1tpXSkge1xuICAgICAgc2FtZVBhcnRzTGVuZ3RoID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdXRwdXRQYXJ0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gc2FtZVBhcnRzTGVuZ3RoOyBpIDwgZnJvbVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgfVxuXG4gIG91dHB1dFBhcnRzID0gb3V0cHV0UGFydHMuY29uY2F0KHRvUGFydHMuc2xpY2Uoc2FtZVBhcnRzTGVuZ3RoKSk7XG5cbiAgcmV0dXJuIG91dHB1dFBhcnRzLmpvaW4oJy8nKTtcbn07XG5cbmV4cG9ydHMuc2VwID0gJy8nO1xuZXhwb3J0cy5kZWxpbWl0ZXIgPSAnOic7XG5cbmV4cG9ydHMuZGlybmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIHJlc3VsdCA9IHNwbGl0UGF0aChwYXRoKSxcbiAgICAgIHJvb3QgPSByZXN1bHRbMF0sXG4gICAgICBkaXIgPSByZXN1bHRbMV07XG5cbiAgaWYgKCFyb290ICYmICFkaXIpIHtcbiAgICAvLyBObyBkaXJuYW1lIHdoYXRzb2V2ZXJcbiAgICByZXR1cm4gJy4nO1xuICB9XG5cbiAgaWYgKGRpcikge1xuICAgIC8vIEl0IGhhcyBhIGRpcm5hbWUsIHN0cmlwIHRyYWlsaW5nIHNsYXNoXG4gICAgZGlyID0gZGlyLnN1YnN0cigwLCBkaXIubGVuZ3RoIC0gMSk7XG4gIH1cblxuICByZXR1cm4gcm9vdCArIGRpcjtcbn07XG5cblxuZXhwb3J0cy5iYXNlbmFtZSA9IGZ1bmN0aW9uKHBhdGgsIGV4dCkge1xuICB2YXIgZiA9IHNwbGl0UGF0aChwYXRoKVsyXTtcbiAgLy8gVE9ETzogbWFrZSB0aGlzIGNvbXBhcmlzb24gY2FzZS1pbnNlbnNpdGl2ZSBvbiB3aW5kb3dzP1xuICBpZiAoZXh0ICYmIGYuc3Vic3RyKC0xICogZXh0Lmxlbmd0aCkgPT09IGV4dCkge1xuICAgIGYgPSBmLnN1YnN0cigwLCBmLmxlbmd0aCAtIGV4dC5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBmO1xufTtcblxuXG5leHBvcnRzLmV4dG5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBzcGxpdFBhdGgocGF0aClbM107XG59O1xuXG5mdW5jdGlvbiBmaWx0ZXIgKHhzLCBmKSB7XG4gICAgaWYgKHhzLmZpbHRlcikgcmV0dXJuIHhzLmZpbHRlcihmKTtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZih4c1tpXSwgaSwgeHMpKSByZXMucHVzaCh4c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFN0cmluZy5wcm90b3R5cGUuc3Vic3RyIC0gbmVnYXRpdmUgaW5kZXggZG9uJ3Qgd29yayBpbiBJRThcbnZhciBzdWJzdHIgPSAnYWInLnN1YnN0cigtMSkgPT09ICdiJ1xuICAgID8gZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikgeyByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKSB9XG4gICAgOiBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7XG4gICAgICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gc3RyLmxlbmd0aCArIHN0YXJ0O1xuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKTtcbiAgICB9XG47XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8qIVxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgQ3l0b3NjYXBlLmpzIDIuNC41LlxuICogXG4gKiBDeXRvc2NhcGUuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZSBGcmVlXG4gKiBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueVxuICogbGF0ZXIgdmVyc2lvbi5cbiAqIFxuICogQ3l0b3NjYXBlLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gKiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTU1xuICogRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZVxuICogZGV0YWlscy5cbiAqIFxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFsb25nIHdpdGhcbiAqIEN5dG9zY2FwZS5qcy4gSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuICovXG4gXG5cbi8vIHRoaXMgaXMgcHV0IGFzIGEgZ2xvYmFsIHZhciBpbiB0aGUgYnJvd3NlclxuLy8gb3IgaXQncyBqdXN0IGEgZ2xvYmFsIHRvIHRoaXMgbW9kdWxlIGlmIGNvbW1vbmpzXG5cbnZhciBjeXRvc2NhcGU7XG5cbihmdW5jdGlvbih3aW5kb3cpeyAndXNlIHN0cmljdCc7XG5cbiAgLy8gdGhlIG9iamVjdCBpdGVzZWxmIGlzIGEgZnVuY3Rpb24gdGhhdCBpbml0J3MgYW4gaW5zdGFuY2Ugb2YgY3l0b3NjYXBlXG5cbiAgdmFyICQkID0gY3l0b3NjYXBlID0gZnVuY3Rpb24oKXsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgcmV0dXJuIGN5dG9zY2FwZS5pbml0LmFwcGx5KGN5dG9zY2FwZSwgYXJndW1lbnRzKTtcbiAgfTtcblxuICAkJC52ZXJzaW9uID0gJzIuNC41JztcbiAgXG4gIC8vIGFsbG93IGZ1bmN0aW9uYWwgYWNjZXNzIHRvIGN5dG9zY2FwZS5qc1xuICAvLyBlLmcuIHZhciBjeXRvID0gJC5jeXRvc2NhcGUoeyBzZWxlY3RvcjogXCIjZm9vXCIsIC4uLiB9KTtcbiAgLy8gICAgICB2YXIgbm9kZXMgPSBjeXRvLm5vZGVzKCk7XG4gICQkLmluaXQgPSBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgIFxuICAgIC8vIGlmIG5vIG9wdGlvbnMgc3BlY2lmaWVkLCB1c2UgZGVmYXVsdFxuICAgIGlmKCBvcHRpb25zID09PSB1bmRlZmluZWQgKXtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgaW5zdGFuY2VcbiAgICBpZiggJCQuaXMucGxhaW5PYmplY3QoIG9wdGlvbnMgKSApe1xuICAgICAgcmV0dXJuIG5ldyAkJC5Db3JlKCBvcHRpb25zICk7XG4gICAgfSBcbiAgICBcbiAgICAvLyBhbGxvdyBmb3IgcmVnaXN0cmF0aW9uIG9mIGV4dGVuc2lvbnNcbiAgICAvLyBlLmcuICQuY3l0b3NjYXBlKCdyZW5kZXJlcicsICdzdmcnLCBTdmdSZW5kZXJlcik7XG4gICAgLy8gZS5nLiAkLmN5dG9zY2FwZSgncmVuZGVyZXInLCAnc3ZnJywgJ25vZGVzaGFwZScsICdlbGxpcHNlJywgU3ZnRWxsaXBzZU5vZGVTaGFwZSk7XG4gICAgLy8gZS5nLiAkLmN5dG9zY2FwZSgnY29yZScsICdkb1NvbWV0aGluZycsIGZ1bmN0aW9uKCl7IC8qIGRvU29tZXRoaW5nIGNvZGUgKi8gfSk7XG4gICAgLy8gZS5nLiAkLmN5dG9zY2FwZSgnY29sbGVjdGlvbicsICdkb1NvbWV0aGluZycsIGZ1bmN0aW9uKCl7IC8qIGRvU29tZXRoaW5nIGNvZGUgKi8gfSk7XG4gICAgZWxzZSBpZiggJCQuaXMuc3RyaW5nKCBvcHRpb25zICkgKSB7XG4gICAgICByZXR1cm4gJCQuZXh0ZW5zaW9uLmFwcGx5KCQkLmV4dGVuc2lvbiwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gZGVmaW5lIHRoZSBmdW5jdGlvbiBuYW1lc3BhY2UgaGVyZSwgc2luY2UgaXQgaGFzIG1lbWJlcnMgaW4gbWFueSBwbGFjZXNcbiAgJCQuZm4gPSB7fTtcblxuICBpZiggdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMgKXsgLy8gZXhwb3NlIGFzIGEgY29tbW9uanMgbW9kdWxlXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjeXRvc2NhcGU7XG4gIH1cblxuICBpZiggdHlwZW9mIGRlZmluZSAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVmaW5lLmFtZCApeyAvLyBleHBvc2UgYXMgYW4gYW1kL3JlcXVpcmVqcyBtb2R1bGVcbiAgICBkZWZpbmUoJ2N5dG9zY2FwZScsIGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gY3l0b3NjYXBlO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gbWFrZSBzdXJlIHdlIGFsd2F5cyByZWdpc3RlciBpbiB0aGUgd2luZG93IGp1c3QgaW4gY2FzZSAoZS5nLiB3LyBkZXJieWpzKVxuICBpZiggd2luZG93ICl7XG4gICAgd2luZG93LmN5dG9zY2FwZSA9IGN5dG9zY2FwZTtcbiAgfVxuICBcbn0pKCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB3aW5kb3cgKTtcblxuLy8gZXh0cmEgc2V0IHRvIGB0aGlzYCBpcyBuZWNlc3NhcnkgZm9yIG1ldGVvclxudGhpcy5jeXRvc2NhcGUgPSBjeXRvc2NhcGU7XG5cbi8vIGludGVybmFsLCBtaW5pbWFsIFByb21pc2UgaW1wbCBzLnQuIGFwaXMgY2FuIHJldHVybiBwcm9taXNlcyBpbiBvbGQgZW52c1xuLy8gYmFzZWQgb24gdGhlbmFibGUgKGh0dHA6Ly9naXRodWIuY29tL3JzZS90aGVuYWJsZSlcblxuLy8gTkI6IHlvdSBtdXN0IHVzZSBgbmV3ICQkLlByb21pc2VgLCBiZWNhdXNlIHlvdSBtYXkgaGF2ZSBuYXRpdmUgcHJvbWlzZXMgdGhhdCBkb24ndCBhdXRvbmV3IGZvciB5b3VcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gIC8qICBwcm9taXNlIHN0YXRlcyBbUHJvbWlzZXMvQSsgMi4xXSAgKi9cbiAgdmFyIFNUQVRFX1BFTkRJTkcgICA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMS4xXSAgKi9cbiAgdmFyIFNUQVRFX0ZVTEZJTExFRCA9IDE7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMS4yXSAgKi9cbiAgdmFyIFNUQVRFX1JFSkVDVEVEICA9IDI7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMS4zXSAgKi9cblxuICAvKiAgcHJvbWlzZSBvYmplY3QgY29uc3RydWN0b3IgICovXG4gIHZhciBhcGkgPSBmdW5jdGlvbiAoZXhlY3V0b3IpIHtcbiAgICAvKiAgb3B0aW9uYWxseSBzdXBwb3J0IG5vbi1jb25zdHJ1Y3Rvci9wbGFpbi1mdW5jdGlvbiBjYWxsICAqL1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBhcGkpKVxuICAgICAgcmV0dXJuIG5ldyBhcGkoZXhlY3V0b3IpO1xuXG4gICAgLyogIGluaXRpYWxpemUgb2JqZWN0ICAqL1xuICAgIHRoaXMuaWQgICAgICAgICAgID0gXCJUaGVuYWJsZS8xLjAuN1wiO1xuICAgIHRoaXMuc3RhdGUgICAgICAgID0gU1RBVEVfUEVORElORzsgLyogIGluaXRpYWwgc3RhdGUgICovXG4gICAgdGhpcy5mdWxmaWxsVmFsdWUgPSB1bmRlZmluZWQ7ICAgICAvKiAgaW5pdGlhbCB2YWx1ZSAgKi8gICAgIC8qICBbUHJvbWlzZXMvQSsgMS4zLCAyLjEuMi4yXSAgKi9cbiAgICB0aGlzLnJlamVjdFJlYXNvbiA9IHVuZGVmaW5lZDsgICAgIC8qICBpbml0aWFsIHJlYXNvbiAqLyAgICAgLyogIFtQcm9taXNlcy9BKyAxLjUsIDIuMS4zLjJdICAqL1xuICAgIHRoaXMub25GdWxmaWxsZWQgID0gW107ICAgICAgICAgICAgLyogIGluaXRpYWwgaGFuZGxlcnMgICovXG4gICAgdGhpcy5vblJlamVjdGVkICAgPSBbXTsgICAgICAgICAgICAvKiAgaW5pdGlhbCBoYW5kbGVycyAgKi9cblxuICAgIC8qICBwcm92aWRlIG9wdGlvbmFsIGluZm9ybWF0aW9uLWhpZGluZyBwcm94eSAgKi9cbiAgICB0aGlzLnByb3h5ID0ge1xuICAgICAgdGhlbjogdGhpcy50aGVuLmJpbmQodGhpcylcbiAgICB9O1xuXG4gICAgLyogIHN1cHBvcnQgb3B0aW9uYWwgZXhlY3V0b3IgZnVuY3Rpb24gICovXG4gICAgaWYgKHR5cGVvZiBleGVjdXRvciA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgZXhlY3V0b3IuY2FsbCh0aGlzLCB0aGlzLmZ1bGZpbGwuYmluZCh0aGlzKSwgdGhpcy5yZWplY3QuYmluZCh0aGlzKSk7XG4gIH07XG5cbiAgLyogIHByb21pc2UgQVBJIG1ldGhvZHMgICovXG4gIGFwaS5wcm90b3R5cGUgPSB7XG4gICAgLyogIHByb21pc2UgcmVzb2x2aW5nIG1ldGhvZHMgICovXG4gICAgZnVsZmlsbDogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBkZWxpdmVyKHRoaXMsIFNUQVRFX0ZVTEZJTExFRCwgXCJmdWxmaWxsVmFsdWVcIiwgdmFsdWUpOyB9LFxuICAgIHJlamVjdDogIGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gZGVsaXZlcih0aGlzLCBTVEFURV9SRUpFQ1RFRCwgIFwicmVqZWN0UmVhc29uXCIsIHZhbHVlKTsgfSxcblxuICAgIC8qICBcIlRoZSB0aGVuIE1ldGhvZFwiIFtQcm9taXNlcy9BKyAxLjEsIDEuMiwgMi4yXSAgKi9cbiAgICB0aGVuOiBmdW5jdGlvbiAob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgIHZhciBjdXJyID0gdGhpcztcbiAgICAgIHZhciBuZXh0ID0gbmV3IGFwaSgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjddICAqL1xuICAgICAgY3Vyci5vbkZ1bGZpbGxlZC5wdXNoKFxuICAgICAgICByZXNvbHZlcihvbkZ1bGZpbGxlZCwgbmV4dCwgXCJmdWxmaWxsXCIpKTsgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuMi8yLjIuNl0gICovXG4gICAgICBjdXJyLm9uUmVqZWN0ZWQucHVzaChcbiAgICAgICAgcmVzb2x2ZXIob25SZWplY3RlZCwgIG5leHQsIFwicmVqZWN0XCIgKSk7ICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjMvMi4yLjZdICAqL1xuICAgICAgZXhlY3V0ZShjdXJyKTtcbiAgICAgIHJldHVybiBuZXh0LnByb3h5OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjcsIDMuM10gICovXG4gICAgfVxuICB9O1xuXG4gIC8qICBkZWxpdmVyIGFuIGFjdGlvbiAgKi9cbiAgdmFyIGRlbGl2ZXIgPSBmdW5jdGlvbiAoY3Vyciwgc3RhdGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKGN1cnIuc3RhdGUgPT09IFNUQVRFX1BFTkRJTkcpIHtcbiAgICAgIGN1cnIuc3RhdGUgPSBzdGF0ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4xLjIuMSwgMi4xLjMuMV0gICovXG4gICAgICBjdXJyW25hbWVdID0gdmFsdWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMS4yLjIsIDIuMS4zLjJdICAqL1xuICAgICAgZXhlY3V0ZShjdXJyKTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnI7XG4gIH07XG5cbiAgLyogIGV4ZWN1dGUgYWxsIGhhbmRsZXJzICAqL1xuICB2YXIgZXhlY3V0ZSA9IGZ1bmN0aW9uIChjdXJyKSB7XG4gICAgaWYgKGN1cnIuc3RhdGUgPT09IFNUQVRFX0ZVTEZJTExFRClcbiAgICAgIGV4ZWN1dGVfaGFuZGxlcnMoY3VyciwgXCJvbkZ1bGZpbGxlZFwiLCBjdXJyLmZ1bGZpbGxWYWx1ZSk7XG4gICAgZWxzZSBpZiAoY3Vyci5zdGF0ZSA9PT0gU1RBVEVfUkVKRUNURUQpXG4gICAgICBleGVjdXRlX2hhbmRsZXJzKGN1cnIsIFwib25SZWplY3RlZFwiLCAgY3Vyci5yZWplY3RSZWFzb24pO1xuICB9O1xuXG4gIC8qICBleGVjdXRlIHBhcnRpY3VsYXIgc2V0IG9mIGhhbmRsZXJzICAqL1xuICB2YXIgZXhlY3V0ZV9oYW5kbGVycyA9IGZ1bmN0aW9uIChjdXJyLCBuYW1lLCB2YWx1ZSkge1xuICAgIC8qIGdsb2JhbCBwcm9jZXNzOiB0cnVlICovXG4gICAgLyogZ2xvYmFsIHNldEltbWVkaWF0ZTogdHJ1ZSAqL1xuICAgIC8qIGdsb2JhbCBzZXRUaW1lb3V0OiB0cnVlICovXG5cbiAgICAvKiAgc2hvcnQtY2lyY3VpdCBwcm9jZXNzaW5nICAqL1xuICAgIGlmIChjdXJyW25hbWVdLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybjtcblxuICAgIC8qICBpdGVyYXRlIG92ZXIgYWxsIGhhbmRsZXJzLCBleGFjdGx5IG9uY2UgICovXG4gICAgdmFyIGhhbmRsZXJzID0gY3VycltuYW1lXTtcbiAgICBjdXJyW25hbWVdID0gW107ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuMi4zLCAyLjIuMy4zXSAgKi9cbiAgICB2YXIgZnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlcnMubGVuZ3RoOyBpKyspXG4gICAgICAgIGhhbmRsZXJzW2ldKHZhbHVlKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuNV0gICovXG4gICAgfTtcblxuICAgIC8qICBleGVjdXRlIHByb2NlZHVyZSBhc3luY2hyb25vdXNseSAgKi8gICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi40LCAzLjFdICAqL1xuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcHJvY2Vzcy5uZXh0VGljayA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jKTtcbiAgICBlbHNlIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICBzZXRJbW1lZGlhdGUoZnVuYyk7XG4gICAgZWxzZVxuICAgICAgc2V0VGltZW91dChmdW5jLCAwKTtcbiAgfTtcblxuICAvKiAgZ2VuZXJhdGUgYSByZXNvbHZlciBmdW5jdGlvbiAgKi9cbiAgdmFyIHJlc29sdmVyID0gZnVuY3Rpb24gKGNiLCBuZXh0LCBtZXRob2QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIGNiICE9PSBcImZ1bmN0aW9uXCIpICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjEsIDIuMi43LjMsIDIuMi43LjRdICAqL1xuICAgICAgICBuZXh0W21ldGhvZF0uY2FsbChuZXh0LCB2YWx1ZSk7ICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjcuMywgMi4yLjcuNF0gICovXG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHsgcmVzdWx0ID0gY2IodmFsdWUpOyB9ICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi4yLjEsIDIuMi4zLjEsIDIuMi41LCAzLjJdICAqL1xuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgIG5leHQucmVqZWN0KGUpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi43LjJdICAqL1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKG5leHQsIHJlc3VsdCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjcuMV0gICovXG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICAvKiAgXCJQcm9taXNlIFJlc29sdXRpb24gUHJvY2VkdXJlXCIgICovICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjNdICAqL1xuICB2YXIgcmVzb2x2ZSA9IGZ1bmN0aW9uIChwcm9taXNlLCB4KSB7XG4gICAgLyogIHNhbml0eSBjaGVjayBhcmd1bWVudHMgICovICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjFdICAqL1xuICAgIGlmIChwcm9taXNlID09PSB4IHx8IHByb21pc2UucHJveHkgPT09IHgpIHtcbiAgICAgIHByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoXCJjYW5ub3QgcmVzb2x2ZSBwcm9taXNlIHdpdGggaXRzZWxmXCIpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKiAgc3VyZ2ljYWxseSBjaGVjayBmb3IgYSBcInRoZW5cIiBtZXRob2RcbiAgICAgIChtYWlubHkgdG8ganVzdCBjYWxsIHRoZSBcImdldHRlclwiIG9mIFwidGhlblwiIG9ubHkgb25jZSkgICovXG4gICAgdmFyIHRoZW47XG4gICAgaWYgKCh0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiAmJiB4ICE9PSBudWxsKSB8fCB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0cnkgeyB0aGVuID0geC50aGVuOyB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjEsIDMuNV0gICovXG4gICAgICBjYXRjaCAoZSkge1xuICAgICAgICBwcm9taXNlLnJlamVjdChlKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMl0gICovXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiAgaGFuZGxlIG93biBUaGVuYWJsZXMgICAgW1Byb21pc2VzL0ErIDIuMy4yXVxuICAgICAgYW5kIHNpbWlsYXIgXCJ0aGVuYWJsZXNcIiBbUHJvbWlzZXMvQSsgMi4zLjNdICAqL1xuICAgIGlmICh0eXBlb2YgdGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB2YXIgcmVzb2x2ZWQgPSBmYWxzZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8qICBjYWxsIHJldHJpZXZlZCBcInRoZW5cIiBtZXRob2QgKi8gICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjNdICAqL1xuICAgICAgICB0aGVuLmNhbGwoeCxcbiAgICAgICAgICAvKiAgcmVzb2x2ZVByb21pc2UgICovICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjFdICAqL1xuICAgICAgICAgIGZ1bmN0aW9uICh5KSB7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZWQpIHJldHVybjsgcmVzb2x2ZWQgPSB0cnVlOyAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuM10gICovXG4gICAgICAgICAgICBpZiAoeSA9PT0geCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDMuNl0gICovXG4gICAgICAgICAgICAgIHByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoXCJjaXJjdWxhciB0aGVuYWJsZSBjaGFpblwiKSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHJlc29sdmUocHJvbWlzZSwgeSk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qICByZWplY3RQcm9taXNlICAqLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuMl0gICovXG4gICAgICAgICAgZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlZCkgcmV0dXJuOyByZXNvbHZlZCA9IHRydWU7ICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMy4zXSAgKi9cbiAgICAgICAgICAgIHByb21pc2UucmVqZWN0KHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGlmICghcmVzb2x2ZWQpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjNdICAqL1xuICAgICAgICAgIHByb21pc2UucmVqZWN0KGUpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuNF0gICovXG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyogIGhhbmRsZSBvdGhlciB2YWx1ZXMgICovXG4gICAgcHJvbWlzZS5mdWxmaWxsKHgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjQsIDIuMy4zLjRdICAqL1xuICB9O1xuXG4gIC8vIHVzZSBuYXRpdmUgcHJvbWlzZXMgd2hlcmUgcG9zc2libGVcbiAgJCQuUHJvbWlzZSA9IHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJyA/IGFwaSA6IFByb21pc2U7XG5cbiAgLy8gc28gd2UgYWx3YXlzIGhhdmUgUHJvbWlzZS5hbGwoKVxuICAkJC5Qcm9taXNlLmFsbCA9ICQkLlByb21pc2UuYWxsIHx8IGZ1bmN0aW9uKCBwcyApe1xuICAgIHJldHVybiBuZXcgJCQuUHJvbWlzZShmdW5jdGlvbiggcmVzb2x2ZUFsbCwgcmVqZWN0QWxsICl7XG4gICAgICB2YXIgdmFscyA9IG5ldyBBcnJheSggcHMubGVuZ3RoICk7XG4gICAgICB2YXIgZG9uZUNvdW50ID0gMDtcblxuICAgICAgdmFyIGZ1bGZpbGwgPSBmdW5jdGlvbiggaSwgdmFsICl7XG4gICAgICAgIHZhbHNbaV0gPSB2YWw7XG4gICAgICAgIGRvbmVDb3VudCsrO1xuXG4gICAgICAgIGlmKCBkb25lQ291bnQgPT09IHBzLmxlbmd0aCApe1xuICAgICAgICAgIHJlc29sdmVBbGwoIHZhbHMgKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAoZnVuY3Rpb24oIGkgKXtcbiAgICAgICAgICB2YXIgcCA9IHBzW2ldO1xuICAgICAgICAgIHZhciBpc1Byb21pc2UgPSBwLnRoZW4gIT0gbnVsbDtcblxuICAgICAgICAgIGlmKCBpc1Byb21pc2UgKXtcbiAgICAgICAgICAgIHAudGhlbihmdW5jdGlvbiggdmFsICl7XG4gICAgICAgICAgICAgIGZ1bGZpbGwoIGksIHZhbCApO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oIGVyciApe1xuICAgICAgICAgICAgICByZWplY3RBbGwoIGVyciApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBwO1xuICAgICAgICAgICAgZnVsZmlsbCggaSwgdmFsICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSggaSApO1xuICAgICAgfVxuXG4gICAgfSk7XG4gIH07XG5cbn0pKCBjeXRvc2NhcGUgKTtcbi8vIHR5cGUgdGVzdGluZyB1dGlsaXR5IGZ1bmN0aW9uc1xuXG47KGZ1bmN0aW9uKCQkLCB3aW5kb3cpeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHR5cGVvZnN0ciA9IHR5cGVvZiAnJztcbiAgdmFyIHR5cGVvZm9iaiA9IHR5cGVvZiB7fTtcbiAgdmFyIHR5cGVvZmZuID0gdHlwZW9mIGZ1bmN0aW9uKCl7fTtcblxuICAkJC5pcyA9IHtcbiAgICBkZWZpbmVkOiBmdW5jdGlvbihvYmope1xuICAgICAgcmV0dXJuIG9iaiAhPSBudWxsOyAvLyBub3QgdW5kZWZpbmVkIG9yIG51bGxcbiAgICB9LFxuXG4gICAgc3RyaW5nOiBmdW5jdGlvbihvYmope1xuICAgICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmogPT0gdHlwZW9mc3RyO1xuICAgIH0sXG4gICAgXG4gICAgZm46IGZ1bmN0aW9uKG9iail7XG4gICAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gdHlwZW9mZm47XG4gICAgfSxcbiAgICBcbiAgICBhcnJheTogZnVuY3Rpb24ob2JqKXtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5ID8gQXJyYXkuaXNBcnJheShvYmopIDogb2JqICE9IG51bGwgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXk7XG4gICAgfSxcbiAgICBcbiAgICBwbGFpbk9iamVjdDogZnVuY3Rpb24ob2JqKXtcbiAgICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSB0eXBlb2ZvYmogJiYgISQkLmlzLmFycmF5KG9iaikgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG4gICAgfSxcblxuICAgIG9iamVjdDogZnVuY3Rpb24ob2JqKXtcbiAgICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSB0eXBlb2ZvYmo7XG4gICAgfSxcbiAgICBcbiAgICBudW1iZXI6IGZ1bmN0aW9uKG9iail7XG4gICAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gdHlwZW9mIDEgJiYgIWlzTmFOKG9iaik7XG4gICAgfSxcblxuICAgIGludGVnZXI6IGZ1bmN0aW9uKCBvYmogKXtcbiAgICAgIHJldHVybiAkJC5pcy5udW1iZXIob2JqKSAmJiBNYXRoLmZsb29yKG9iaikgPT09IG9iajtcbiAgICB9LFxuICAgIFxuICAgIGNvbG9yOiBmdW5jdGlvbihvYmope1xuICAgICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmogPT09IHR5cGVvZiAnJyAmJiAkLkNvbG9yKG9iaikudG9TdHJpbmcoKSAhPT0gJyc7XG4gICAgfSxcbiAgICBcbiAgICBib29sOiBmdW5jdGlvbihvYmope1xuICAgICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmogPT09IHR5cGVvZiB0cnVlO1xuICAgIH0sXG4gICAgXG4gICAgZWxlbWVudE9yQ29sbGVjdGlvbjogZnVuY3Rpb24ob2JqKXtcbiAgICAgIHJldHVybiAkJC5pcy5lbGVtZW50KG9iaikgfHwgJCQuaXMuY29sbGVjdGlvbihvYmopO1xuICAgIH0sXG4gICAgXG4gICAgZWxlbWVudDogZnVuY3Rpb24ob2JqKXtcbiAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiAkJC5FbGVtZW50ICYmIG9iai5fcHJpdmF0ZS5zaW5nbGU7XG4gICAgfSxcbiAgICBcbiAgICBjb2xsZWN0aW9uOiBmdW5jdGlvbihvYmope1xuICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mICQkLkNvbGxlY3Rpb24gJiYgIW9iai5fcHJpdmF0ZS5zaW5nbGU7XG4gICAgfSxcbiAgICBcbiAgICBjb3JlOiBmdW5jdGlvbihvYmope1xuICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mICQkLkNvcmU7XG4gICAgfSxcblxuICAgIHN0eWxlOiBmdW5jdGlvbihvYmope1xuICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mICQkLlN0eWxlO1xuICAgIH0sXG5cbiAgICBzdHlsZXNoZWV0OiBmdW5jdGlvbihvYmope1xuICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mICQkLlN0eWxlc2hlZXQ7XG4gICAgfSxcblxuICAgIGV2ZW50OiBmdW5jdGlvbihvYmope1xuICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mICQkLkV2ZW50O1xuICAgIH0sXG5cbiAgICB0aHJlYWQ6IGZ1bmN0aW9uKG9iail7XG4gICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgJCQuVGhyZWFkO1xuICAgIH0sXG5cbiAgICBmYWJyaWM6IGZ1bmN0aW9uKG9iail7XG4gICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgJCQuRmFicmljO1xuICAgIH0sXG5cbiAgICBlbXB0eVN0cmluZzogZnVuY3Rpb24ob2JqKXtcbiAgICAgIGlmKCAhb2JqICl7IC8vIG51bGwgaXMgZW1wdHlcbiAgICAgICAgcmV0dXJuIHRydWU7IFxuICAgICAgfSBlbHNlIGlmKCAkJC5pcy5zdHJpbmcob2JqKSApe1xuICAgICAgICBpZiggb2JqID09PSAnJyB8fCBvYmoubWF0Y2goL15cXHMrJC8pICl7XG4gICAgICAgICAgcmV0dXJuIHRydWU7IC8vIGVtcHR5IHN0cmluZyBpcyBlbXB0eVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gb3RoZXJ3aXNlLCB3ZSBkb24ndCBrbm93IHdoYXQgd2UndmUgZ290XG4gICAgfSxcbiAgICBcbiAgICBub25lbXB0eVN0cmluZzogZnVuY3Rpb24ob2JqKXtcbiAgICAgIGlmKCBvYmogJiYgJCQuaXMuc3RyaW5nKG9iaikgJiYgb2JqICE9PSAnJyAmJiAhb2JqLm1hdGNoKC9eXFxzKyQvKSApe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBkb21FbGVtZW50OiBmdW5jdGlvbihvYmope1xuICAgICAgaWYoIHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcgKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyB3ZSdyZSBub3QgaW4gYSBicm93c2VyIHNvIGl0IGRvZXNuJ3QgbWF0dGVyXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGJvdW5kaW5nQm94OiBmdW5jdGlvbihvYmope1xuICAgICAgcmV0dXJuICQkLmlzLnBsYWluT2JqZWN0KG9iaikgJiYgXG4gICAgICAgICQkLmlzLm51bWJlcihvYmoueDEpICYmICQkLmlzLm51bWJlcihvYmoueDIpICYmXG4gICAgICAgICQkLmlzLm51bWJlcihvYmoueTEpICYmICQkLmlzLm51bWJlcihvYmoueTIpXG4gICAgICA7XG4gICAgfSxcblxuICAgIHByb21pc2U6IGZ1bmN0aW9uKG9iail7XG4gICAgICByZXR1cm4gJCQuaXMub2JqZWN0KG9iaikgJiYgJCQuaXMuZm4ob2JqLnRoZW4pO1xuICAgIH0sXG5cbiAgICB0b3VjaDogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB3aW5kb3cgJiYgKCAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSB8fCB3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIERvY3VtZW50VG91Y2ggKTtcbiAgICB9LFxuXG4gICAgZ2Vja286IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdHlwZW9mIEluc3RhbGxUcmlnZ2VyICE9PSAndW5kZWZpbmVkJyB8fCAoJ01vekFwcGVhcmFuY2UnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSk7XG4gICAgfSxcblxuICAgIHdlYmtpdDogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0eXBlb2Ygd2Via2l0VVJMICE9PSAndW5kZWZpbmVkJyB8fCAoJ1dlYmtpdEFwcGVhcmFuY2UnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSk7XG4gICAgfSxcblxuICAgIGNocm9taXVtOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHR5cGVvZiBjaHJvbWUgIT09ICd1bmRlZmluZWQnO1xuICAgIH0sXG5cbiAgICBraHRtbDogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBuYXZpZ2F0b3IudmVuZG9yLm1hdGNoKC9rZGUvaSk7IC8vIFRPRE8gcHJvYmFibHkgYSBiZXR0ZXIgd2F5IHRvIGRldGVjdCB0aGlzLi4uXG4gICAgfSxcblxuICAgIGtodG1sRXRjOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuICQkLmlzLmtodG1sKCkgfHwgJCQuaXMud2Via2l0KCkgfHwgJCQuaXMuY2hyb21pdW0oKTtcbiAgICB9LFxuXG4gICAgdHJpZGVudDogZnVuY3Rpb24oKXtcbiAgICAgICByZXR1cm4gdHlwZW9mIEFjdGl2ZVhPYmplY3QgIT09ICd1bmRlZmluZWQnIHx8IC8qQGNjX29uIUAqL2ZhbHNlO1xuICAgIH0sXG5cbiAgICB3aW5kb3dzOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci5hcHBWZXJzaW9uLm1hdGNoKC9XaW4vaSk7XG4gICAgfSxcblxuICAgIG1hYzogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IuYXBwVmVyc2lvbi5tYXRjaCgvTWFjL2kpO1xuICAgIH0sXG5cbiAgICBsaW51eDogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IuYXBwVmVyc2lvbi5tYXRjaCgvTGludXgvaSk7XG4gICAgfSxcblxuICAgIHVuaXg6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLmFwcFZlcnNpb24ubWF0Y2goL1gxMS9pKTtcbiAgICB9XG4gIH07ICBcbiAgXG59KSggY3l0b3NjYXBlLCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB3aW5kb3cgKTtcblxuOyhmdW5jdGlvbigkJCwgd2luZG93KXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgLy8gdXRpbGl0eSBmdW5jdGlvbnMgb25seSBmb3IgaW50ZXJuYWwgdXNlXG5cbiAgJCQudXRpbCA9IHtcblxuICAgIC8vIHRoZSBqcXVlcnkgZXh0ZW5kKCkgZnVuY3Rpb25cbiAgICAvLyBOQjogbW9kaWZpZWQgdG8gdXNlICQkLmlzIGV0YyBzaW5jZSB3ZSBjYW4ndCB1c2UganF1ZXJ5IGZ1bmN0aW9uc1xuICAgIGV4dGVuZDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXG4gICAgICAgIHRhcmdldCA9IGFyZ3VtZW50c1swXSB8fCB7fSxcbiAgICAgICAgaSA9IDEsXG4gICAgICAgIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgIGRlZXAgPSBmYWxzZTtcblxuICAgICAgLy8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuICAgICAgaWYgKCB0eXBlb2YgdGFyZ2V0ID09PSAnYm9vbGVhbicgKSB7XG4gICAgICAgIGRlZXAgPSB0YXJnZXQ7XG4gICAgICAgIHRhcmdldCA9IGFyZ3VtZW50c1sxXSB8fCB7fTtcbiAgICAgICAgLy8gc2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuICAgICAgICBpID0gMjtcbiAgICAgIH1cblxuICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG4gICAgICBpZiAoIHR5cGVvZiB0YXJnZXQgIT09ICdvYmplY3QnICYmICEkJC5pcy5mbih0YXJnZXQpICkge1xuICAgICAgICB0YXJnZXQgPSB7fTtcbiAgICAgIH1cblxuICAgICAgLy8gZXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG4gICAgICBpZiAoIGxlbmd0aCA9PT0gaSApIHtcbiAgICAgICAgdGFyZ2V0ID0gdGhpcztcbiAgICAgICAgLS1pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcbiAgICAgICAgLy8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuICAgICAgICBpZiAoIChvcHRpb25zID0gYXJndW1lbnRzWyBpIF0pICE9IG51bGwgKSB7XG4gICAgICAgICAgLy8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuICAgICAgICAgIGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcbiAgICAgICAgICAgIHNyYyA9IHRhcmdldFsgbmFtZSBdO1xuICAgICAgICAgICAgY29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuICAgICAgICAgICAgLy8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxuICAgICAgICAgICAgaWYgKCB0YXJnZXQgPT09IGNvcHkgKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcbiAgICAgICAgICAgIGlmICggZGVlcCAmJiBjb3B5ICYmICggJCQuaXMucGxhaW5PYmplY3QoY29weSkgfHwgKGNvcHlJc0FycmF5ID0gJCQuaXMuYXJyYXkoY29weSkpICkgKSB7XG4gICAgICAgICAgICAgIGlmICggY29weUlzQXJyYXkgKSB7XG4gICAgICAgICAgICAgICAgY29weUlzQXJyYXkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjbG9uZSA9IHNyYyAmJiAkJC5pcy5hcnJheShzcmMpID8gc3JjIDogW107XG5cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbG9uZSA9IHNyYyAmJiAkJC5pcy5wbGFpbk9iamVjdChzcmMpID8gc3JjIDoge307XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cbiAgICAgICAgICAgICAgdGFyZ2V0WyBuYW1lIF0gPSAkJC51dGlsLmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcblxuICAgICAgICAgICAgLy8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuICAgICAgICAgICAgfSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICB0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0sXG5cbiAgICAvLyByZXF1aXJlIHRoYXQgcHVsbHMgaW4gbW9kdWxlIGZyb20gY29tbW9uanMsIGFtZCwgb3Igd2luZG93IChmYWxsaW5nIGJhY2sgdW50aWwgZm91bmQpXG4gICAgcmVxdWlyZTogZnVuY3Rpb24oIG5hbWUsIGNhbGxiYWNrLCBvcHRpb25zICl7XG4gICAgICB2YXIgcmV0O1xuICAgICAgb3B0aW9ucyA9ICQkLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgbXNnSWZOb3RGb3VuZDogdHJ1ZVxuICAgICAgfSwgb3B0aW9ucyk7XG5cbiAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICB2YXIgZnVsZmlsID0gZnVuY3Rpb24oIHJldCApe1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgY2FsbGJhY2soIHJldCApO1xuICAgICAgfTtcblxuICAgICAgdmFyIGNoZWNrV2luZG93ID0gZnVuY3Rpb24oIG5leHQgKXtcbiAgICAgICAgaWYoIHdpbmRvdyApeyAvLyBkZXRlY3RlZCBicm93c2VyL3dpbmRvdyBlbnZcbiAgICAgICAgICByZXQgPSB3aW5kb3dbIG5hbWUgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCByZXQgIT09IHVuZGVmaW5lZCApeyBmdWxmaWwocmV0KTsgfVxuICAgICAgICBpZiggbmV4dCApeyBuZXh0KCk7IH1cbiAgICAgIH07XG4gICAgICB2YXIgb25DaGVja1dpbmRvd0RvbmUgPSBmdW5jdGlvbigpe1xuICAgICAgICBpZiggIWRvbmUgKXtcbiAgICAgICAgICBjaGVja0NvbW1vbkpzKCBvbkNoZWNrQ29tbW9uSnNEb25lICk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBjaGVja0NvbW1vbkpzID0gZnVuY3Rpb24oIG5leHQgKXtcbiAgICAgICAgaWYoIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzICYmIHJlcXVpcmUgKXsgLy8gZGV0ZWN0ZWQgY29tbW9uanMgZW52XG4gICAgICAgICAgcmV0ID0gcmVxdWlyZSggbmFtZSApOyAvLyByZWd1bGFyIHJlcXVpcmVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCByZXQgIT09IHVuZGVmaW5lZCApeyBmdWxmaWwocmV0KTsgfVxuICAgICAgICBpZiggbmV4dCApeyBuZXh0KCk7IH1cbiAgICAgIH07XG4gICAgICB2YXIgb25DaGVja0NvbW1vbkpzRG9uZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKCAhZG9uZSApe1xuICAgICAgICAgIGNoZWNrQW1kKCBvbkNoZWNrQW1kRG9uZSApO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgY2hlY2tBbWQgPSBmdW5jdGlvbiggbmV4dCApe1xuICAgICAgICBpZiggdHlwZW9mIGRlZmluZSAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVmaW5lLmFtZCAmJiByZXF1aXJlICl7IC8vIGRldGVjdGVkIGFtZCBlbnYgdy8gZGVmaW5lZCBtb2R1bGVcbiAgICAgICAgICByZXF1aXJlKFsgbmFtZSBdLCBmdW5jdGlvbiggbmFtZUltcGwgKXtcbiAgICAgICAgICAgIHJldCA9IG5hbWVJbXBsO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiggcmV0ICE9PSB1bmRlZmluZWQgKXsgZnVsZmlsKHJldCk7IH1cbiAgICAgICAgICAgIGlmKCBuZXh0ICl7IG5leHQoKTsgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdmFyIG9uQ2hlY2tBbWREb25lID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoICFkb25lICYmIG9wdGlvbnMubXNnSWZOb3RGb3VuZCApe1xuICAgICAgICAgICQkLnV0aWwuZXJyb3IoJ0N5dG9zY2FwZS5qcyB0cmllZCB0byBwdWxsIGluIGRlcGVuZGVuY3kgYCcgKyBuYW1lICsgJ2AgYnV0IG5vIG1vZHVsZSAoaS5lLiBDb21tb25KUywgQU1ELCBvciB3aW5kb3cpIHdhcyBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBraWNrIG9mZiAxc3QgY2hlY2s6IHdpbmRvd1xuICAgICAgY2hlY2tXaW5kb3coIG9uQ2hlY2tXaW5kb3dEb25lICk7XG5cbiAgICB9LFxuXG4gICAgLy8gbXVsdGlwbGUgcmVxdWlyZXMgaW4gb25lIGNhbGxiYWNrXG4gICAgcmVxdWlyZXM6IGZ1bmN0aW9uKCBuYW1lcywgY2FsbGJhY2sgKXtcbiAgICAgIHZhciBpbXBscyA9IFtdO1xuICAgICAgdmFyIGdvdEltcGwgPSBbXTtcblxuICAgICAgdmFyIGNoZWNrRG9uZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKysgKXsgLy8gY2hlY2sgaGF2ZSBhbGwgaW1wbHNcbiAgICAgICAgICBpZiggIWdvdEltcGxbaV0gKXsgcmV0dXJuOyB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvdGhlcndpc2UsIGFsbCBnb3QgYWxsIGltcGxzID0+IGRvbmVcbiAgICAgICAgY2FsbGJhY2suYXBwbHkoIGNhbGxiYWNrLCBpbXBscyApOyBcbiAgICAgIH07XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKysgKXsgKGZ1bmN0aW9uKCl7IC8vIHcvc2NvcGVcbiAgICAgICAgdmFyIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgdmFyIGluZGV4ID0gaTtcblxuICAgICAgICAkJC51dGlsLnJlcXVpcmUobmFtZSwgZnVuY3Rpb24oaW1wbCl7XG4gICAgICAgICAgaW1wbHNbaW5kZXhdID0gaW1wbDtcbiAgICAgICAgICBnb3RJbXBsW2luZGV4XSA9IHRydWU7XG5cbiAgICAgICAgICBjaGVja0RvbmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSgpOyB9XG4gICAgfSxcblxuICAgIC8vIHBvcnRlZCBsb2Rhc2ggdGhyb3R0bGUgZnVuY3Rpb25cbiAgICB0aHJvdHRsZTogZnVuY3Rpb24oZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgdmFyIGxlYWRpbmcgPSB0cnVlLFxuICAgICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgIGxlYWRpbmcgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoJCQuaXMucGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgbGVhZGluZyA9ICdsZWFkaW5nJyBpbiBvcHRpb25zID8gb3B0aW9ucy5sZWFkaW5nIDogbGVhZGluZztcbiAgICAgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyBvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gICAgICB9XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIG9wdGlvbnMubGVhZGluZyA9IGxlYWRpbmc7XG4gICAgICBvcHRpb25zLm1heFdhaXQgPSB3YWl0O1xuICAgICAgb3B0aW9ucy50cmFpbGluZyA9IHRyYWlsaW5nO1xuXG4gICAgICByZXR1cm4gJCQudXRpbC5kZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgbm93OiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuICtuZXcgRGF0ZSgpO1xuICAgIH0sXG5cbiAgICAvLyBwb3J0ZWQgbG9kYXNoIGRlYm91bmNlIGZ1bmN0aW9uXG4gICAgZGVib3VuY2U6IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBhcmdzLFxuICAgICAgICAgIG1heFRpbWVvdXRJZCxcbiAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgc3RhbXAsXG4gICAgICAgICAgdGhpc0FyZyxcbiAgICAgICAgICB0aW1lb3V0SWQsXG4gICAgICAgICAgdHJhaWxpbmdDYWxsLFxuICAgICAgICAgIGxhc3RDYWxsZWQgPSAwLFxuICAgICAgICAgIG1heFdhaXQgPSBmYWxzZSxcbiAgICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICAgIGlmICghJCQuaXMuZm4oZnVuYykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd2FpdCA9IE1hdGgubWF4KDAsIHdhaXQpIHx8IDA7XG4gICAgICBpZiAob3B0aW9ucyA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgbGVhZGluZyA9IHRydWU7XG4gICAgICAgIHRyYWlsaW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKCQkLmlzLnBsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIGxlYWRpbmcgPSBvcHRpb25zLmxlYWRpbmc7XG4gICAgICAgIG1heFdhaXQgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucyAmJiAoTWF0aC5tYXgod2FpdCwgb3B0aW9ucy5tYXhXYWl0KSB8fCAwKTtcbiAgICAgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyBvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gICAgICB9XG4gICAgICB2YXIgZGVsYXllZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtICgkJC51dGlsLm5vdygpIC0gc3RhbXApO1xuICAgICAgICBpZiAocmVtYWluaW5nIDw9IDApIHtcbiAgICAgICAgICBpZiAobWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQobWF4VGltZW91dElkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGlzQ2FsbGVkID0gdHJhaWxpbmdDYWxsO1xuICAgICAgICAgIG1heFRpbWVvdXRJZCA9IHRpbWVvdXRJZCA9IHRyYWlsaW5nQ2FsbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAoaXNDYWxsZWQpIHtcbiAgICAgICAgICAgIGxhc3RDYWxsZWQgPSAkJC51dGlsLm5vdygpO1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgICAgIGlmICghdGltZW91dElkICYmICFtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgICAgYXJncyA9IHRoaXNBcmcgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGRlbGF5ZWQsIHJlbWFpbmluZyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBtYXhEZWxheWVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aW1lb3V0SWQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICBtYXhUaW1lb3V0SWQgPSB0aW1lb3V0SWQgPSB0cmFpbGluZ0NhbGwgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0cmFpbGluZyB8fCAobWF4V2FpdCAhPT0gd2FpdCkpIHtcbiAgICAgICAgICBsYXN0Q2FsbGVkID0gJCQudXRpbC5ub3coKTtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgIGlmICghdGltZW91dElkICYmICFtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGFyZ3MgPSB0aGlzQXJnID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgc3RhbXAgPSAkJC51dGlsLm5vdygpO1xuICAgICAgICB0aGlzQXJnID0gdGhpcztcbiAgICAgICAgdHJhaWxpbmdDYWxsID0gdHJhaWxpbmcgJiYgKHRpbWVvdXRJZCB8fCAhbGVhZGluZyk7XG5cbiAgICAgICAgaWYgKG1heFdhaXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdmFyIGxlYWRpbmdDYWxsID0gbGVhZGluZyAmJiAhdGltZW91dElkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghbWF4VGltZW91dElkICYmICFsZWFkaW5nKSB7XG4gICAgICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZW1haW5pbmcgPSBtYXhXYWl0IC0gKHN0YW1wIC0gbGFzdENhbGxlZCksXG4gICAgICAgICAgICAgIGlzQ2FsbGVkID0gcmVtYWluaW5nIDw9IDA7XG5cbiAgICAgICAgICBpZiAoaXNDYWxsZWQpIHtcbiAgICAgICAgICAgIGlmIChtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgICAgbWF4VGltZW91dElkID0gY2xlYXJUaW1lb3V0KG1heFRpbWVvdXRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICghbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICBtYXhUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KG1heERlbGF5ZWQsIHJlbWFpbmluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NhbGxlZCAmJiB0aW1lb3V0SWQpIHtcbiAgICAgICAgICB0aW1lb3V0SWQgPSBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGltZW91dElkICYmIHdhaXQgIT09IG1heFdhaXQpIHtcbiAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGRlbGF5ZWQsIHdhaXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWFkaW5nQ2FsbCkge1xuICAgICAgICAgIGlzQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NhbGxlZCAmJiAhdGltZW91dElkICYmICFtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICBhcmdzID0gdGhpc0FyZyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSxcblxuICAgIGVycm9yOiBmdW5jdGlvbiggbXNnICl7XG4gICAgICBpZiggY29uc29sZSApe1xuICAgICAgICBpZiggY29uc29sZS5lcnJvciApe1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IuYXBwbHkoIGNvbnNvbGUsIGFyZ3VtZW50cyApO1xuICAgICAgICB9IGVsc2UgaWYoIGNvbnNvbGUubG9nICl7XG4gICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoIGNvbnNvbGUsIGFyZ3VtZW50cyApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG1zZztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbXNnO1xuICAgICAgfVxuICAgIH0sICAgIFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCBvYmogKXtcbiAgICAgIHZhciB0YXJnZXQgPSB7fTtcbiAgICAgIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgICAgIGlmICggb2JqLmhhc093blByb3BlcnR5KGkpICkgeyAvLyBUT0RPIGlzIHRoaXMgaGFzT3duUHJvcGVydHkoKSBjYWxsIG5lY2Vzc2FyeSBmb3Igb3VyIHVzZT9cbiAgICAgICAgICB0YXJnZXRbaV0gPSBvYmpbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSxcblxuICAgIC8vIGdldHMgYSBzaGFsbG93IGNvcHkgb2YgdGhlIGFyZ3VtZW50XG4gICAgY29weTogZnVuY3Rpb24oIG9iaiApe1xuICAgICAgaWYoIG9iaiA9PSBudWxsICl7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9IGlmKCAkJC5pcy5hcnJheShvYmopICl7XG4gICAgICAgIHJldHVybiBvYmouc2xpY2UoKTtcbiAgICAgIH0gZWxzZSBpZiggJCQuaXMucGxhaW5PYmplY3Qob2JqKSApe1xuICAgICAgICByZXR1cm4gJCQudXRpbC5jbG9uZSggb2JqICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgLy8gbWFrZXMgYSBmdWxsIGJiICh4MSwgeTEsIHgyLCB5MiwgdywgaCkgZnJvbSBpbXBsaWNpdCBwYXJhbXNcbiAgICBtYWtlQm91bmRpbmdCb3g6IGZ1bmN0aW9uKCBiYiApe1xuICAgICAgaWYoIGJiLngxICE9IG51bGwgJiYgYmIueTEgIT0gbnVsbCApe1xuICAgICAgICBpZiggYmIueDIgIT0gbnVsbCAmJiBiYi55MiAhPSBudWxsICYmIGJiLngyID49IGJiLngxICYmIGJiLnkyID49IGJiLnkxICl7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHgxOiBiYi54MSxcbiAgICAgICAgICAgIHkxOiBiYi55MSxcbiAgICAgICAgICAgIHgyOiBiYi54MixcbiAgICAgICAgICAgIHkyOiBiYi55MixcbiAgICAgICAgICAgIHc6IGJiLngyIC0gYmIueDEsXG4gICAgICAgICAgICBoOiBiYi55MiAtIGJiLnkxXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmKCBiYi53ICE9IG51bGwgJiYgYmIuaCAhPSBudWxsICYmIGJiLncgPj0gMCAmJiBiYi5oID49IDAgKXtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDE6IGJiLngxLFxuICAgICAgICAgICAgeTE6IGJiLnkxLFxuICAgICAgICAgICAgeDI6IGJiLngxICsgYmIudyxcbiAgICAgICAgICAgIHkyOiBiYi55MSArIGJiLmgsXG4gICAgICAgICAgICB3OiBiYi53LFxuICAgICAgICAgICAgaDogYmIuaFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gXG4gICAgfSxcblxuICAgIC8vIGhhcyBhbnl0aGluZyBiZWVuIHNldCBpbiB0aGUgbWFwXG4gICAgbWFwRW1wdHk6IGZ1bmN0aW9uKCBtYXAgKXtcbiAgICAgIHZhciBlbXB0eSA9IHRydWU7XG5cbiAgICAgIGlmKCBtYXAgIT0gbnVsbCApe1xuICAgICAgICBmb3IodmFyIGkgaW4gbWFwKXsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZW1wdHk7XG4gICAgfSxcblxuICAgIC8vIHB1c2hlcyB0byB0aGUgYXJyYXkgYXQgdGhlIGVuZCBvZiBhIG1hcCAobWFwIG1heSBub3QgYmUgYnVpbHQpXG4gICAgcHVzaE1hcDogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICAgIHZhciBhcnJheSA9ICQkLnV0aWwuZ2V0TWFwKG9wdGlvbnMpO1xuXG4gICAgICBpZiggYXJyYXkgPT0gbnVsbCApeyAvLyBpZiBlbXB0eSwgcHV0IGluaXRpYWwgYXJyYXlcbiAgICAgICAgJCQudXRpbC5zZXRNYXAoICQuZXh0ZW5kKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgdmFsdWU6IFsgb3B0aW9ucy52YWx1ZSBdXG4gICAgICAgIH0pICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcnJheS5wdXNoKCBvcHRpb25zLnZhbHVlICk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIHNldHMgdGhlIHZhbHVlIGluIGEgbWFwIChtYXAgbWF5IG5vdCBiZSBidWlsdClcbiAgICBzZXRNYXA6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgICB2YXIgb2JqID0gb3B0aW9ucy5tYXA7XG4gICAgICB2YXIga2V5O1xuICAgICAgdmFyIGtleXMgPSBvcHRpb25zLmtleXM7XG4gICAgICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuXG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrKXtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYoICQkLmlzLnBsYWluT2JqZWN0KCBrZXkgKSApe1xuICAgICAgICAgICQkLnV0aWwuZXJyb3IoJ1RyaWVkIHRvIHNldCBtYXAgd2l0aCBvYmplY3Qga2V5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggaSA8IGtleXMubGVuZ3RoIC0gMSApe1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIGV4dGVuZCB0aGUgbWFwIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgIGlmKCBvYmpba2V5XSA9PSBudWxsICl7XG4gICAgICAgICAgICBvYmpba2V5XSA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBvYmogPSBvYmpba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBzZXQgdGhlIHZhbHVlXG4gICAgICAgICAgb2JqW2tleV0gPSBvcHRpb25zLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcbiAgICAvLyBnZXRzIHRoZSB2YWx1ZSBpbiBhIG1hcCBldmVuIGlmIGl0J3Mgbm90IGJ1aWx0IGluIHBsYWNlc1xuICAgIGdldE1hcDogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICAgIHZhciBvYmogPSBvcHRpb25zLm1hcDtcbiAgICAgIHZhciBrZXlzID0gb3B0aW9ucy5rZXlzO1xuICAgICAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcbiAgICAgIFxuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKyl7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmKCAkJC5pcy5wbGFpbk9iamVjdCgga2V5ICkgKXtcbiAgICAgICAgICAkJC51dGlsLmVycm9yKCdUcmllZCB0byBnZXQgbWFwIHdpdGggb2JqZWN0IGtleScpO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0gb2JqW2tleV07XG4gICAgICAgIFxuICAgICAgICBpZiggb2JqID09IG51bGwgKXtcbiAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcblxuICAgIC8vIGRlbGV0ZXMgdGhlIGVudHJ5IGluIHRoZSBtYXBcbiAgICBkZWxldGVNYXA6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgICB2YXIgb2JqID0gb3B0aW9ucy5tYXA7XG4gICAgICB2YXIga2V5cyA9IG9wdGlvbnMua2V5cztcbiAgICAgIHZhciBsID0ga2V5cy5sZW5ndGg7XG4gICAgICB2YXIga2VlcENoaWxkcmVuID0gb3B0aW9ucy5rZWVwQ2hpbGRyZW47XG4gICAgICBcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKyspe1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiggJCQuaXMucGxhaW5PYmplY3QoIGtleSApICl7XG4gICAgICAgICAgJCQudXRpbC5lcnJvcignVHJpZWQgdG8gZGVsZXRlIG1hcCB3aXRoIG9iamVjdCBrZXknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYXN0S2V5ID0gaSA9PT0gb3B0aW9ucy5rZXlzLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmKCBsYXN0S2V5ICl7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYoIGtlZXBDaGlsZHJlbiApeyAvLyB0aGVuIG9ubHkgZGVsZXRlIGNoaWxkIGZpZWxkcyBub3QgaW4ga2VlcENoaWxkcmVuXG4gICAgICAgICAgICBmb3IoIHZhciBjaGlsZCBpbiBvYmogKXtcbiAgICAgICAgICAgICAgaWYoICFrZWVwQ2hpbGRyZW5bY2hpbGRdICl7XG4gICAgICAgICAgICAgICAgb2JqW2NoaWxkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYmpba2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYmogPSBvYmpba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgY2FwaXRhbGl6ZTogZnVuY3Rpb24oc3RyKXtcbiAgICAgIGlmKCAkJC5pcy5lbXB0eVN0cmluZyhzdHIpICl7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xuICAgIH0sXG5cbiAgICBjYW1lbDJkYXNoOiBmdW5jdGlvbiggc3RyICl7XG4gICAgICB2YXIgcmV0ID0gW107XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBjaCA9IHN0cltpXTtcbiAgICAgICAgdmFyIGNoTG93ZXJDYXNlID0gY2gudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIGlzVXBwZXJDYXNlID0gY2ggIT09IGNoTG93ZXJDYXNlO1xuXG4gICAgICAgIGlmKCBpc1VwcGVyQ2FzZSApe1xuICAgICAgICAgIHJldC5wdXNoKCAnLScgKTtcbiAgICAgICAgICByZXQucHVzaCggY2hMb3dlckNhc2UgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQucHVzaCggY2ggKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbm9VcHBlckNhc2VzID0gcmV0Lmxlbmd0aCA9PT0gc3RyLmxlbmd0aDtcbiAgICAgIGlmKCBub1VwcGVyQ2FzZXMgKXsgcmV0dXJuIHN0cjsgfSAvLyBjaGVhcGVyIHRoYW4gLmpvaW4oKVxuXG4gICAgICByZXR1cm4gcmV0LmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICBkYXNoMmNhbWVsOiBmdW5jdGlvbiggc3RyICl7XG4gICAgICB2YXIgcmV0ID0gW107XG4gICAgICB2YXIgbmV4dElzVXBwZXIgPSBmYWxzZTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGNoID0gc3RyW2ldO1xuICAgICAgICB2YXIgaXNEYXNoID0gY2ggPT09ICctJztcblxuICAgICAgICBpZiggaXNEYXNoICl7XG4gICAgICAgICAgbmV4dElzVXBwZXIgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmKCBuZXh0SXNVcHBlciApe1xuICAgICAgICAgICAgcmV0LnB1c2goIGNoLnRvVXBwZXJDYXNlKCkgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0LnB1c2goIGNoICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dElzVXBwZXIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0LmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvLyBzdHJpcCBzcGFjZXMgZnJvbSBiZWdpbm5pbmcgb2Ygc3RyaW5nIGFuZCBlbmQgb2Ygc3RyaW5nXG4gICAgdHJpbTogZnVuY3Rpb24oIHN0ciApe1xuICAgICAgdmFyIGZpcnN0LCBsYXN0O1xuXG4gICAgICAvLyBmaW5kIGZpcnN0IG5vbi1zcGFjZSBjaGFyXG4gICAgICBmb3IoIGZpcnN0ID0gMDsgZmlyc3QgPCBzdHIubGVuZ3RoICYmIHN0cltmaXJzdF0gPT09ICcgJzsgZmlyc3QrKyApe31cblxuICAgICAgLy8gZmluZCBsYXN0IG5vbi1zcGFjZSBjaGFyXG4gICAgICBmb3IoIGxhc3QgPSBzdHIubGVuZ3RoIC0gMTsgbGFzdCA+IGZpcnN0ICYmIHN0cltsYXN0XSA9PT0gJyAnOyBsYXN0LS0gKXt9XG5cbiAgICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKGZpcnN0LCBsYXN0ICsgMSk7XG4gICAgfSxcblxuICAgIC8vIGdldCBbciwgZywgYl0gZnJvbSAjYWJjIG9yICNhYWJiY2NcbiAgICBoZXgydHVwbGU6IGZ1bmN0aW9uKCBoZXggKXtcbiAgICAgIGlmKCAhKGhleC5sZW5ndGggPT09IDQgfHwgaGV4Lmxlbmd0aCA9PT0gNykgfHwgaGV4WzBdICE9PSBcIiNcIiApeyByZXR1cm47IH1cblxuICAgICAgdmFyIHNob3J0SGV4ID0gaGV4Lmxlbmd0aCA9PT0gNDtcbiAgICAgIHZhciByLCBnLCBiO1xuICAgICAgdmFyIGJhc2UgPSAxNjtcblxuICAgICAgaWYoIHNob3J0SGV4ICl7XG4gICAgICAgIHIgPSBwYXJzZUludCggaGV4WzFdICsgaGV4WzFdLCBiYXNlICk7XG4gICAgICAgIGcgPSBwYXJzZUludCggaGV4WzJdICsgaGV4WzJdLCBiYXNlICk7XG4gICAgICAgIGIgPSBwYXJzZUludCggaGV4WzNdICsgaGV4WzNdLCBiYXNlICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByID0gcGFyc2VJbnQoIGhleFsxXSArIGhleFsyXSwgYmFzZSApO1xuICAgICAgICBnID0gcGFyc2VJbnQoIGhleFszXSArIGhleFs0XSwgYmFzZSApO1xuICAgICAgICBiID0gcGFyc2VJbnQoIGhleFs1XSArIGhleFs2XSwgYmFzZSApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW3IsIGcsIGJdO1xuICAgIH0sXG5cbiAgICAvLyBnZXQgW3IsIGcsIGIsIGFdIGZyb20gaHNsKDAsIDAsIDApIG9yIGhzbGEoMCwgMCwgMCwgMClcbiAgICBoc2wydHVwbGU6IGZ1bmN0aW9uKCBoc2wgKXtcbiAgICAgIHZhciByZXQ7XG4gICAgICB2YXIgaCwgcywgbCwgYSwgciwgZywgYjtcbiAgICAgIGZ1bmN0aW9uIGh1ZTJyZ2IocCwgcSwgdCl7XG4gICAgICAgIGlmKHQgPCAwKSB0ICs9IDE7XG4gICAgICAgIGlmKHQgPiAxKSB0IC09IDE7XG4gICAgICAgIGlmKHQgPCAxLzYpIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xuICAgICAgICBpZih0IDwgMS8yKSByZXR1cm4gcTtcbiAgICAgICAgaWYodCA8IDIvMykgcmV0dXJuIHAgKyAocSAtIHApICogKDIvMyAtIHQpICogNjtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgICB9XG5cbiAgICAgIHZhciBtID0gbmV3IFJlZ0V4cChcIl5cIiArICQkLnV0aWwucmVnZXguaHNsYSArIFwiJFwiKS5leGVjKGhzbCk7XG4gICAgICBpZiggbSApe1xuXG4gICAgICAgIC8vIGdldCBodWVcbiAgICAgICAgaCA9IHBhcnNlSW50KCBtWzFdICk7IFxuICAgICAgICBpZiggaCA8IDAgKXtcbiAgICAgICAgICBoID0gKCAzNjAgLSAoLTEqaCAlIDM2MCkgKSAlIDM2MDtcbiAgICAgICAgfSBlbHNlIGlmKCBoID4gMzYwICl7XG4gICAgICAgICAgaCA9IGggJSAzNjA7XG4gICAgICAgIH1cbiAgICAgICAgaCAvPSAzNjA7IC8vIG5vcm1hbGlzZSBvbiBbMCwgMV1cblxuICAgICAgICBzID0gcGFyc2VGbG9hdCggbVsyXSApO1xuICAgICAgICBpZiggcyA8IDAgfHwgcyA+IDEwMCApeyByZXR1cm47IH0gLy8gc2F0dXJhdGlvbiBpcyBbMCwgMTAwXVxuICAgICAgICBzID0gcy8xMDA7IC8vIG5vcm1hbGlzZSBvbiBbMCwgMV1cblxuICAgICAgICBsID0gcGFyc2VGbG9hdCggbVszXSApO1xuICAgICAgICBpZiggbCA8IDAgfHwgbCA+IDEwMCApeyByZXR1cm47IH0gLy8gbGlnaHRuZXNzIGlzIFswLCAxMDBdXG4gICAgICAgIGwgPSBsLzEwMDsgLy8gbm9ybWFsaXNlIG9uIFswLCAxXVxuXG4gICAgICAgIGEgPSBtWzRdO1xuICAgICAgICBpZiggYSAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgYSA9IHBhcnNlRmxvYXQoIGEgKTtcblxuICAgICAgICAgIGlmKCBhIDwgMCB8fCBhID4gMSApeyByZXR1cm47IH0gLy8gYWxwaGEgaXMgWzAsIDFdXG4gICAgICAgIH1cblxuICAgICAgICAvLyBub3csIGNvbnZlcnQgdG8gcmdiXG4gICAgICAgIC8vIGNvZGUgZnJvbSBodHRwOi8vbWppamFja3Nvbi5jb20vMjAwOC8wMi9yZ2ItdG8taHNsLWFuZC1yZ2ItdG8taHN2LWNvbG9yLW1vZGVsLWNvbnZlcnNpb24tYWxnb3JpdGhtcy1pbi1qYXZhc2NyaXB0XG4gICAgICAgIGlmKCBzID09PSAwICl7XG4gICAgICAgICAgciA9IGcgPSBiID0gTWF0aC5yb3VuZChsICogMjU1KTsgLy8gYWNocm9tYXRpY1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBxID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcbiAgICAgICAgICB2YXIgcCA9IDIgKiBsIC0gcTtcbiAgICAgICAgICByID0gTWF0aC5yb3VuZCggMjU1ICogaHVlMnJnYihwLCBxLCBoICsgMS8zKSApO1xuICAgICAgICAgIGcgPSBNYXRoLnJvdW5kKCAyNTUgKiBodWUycmdiKHAsIHEsIGgpICk7XG4gICAgICAgICAgYiA9IE1hdGgucm91bmQoIDI1NSAqIGh1ZTJyZ2IocCwgcSwgaCAtIDEvMykgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldCA9IFtyLCBnLCBiLCBhXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuXG4gICAgLy8gZ2V0IFtyLCBnLCBiLCBhXSBmcm9tIHJnYigwLCAwLCAwKSBvciByZ2JhKDAsIDAsIDAsIDApXG4gICAgcmdiMnR1cGxlOiBmdW5jdGlvbiggcmdiICl7XG4gICAgICB2YXIgcmV0O1xuXG4gICAgICB2YXIgbSA9IG5ldyBSZWdFeHAoXCJeXCIgKyAkJC51dGlsLnJlZ2V4LnJnYmEgKyBcIiRcIikuZXhlYyhyZ2IpO1xuICAgICAgaWYoIG0gKXtcbiAgICAgICAgcmV0ID0gW107XG5cbiAgICAgICAgdmFyIGlzUGN0ID0gW107XG4gICAgICAgIGZvciggdmFyIGkgPSAxOyBpIDw9IDM7IGkrKyApe1xuICAgICAgICAgIHZhciBjaGFubmVsID0gbVtpXTtcblxuICAgICAgICAgIGlmKCBjaGFubmVsWyBjaGFubmVsLmxlbmd0aCAtIDEgXSA9PT0gXCIlXCIgKXtcbiAgICAgICAgICAgIGlzUGN0W2ldID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2hhbm5lbCA9IHBhcnNlRmxvYXQoIGNoYW5uZWwgKTtcblxuICAgICAgICAgIGlmKCBpc1BjdFtpXSApe1xuICAgICAgICAgICAgY2hhbm5lbCA9IGNoYW5uZWwvMTAwICogMjU1OyAvLyBub3JtYWxpc2UgdG8gWzAsIDI1NV1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggY2hhbm5lbCA8IDAgfHwgY2hhbm5lbCA+IDI1NSApeyByZXR1cm47IH0gLy8gaW52YWxpZCBjaGFubmVsIHZhbHVlXG5cbiAgICAgICAgICByZXQucHVzaCggTWF0aC5mbG9vcihjaGFubmVsKSApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGF0TGVhc3RPbmVJc1BjdCA9IGlzUGN0WzFdIHx8IGlzUGN0WzJdIHx8IGlzUGN0WzNdO1xuICAgICAgICB2YXIgYWxsQXJlUGN0ID0gaXNQY3RbMV0gJiYgaXNQY3RbMl0gJiYgaXNQY3RbM107XG4gICAgICAgIGlmKCBhdExlYXN0T25lSXNQY3QgJiYgIWFsbEFyZVBjdCApeyByZXR1cm47IH0gLy8gbXVzdCBhbGwgYmUgcGVyY2VudCB2YWx1ZXMgaWYgb25lIGlzXG5cbiAgICAgICAgdmFyIGFscGhhID0gbVs0XTtcbiAgICAgICAgaWYoIGFscGhhICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICBhbHBoYSA9IHBhcnNlRmxvYXQoIGFscGhhICk7XG5cbiAgICAgICAgICBpZiggYWxwaGEgPCAwIHx8IGFscGhhID4gMSApeyByZXR1cm47IH0gLy8gaW52YWxpZCBhbHBoYSB2YWx1ZVxuXG4gICAgICAgICAgcmV0LnB1c2goIGFscGhhICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuXG4gICAgY29sb3JuYW1lMnR1cGxlOiBmdW5jdGlvbiggY29sb3IgKXtcbiAgICAgIHJldHVybiAkJC51dGlsLmNvbG9yc1sgY29sb3IudG9Mb3dlckNhc2UoKSBdO1xuICAgIH0sXG5cbiAgICBjb2xvcjJ0dXBsZTogZnVuY3Rpb24oIGNvbG9yICl7XG4gICAgICByZXR1cm4gKCAkJC5pcy5hcnJheShjb2xvcikgPyBjb2xvciA6IG51bGwgKSBcbiAgICAgICAgfHwgJCQudXRpbC5jb2xvcm5hbWUydHVwbGUoY29sb3IpXG4gICAgICAgIHx8ICQkLnV0aWwuaGV4MnR1cGxlKGNvbG9yKVxuICAgICAgICB8fCAkJC51dGlsLnJnYjJ0dXBsZShjb2xvcilcbiAgICAgICAgfHwgJCQudXRpbC5oc2wydHVwbGUoY29sb3IpO1xuICAgIH0sXG5cbiAgICB0dXBsZTJoZXg6IGZ1bmN0aW9uKCB0dXBsZSApe1xuICAgICAgdmFyIHIgPSB0dXBsZVswXTtcbiAgICAgIHZhciBnID0gdHVwbGVbMV07XG4gICAgICB2YXIgYiA9IHR1cGxlWzJdO1xuXG4gICAgICBmdW5jdGlvbiBjaDJoZXgoIGNoICl7XG4gICAgICAgIHZhciBoZXggPSBjaC50b1N0cmluZygxNik7XG5cbiAgICAgICAgaWYoIGhleC5sZW5ndGggPT09IDEgKXtcbiAgICAgICAgICBoZXggPSAnMCcgKyBoZXg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaGV4O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJyMnICsgY2gyaGV4KHIpICsgY2gyaGV4KGcpICsgY2gyaGV4KGIpO1xuICAgIH0sXG5cbiAgICBjb2xvcnM6IHtcbiAgICAgIC8vIHNwZWNpYWwgY29sb3VyIG5hbWVzXG4gICAgICB0cmFuc3BhcmVudDogICAgICBbMCwwLDAsMF0sIC8vIE5CIGFscGhhID09PSAwXG5cbiAgICAgIC8vIHJlZ3VsYXIgY29sb3Vyc1xuICAgICAgYWxpY2VibHVlOiAgICAgICAgWzI0MCwyNDgsMjU1XSxcbiAgICAgIGFudGlxdWV3aGl0ZTogICAgICBbMjUwLDIzNSwyMTVdLFxuICAgICAgYXF1YTogICAgICAgICAgWzAsMjU1LDI1NV0sXG4gICAgICBhcXVhbWFyaW5lOiAgICAgICAgWzEyNywyNTUsMjEyXSxcbiAgICAgIGF6dXJlOiAgICAgICAgICBbMjQwLDI1NSwyNTVdLFxuICAgICAgYmVpZ2U6ICAgICAgICAgIFsyNDUsMjQ1LDIyMF0sXG4gICAgICBiaXNxdWU6ICAgICAgICAgIFsyNTUsMjI4LDE5Nl0sXG4gICAgICBibGFjazogICAgICAgICAgWzAsMCwwXSxcbiAgICAgIGJsYW5jaGVkYWxtb25kOiAgICAgIFsyNTUsMjM1LDIwNV0sXG4gICAgICBibHVlOiAgICAgICAgICBbMCwwLDI1NV0sXG4gICAgICBibHVldmlvbGV0OiAgICAgICAgWzEzOCw0MywyMjZdLFxuICAgICAgYnJvd246ICAgICAgICAgIFsxNjUsNDIsNDJdLFxuICAgICAgYnVybHl3b29kOiAgICAgICAgWzIyMiwxODQsMTM1XSxcbiAgICAgIGNhZGV0Ymx1ZTogICAgICAgIFs5NSwxNTgsMTYwXSxcbiAgICAgIGNoYXJ0cmV1c2U6ICAgICAgICBbMTI3LDI1NSwwXSxcbiAgICAgIGNob2NvbGF0ZTogICAgICAgIFsyMTAsMTA1LDMwXSxcbiAgICAgIGNvcmFsOiAgICAgICAgICBbMjU1LDEyNyw4MF0sXG4gICAgICBjb3JuZmxvd2VyYmx1ZTogICAgICBbMTAwLDE0OSwyMzddLFxuICAgICAgY29ybnNpbGs6ICAgICAgICBbMjU1LDI0OCwyMjBdLFxuICAgICAgY3JpbXNvbjogICAgICAgIFsyMjAsMjAsNjBdLFxuICAgICAgY3lhbjogICAgICAgICAgWzAsMjU1LDI1NV0sXG4gICAgICBkYXJrYmx1ZTogICAgICAgIFswLDAsMTM5XSxcbiAgICAgIGRhcmtjeWFuOiAgICAgICAgWzAsMTM5LDEzOV0sXG4gICAgICBkYXJrZ29sZGVucm9kOiAgICAgIFsxODQsMTM0LDExXSxcbiAgICAgIGRhcmtncmF5OiAgICAgICAgWzE2OSwxNjksMTY5XSxcbiAgICAgIGRhcmtncmVlbjogICAgICAgIFswLDEwMCwwXSxcbiAgICAgIGRhcmtncmV5OiAgICAgICAgWzE2OSwxNjksMTY5XSxcbiAgICAgIGRhcmtraGFraTogICAgICAgIFsxODksMTgzLDEwN10sXG4gICAgICBkYXJrbWFnZW50YTogICAgICBbMTM5LDAsMTM5XSxcbiAgICAgIGRhcmtvbGl2ZWdyZWVuOiAgICAgIFs4NSwxMDcsNDddLFxuICAgICAgZGFya29yYW5nZTogICAgICAgIFsyNTUsMTQwLDBdLFxuICAgICAgZGFya29yY2hpZDogICAgICAgIFsxNTMsNTAsMjA0XSxcbiAgICAgIGRhcmtyZWQ6ICAgICAgICBbMTM5LDAsMF0sXG4gICAgICBkYXJrc2FsbW9uOiAgICAgICAgWzIzMywxNTAsMTIyXSxcbiAgICAgIGRhcmtzZWFncmVlbjogICAgICBbMTQzLDE4OCwxNDNdLFxuICAgICAgZGFya3NsYXRlYmx1ZTogICAgICBbNzIsNjEsMTM5XSxcbiAgICAgIGRhcmtzbGF0ZWdyYXk6ICAgICAgWzQ3LDc5LDc5XSxcbiAgICAgIGRhcmtzbGF0ZWdyZXk6ICAgICAgWzQ3LDc5LDc5XSxcbiAgICAgIGRhcmt0dXJxdW9pc2U6ICAgICAgWzAsMjA2LDIwOV0sXG4gICAgICBkYXJrdmlvbGV0OiAgICAgICAgWzE0OCwwLDIxMV0sXG4gICAgICBkZWVwcGluazogICAgICAgIFsyNTUsMjAsMTQ3XSxcbiAgICAgIGRlZXBza3libHVlOiAgICAgIFswLDE5MSwyNTVdLFxuICAgICAgZGltZ3JheTogICAgICAgIFsxMDUsMTA1LDEwNV0sXG4gICAgICBkaW1ncmV5OiAgICAgICAgWzEwNSwxMDUsMTA1XSxcbiAgICAgIGRvZGdlcmJsdWU6ICAgICAgICBbMzAsMTQ0LDI1NV0sXG4gICAgICBmaXJlYnJpY2s6ICAgICAgICBbMTc4LDM0LDM0XSxcbiAgICAgIGZsb3JhbHdoaXRlOiAgICAgIFsyNTUsMjUwLDI0MF0sXG4gICAgICBmb3Jlc3RncmVlbjogICAgICBbMzQsMTM5LDM0XSxcbiAgICAgIGZ1Y2hzaWE6ICAgICAgICBbMjU1LDAsMjU1XSxcbiAgICAgIGdhaW5zYm9ybzogICAgICAgIFsyMjAsMjIwLDIyMF0sXG4gICAgICBnaG9zdHdoaXRlOiAgICAgICAgWzI0OCwyNDgsMjU1XSxcbiAgICAgIGdvbGQ6ICAgICAgICAgIFsyNTUsMjE1LDBdLFxuICAgICAgZ29sZGVucm9kOiAgICAgICAgWzIxOCwxNjUsMzJdLFxuICAgICAgZ3JheTogICAgICAgICAgWzEyOCwxMjgsMTI4XSxcbiAgICAgIGdyZXk6ICAgICAgICAgIFsxMjgsMTI4LDEyOF0sXG4gICAgICBncmVlbjogICAgICAgICAgWzAsMTI4LDBdLFxuICAgICAgZ3JlZW55ZWxsb3c6ICAgICAgWzE3MywyNTUsNDddLFxuICAgICAgaG9uZXlkZXc6ICAgICAgICBbMjQwLDI1NSwyNDBdLFxuICAgICAgaG90cGluazogICAgICAgIFsyNTUsMTA1LDE4MF0sXG4gICAgICBpbmRpYW5yZWQ6ICAgICAgICBbMjA1LDkyLDkyXSxcbiAgICAgIGluZGlnbzogICAgICAgICAgWzc1LDAsMTMwXSxcbiAgICAgIGl2b3J5OiAgICAgICAgICBbMjU1LDI1NSwyNDBdLFxuICAgICAga2hha2k6ICAgICAgICAgIFsyNDAsMjMwLDE0MF0sXG4gICAgICBsYXZlbmRlcjogICAgICAgIFsyMzAsMjMwLDI1MF0sXG4gICAgICBsYXZlbmRlcmJsdXNoOiAgICAgIFsyNTUsMjQwLDI0NV0sXG4gICAgICBsYXduZ3JlZW46ICAgICAgICBbMTI0LDI1MiwwXSxcbiAgICAgIGxlbW9uY2hpZmZvbjogICAgICBbMjU1LDI1MCwyMDVdLFxuICAgICAgbGlnaHRibHVlOiAgICAgICAgWzE3MywyMTYsMjMwXSxcbiAgICAgIGxpZ2h0Y29yYWw6ICAgICAgICBbMjQwLDEyOCwxMjhdLFxuICAgICAgbGlnaHRjeWFuOiAgICAgICAgWzIyNCwyNTUsMjU1XSxcbiAgICAgIGxpZ2h0Z29sZGVucm9keWVsbG93OiAgWzI1MCwyNTAsMjEwXSxcbiAgICAgIGxpZ2h0Z3JheTogICAgICAgIFsyMTEsMjExLDIxMV0sXG4gICAgICBsaWdodGdyZWVuOiAgICAgICAgWzE0NCwyMzgsMTQ0XSxcbiAgICAgIGxpZ2h0Z3JleTogICAgICAgIFsyMTEsMjExLDIxMV0sXG4gICAgICBsaWdodHBpbms6ICAgICAgICBbMjU1LDE4MiwxOTNdLFxuICAgICAgbGlnaHRzYWxtb246ICAgICAgWzI1NSwxNjAsMTIyXSxcbiAgICAgIGxpZ2h0c2VhZ3JlZW46ICAgICAgWzMyLDE3OCwxNzBdLFxuICAgICAgbGlnaHRza3libHVlOiAgICAgIFsxMzUsMjA2LDI1MF0sXG4gICAgICBsaWdodHNsYXRlZ3JheTogICAgICBbMTE5LDEzNiwxNTNdLFxuICAgICAgbGlnaHRzbGF0ZWdyZXk6ICAgICAgWzExOSwxMzYsMTUzXSxcbiAgICAgIGxpZ2h0c3RlZWxibHVlOiAgICAgIFsxNzYsMTk2LDIyMl0sXG4gICAgICBsaWdodHllbGxvdzogICAgICBbMjU1LDI1NSwyMjRdLFxuICAgICAgbGltZTogICAgICAgICAgWzAsMjU1LDBdLFxuICAgICAgbGltZWdyZWVuOiAgICAgICAgWzUwLDIwNSw1MF0sXG4gICAgICBsaW5lbjogICAgICAgICAgWzI1MCwyNDAsMjMwXSxcbiAgICAgIG1hZ2VudGE6ICAgICAgICBbMjU1LDAsMjU1XSxcbiAgICAgIG1hcm9vbjogICAgICAgICAgWzEyOCwwLDBdLFxuICAgICAgbWVkaXVtYXF1YW1hcmluZTogICAgWzEwMiwyMDUsMTcwXSxcbiAgICAgIG1lZGl1bWJsdWU6ICAgICAgICBbMCwwLDIwNV0sXG4gICAgICBtZWRpdW1vcmNoaWQ6ICAgICAgWzE4Niw4NSwyMTFdLFxuICAgICAgbWVkaXVtcHVycGxlOiAgICAgIFsxNDcsMTEyLDIxOV0sXG4gICAgICBtZWRpdW1zZWFncmVlbjogICAgICBbNjAsMTc5LDExM10sXG4gICAgICBtZWRpdW1zbGF0ZWJsdWU6ICAgIFsxMjMsMTA0LDIzOF0sXG4gICAgICBtZWRpdW1zcHJpbmdncmVlbjogICAgWzAsMjUwLDE1NF0sXG4gICAgICBtZWRpdW10dXJxdW9pc2U6ICAgIFs3MiwyMDksMjA0XSxcbiAgICAgIG1lZGl1bXZpb2xldHJlZDogICAgWzE5OSwyMSwxMzNdLFxuICAgICAgbWlkbmlnaHRibHVlOiAgICAgIFsyNSwyNSwxMTJdLFxuICAgICAgbWludGNyZWFtOiAgICAgICAgWzI0NSwyNTUsMjUwXSxcbiAgICAgIG1pc3R5cm9zZTogICAgICAgIFsyNTUsMjI4LDIyNV0sXG4gICAgICBtb2NjYXNpbjogICAgICAgIFsyNTUsMjI4LDE4MV0sXG4gICAgICBuYXZham93aGl0ZTogICAgICBbMjU1LDIyMiwxNzNdLFxuICAgICAgbmF2eTogICAgICAgICAgWzAsMCwxMjhdLFxuICAgICAgb2xkbGFjZTogICAgICAgIFsyNTMsMjQ1LDIzMF0sXG4gICAgICBvbGl2ZTogICAgICAgICAgWzEyOCwxMjgsMF0sXG4gICAgICBvbGl2ZWRyYWI6ICAgICAgICBbMTA3LDE0MiwzNV0sXG4gICAgICBvcmFuZ2U6ICAgICAgICAgIFsyNTUsMTY1LDBdLFxuICAgICAgb3JhbmdlcmVkOiAgICAgICAgWzI1NSw2OSwwXSxcbiAgICAgIG9yY2hpZDogICAgICAgICAgWzIxOCwxMTIsMjE0XSxcbiAgICAgIHBhbGVnb2xkZW5yb2Q6ICAgICAgWzIzOCwyMzIsMTcwXSxcbiAgICAgIHBhbGVncmVlbjogICAgICAgIFsxNTIsMjUxLDE1Ml0sXG4gICAgICBwYWxldHVycXVvaXNlOiAgICAgIFsxNzUsMjM4LDIzOF0sXG4gICAgICBwYWxldmlvbGV0cmVkOiAgICAgIFsyMTksMTEyLDE0N10sXG4gICAgICBwYXBheWF3aGlwOiAgICAgICAgWzI1NSwyMzksMjEzXSxcbiAgICAgIHBlYWNocHVmZjogICAgICAgIFsyNTUsMjE4LDE4NV0sXG4gICAgICBwZXJ1OiAgICAgICAgICBbMjA1LDEzMyw2M10sXG4gICAgICBwaW5rOiAgICAgICAgICBbMjU1LDE5MiwyMDNdLFxuICAgICAgcGx1bTogICAgICAgICAgWzIyMSwxNjAsMjIxXSxcbiAgICAgIHBvd2RlcmJsdWU6ICAgICAgICBbMTc2LDIyNCwyMzBdLFxuICAgICAgcHVycGxlOiAgICAgICAgICBbMTI4LDAsMTI4XSxcbiAgICAgIHJlZDogICAgICAgICAgWzI1NSwwLDBdLFxuICAgICAgcm9zeWJyb3duOiAgICAgICAgWzE4OCwxNDMsMTQzXSxcbiAgICAgIHJveWFsYmx1ZTogICAgICAgIFs2NSwxMDUsMjI1XSxcbiAgICAgIHNhZGRsZWJyb3duOiAgICAgIFsxMzksNjksMTldLFxuICAgICAgc2FsbW9uOiAgICAgICAgICBbMjUwLDEyOCwxMTRdLFxuICAgICAgc2FuZHlicm93bjogICAgICAgIFsyNDQsMTY0LDk2XSxcbiAgICAgIHNlYWdyZWVuOiAgICAgICAgWzQ2LDEzOSw4N10sXG4gICAgICBzZWFzaGVsbDogICAgICAgIFsyNTUsMjQ1LDIzOF0sXG4gICAgICBzaWVubmE6ICAgICAgICAgIFsxNjAsODIsNDVdLFxuICAgICAgc2lsdmVyOiAgICAgICAgICBbMTkyLDE5MiwxOTJdLFxuICAgICAgc2t5Ymx1ZTogICAgICAgIFsxMzUsMjA2LDIzNV0sXG4gICAgICBzbGF0ZWJsdWU6ICAgICAgICBbMTA2LDkwLDIwNV0sXG4gICAgICBzbGF0ZWdyYXk6ICAgICAgICBbMTEyLDEyOCwxNDRdLFxuICAgICAgc2xhdGVncmV5OiAgICAgICAgWzExMiwxMjgsMTQ0XSxcbiAgICAgIHNub3c6ICAgICAgICAgIFsyNTUsMjUwLDI1MF0sXG4gICAgICBzcHJpbmdncmVlbjogICAgICBbMCwyNTUsMTI3XSxcbiAgICAgIHN0ZWVsYmx1ZTogICAgICAgIFs3MCwxMzAsMTgwXSxcbiAgICAgIHRhbjogICAgICAgICAgWzIxMCwxODAsMTQwXSxcbiAgICAgIHRlYWw6ICAgICAgICAgIFswLDEyOCwxMjhdLFxuICAgICAgdGhpc3RsZTogICAgICAgIFsyMTYsMTkxLDIxNl0sXG4gICAgICB0b21hdG86ICAgICAgICAgIFsyNTUsOTksNzFdLFxuICAgICAgdHVycXVvaXNlOiAgICAgICAgWzY0LDIyNCwyMDhdLFxuICAgICAgdmlvbGV0OiAgICAgICAgICBbMjM4LDEzMCwyMzhdLFxuICAgICAgd2hlYXQ6ICAgICAgICAgIFsyNDUsMjIyLDE3OV0sXG4gICAgICB3aGl0ZTogICAgICAgICAgWzI1NSwyNTUsMjU1XSxcbiAgICAgIHdoaXRlc21va2U6ICAgICAgICBbMjQ1LDI0NSwyNDVdLFxuICAgICAgeWVsbG93OiAgICAgICAgICBbMjU1LDI1NSwwXSxcbiAgICAgIHllbGxvd2dyZWVuOiAgICAgIFsxNTQsMjA1LDUwXVxuICAgIH1cbiAgICAgIFxuICB9O1xuXG4gICQkLnV0aWwucmVnZXggPSB7fTtcbiAgXG4gICQkLnV0aWwucmVnZXgubnVtYmVyID0gXCIoPzpbLV0/XFxcXGQqXFxcXC5cXFxcZCt8Wy1dP1xcXFxkK3xbLV0/XFxcXGQqXFxcXC5cXFxcZCtbZUVdXFxcXGQrKVwiO1xuICBcbiAgJCQudXRpbC5yZWdleC5yZ2JhID0gXCJyZ2JbYV0/XFxcXCgoXCIrICQkLnV0aWwucmVnZXgubnVtYmVyICtcIlslXT8pXFxcXHMqLFxcXFxzKihcIisgJCQudXRpbC5yZWdleC5udW1iZXIgK1wiWyVdPylcXFxccyosXFxcXHMqKFwiKyAkJC51dGlsLnJlZ2V4Lm51bWJlciArXCJbJV0/KSg/OlxcXFxzKixcXFxccyooXCIrICQkLnV0aWwucmVnZXgubnVtYmVyICtcIikpP1xcXFwpXCI7XG4gICQkLnV0aWwucmVnZXgucmdiYU5vQmFja1JlZnMgPSBcInJnYlthXT9cXFxcKCg/OlwiKyAkJC51dGlsLnJlZ2V4Lm51bWJlciArXCJbJV0/KVxcXFxzKixcXFxccyooPzpcIisgJCQudXRpbC5yZWdleC5udW1iZXIgK1wiWyVdPylcXFxccyosXFxcXHMqKD86XCIrICQkLnV0aWwucmVnZXgubnVtYmVyICtcIlslXT8pKD86XFxcXHMqLFxcXFxzKig/OlwiKyAkJC51dGlsLnJlZ2V4Lm51bWJlciArXCIpKT9cXFxcKVwiO1xuICBcbiAgJCQudXRpbC5yZWdleC5oc2xhID0gXCJoc2xbYV0/XFxcXCgoXCIrICQkLnV0aWwucmVnZXgubnVtYmVyICtcIilcXFxccyosXFxcXHMqKFwiKyAkJC51dGlsLnJlZ2V4Lm51bWJlciArXCJbJV0pXFxcXHMqLFxcXFxzKihcIisgJCQudXRpbC5yZWdleC5udW1iZXIgK1wiWyVdKSg/OlxcXFxzKixcXFxccyooXCIrICQkLnV0aWwucmVnZXgubnVtYmVyICtcIikpP1xcXFwpXCI7XG4gICQkLnV0aWwucmVnZXguaHNsYU5vQmFja1JlZnMgPSBcImhzbFthXT9cXFxcKCg/OlwiKyAkJC51dGlsLnJlZ2V4Lm51bWJlciArXCIpXFxcXHMqLFxcXFxzKig/OlwiKyAkJC51dGlsLnJlZ2V4Lm51bWJlciArXCJbJV0pXFxcXHMqLFxcXFxzKig/OlwiKyAkJC51dGlsLnJlZ2V4Lm51bWJlciArXCJbJV0pKD86XFxcXHMqLFxcXFxzKig/OlwiKyAkJC51dGlsLnJlZ2V4Lm51bWJlciArXCIpKT9cXFxcKVwiO1xuICBcbiAgJCQudXRpbC5yZWdleC5oZXgzID0gXCJcXFxcI1swLTlhLWZBLUZdezN9XCI7XG4gICQkLnV0aWwucmVnZXguaGV4NiA9IFwiXFxcXCNbMC05YS1mQS1GXXs2fVwiO1xuXG4gIHZhciByYWYgPSAhd2luZG93ID8gbnVsbCA6ICggd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8ICBcbiAgICAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKTtcblxuICByYWYgPSByYWYgfHwgZnVuY3Rpb24oZm4peyBpZihmbil7IHNldFRpbWVvdXQoZm4sIDEwMDAvNjApOyB9IH07XG5cbiAgJCQudXRpbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbihmbil7XG4gICAgcmFmKCBmbiApO1xuICB9O1xuXG59KSggY3l0b3NjYXBlLCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB3aW5kb3cgICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICAkJC5tYXRoID0ge307XG4gIFxuICAkJC5tYXRoLnNpZ251bSA9IGZ1bmN0aW9uKHgpe1xuICAgIGlmKCB4ID4gMCApe1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmKCB4IDwgMCApe1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH07XG5cbiAgJCQubWF0aC5kaXN0YW5jZSA9IGZ1bmN0aW9uKCBwMSwgcDIgKXtcbiAgICB2YXIgZHggPSBwMi54IC0gcDEueDtcbiAgICB2YXIgZHkgPSBwMi55IC0gcDEueTtcblxuICAgIHJldHVybiBNYXRoLnNxcnQoIGR4KmR4ICsgZHkqZHkgKTtcbiAgfTtcblxuICAvLyBmcm9tIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQsOpemllcl9jdXJ2ZSNRdWFkcmF0aWNfY3VydmVzXG4gICQkLm1hdGgucWJlemllckF0ID0gZnVuY3Rpb24ocDAsIHAxLCBwMiwgdCl7XG4gICAgcmV0dXJuICgxIC0gdCkqKDEgLSB0KSpwMCArIDIqKDEgLSB0KSp0KnAxICsgdCp0KnAyO1xuICB9O1xuXG4gICQkLm1hdGgucWJlemllclB0QXQgPSBmdW5jdGlvbihwMCwgcDEsIHAyLCB0KXtcbiAgICByZXR1cm4ge1xuICAgICAgeDogJCQubWF0aC5xYmV6aWVyQXQoIHAwLngsIHAxLngsIHAyLngsIHQgKSxcbiAgICAgIHk6ICQkLm1hdGgucWJlemllckF0KCBwMC55LCBwMS55LCBwMi55LCB0IClcbiAgICB9O1xuICB9O1xuXG4gICQkLm1hdGguYm91bmRpbmdCb3hlc0ludGVyc2VjdCA9IGZ1bmN0aW9uKCBiYjEsIGJiMiApe1xuICAgIC8vIGNhc2U6IG9uZSBiYiB0byByaWdodCBvZiBvdGhlclxuICAgIGlmKCBiYjEueDEgPiBiYjIueDIgKXsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaWYoIGJiMi54MSA+IGJiMS54MiApeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIC8vIGNhc2U6IG9uZSBiYiB0byBsZWZ0IG9mIG90aGVyXG4gICAgaWYoIGJiMS54MiA8IGJiMi54MSApeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpZiggYmIyLngyIDwgYmIxLngxICl7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgLy8gY2FzZTogb25lIGJiIGFib3ZlIG90aGVyXG4gICAgaWYoIGJiMS55MiA8IGJiMi55MSApeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpZiggYmIyLnkyIDwgYmIxLnkxICl7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgLy8gY2FzZTogb25lIGJiIGJlbG93IG90aGVyXG4gICAgaWYoIGJiMS55MSA+IGJiMi55MiApeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpZiggYmIyLnkxID4gYmIxLnkyICl7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgLy8gb3RoZXJ3aXNlLCBtdXN0IGhhdmUgc29tZSBvdmVybGFwXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgJCQubWF0aC5pbkJvdW5kaW5nQm94ID0gZnVuY3Rpb24oIGJiLCB4LCB5ICl7XG4gICAgcmV0dXJuIGJiLngxIDw9IHggJiYgeCA8PSBiYi54MiAmJiBiYi55MSA8PSB5ICYmIHkgPD0gYmIueTI7XG4gIH07XG5cbiAgJCQubWF0aC5wb2ludEluQm91bmRpbmdCb3ggPSBmdW5jdGlvbiggYmIsIHB0ICl7XG4gICAgcmV0dXJuIHRoaXMuaW5Cb3VuZGluZ0JveCggYmIsIHB0LngsIHB0LnkgKTtcbiAgfTtcblxuICAkJC5tYXRoLnJvdW5kUmVjdGFuZ2xlSW50ZXJzZWN0TGluZSA9IGZ1bmN0aW9uKFxuICAgIHgsIHksIG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgcGFkZGluZykge1xuICAgIFxuICAgIHZhciBjb3JuZXJSYWRpdXMgPSB0aGlzLmdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzKHdpZHRoLCBoZWlnaHQpO1xuICAgIFxuICAgIHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG4gICAgdmFyIGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyO1xuICAgIFxuICAgIC8vIENoZWNrIGludGVyc2VjdGlvbnMgd2l0aCBzdHJhaWdodCBsaW5lIHNlZ21lbnRzXG4gICAgdmFyIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnM7XG4gICAgXG4gICAgLy8gVG9wIHNlZ21lbnQsIGxlZnQgdG8gcmlnaHRcbiAgICB7XG4gICAgICB2YXIgdG9wU3RhcnRYID0gbm9kZVggLSBoYWxmV2lkdGggKyBjb3JuZXJSYWRpdXMgLSBwYWRkaW5nO1xuICAgICAgdmFyIHRvcFN0YXJ0WSA9IG5vZGVZIC0gaGFsZkhlaWdodCAtIHBhZGRpbmc7XG4gICAgICB2YXIgdG9wRW5kWCA9IG5vZGVYICsgaGFsZldpZHRoIC0gY29ybmVyUmFkaXVzICsgcGFkZGluZztcbiAgICAgIHZhciB0b3BFbmRZID0gdG9wU3RhcnRZO1xuICAgICAgXG4gICAgICBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zID0gdGhpcy5maW5pdGVMaW5lc0ludGVyc2VjdChcbiAgICAgICAgeCwgeSwgbm9kZVgsIG5vZGVZLCB0b3BTdGFydFgsIHRvcFN0YXJ0WSwgdG9wRW5kWCwgdG9wRW5kWSwgZmFsc2UpO1xuICAgICAgXG4gICAgICBpZiAoc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBSaWdodCBzZWdtZW50LCB0b3AgdG8gYm90dG9tXG4gICAge1xuICAgICAgdmFyIHJpZ2h0U3RhcnRYID0gbm9kZVggKyBoYWxmV2lkdGggKyBwYWRkaW5nO1xuICAgICAgdmFyIHJpZ2h0U3RhcnRZID0gbm9kZVkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyUmFkaXVzIC0gcGFkZGluZztcbiAgICAgIHZhciByaWdodEVuZFggPSByaWdodFN0YXJ0WDtcbiAgICAgIHZhciByaWdodEVuZFkgPSBub2RlWSArIGhhbGZIZWlnaHQgLSBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nO1xuICAgICAgXG4gICAgICBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zID0gdGhpcy5maW5pdGVMaW5lc0ludGVyc2VjdChcbiAgICAgICAgeCwgeSwgbm9kZVgsIG5vZGVZLCByaWdodFN0YXJ0WCwgcmlnaHRTdGFydFksIHJpZ2h0RW5kWCwgcmlnaHRFbmRZLCBmYWxzZSk7XG4gICAgICBcbiAgICAgIGlmIChzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnM7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEJvdHRvbSBzZWdtZW50LCBsZWZ0IHRvIHJpZ2h0XG4gICAge1xuICAgICAgdmFyIGJvdHRvbVN0YXJ0WCA9IG5vZGVYIC0gaGFsZldpZHRoICsgY29ybmVyUmFkaXVzIC0gcGFkZGluZztcbiAgICAgIHZhciBib3R0b21TdGFydFkgPSBub2RlWSArIGhhbGZIZWlnaHQgKyBwYWRkaW5nO1xuICAgICAgdmFyIGJvdHRvbUVuZFggPSBub2RlWCArIGhhbGZXaWR0aCAtIGNvcm5lclJhZGl1cyArIHBhZGRpbmc7XG4gICAgICB2YXIgYm90dG9tRW5kWSA9IGJvdHRvbVN0YXJ0WTtcbiAgICAgIFxuICAgICAgc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucyA9IHRoaXMuZmluaXRlTGluZXNJbnRlcnNlY3QoXG4gICAgICAgIHgsIHksIG5vZGVYLCBub2RlWSwgYm90dG9tU3RhcnRYLCBib3R0b21TdGFydFksIGJvdHRvbUVuZFgsIGJvdHRvbUVuZFksIGZhbHNlKTtcbiAgICAgIFxuICAgICAgaWYgKHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucztcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gTGVmdCBzZWdtZW50LCB0b3AgdG8gYm90dG9tXG4gICAge1xuICAgICAgdmFyIGxlZnRTdGFydFggPSBub2RlWCAtIGhhbGZXaWR0aCAtIHBhZGRpbmc7XG4gICAgICB2YXIgbGVmdFN0YXJ0WSA9IG5vZGVZIC0gaGFsZkhlaWdodCArIGNvcm5lclJhZGl1cyAtIHBhZGRpbmc7XG4gICAgICB2YXIgbGVmdEVuZFggPSBsZWZ0U3RhcnRYO1xuICAgICAgdmFyIGxlZnRFbmRZID0gbm9kZVkgKyBoYWxmSGVpZ2h0IC0gY29ybmVyUmFkaXVzICsgcGFkZGluZztcbiAgICAgIFxuICAgICAgc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucyA9IHRoaXMuZmluaXRlTGluZXNJbnRlcnNlY3QoXG4gICAgICAgIHgsIHksIG5vZGVYLCBub2RlWSwgbGVmdFN0YXJ0WCwgbGVmdFN0YXJ0WSwgbGVmdEVuZFgsIGxlZnRFbmRZLCBmYWxzZSk7XG4gICAgICBcbiAgICAgIGlmIChzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnM7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGludGVyc2VjdGlvbnMgd2l0aCBhcmMgc2VnbWVudHNcbiAgICB2YXIgYXJjSW50ZXJzZWN0aW9ucztcbiAgICBcbiAgICAvLyBUb3AgTGVmdFxuICAgIHtcbiAgICAgIHZhciB0b3BMZWZ0Q2VudGVyWCA9IG5vZGVYIC0gaGFsZldpZHRoICsgY29ybmVyUmFkaXVzO1xuICAgICAgdmFyIHRvcExlZnRDZW50ZXJZID0gbm9kZVkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyUmFkaXVzO1xuICAgICAgYXJjSW50ZXJzZWN0aW9ucyA9IHRoaXMuaW50ZXJzZWN0TGluZUNpcmNsZShcbiAgICAgICAgeCwgeSwgbm9kZVgsIG5vZGVZLCBcbiAgICAgICAgdG9wTGVmdENlbnRlclgsIHRvcExlZnRDZW50ZXJZLCBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nKTtcbiAgICAgIFxuICAgICAgLy8gRW5zdXJlIHRoZSBpbnRlcnNlY3Rpb24gaXMgb24gdGhlIGRlc2lyZWQgcXVhcnRlciBvZiB0aGUgY2lyY2xlXG4gICAgICBpZiAoYXJjSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwXG4gICAgICAgICYmIGFyY0ludGVyc2VjdGlvbnNbMF0gPD0gdG9wTGVmdENlbnRlclhcbiAgICAgICAgJiYgYXJjSW50ZXJzZWN0aW9uc1sxXSA8PSB0b3BMZWZ0Q2VudGVyWSkge1xuICAgICAgICByZXR1cm4gW2FyY0ludGVyc2VjdGlvbnNbMF0sIGFyY0ludGVyc2VjdGlvbnNbMV1dO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBUb3AgUmlnaHRcbiAgICB7XG4gICAgICB2YXIgdG9wUmlnaHRDZW50ZXJYID0gbm9kZVggKyBoYWxmV2lkdGggLSBjb3JuZXJSYWRpdXM7XG4gICAgICB2YXIgdG9wUmlnaHRDZW50ZXJZID0gbm9kZVkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyUmFkaXVzO1xuICAgICAgYXJjSW50ZXJzZWN0aW9ucyA9IHRoaXMuaW50ZXJzZWN0TGluZUNpcmNsZShcbiAgICAgICAgeCwgeSwgbm9kZVgsIG5vZGVZLCBcbiAgICAgICAgdG9wUmlnaHRDZW50ZXJYLCB0b3BSaWdodENlbnRlclksIGNvcm5lclJhZGl1cyArIHBhZGRpbmcpO1xuICAgICAgXG4gICAgICAvLyBFbnN1cmUgdGhlIGludGVyc2VjdGlvbiBpcyBvbiB0aGUgZGVzaXJlZCBxdWFydGVyIG9mIHRoZSBjaXJjbGVcbiAgICAgIGlmIChhcmNJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDBcbiAgICAgICAgJiYgYXJjSW50ZXJzZWN0aW9uc1swXSA+PSB0b3BSaWdodENlbnRlclhcbiAgICAgICAgJiYgYXJjSW50ZXJzZWN0aW9uc1sxXSA8PSB0b3BSaWdodENlbnRlclkpIHtcbiAgICAgICAgcmV0dXJuIFthcmNJbnRlcnNlY3Rpb25zWzBdLCBhcmNJbnRlcnNlY3Rpb25zWzFdXTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gQm90dG9tIFJpZ2h0XG4gICAge1xuICAgICAgdmFyIGJvdHRvbVJpZ2h0Q2VudGVyWCA9IG5vZGVYICsgaGFsZldpZHRoIC0gY29ybmVyUmFkaXVzO1xuICAgICAgdmFyIGJvdHRvbVJpZ2h0Q2VudGVyWSA9IG5vZGVZICsgaGFsZkhlaWdodCAtIGNvcm5lclJhZGl1cztcbiAgICAgIGFyY0ludGVyc2VjdGlvbnMgPSB0aGlzLmludGVyc2VjdExpbmVDaXJjbGUoXG4gICAgICAgIHgsIHksIG5vZGVYLCBub2RlWSwgXG4gICAgICAgIGJvdHRvbVJpZ2h0Q2VudGVyWCwgYm90dG9tUmlnaHRDZW50ZXJZLCBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nKTtcbiAgICAgIFxuICAgICAgLy8gRW5zdXJlIHRoZSBpbnRlcnNlY3Rpb24gaXMgb24gdGhlIGRlc2lyZWQgcXVhcnRlciBvZiB0aGUgY2lyY2xlXG4gICAgICBpZiAoYXJjSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwXG4gICAgICAgICYmIGFyY0ludGVyc2VjdGlvbnNbMF0gPj0gYm90dG9tUmlnaHRDZW50ZXJYXG4gICAgICAgICYmIGFyY0ludGVyc2VjdGlvbnNbMV0gPj0gYm90dG9tUmlnaHRDZW50ZXJZKSB7XG4gICAgICAgIHJldHVybiBbYXJjSW50ZXJzZWN0aW9uc1swXSwgYXJjSW50ZXJzZWN0aW9uc1sxXV07XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEJvdHRvbSBMZWZ0XG4gICAge1xuICAgICAgdmFyIGJvdHRvbUxlZnRDZW50ZXJYID0gbm9kZVggLSBoYWxmV2lkdGggKyBjb3JuZXJSYWRpdXM7XG4gICAgICB2YXIgYm90dG9tTGVmdENlbnRlclkgPSBub2RlWSArIGhhbGZIZWlnaHQgLSBjb3JuZXJSYWRpdXM7XG4gICAgICBhcmNJbnRlcnNlY3Rpb25zID0gdGhpcy5pbnRlcnNlY3RMaW5lQ2lyY2xlKFxuICAgICAgICB4LCB5LCBub2RlWCwgbm9kZVksIFxuICAgICAgICBib3R0b21MZWZ0Q2VudGVyWCwgYm90dG9tTGVmdENlbnRlclksIGNvcm5lclJhZGl1cyArIHBhZGRpbmcpO1xuICAgICAgXG4gICAgICAvLyBFbnN1cmUgdGhlIGludGVyc2VjdGlvbiBpcyBvbiB0aGUgZGVzaXJlZCBxdWFydGVyIG9mIHRoZSBjaXJjbGVcbiAgICAgIGlmIChhcmNJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDBcbiAgICAgICAgJiYgYXJjSW50ZXJzZWN0aW9uc1swXSA8PSBib3R0b21MZWZ0Q2VudGVyWFxuICAgICAgICAmJiBhcmNJbnRlcnNlY3Rpb25zWzFdID49IGJvdHRvbUxlZnRDZW50ZXJZKSB7XG4gICAgICAgIHJldHVybiBbYXJjSW50ZXJzZWN0aW9uc1swXSwgYXJjSW50ZXJzZWN0aW9uc1sxXV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtdOyAvLyBpZiBub3RoaW5nXG4gIH07XG4gIFxuICAkJC5tYXRoLnJvdW5kUmVjdGFuZ2xlSW50ZXJzZWN0Qm94ID0gZnVuY3Rpb24oXG4gICAgYm94WDEsIGJveFkxLCBib3hYMiwgYm94WTIsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclksIHBhZGRpbmcpIHtcbiAgICBcbiAgICAvLyBXZSBoYXZlIHRoZSBmb2xsb3dpbmcgc2hwYWVcbiAgICBcbiAgICAvLyAgICBfX19fX1xuICAgIC8vICBffCAgICAgfF9cbiAgICAvLyB8ICAgICAgICAgfFxuICAgIC8vIHxfICAgICAgIF98XG4gICAgLy8gICB8X19fX198XG4gICAgLy9cbiAgICAvLyBXaXRoIGEgcXVhcnRlciBjaXJjbGUgYXQgZWFjaCBjb3JuZXIuXG4gICAgXG4gICAgdmFyIGNvcm5lclJhZGl1cyA9IHRoaXMuZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMod2lkdGgsIGhlaWdodCk7XG4gICAgXG4gICAgdmFyIGhCb3hUb3BMZWZ0WCA9IGNlbnRlclggLSB3aWR0aCAvIDIgLSBwYWRkaW5nO1xuICAgIHZhciBoQm94VG9wTGVmdFkgPSBjZW50ZXJZIC0gaGVpZ2h0IC8gMiArIGNvcm5lclJhZGl1cyAtIHBhZGRpbmc7XG4gICAgdmFyIGhCb3hCb3R0b21SaWdodFggPSBjZW50ZXJYICsgd2lkdGggLyAyICsgcGFkZGluZztcbiAgICB2YXIgaEJveEJvdHRvbVJpZ2h0WSA9IGNlbnRlclkgKyBoZWlnaHQgLyAyIC0gY29ybmVyUmFkaXVzICsgcGFkZGluZztcbiAgICBcbiAgICB2YXIgdkJveFRvcExlZnRYID0gY2VudGVyWCAtIHdpZHRoIC8gMiArIGNvcm5lclJhZGl1cyAtIHBhZGRpbmc7XG4gICAgdmFyIHZCb3hUb3BMZWZ0WSA9IGNlbnRlclkgLSBoZWlnaHQgLyAyIC0gcGFkZGluZztcbiAgICB2YXIgdkJveEJvdHRvbVJpZ2h0WCA9IGNlbnRlclggKyB3aWR0aCAvIDIgLSBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nO1xuICAgIHZhciB2Qm94Qm90dG9tUmlnaHRZID0gY2VudGVyWSArIGhlaWdodCAvIDIgKyBwYWRkaW5nO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIHRoZSBib3ggaXMgb3V0IG9mIGJvdW5kc1xuICAgIHZhciBib3hNaW5YID0gTWF0aC5taW4oYm94WDEsIGJveFgyKTtcbiAgICB2YXIgYm94TWF4WCA9IE1hdGgubWF4KGJveFgxLCBib3hYMik7XG4gICAgdmFyIGJveE1pblkgPSBNYXRoLm1pbihib3hZMSwgYm94WTIpO1xuICAgIHZhciBib3hNYXhZID0gTWF0aC5tYXgoYm94WTEsIGJveFkyKTtcbiAgICBcbiAgICBpZiAoYm94TWF4WCA8IGhCb3hUb3BMZWZ0WCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoYm94TWluWCA+IGhCb3hCb3R0b21SaWdodFgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGJveE1heFkgPCB2Qm94VG9wTGVmdFkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGJveE1pblkgPiB2Qm94Qm90dG9tUmlnaHRZKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGlmIGFuIGhCb3ggcG9pbnQgaXMgaW4gZ2l2ZW4gYm94XG4gICAgaWYgKGhCb3hUb3BMZWZ0WCA+PSBib3hNaW5YICYmIGhCb3hUb3BMZWZ0WCA8PSBib3hNYXhYXG4gICAgICAgICYmIGhCb3hUb3BMZWZ0WSA+PSBib3hNaW5ZICYmIGhCb3hUb3BMZWZ0WSA8PSBib3hNYXhZKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGhCb3hCb3R0b21SaWdodFggPj0gYm94TWluWCAmJiBoQm94Qm90dG9tUmlnaHRYIDw9IGJveE1heFhcbiAgICAgICAgJiYgaEJveFRvcExlZnRZID49IGJveE1pblkgJiYgaEJveFRvcExlZnRZIDw9IGJveE1heFkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoaEJveEJvdHRvbVJpZ2h0WCA+PSBib3hNaW5YICYmIGhCb3hCb3R0b21SaWdodFggPD0gYm94TWF4WFxuICAgICAgICAmJiBoQm94Qm90dG9tUmlnaHRZID49IGJveE1pblkgJiYgaEJveEJvdHRvbVJpZ2h0WSA8PSBib3hNYXhZKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGhCb3hUb3BMZWZ0WCA+PSBib3hNaW5YICYmIGhCb3hUb3BMZWZ0WCA8PSBib3hNYXhYXG4gICAgICAgICYmIGhCb3hCb3R0b21SaWdodFkgPj0gYm94TWluWSAmJiBoQm94Qm90dG9tUmlnaHRZIDw9IGJveE1heFkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBpZiBhIGdpdmVuIHBvaW50IGJveCBpcyBpbiB0aGUgaEJveFxuICAgIGlmIChib3hNaW5YID49IGhCb3hUb3BMZWZ0WCAmJiBib3hNaW5YIDw9IGhCb3hCb3R0b21SaWdodFhcbiAgICAgICYmIGJveE1pblkgPj0gaEJveFRvcExlZnRZICYmIGJveE1pblkgPD0gaEJveEJvdHRvbVJpZ2h0WSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmIChib3hNYXhYID49IGhCb3hUb3BMZWZ0WCAmJiBib3hNYXhYIDw9IGhCb3hCb3R0b21SaWdodFhcbiAgICAgICYmIGJveE1pblkgPj0gaEJveFRvcExlZnRZICYmIGJveE1pblkgPD0gaEJveEJvdHRvbVJpZ2h0WSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmIChib3hNYXhYID49IGhCb3hUb3BMZWZ0WCAmJiBib3hNYXhYIDw9IGhCb3hCb3R0b21SaWdodFhcbiAgICAgICYmIGJveE1heFkgPj0gaEJveFRvcExlZnRZICYmIGJveE1heFkgPD0gaEJveEJvdHRvbVJpZ2h0WSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmIChib3hNaW5YID49IGhCb3hUb3BMZWZ0WCAmJiBib3hNaW5YIDw9IGhCb3hCb3R0b21SaWdodFhcbiAgICAgICYmIGJveE1heFkgPj0gaEJveFRvcExlZnRZICYmIGJveE1heFkgPD0gaEJveEJvdHRvbVJpZ2h0WSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGlmIGFuIHZCb3ggcG9pbnQgaXMgaW4gZ2l2ZW4gYm94XG4gICAgaWYgKHZCb3hUb3BMZWZ0WCA+PSBib3hNaW5YICYmIHZCb3hUb3BMZWZ0WCA8PSBib3hNYXhYXG4gICAgICAgICYmIHZCb3hUb3BMZWZ0WSA+PSBib3hNaW5ZICYmIHZCb3hUb3BMZWZ0WSA8PSBib3hNYXhZKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHZCb3hCb3R0b21SaWdodFggPj0gYm94TWluWCAmJiB2Qm94Qm90dG9tUmlnaHRYIDw9IGJveE1heFhcbiAgICAgICAgJiYgdkJveFRvcExlZnRZID49IGJveE1pblkgJiYgdkJveFRvcExlZnRZIDw9IGJveE1heFkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBpZiAodkJveEJvdHRvbVJpZ2h0WCA+PSBib3hNaW5YICYmIHZCb3hCb3R0b21SaWdodFggPD0gYm94TWF4WFxuICAgICAgICAmJiB2Qm94Qm90dG9tUmlnaHRZID49IGJveE1pblkgJiYgdkJveEJvdHRvbVJpZ2h0WSA8PSBib3hNYXhZKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHZCb3hUb3BMZWZ0WCA+PSBib3hNaW5YICYmIHZCb3hUb3BMZWZ0WCA8PSBib3hNYXhYXG4gICAgICAgICYmIHZCb3hCb3R0b21SaWdodFkgPj0gYm94TWluWSAmJiB2Qm94Qm90dG9tUmlnaHRZIDw9IGJveE1heFkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBpZiBhIGdpdmVuIHBvaW50IGJveCBpcyBpbiB0aGUgdkJveFxuICAgIGlmIChib3hNaW5YID49IHZCb3hUb3BMZWZ0WCAmJiBib3hNaW5YIDw9IHZCb3hCb3R0b21SaWdodFhcbiAgICAgICYmIGJveE1pblkgPj0gdkJveFRvcExlZnRZICYmIGJveE1pblkgPD0gdkJveEJvdHRvbVJpZ2h0WSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmIChib3hNYXhYID49IHZCb3hUb3BMZWZ0WCAmJiBib3hNYXhYIDw9IHZCb3hCb3R0b21SaWdodFhcbiAgICAgICYmIGJveE1pblkgPj0gdkJveFRvcExlZnRZICYmIGJveE1pblkgPD0gdkJveEJvdHRvbVJpZ2h0WSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmIChib3hNYXhYID49IHZCb3hUb3BMZWZ0WCAmJiBib3hNYXhYIDw9IHZCb3hCb3R0b21SaWdodFhcbiAgICAgICYmIGJveE1heFkgPj0gdkJveFRvcExlZnRZICYmIGJveE1heFkgPD0gdkJveEJvdHRvbVJpZ2h0WSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmIChib3hNaW5YID49IHZCb3hUb3BMZWZ0WCAmJiBib3hNaW5YIDw9IHZCb3hCb3R0b21SaWdodFhcbiAgICAgICYmIGJveE1heFkgPj0gdkJveFRvcExlZnRZICYmIGJveE1heFkgPD0gdkJveEJvdHRvbVJpZ2h0WSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIC8vIExhc3RseSwgY2hlY2sgaWYgb25lIG9mIHRoZSBlbGxpcHNlcyBjb2luY2lkZSB3aXRoIHRoZSBib3hcbiAgICBcbiAgICBpZiAodGhpcy5ib3hJbnRlcnNlY3RFbGxpcHNlKGJveE1pblgsIGJveE1pblksIGJveE1heFgsIGJveE1heFksIHBhZGRpbmcsXG4gICAgICAgIGNvcm5lclJhZGl1cyAqIDIsIGNvcm5lclJhZGl1cyAqIDIsIHZCb3hUb3BMZWZ0WCArIHBhZGRpbmcsIGhCb3hUb3BMZWZ0WSArIHBhZGRpbmcpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHRoaXMuYm94SW50ZXJzZWN0RWxsaXBzZShib3hNaW5YLCBib3hNaW5ZLCBib3hNYXhYLCBib3hNYXhZLCBwYWRkaW5nLFxuICAgICAgICBjb3JuZXJSYWRpdXMgKiAyLCBjb3JuZXJSYWRpdXMgKiAyLCB2Qm94Qm90dG9tUmlnaHRYIC0gcGFkZGluZywgaEJveFRvcExlZnRZICsgcGFkZGluZykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBpZiAodGhpcy5ib3hJbnRlcnNlY3RFbGxpcHNlKGJveE1pblgsIGJveE1pblksIGJveE1heFgsIGJveE1heFksIHBhZGRpbmcsXG4gICAgICAgIGNvcm5lclJhZGl1cyAqIDIsIGNvcm5lclJhZGl1cyAqIDIsIHZCb3hCb3R0b21SaWdodFggLSBwYWRkaW5nLCBoQm94Qm90dG9tUmlnaHRZIC0gcGFkZGluZykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBpZiAodGhpcy5ib3hJbnRlcnNlY3RFbGxpcHNlKGJveE1pblgsIGJveE1pblksIGJveE1heFgsIGJveE1heFksIHBhZGRpbmcsXG4gICAgICAgIGNvcm5lclJhZGl1cyAqIDIsIGNvcm5lclJhZGl1cyAqIDIsIHZCb3hUb3BMZWZ0WCArIHBhZGRpbmcsIGhCb3hCb3R0b21SaWdodFkgLSBwYWRkaW5nKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgXG4gIC8vIEBPIEFwcHJveGltYXRlIGNvbGxpc2lvbiBmdW5jdGlvbnNcbiAgJCQubWF0aC5jaGVja0luQm91bmRpbmdDaXJjbGUgPSBmdW5jdGlvbihcbiAgICB4LCB5LCBmYXJ0aGVzdFBvaW50U3FEaXN0YW5jZSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgIFxuICAgIHggPSAoeCAtIGNlbnRlclgpIC8gKHdpZHRoICsgcGFkZGluZyk7XG4gICAgeSA9ICh5IC0gY2VudGVyWSkgLyAoaGVpZ2h0ICsgcGFkZGluZyk7XG4gICAgXG4gICAgcmV0dXJuICh4ICogeCArIHkgKiB5KSA8PSBmYXJ0aGVzdFBvaW50U3FEaXN0YW5jZTtcbiAgfTtcbiAgXG4gICQkLm1hdGguYm94SW5CZXppZXJWaWNpbml0eSA9IGZ1bmN0aW9uKFxuICAgIHgxYm94LCB5MWJveCwgeDJib3gsIHkyYm94LCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB0b2xlcmFuY2UpIHtcbiAgICBcbiAgICAvLyBSZXR1cm4gdmFsdWVzOlxuICAgIC8vIDAgLSBjdXJ2ZSBpcyBub3QgaW4gYm94XG4gICAgLy8gMSAtIGN1cnZlIG1heSBiZSBpbiBib3g7IG5lZWRzIHByZWNpc2UgY2hlY2tcbiAgICAvLyAyIC0gY3VydmUgaXMgaW4gYm94XG4gICAgXG4gICAgLy8gbWlkcG9pbnRcbiAgICB2YXIgbWlkWCA9IDAuMjUgKiB4MSArIDAuNSAqIHgyICsgMC4yNSAqIHgzO1xuICAgIHZhciBtaWRZID0gMC4yNSAqIHkxICsgMC41ICogeTIgKyAwLjI1ICogeTM7XG5cbiAgICB2YXIgYm94TWluWCA9IE1hdGgubWluKHgxYm94LCB4MmJveCkgLSB0b2xlcmFuY2U7XG4gICAgdmFyIGJveE1pblkgPSBNYXRoLm1pbih5MWJveCwgeTJib3gpIC0gdG9sZXJhbmNlO1xuICAgIHZhciBib3hNYXhYID0gTWF0aC5tYXgoeDFib3gsIHgyYm94KSArIHRvbGVyYW5jZTtcbiAgICB2YXIgYm94TWF4WSA9IE1hdGgubWF4KHkxYm94LCB5MmJveCkgKyB0b2xlcmFuY2U7XG4gICAgXG4gICAgaWYgKHgxID49IGJveE1pblggJiYgeDEgPD0gYm94TWF4WCAmJiB5MSA+PSBib3hNaW5ZICYmIHkxIDw9IGJveE1heFkpIHsgLy8gKHgxLCB5MSkgaW4gYm94XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKHgzID49IGJveE1pblggJiYgeDMgPD0gYm94TWF4WCAmJiB5MyA+PSBib3hNaW5ZICYmIHkzIDw9IGJveE1heFkpIHsgLy8gKHgzLCB5MykgaW4gYm94XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKG1pZFggPj0gYm94TWluWCAmJiBtaWRYIDw9IGJveE1heFggJiYgbWlkWSA+PSBib3hNaW5ZICYmIG1pZFkgPD0gYm94TWF4WSkgeyAvLyAobWlkWCwgbWlkWSkgaW4gYm94XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKHgyID49IGJveE1pblggJiYgeDIgPD0gYm94TWF4WCAmJiB5MiA+PSBib3hNaW5ZICYmIHkyIDw9IGJveE1heFkpIHsgLy8gY3RybCBwdCBpbiBib3hcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBcbiAgICB2YXIgY3VydmVNaW5YID0gTWF0aC5taW4oeDEsIG1pZFgsIHgzKTtcbiAgICB2YXIgY3VydmVNaW5ZID0gTWF0aC5taW4oeTEsIG1pZFksIHkzKTtcbiAgICB2YXIgY3VydmVNYXhYID0gTWF0aC5tYXgoeDEsIG1pZFgsIHgzKTtcbiAgICB2YXIgY3VydmVNYXhZID0gTWF0aC5tYXgoeTEsIG1pZFksIHkzKTtcbiAgICBcbiAgICAvKlxuICAgIGNvbnNvbGUubG9nKGN1cnZlTWluWCArIFwiLCBcIiArIGN1cnZlTWluWSArIFwiLCBcIiArIGN1cnZlTWF4WCBcbiAgICAgICsgXCIsIFwiICsgY3VydmVNYXhZKTtcbiAgICBpZiAoY3VydmVNaW5YID09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc29sZS5sb2coXCJ1bmRlZmluZWQgY3VydmVNaW5YOiBcIiArIHgxICsgXCIsIFwiICsgeDIgKyBcIiwgXCIgKyB4Myk7XG4gICAgfVxuICAgICovXG4gICAgXG4gICAgaWYgKGN1cnZlTWluWCA+IGJveE1heFhcbiAgICAgIHx8IGN1cnZlTWF4WCA8IGJveE1pblhcbiAgICAgIHx8IGN1cnZlTWluWSA+IGJveE1heFlcbiAgICAgIHx8IGN1cnZlTWF4WSA8IGJveE1pblkpIHtcbiAgICAgIFxuICAgICAgcmV0dXJuIDA7ICBcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIDE7XG4gIH07XG5cbiAgJCQubWF0aC5jaGVja0JlemllckluQm94ID0gZnVuY3Rpb24oXG4gICAgeDFib3gsIHkxYm94LCB4MmJveCwgeTJib3gsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHRvbGVyYW5jZSkge1xuXG4gICAgZnVuY3Rpb24gc2FtcGxlSW5Cb3godCl7XG4gICAgICB2YXIgeCA9ICQkLm1hdGgucWJlemllckF0KHgxLCB4MiwgeDMsIHQpO1xuICAgICAgdmFyIHkgPSAkJC5tYXRoLnFiZXppZXJBdCh5MSwgeTIsIHkzLCB0KTtcblxuICAgICAgcmV0dXJuIHgxYm94IDw9IHggJiYgeCA8PSB4MmJveFxuICAgICAgICAmJiB5MWJveCA8PSB5ICYmIHkgPD0geTJib3hcbiAgICAgIDtcbiAgICB9XG5cbiAgICBmb3IoIHZhciB0ID0gMDsgdCA8PSAxOyB0ICs9IDAuMjUgKXtcbiAgICAgIGlmKCAhc2FtcGxlSW5Cb3godCkgKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICBcbiAgJCQubWF0aC5jaGVja1N0cmFpZ2h0RWRnZUluQm94ID0gZnVuY3Rpb24oXG4gICAgeDFib3gsIHkxYm94LCB4MmJveCwgeTJib3gsIHgxLCB5MSwgeDIsIHkyLCB0b2xlcmFuY2UpIHtcblxuICAgIHJldHVybiB4MWJveCA8PSB4MSAmJiB4MSA8PSB4MmJveFxuICAgICAgJiYgeDFib3ggPD0geDIgJiYgeDIgPD0geDJib3hcbiAgICAgICYmIHkxYm94IDw9IHkxICYmIHkxIDw9IHkyYm94XG4gICAgICAmJiB5MWJveCA8PSB5MiAmJiB5MiA8PSB5MmJveFxuICAgIDtcbiAgfTtcblxuICAkJC5tYXRoLmNoZWNrU3RyYWlnaHRFZGdlQ3Jvc3Nlc0JveCA9IGZ1bmN0aW9uKFxuICAgIHgxYm94LCB5MWJveCwgeDJib3gsIHkyYm94LCB4MSwgeTEsIHgyLCB5MiwgdG9sZXJhbmNlKSB7XG4gICAgXG4gICAvL2NvbnNvbGUubG9nKGFyZ3VtZW50cyk7XG4gICAgXG4gICAgdmFyIGJveE1pblggPSBNYXRoLm1pbih4MWJveCwgeDJib3gpIC0gdG9sZXJhbmNlO1xuICAgIHZhciBib3hNaW5ZID0gTWF0aC5taW4oeTFib3gsIHkyYm94KSAtIHRvbGVyYW5jZTtcbiAgICB2YXIgYm94TWF4WCA9IE1hdGgubWF4KHgxYm94LCB4MmJveCkgKyB0b2xlcmFuY2U7XG4gICAgdmFyIGJveE1heFkgPSBNYXRoLm1heCh5MWJveCwgeTJib3gpICsgdG9sZXJhbmNlO1xuICAgIFxuICAgIC8vIENoZWNrIGxlZnQgKyByaWdodCBib3VuZHNcbiAgICB2YXIgYVggPSB4MiAtIHgxO1xuICAgIHZhciBiWCA9IHgxO1xuICAgIHZhciB5VmFsdWU7XG4gICAgXG4gICAgLy8gVG9wIGFuZCBib3R0b21cbiAgICB2YXIgYVkgPSB5MiAtIHkxO1xuICAgIHZhciBiWSA9IHkxO1xuICAgIHZhciB4VmFsdWU7XG4gICAgXG4gICAgaWYgKE1hdGguYWJzKGFYKSA8IDAuMDAwMSkge1xuICAgICAgcmV0dXJuICh4MSA+PSBib3hNaW5YICYmIHgxIDw9IGJveE1heFhcbiAgICAgICAgJiYgTWF0aC5taW4oeTEsIHkyKSA8PSBib3hNaW5ZXG4gICAgICAgICYmIE1hdGgubWF4KHkxLCB5MikgPj0gYm94TWF4WSk7ICBcbiAgICB9XG4gICAgXG4gICAgdmFyIHRMZWZ0ID0gKGJveE1pblggLSBiWCkgLyBhWDtcbiAgICBpZiAodExlZnQgPiAwICYmIHRMZWZ0IDw9IDEpIHtcbiAgICAgIHlWYWx1ZSA9IGFZICogdExlZnQgKyBiWTtcbiAgICAgIGlmICh5VmFsdWUgPj0gYm94TWluWSAmJiB5VmFsdWUgPD0gYm94TWF4WSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gXG4gICAgfVxuICAgIFxuICAgIHZhciB0UmlnaHQgPSAoYm94TWF4WCAtIGJYKSAvIGFYO1xuICAgIGlmICh0UmlnaHQgPiAwICYmIHRSaWdodCA8PSAxKSB7XG4gICAgICB5VmFsdWUgPSBhWSAqIHRSaWdodCArIGJZO1xuICAgICAgaWYgKHlWYWx1ZSA+PSBib3hNaW5ZICYmIHlWYWx1ZSA8PSBib3hNYXhZKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBcbiAgICB9XG4gICAgXG4gICAgdmFyIHRUb3AgPSAoYm94TWluWSAtIGJZKSAvIGFZO1xuICAgIGlmICh0VG9wID4gMCAmJiB0VG9wIDw9IDEpIHtcbiAgICAgIHhWYWx1ZSA9IGFYICogdFRvcCArIGJYO1xuICAgICAgaWYgKHhWYWx1ZSA+PSBib3hNaW5YICYmIHhWYWx1ZSA8PSBib3hNYXhYKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBcbiAgICB9XG4gICAgXG4gICAgdmFyIHRCb3R0b20gPSAoYm94TWF4WSAtIGJZKSAvIGFZO1xuICAgIGlmICh0Qm90dG9tID4gMCAmJiB0Qm90dG9tIDw9IDEpIHtcbiAgICAgIHhWYWx1ZSA9IGFYICogdEJvdHRvbSArIGJYO1xuICAgICAgaWYgKHhWYWx1ZSA+PSBib3hNaW5YICYmIHhWYWx1ZSA8PSBib3hNYXhYKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBcbiAgJCQubWF0aC5jaGVja0JlemllckNyb3NzZXNCb3ggPSBmdW5jdGlvbihcbiAgICB4MWJveCwgeTFib3gsIHgyYm94LCB5MmJveCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgdG9sZXJhbmNlKSB7XG4gICAgXG4gICAgdmFyIGJveE1pblggPSBNYXRoLm1pbih4MWJveCwgeDJib3gpIC0gdG9sZXJhbmNlO1xuICAgIHZhciBib3hNaW5ZID0gTWF0aC5taW4oeTFib3gsIHkyYm94KSAtIHRvbGVyYW5jZTtcbiAgICB2YXIgYm94TWF4WCA9IE1hdGgubWF4KHgxYm94LCB4MmJveCkgKyB0b2xlcmFuY2U7XG4gICAgdmFyIGJveE1heFkgPSBNYXRoLm1heCh5MWJveCwgeTJib3gpICsgdG9sZXJhbmNlO1xuICAgIFxuICAgIGlmICh4MSA+PSBib3hNaW5YICYmIHgxIDw9IGJveE1heFggJiYgeTEgPj0gYm94TWluWSAmJiB5MSA8PSBib3hNYXhZKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHgzID49IGJveE1pblggJiYgeDMgPD0gYm94TWF4WCAmJiB5MyA+PSBib3hNaW5ZICYmIHkzIDw9IGJveE1heFkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICB2YXIgYVggPSB4MSAtIDIgKiB4MiArIHgzO1xuICAgIHZhciBiWCA9IC0yICogeDEgKyAyICogeDI7XG4gICAgdmFyIGNYID0geDE7XG5cbiAgICB2YXIgeEludGVydmFscyA9IFtdO1xuICAgIFxuICAgIGlmIChNYXRoLmFicyhhWCkgPCAwLjAwMDEpIHtcbiAgICAgIHZhciBsZWZ0UGFyYW0gPSAoYm94TWluWCAtIHgxKSAvIGJYO1xuICAgICAgdmFyIHJpZ2h0UGFyYW0gPSAoYm94TWF4WCAtIHgxKSAvIGJYO1xuICAgICAgXG4gICAgICB4SW50ZXJ2YWxzLnB1c2gobGVmdFBhcmFtLCByaWdodFBhcmFtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmluZCB3aGVuIHggY29vcmRpbmF0ZSBvZiB0aGUgY3VydmUgY3Jvc3NlcyB0aGUgbGVmdCBzaWRlIG9mIHRoZSBib3hcbiAgICAgIHZhciBkaXNjcmltaW5hbnRYMSA9IGJYICogYlggLSA0ICogYVggKiAoY1ggLSBib3hNaW5YKTtcbiAgICAgIHZhciB0WDEsIHRYMjtcbiAgICAgIGlmIChkaXNjcmltaW5hbnRYMSA+IDApIHtcbiAgICAgICAgdmFyIHNxcnQgPSBNYXRoLnNxcnQoZGlzY3JpbWluYW50WDEpO1xuICAgICAgICB0WDEgPSAoLWJYICsgc3FydCkgLyAoMiAqIGFYKTtcbiAgICAgICAgdFgyID0gKC1iWCAtIHNxcnQpIC8gKDIgKiBhWCk7XG4gICAgICAgIFxuICAgICAgICB4SW50ZXJ2YWxzLnB1c2godFgxLCB0WDIpO1xuICAgICAgfVxuICAgICAgXG4gICAgICB2YXIgZGlzY3JpbWluYW50WDIgPSBiWCAqIGJYIC0gNCAqIGFYICogKGNYIC0gYm94TWF4WCk7XG4gICAgICB2YXIgdFgzLCB0WDQ7XG4gICAgICBpZiAoZGlzY3JpbWluYW50WDIgPiAwKSB7XG4gICAgICAgIHZhciBzcXJ0ID0gTWF0aC5zcXJ0KGRpc2NyaW1pbmFudFgyKTtcbiAgICAgICAgdFgzID0gKC1iWCArIHNxcnQpIC8gKDIgKiBhWCk7XG4gICAgICAgIHRYNCA9ICgtYlggLSBzcXJ0KSAvICgyICogYVgpO1xuICAgICAgICBcbiAgICAgICAgeEludGVydmFscy5wdXNoKHRYMywgdFg0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgeEludGVydmFscy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEgLSBiOyB9KTtcbiAgICBcbiAgICB2YXIgYVkgPSB5MSAtIDIgKiB5MiArIHkzO1xuICAgIHZhciBiWSA9IC0yICogeTEgKyAyICogeTI7XG4gICAgdmFyIGNZID0geTE7XG4gICAgXG4gICAgdmFyIHlJbnRlcnZhbHMgPSBbXTtcbiAgICBcbiAgICBpZiAoTWF0aC5hYnMoYVkpIDwgMC4wMDAxKSB7XG4gICAgICB2YXIgdG9wUGFyYW0gPSAoYm94TWluWSAtIHkxKSAvIGJZO1xuICAgICAgdmFyIGJvdHRvbVBhcmFtID0gKGJveE1heFkgLSB5MSkgLyBiWTtcbiAgICAgIFxuICAgICAgeUludGVydmFscy5wdXNoKHRvcFBhcmFtLCBib3R0b21QYXJhbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkaXNjcmltaW5hbnRZMSA9IGJZICogYlkgLSA0ICogYVkgKiAoY1kgLSBib3hNaW5ZKTtcbiAgICAgIFxuICAgICAgdmFyIHRZMSwgdFkyO1xuICAgICAgaWYgKGRpc2NyaW1pbmFudFkxID4gMCkge1xuICAgICAgICB2YXIgc3FydCA9IE1hdGguc3FydChkaXNjcmltaW5hbnRZMSk7XG4gICAgICAgIHRZMSA9ICgtYlkgKyBzcXJ0KSAvICgyICogYVkpO1xuICAgICAgICB0WTIgPSAoLWJZIC0gc3FydCkgLyAoMiAqIGFZKTtcbiAgICAgICAgXG4gICAgICAgIHlJbnRlcnZhbHMucHVzaCh0WTEsIHRZMik7XG4gICAgICB9XG4gIFxuICAgICAgdmFyIGRpc2NyaW1pbmFudFkyID0gYlkgKiBiWSAtIDQgKiBhWSAqIChjWSAtIGJveE1heFkpO1xuICAgICAgXG4gICAgICB2YXIgdFkzLCB0WTQ7XG4gICAgICBpZiAoZGlzY3JpbWluYW50WTIgPiAwKSB7XG4gICAgICAgIHZhciBzcXJ0ID0gTWF0aC5zcXJ0KGRpc2NyaW1pbmFudFkyKTtcbiAgICAgICAgdFkzID0gKC1iWSArIHNxcnQpIC8gKDIgKiBhWSk7XG4gICAgICAgIHRZNCA9ICgtYlkgLSBzcXJ0KSAvICgyICogYVkpO1xuICAgICAgICBcbiAgICAgICAgeUludGVydmFscy5wdXNoKHRZMywgdFk0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgICAgIFxuICAgIHlJbnRlcnZhbHMuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhIC0gYjsgfSk7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgeEludGVydmFscy5sZW5ndGg7IGluZGV4ICs9IDIpIHtcbiAgICAgIGZvciAodmFyIHlJbmRleCA9IDE7IHlJbmRleCA8IHlJbnRlcnZhbHMubGVuZ3RoOyB5SW5kZXggKz0gMikge1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUgZXhpc3RzIHZhbHVlcyBmb3IgdGhlIEJlemllciBjdXJ2ZVxuICAgICAgICAvLyBwYXJhbWV0ZXIgYmV0d2VlbiAwIGFuZCAxIHdoZXJlIGJvdGggdGhlIGN1cnZlJ3NcbiAgICAgICAgLy8geCBhbmQgeSBjb29yZGluYXRlcyBhcmUgd2l0aGluIHRoZSBib3VuZHMgc3BlY2lmaWVkIGJ5IHRoZSBib3hcbiAgICAgICAgaWYgKHhJbnRlcnZhbHNbaW5kZXhdIDwgeUludGVydmFsc1t5SW5kZXhdXG4gICAgICAgICAgJiYgeUludGVydmFsc1t5SW5kZXhdID49IDAuMFxuICAgICAgICAgICYmIHhJbnRlcnZhbHNbaW5kZXhdIDw9IDEuMFxuICAgICAgICAgICYmIHhJbnRlcnZhbHNbaW5kZXggKyAxXSA+IHlJbnRlcnZhbHNbeUluZGV4IC0gMV1cbiAgICAgICAgICAmJiB5SW50ZXJ2YWxzW3lJbmRleCAtIDFdIDw9IDEuMFxuICAgICAgICAgICYmIHhJbnRlcnZhbHNbaW5kZXggKyAxXSA+PSAwLjApIHtcbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIFxuICAkJC5tYXRoLmluTGluZVZpY2luaXR5ID0gZnVuY3Rpb24oeCwgeSwgbHgxLCBseTEsIGx4MiwgbHkyLCB0b2xlcmFuY2Upe1xuICAgIHZhciB0ID0gdG9sZXJhbmNlO1xuXG4gICAgdmFyIHgxID0gTWF0aC5taW4obHgxLCBseDIpO1xuICAgIHZhciB4MiA9IE1hdGgubWF4KGx4MSwgbHgyKTtcbiAgICB2YXIgeTEgPSBNYXRoLm1pbihseTEsIGx5Mik7XG4gICAgdmFyIHkyID0gTWF0aC5tYXgobHkxLCBseTIpO1xuXG4gICAgcmV0dXJuIHgxIC0gdCA8PSB4ICYmIHggPD0geDIgKyB0XG4gICAgICAmJiB5MSAtIHQgPD0geSAmJiB5IDw9IHkyICsgdDtcbiAgfTtcblxuICAkJC5tYXRoLmluQmV6aWVyVmljaW5pdHkgPSBmdW5jdGlvbihcbiAgICB4LCB5LCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB0b2xlcmFuY2VTcXVhcmVkKSB7XG5cbiAgICB2YXIgYmIgPSB7XG4gICAgICB4MTogTWF0aC5taW4oIHgxLCB4MywgeDIgKSxcbiAgICAgIHgyOiBNYXRoLm1heCggeDEsIHgzLCB4MiApLFxuICAgICAgeTE6IE1hdGgubWluKCB5MSwgeTMsIHkyICksXG4gICAgICB5MjogTWF0aC5tYXgoIHkxLCB5MywgeTIgKVxuICAgIH07XG5cbiAgICAvLyBpZiBvdXRzaWRlIHRoZSByb3VnaCBib3VuZGluZyBib3ggZm9yIHRoZSBiZXppZXIsIHRoZW4gaXQgY2FuJ3QgYmUgYSBoaXRcbiAgICBpZiggeCA8IGJiLngxIHx8IHggPiBiYi54MiB8fCB5IDwgYmIueTEgfHwgeSA+IGJiLnkyICl7XG4gICAgICAvLyBjb25zb2xlLmxvZygnYmV6aWVyIG91dCBvZiByb3VnaCBiYicpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdkbyBtb3JlIGV4cGVuc2l2ZSBjaGVjaycpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gIH07XG4gIFxuICAkJC5tYXRoLnNvbHZlQ3ViaWMgPSBmdW5jdGlvbihhLCBiLCBjLCBkLCByZXN1bHQpIHtcbiAgICBcbiAgICAvLyBTb2x2ZXMgYSBjdWJpYyBmdW5jdGlvbiwgcmV0dXJucyByb290IGluIGZvcm0gW3IxLCBpMSwgcjIsIGkyLCByMywgaTNdLCB3aGVyZVxuICAgIC8vIHIgaXMgdGhlIHJlYWwgY29tcG9uZW50LCBpIGlzIHRoZSBpbWFnaW5hcnkgY29tcG9uZW50XG5cbiAgICAvLyBBbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgQ2FyZGFubyBtZXRob2QgZnJvbSB0aGUgeWVhciAxNTQ1XG4gICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DdWJpY19mdW5jdGlvbiNUaGVfbmF0dXJlX29mX3RoZV9yb290c1xuXG4gICAgYiAvPSBhO1xuICAgIGMgLz0gYTtcbiAgICBkIC89IGE7XG4gICAgXG4gICAgdmFyIGRpc2NyaW1pbmFudCwgcSwgciwgZHVtMSwgcywgdCwgdGVybTEsIHIxMztcblxuICAgIHEgPSAoMy4wICogYyAtIChiICogYikpIC8gOS4wO1xuICAgIHIgPSAtKDI3LjAgKiBkKSArIGIgKiAoOS4wICogYyAtIDIuMCAqIChiICogYikpO1xuICAgIHIgLz0gNTQuMDtcbiAgICBcbiAgICBkaXNjcmltaW5hbnQgPSBxICogcSAqIHEgKyByICogcjtcbiAgICByZXN1bHRbMV0gPSAwO1xuICAgIHRlcm0xID0gKGIgLyAzLjApO1xuICAgIFxuICAgIGlmIChkaXNjcmltaW5hbnQgPiAwKSB7XG4gICAgICBzID0gciArIE1hdGguc3FydChkaXNjcmltaW5hbnQpO1xuICAgICAgcyA9ICgocyA8IDApID8gLU1hdGgucG93KC1zLCAoMS4wIC8gMy4wKSkgOiBNYXRoLnBvdyhzLCAoMS4wIC8gMy4wKSkpO1xuICAgICAgdCA9IHIgLSBNYXRoLnNxcnQoZGlzY3JpbWluYW50KTtcbiAgICAgIHQgPSAoKHQgPCAwKSA/IC1NYXRoLnBvdygtdCwgKDEuMCAvIDMuMCkpIDogTWF0aC5wb3codCwgKDEuMCAvIDMuMCkpKTtcbiAgICAgIHJlc3VsdFswXSA9IC10ZXJtMSArIHMgKyB0O1xuICAgICAgdGVybTEgKz0gKHMgKyB0KSAvIDIuMDtcbiAgICAgIHJlc3VsdFs0XSA9IHJlc3VsdFsyXSA9IC10ZXJtMTtcbiAgICAgIHRlcm0xID0gTWF0aC5zcXJ0KDMuMCkgKiAoLXQgKyBzKSAvIDI7XG4gICAgICByZXN1bHRbM10gPSB0ZXJtMTtcbiAgICAgIHJlc3VsdFs1XSA9IC10ZXJtMTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgcmVzdWx0WzVdID0gcmVzdWx0WzNdID0gMDtcbiAgICBcbiAgICBpZiAoZGlzY3JpbWluYW50ID09PSAwKSB7XG4gICAgICByMTMgPSAoKHIgPCAwKSA/IC1NYXRoLnBvdygtciwgKDEuMCAvIDMuMCkpIDogTWF0aC5wb3cociwgKDEuMCAvIDMuMCkpKTtcbiAgICAgIHJlc3VsdFswXSA9IC10ZXJtMSArIDIuMCAqIHIxMztcbiAgICAgIHJlc3VsdFs0XSA9IHJlc3VsdFsyXSA9IC0ocjEzICsgdGVybTEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBxID0gLXE7XG4gICAgZHVtMSA9IHEgKiBxICogcTtcbiAgICBkdW0xID0gTWF0aC5hY29zKHIgLyBNYXRoLnNxcnQoZHVtMSkpO1xuICAgIHIxMyA9IDIuMCAqIE1hdGguc3FydChxKTtcbiAgICByZXN1bHRbMF0gPSAtdGVybTEgKyByMTMgKiBNYXRoLmNvcyhkdW0xIC8gMy4wKTtcbiAgICByZXN1bHRbMl0gPSAtdGVybTEgKyByMTMgKiBNYXRoLmNvcygoZHVtMSArIDIuMCAqIE1hdGguUEkpIC8gMy4wKTtcbiAgICByZXN1bHRbNF0gPSAtdGVybTEgKyByMTMgKiBNYXRoLmNvcygoZHVtMSArIDQuMCAqIE1hdGguUEkpIC8gMy4wKTtcbiAgICBcbiAgICByZXR1cm47XG4gIH07XG5cbiAgJCQubWF0aC5zcURpc3RhbmNlVG9RdWFkcmF0aWNCZXppZXIgPSBmdW5jdGlvbihcbiAgICB4LCB5LCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgXG4gICAgLy8gRmluZCBtaW5pbXVtIGRpc3RhbmNlIGJ5IHVzaW5nIHRoZSBtaW5pbXVtIG9mIHRoZSBkaXN0YW5jZSBcbiAgICAvLyBmdW5jdGlvbiBiZXR3ZWVuIHRoZSBnaXZlbiBwb2ludCBhbmQgdGhlIGN1cnZlXG4gICAgXG4gICAgLy8gVGhpcyBnaXZlcyB0aGUgY29lZmZpY2llbnRzIG9mIHRoZSByZXN1bHRpbmcgY3ViaWMgZXF1YXRpb25cbiAgICAvLyB3aG9zZSByb290cyB0ZWxsIHVzIHdoZXJlIGEgcG9zc2libGUgbWluaW11bSBpc1xuICAgIC8vIChDb2VmZmljaWVudHMgYXJlIGRpdmlkZWQgYnkgNClcbiAgICBcbiAgICB2YXIgYSA9IDEuMCAqIHgxKngxIC0gNCp4MSp4MiArIDIqeDEqeDMgKyA0KngyKngyIC0gNCp4Mip4MyArIHgzKngzXG4gICAgICArIHkxKnkxIC0gNCp5MSp5MiArIDIqeTEqeTMgKyA0KnkyKnkyIC0gNCp5Mip5MyArIHkzKnkzO1xuICAgIFxuICAgIHZhciBiID0gMS4wICogOSp4MSp4MiAtIDMqeDEqeDEgLSAzKngxKngzIC0gNip4Mip4MiArIDMqeDIqeDNcbiAgICAgICsgOSp5MSp5MiAtIDMqeTEqeTEgLSAzKnkxKnkzIC0gNip5Mip5MiArIDMqeTIqeTM7XG4gICAgXG4gICAgdmFyIGMgPSAxLjAgKiAzKngxKngxIC0gNip4MSp4MiArIHgxKngzIC0geDEqeCArIDIqeDIqeDIgKyAyKngyKnggLSB4Myp4XG4gICAgICArIDMqeTEqeTEgLSA2KnkxKnkyICsgeTEqeTMgLSB5MSp5ICsgMip5Mip5MiArIDIqeTIqeSAtIHkzKnk7XG4gICAgICBcbiAgICB2YXIgZCA9IDEuMCAqIHgxKngyIC0geDEqeDEgKyB4MSp4IC0geDIqeFxuICAgICAgKyB5MSp5MiAtIHkxKnkxICsgeTEqeSAtIHkyKnk7XG4gICAgXG4gICAgLy8gZGVidWcoXCJjb2VmZmljaWVudHM6IFwiICsgYSAvIGEgKyBcIiwgXCIgKyBiIC8gYSArIFwiLCBcIiArIGMgLyBhICsgXCIsIFwiICsgZCAvIGEpO1xuICAgIFxuICAgIHZhciByb290cyA9IFtdO1xuICAgIFxuICAgIC8vIFVzZSB0aGUgY3ViaWMgc29sdmluZyBhbGdvcml0aG1cbiAgICB0aGlzLnNvbHZlQ3ViaWMoYSwgYiwgYywgZCwgcm9vdHMpO1xuICAgIFxuICAgIHZhciB6ZXJvVGhyZXNob2xkID0gMC4wMDAwMDAxO1xuICAgIFxuICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICBcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgNjsgaW5kZXggKz0gMikge1xuICAgICAgaWYgKE1hdGguYWJzKHJvb3RzW2luZGV4ICsgMV0pIDwgemVyb1RocmVzaG9sZFxuICAgICAgICAgICYmIHJvb3RzW2luZGV4XSA+PSAwXG4gICAgICAgICAgJiYgcm9vdHNbaW5kZXhdIDw9IDEuMCkge1xuICAgICAgICBwYXJhbXMucHVzaChyb290c1tpbmRleF0pO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBwYXJhbXMucHVzaCgxLjApO1xuICAgIHBhcmFtcy5wdXNoKDAuMCk7XG4gICAgXG4gICAgdmFyIG1pbkRpc3RhbmNlU3F1YXJlZCA9IC0xO1xuICAgIHZhciBjbG9zZXN0UGFyYW07XG4gICAgXG4gICAgdmFyIGN1clgsIGN1clksIGRpc3RTcXVhcmVkO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjdXJYID0gTWF0aC5wb3coMS4wIC0gcGFyYW1zW2ldLCAyLjApICogeDFcbiAgICAgICAgKyAyLjAgKiAoMSAtIHBhcmFtc1tpXSkgKiBwYXJhbXNbaV0gKiB4MlxuICAgICAgICArIHBhcmFtc1tpXSAqIHBhcmFtc1tpXSAqIHgzO1xuICAgICAgICBcbiAgICAgIGN1clkgPSBNYXRoLnBvdygxIC0gcGFyYW1zW2ldLCAyLjApICogeTFcbiAgICAgICAgKyAyICogKDEuMCAtIHBhcmFtc1tpXSkgKiBwYXJhbXNbaV0gKiB5MlxuICAgICAgICArIHBhcmFtc1tpXSAqIHBhcmFtc1tpXSAqIHkzO1xuICAgICAgICBcbiAgICAgIGRpc3RTcXVhcmVkID0gTWF0aC5wb3coY3VyWCAtIHgsIDIpICsgTWF0aC5wb3coY3VyWSAtIHksIDIpO1xuICAgICAgLy8gZGVidWcoJ2Rpc3RhbmNlIGZvciBwYXJhbSAnICsgcGFyYW1zW2ldICsgXCI6IFwiICsgTWF0aC5zcXJ0KGRpc3RTcXVhcmVkKSk7XG4gICAgICBpZiAobWluRGlzdGFuY2VTcXVhcmVkID49IDApIHtcbiAgICAgICAgaWYgKGRpc3RTcXVhcmVkIDwgbWluRGlzdGFuY2VTcXVhcmVkKSB7XG4gICAgICAgICAgbWluRGlzdGFuY2VTcXVhcmVkID0gZGlzdFNxdWFyZWQ7XG4gICAgICAgICAgY2xvc2VzdFBhcmFtID0gcGFyYW1zW2ldO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaW5EaXN0YW5jZVNxdWFyZWQgPSBkaXN0U3F1YXJlZDtcbiAgICAgICAgY2xvc2VzdFBhcmFtID0gcGFyYW1zW2ldO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvKlxuICAgIGRlYnVnU3RhdHMuY2xpY2tYID0geDtcbiAgICBkZWJ1Z1N0YXRzLmNsaWNrWSA9IHk7XG4gICAgXG4gICAgZGVidWdTdGF0cy5jbG9zZXN0WCA9IE1hdGgucG93KDEuMCAtIGNsb3Nlc3RQYXJhbSwgMi4wKSAqIHgxXG4gICAgICAgICsgMi4wICogKDEuMCAtIGNsb3Nlc3RQYXJhbSkgKiBjbG9zZXN0UGFyYW0gKiB4MlxuICAgICAgICArIGNsb3Nlc3RQYXJhbSAqIGNsb3Nlc3RQYXJhbSAqIHgzO1xuICAgICAgICBcbiAgICBkZWJ1Z1N0YXRzLmNsb3Nlc3RZID0gTWF0aC5wb3coMS4wIC0gY2xvc2VzdFBhcmFtLCAyLjApICogeTFcbiAgICAgICAgKyAyLjAgKiAoMS4wIC0gY2xvc2VzdFBhcmFtKSAqIGNsb3Nlc3RQYXJhbSAqIHkyXG4gICAgICAgICsgY2xvc2VzdFBhcmFtICogY2xvc2VzdFBhcmFtICogeTM7XG4gICAgKi9cbiAgICBcbiAgICAvLyBkZWJ1ZyhcImdpdmVuOiBcIiBcbiAgICAvLyAgICsgXCIoIFwiICsgeCArIFwiLCBcIiArIHkgKyBcIiksIFwiIFxuICAgIC8vICAgKyBcIiggXCIgKyB4MSArIFwiLCBcIiArIHkxICsgXCIpLCBcIiBcbiAgICAvLyAgICsgXCIoIFwiICsgeDIgKyBcIiwgXCIgKyB5MiArIFwiKSwgXCJcbiAgICAvLyAgICsgXCIoIFwiICsgeDMgKyBcIiwgXCIgKyB5MyArIFwiKVwiKTtcbiAgICBcbiAgICBcbiAgICAvLyBkZWJ1ZyhcInJvb3RzOiBcIiArIHJvb3RzKTtcbiAgICAvLyBkZWJ1ZyhcInBhcmFtczogXCIgKyBwYXJhbXMpO1xuICAgIC8vIGRlYnVnKFwiY2xvc2VzdCBwYXJhbTogXCIgKyBjbG9zZXN0UGFyYW0pO1xuICAgIHJldHVybiBtaW5EaXN0YW5jZVNxdWFyZWQ7XG4gIH07XG4gIFxuICAkJC5tYXRoLnNxRGlzdGFuY2VUb0Zpbml0ZUxpbmUgPSBmdW5jdGlvbih4LCB5LCB4MSwgeTEsIHgyLCB5Mikge1xuICAgIHZhciBvZmZzZXQgPSBbeCAtIHgxLCB5IC0geTFdO1xuICAgIHZhciBsaW5lID0gW3gyIC0geDEsIHkyIC0geTFdO1xuICAgIFxuICAgIHZhciBsaW5lU3EgPSBsaW5lWzBdICogbGluZVswXSArIGxpbmVbMV0gKiBsaW5lWzFdO1xuICAgIHZhciBoeXBTcSA9IG9mZnNldFswXSAqIG9mZnNldFswXSArIG9mZnNldFsxXSAqIG9mZnNldFsxXTtcbiAgICBcbiAgICB2YXIgZG90UHJvZHVjdCA9IG9mZnNldFswXSAqIGxpbmVbMF0gKyBvZmZzZXRbMV0gKiBsaW5lWzFdO1xuICAgIHZhciBhZGpTcSA9IGRvdFByb2R1Y3QgKiBkb3RQcm9kdWN0IC8gbGluZVNxO1xuICAgIFxuICAgIGlmIChkb3RQcm9kdWN0IDwgMCkge1xuICAgICAgcmV0dXJuIGh5cFNxO1xuICAgIH1cbiAgICBcbiAgICBpZiAoYWRqU3EgPiBsaW5lU3EpIHtcbiAgICAgIHJldHVybiAoeCAtIHgyKSAqICh4IC0geDIpICsgKHkgLSB5MikgKiAoeSAtIHkyKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGh5cFNxIC0gYWRqU3E7XG4gIH07XG5cbiAgJCQubWF0aC5wb2ludEluc2lkZVBvbHlnb24gPSBmdW5jdGlvbihcbiAgICB4LCB5LCBiYXNlUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcpIHtcblxuICAgIC8vdmFyIGRpcmVjdGlvbiA9IGFyZ3VtZW50c1s2XTtcbiAgICB2YXIgdHJhbnNmb3JtZWRQb2ludHMgPSBuZXcgQXJyYXkoYmFzZVBvaW50cy5sZW5ndGgpO1xuXG4gICAgLy8gR2l2ZXMgbmVnYXRpdmUgYW5nbGVcbiAgICB2YXIgYW5nbGUgPSBNYXRoLmFzaW4oZGlyZWN0aW9uWzFdIC8gKE1hdGguc3FydChkaXJlY3Rpb25bMF0gKiBkaXJlY3Rpb25bMF0gXG4gICAgICArIGRpcmVjdGlvblsxXSAqIGRpcmVjdGlvblsxXSkpKTtcbiAgICBcbiAgICBpZiAoZGlyZWN0aW9uWzBdIDwgMCkge1xuICAgICAgYW5nbGUgPSBhbmdsZSArIE1hdGguUEkgLyAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbmdsZSA9IC1hbmdsZSAtIE1hdGguUEkgLyAyO1xuICAgIH1cbiAgICAgICAgXG4gICAgdmFyIGNvcyA9IE1hdGguY29zKC1hbmdsZSk7XG4gICAgdmFyIHNpbiA9IE1hdGguc2luKC1hbmdsZSk7XG4gICAgXG4vLyAgICBjb25zb2xlLmxvZyhcImJhc2U6IFwiICsgYmFzZVBvaW50cyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1lZFBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyXSA9IFxuICAgICAgICB3aWR0aCAvIDIgKiAoYmFzZVBvaW50c1tpICogMl0gKiBjb3NcbiAgICAgICAgICAtIGJhc2VQb2ludHNbaSAqIDIgKyAxXSAqIHNpbik7XG4gICAgICBcbiAgICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyICsgMV0gPSBcbiAgICAgICAgaGVpZ2h0IC8gMiAqIChiYXNlUG9pbnRzW2kgKiAyICsgMV0gKiBjb3MgXG4gICAgICAgICAgKyBiYXNlUG9pbnRzW2kgKiAyXSAqIHNpbik7XG5cbiAgICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyXSArPSBjZW50ZXJYO1xuICAgICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDIgKyAxXSArPSBjZW50ZXJZO1xuICAgIH1cbiAgICBcbiAgICB2YXIgcG9pbnRzO1xuICAgIFxuICAgIGlmIChwYWRkaW5nID4gMCkge1xuICAgICAgdmFyIGV4cGFuZGVkTGluZVNldCA9IHRoaXMuZXhwYW5kUG9seWdvbihcbiAgICAgICAgdHJhbnNmb3JtZWRQb2ludHMsXG4gICAgICAgIC1wYWRkaW5nKTtcbiAgICAgIFxuICAgICAgcG9pbnRzID0gdGhpcy5qb2luTGluZXMoZXhwYW5kZWRMaW5lU2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnRzID0gdHJhbnNmb3JtZWRQb2ludHM7XG4gICAgfVxuICAgIFxuICAgIHZhciB4MSwgeTEsIHgyLCB5MjtcbiAgICB2YXIgeTM7XG4gICAgXG4gICAgLy8gSW50ZXJzZWN0IHdpdGggdmVydGljYWwgbGluZSB0aHJvdWdoICh4LCB5KVxuICAgIHZhciB1cCA9IDA7XG4gICAgdmFyIGRvd24gPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgXG4gICAgICB4MSA9IHBvaW50c1tpICogMl07XG4gICAgICB5MSA9IHBvaW50c1tpICogMiArIDFdO1xuICAgICAgXG4gICAgICBpZiAoaSArIDEgPCBwb2ludHMubGVuZ3RoIC8gMikge1xuICAgICAgICB4MiA9IHBvaW50c1soaSArIDEpICogMl07XG4gICAgICAgIHkyID0gcG9pbnRzWyhpICsgMSkgKiAyICsgMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4MiA9IHBvaW50c1soaSArIDEgLSBwb2ludHMubGVuZ3RoIC8gMikgKiAyXTtcbiAgICAgICAgeTIgPSBwb2ludHNbKGkgKyAxIC0gcG9pbnRzLmxlbmd0aCAvIDIpICogMiArIDFdO1xuICAgICAgfVxuICAgICAgXG4vLyogICAgICBjb25zb2xlLmxvZyhcImxpbmUgZnJvbSAoXCIgKyB4MSArIFwiLCBcIiArIHkxICsgXCIpIHRvIChcIiArIHgyICsgXCIsIFwiICsgeTIgKyBcIilcIik7XG5cbi8vJiAgICAgIGNvbnNvbGUubG9nKHgxLCB4LCB4Mik7XG5cbiAgICAgIGlmICh4MSA9PSB4ICYmIHgyID09IHgpIHtcbiAgICAgICAgXG4gICAgICB9IGVsc2UgaWYgKCh4MSA+PSB4ICYmIHggPj0geDIpXG4gICAgICAgIHx8ICh4MSA8PSB4ICYmIHggPD0geDIpKSB7XG4gICAgICAgIFxuICAgICAgICB5MyA9ICh4IC0geDEpIC8gKHgyIC0geDEpICogKHkyIC0geTEpICsgeTE7XG4gICAgICAgIFxuICAgICAgICBpZiAoeTMgPiB5KSB7XG4gICAgICAgICAgdXArKztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHkzIDwgeSkge1xuICAgICAgICAgIGRvd24rKztcbiAgICAgICAgfVxuICAgICAgICBcbi8vKiAgICAgICAgY29uc29sZS5sb2coeTMsIHkpO1xuICAgICAgICBcbiAgICAgIH0gZWxzZSB7XG4vLyogICAgICAgIGNvbnNvbGUubG9nKCcyMicpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgIH1cbiAgICBcbi8vKiAgICBjb25zb2xlLmxvZyhcInVwOiBcIiArIHVwICsgXCIsIGRvd246IFwiICsgZG93bik7XG4gICAgXG4gICAgaWYgKHVwICUgMiA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgJCQubWF0aC5qb2luTGluZXMgPSBmdW5jdGlvbihsaW5lU2V0KSB7XG4gICAgXG4gICAgdmFyIHZlcnRpY2VzID0gbmV3IEFycmF5KGxpbmVTZXQubGVuZ3RoIC8gMik7XG4gICAgXG4gICAgdmFyIGN1cnJlbnRMaW5lU3RhcnRYLCBjdXJyZW50TGluZVN0YXJ0WSwgY3VycmVudExpbmVFbmRYLCBjdXJyZW50TGluZUVuZFk7XG4gICAgdmFyIG5leHRMaW5lU3RhcnRYLCBuZXh0TGluZVN0YXJ0WSwgbmV4dExpbmVFbmRYLCBuZXh0TGluZUVuZFk7XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lU2V0Lmxlbmd0aCAvIDQ7IGkrKykge1xuICAgICAgY3VycmVudExpbmVTdGFydFggPSBsaW5lU2V0W2kgKiA0XTtcbiAgICAgIGN1cnJlbnRMaW5lU3RhcnRZID0gbGluZVNldFtpICogNCArIDFdO1xuICAgICAgY3VycmVudExpbmVFbmRYID0gbGluZVNldFtpICogNCArIDJdO1xuICAgICAgY3VycmVudExpbmVFbmRZID0gbGluZVNldFtpICogNCArIDNdO1xuICAgICAgXG4gICAgICBpZiAoaSA8IGxpbmVTZXQubGVuZ3RoIC8gNCAtIDEpIHtcbiAgICAgICAgbmV4dExpbmVTdGFydFggPSBsaW5lU2V0WyhpICsgMSkgKiA0XTtcbiAgICAgICAgbmV4dExpbmVTdGFydFkgPSBsaW5lU2V0WyhpICsgMSkgKiA0ICsgMV07XG4gICAgICAgIG5leHRMaW5lRW5kWCA9IGxpbmVTZXRbKGkgKyAxKSAqIDQgKyAyXTtcbiAgICAgICAgbmV4dExpbmVFbmRZID0gbGluZVNldFsoaSArIDEpICogNCArIDNdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dExpbmVTdGFydFggPSBsaW5lU2V0WzBdO1xuICAgICAgICBuZXh0TGluZVN0YXJ0WSA9IGxpbmVTZXRbMV07XG4gICAgICAgIG5leHRMaW5lRW5kWCA9IGxpbmVTZXRbMl07XG4gICAgICAgIG5leHRMaW5lRW5kWSA9IGxpbmVTZXRbM107XG4gICAgICB9XG4gICAgICBcbiAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSB0aGlzLmZpbml0ZUxpbmVzSW50ZXJzZWN0KFxuICAgICAgICBjdXJyZW50TGluZVN0YXJ0WCwgY3VycmVudExpbmVTdGFydFksXG4gICAgICAgIGN1cnJlbnRMaW5lRW5kWCwgY3VycmVudExpbmVFbmRZLFxuICAgICAgICBuZXh0TGluZVN0YXJ0WCwgbmV4dExpbmVTdGFydFksXG4gICAgICAgIG5leHRMaW5lRW5kWCwgbmV4dExpbmVFbmRZLFxuICAgICAgICB0cnVlKTtcbiAgICAgIFxuICAgICAgdmVydGljZXNbaSAqIDJdID0gaW50ZXJzZWN0aW9uWzBdO1xuICAgICAgdmVydGljZXNbaSAqIDIgKyAxXSA9IGludGVyc2VjdGlvblsxXTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHZlcnRpY2VzO1xuICB9O1xuXG4gICQkLm1hdGguZXhwYW5kUG9seWdvbiA9IGZ1bmN0aW9uKHBvaW50cywgcGFkKSB7XG4gICAgXG4gICAgdmFyIGV4cGFuZGVkTGluZVNldCA9IG5ldyBBcnJheShwb2ludHMubGVuZ3RoICogMik7XG4gICAgXG4gICAgdmFyIGN1cnJlbnRQb2ludFgsIGN1cnJlbnRQb2ludFksIG5leHRQb2ludFgsIG5leHRQb2ludFk7XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICBjdXJyZW50UG9pbnRYID0gcG9pbnRzW2kgKiAyXTtcbiAgICAgIGN1cnJlbnRQb2ludFkgPSBwb2ludHNbaSAqIDIgKyAxXTtcbiAgICAgIFxuICAgICAgaWYgKGkgPCBwb2ludHMubGVuZ3RoIC8gMiAtIDEpIHtcbiAgICAgICAgbmV4dFBvaW50WCA9IHBvaW50c1soaSArIDEpICogMl07XG4gICAgICAgIG5leHRQb2ludFkgPSBwb2ludHNbKGkgKyAxKSAqIDIgKyAxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRQb2ludFggPSBwb2ludHNbMF07XG4gICAgICAgIG5leHRQb2ludFkgPSBwb2ludHNbMV07XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEN1cnJlbnQgbGluZTogW2N1cnJlbnRQb2ludFgsIGN1cnJlbnRQb2ludFldIHRvIFtuZXh0UG9pbnRYLCBuZXh0UG9pbnRZXVxuICAgICAgXG4gICAgICAvLyBBc3N1bWUgQ0NXIHBvbHlnb24gd2luZGluZ1xuICAgICAgXG4gICAgICB2YXIgb2Zmc2V0WCA9IChuZXh0UG9pbnRZIC0gY3VycmVudFBvaW50WSk7XG4gICAgICB2YXIgb2Zmc2V0WSA9IC0obmV4dFBvaW50WCAtIGN1cnJlbnRQb2ludFgpO1xuICAgICAgXG4gICAgICAvLyBOb3JtYWxpemVcbiAgICAgIHZhciBvZmZzZXRMZW5ndGggPSBNYXRoLnNxcnQob2Zmc2V0WCAqIG9mZnNldFggKyBvZmZzZXRZICogb2Zmc2V0WSk7XG4gICAgICB2YXIgbm9ybWFsaXplZE9mZnNldFggPSBvZmZzZXRYIC8gb2Zmc2V0TGVuZ3RoO1xuICAgICAgdmFyIG5vcm1hbGl6ZWRPZmZzZXRZID0gb2Zmc2V0WSAvIG9mZnNldExlbmd0aDtcbiAgICAgIFxuICAgICAgZXhwYW5kZWRMaW5lU2V0W2kgKiA0XSA9IGN1cnJlbnRQb2ludFggKyBub3JtYWxpemVkT2Zmc2V0WCAqIHBhZDtcbiAgICAgIGV4cGFuZGVkTGluZVNldFtpICogNCArIDFdID0gY3VycmVudFBvaW50WSArIG5vcm1hbGl6ZWRPZmZzZXRZICogcGFkO1xuICAgICAgZXhwYW5kZWRMaW5lU2V0W2kgKiA0ICsgMl0gPSBuZXh0UG9pbnRYICsgbm9ybWFsaXplZE9mZnNldFggKiBwYWQ7XG4gICAgICBleHBhbmRlZExpbmVTZXRbaSAqIDQgKyAzXSA9IG5leHRQb2ludFkgKyBub3JtYWxpemVkT2Zmc2V0WSAqIHBhZDtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGV4cGFuZGVkTGluZVNldDtcbiAgfTtcblxuICAkJC5tYXRoLmludGVyc2VjdExpbmVFbGxpcHNlID0gZnVuY3Rpb24oXG4gICAgeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgZWxsaXBzZVdyYWRpdXMsIGVsbGlwc2VIcmFkaXVzKSB7XG4gICAgXG4gICAgdmFyIGRpc3BYID0gY2VudGVyWCAtIHg7XG4gICAgdmFyIGRpc3BZID0gY2VudGVyWSAtIHk7XG4gICAgXG4gICAgZGlzcFggLz0gZWxsaXBzZVdyYWRpdXM7XG4gICAgZGlzcFkgLz0gZWxsaXBzZUhyYWRpdXM7XG4gICAgXG4gICAgdmFyIGxlbiA9IE1hdGguc3FydChkaXNwWCAqIGRpc3BYICsgZGlzcFkgKiBkaXNwWSk7XG4gICAgXG4gICAgdmFyIG5ld0xlbmd0aCA9IGxlbiAtIDE7XG4gICAgXG4gICAgaWYgKG5ld0xlbmd0aCA8IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgXG4gICAgdmFyIGxlblByb3BvcnRpb24gPSBuZXdMZW5ndGggLyBsZW47XG4gICAgXG4gICAgcmV0dXJuIFsoY2VudGVyWCAtIHgpICogbGVuUHJvcG9ydGlvbiArIHgsIChjZW50ZXJZIC0geSkgKiBsZW5Qcm9wb3J0aW9uICsgeV07XG4gIH07XG4gIFxuICAkJC5tYXRoLmRvdFByb2R1Y3QgPSBmdW5jdGlvbihcbiAgICB2ZWMxLCB2ZWMyKSB7XG4gICAgXG4gICAgaWYgKHZlYzEubGVuZ3RoICE9IDIgfHwgdmVjMi5sZW5ndGggIT0gMikge1xuICAgICAgdGhyb3cgJ2RvdCBwcm9kdWN0OiBhcmd1bWVudHMgYXJlIG5vdCB2ZWN0b3JzJztcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuICh2ZWMxWzBdICogdmVjMlswXSArIHZlYzFbMV0gKiB2ZWMyWzFdKTtcbiAgfTtcbiAgXG4gIC8vIFJldHVybnMgaW50ZXJzZWN0aW9ucyBvZiBpbmNyZWFzaW5nIGRpc3RhbmNlIGZyb20gbGluZSdzIHN0YXJ0IHBvaW50XG4gICQkLm1hdGguaW50ZXJzZWN0TGluZUNpcmNsZSA9IGZ1bmN0aW9uKFxuICAgIHgxLCB5MSwgeDIsIHkyLCBjZW50ZXJYLCBjZW50ZXJZLCByYWRpdXMpIHtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgZCwgZGlyZWN0aW9uIHZlY3RvciBvZiBsaW5lXG4gICAgdmFyIGQgPSBbeDIgLSB4MSwgeTIgLSB5MV07IC8vIERpcmVjdGlvbiB2ZWN0b3Igb2YgbGluZVxuICAgIHZhciBjID0gW2NlbnRlclgsIGNlbnRlclldOyAvLyBDZW50ZXIgb2YgY2lyY2xlXG4gICAgdmFyIGYgPSBbeDEgLSBjZW50ZXJYLCB5MSAtIGNlbnRlclldO1xuICAgIFxuICAgIHZhciBhID0gZFswXSAqIGRbMF0gKyBkWzFdICogZFsxXTtcbiAgICB2YXIgYiA9IDIgKiAoZlswXSAqIGRbMF0gKyBmWzFdICogZFsxXSk7XG4gICAgdmFyIGMgPSAoZlswXSAqIGZbMF0gKyBmWzFdICogZlsxXSkgLSByYWRpdXMgKiByYWRpdXMgO1xuICAgIFxuICAgIHZhciBkaXNjcmltaW5hbnQgPSBiKmItNCphKmM7XG4gICAgXG4gICAgaWYgKGRpc2NyaW1pbmFudCA8IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgXG4gICAgdmFyIHQxID0gKC1iICsgTWF0aC5zcXJ0KGRpc2NyaW1pbmFudCkpIC8gKDIgKiBhKTtcbiAgICB2YXIgdDIgPSAoLWIgLSBNYXRoLnNxcnQoZGlzY3JpbWluYW50KSkgLyAoMiAqIGEpO1xuICAgIFxuICAgIHZhciB0TWluID0gTWF0aC5taW4odDEsIHQyKTtcbiAgICB2YXIgdE1heCA9IE1hdGgubWF4KHQxLCB0Mik7XG4gICAgdmFyIGluUmFuZ2VQYXJhbXMgPSBbXTtcbiAgICBcbiAgICBpZiAodE1pbiA+PSAwICYmIHRNaW4gPD0gMSkge1xuICAgICAgaW5SYW5nZVBhcmFtcy5wdXNoKHRNaW4pO1xuICAgIH1cbiAgICBcbiAgICBpZiAodE1heCA+PSAwICYmIHRNYXggPD0gMSkge1xuICAgICAgaW5SYW5nZVBhcmFtcy5wdXNoKHRNYXgpO1xuICAgIH1cbiAgICBcbiAgICBpZiAoaW5SYW5nZVBhcmFtcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgXG4gICAgdmFyIG5lYXJJbnRlcnNlY3Rpb25YID0gaW5SYW5nZVBhcmFtc1swXSAqIGRbMF0gKyB4MTtcbiAgICB2YXIgbmVhckludGVyc2VjdGlvblkgPSBpblJhbmdlUGFyYW1zWzBdICogZFsxXSArIHkxO1xuICAgIFxuICAgIGlmIChpblJhbmdlUGFyYW1zLmxlbmd0aCA+IDEpIHtcbiAgICBcbiAgICAgIGlmIChpblJhbmdlUGFyYW1zWzBdID09IGluUmFuZ2VQYXJhbXNbMV0pIHtcbiAgICAgICAgcmV0dXJuIFtuZWFySW50ZXJzZWN0aW9uWCwgbmVhckludGVyc2VjdGlvblldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgXG4gICAgICAgIHZhciBmYXJJbnRlcnNlY3Rpb25YID0gaW5SYW5nZVBhcmFtc1sxXSAqIGRbMF0gKyB4MTtcbiAgICAgICAgdmFyIGZhckludGVyc2VjdGlvblkgPSBpblJhbmdlUGFyYW1zWzFdICogZFsxXSArIHkxO1xuICAgICAgXG4gICAgICAgIHJldHVybiBbbmVhckludGVyc2VjdGlvblgsIG5lYXJJbnRlcnNlY3Rpb25ZLCBmYXJJbnRlcnNlY3Rpb25YLCBmYXJJbnRlcnNlY3Rpb25ZXTtcbiAgICAgIH1cbiAgICAgIFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW25lYXJJbnRlcnNlY3Rpb25YLCBuZWFySW50ZXJzZWN0aW9uWV07XG4gICAgfVxuICAgIFxuICB9O1xuICBcbiAgJCQubWF0aC5maW5kQ2lyY2xlTmVhclBvaW50ID0gZnVuY3Rpb24oY2VudGVyWCwgY2VudGVyWSwgXG4gICAgcmFkaXVzLCBmYXJYLCBmYXJZKSB7XG4gICAgXG4gICAgdmFyIGRpc3BsYWNlbWVudFggPSBmYXJYIC0gY2VudGVyWDtcbiAgICB2YXIgZGlzcGxhY2VtZW50WSA9IGZhclkgLSBjZW50ZXJZO1xuICAgIHZhciBkaXN0YW5jZSA9IE1hdGguc3FydChkaXNwbGFjZW1lbnRYICogZGlzcGxhY2VtZW50WCBcbiAgICAgICsgZGlzcGxhY2VtZW50WSAqIGRpc3BsYWNlbWVudFkpO1xuICAgIFxuICAgIHZhciB1bml0RGlzcGxhY2VtZW50WCA9IGRpc3BsYWNlbWVudFggLyBkaXN0YW5jZTtcbiAgICB2YXIgdW5pdERpc3BsYWNlbWVudFkgPSBkaXNwbGFjZW1lbnRZIC8gZGlzdGFuY2U7XG4gICAgXG4gICAgcmV0dXJuIFtjZW50ZXJYICsgdW5pdERpc3BsYWNlbWVudFggKiByYWRpdXMsIFxuICAgICAgY2VudGVyWSArIHVuaXREaXNwbGFjZW1lbnRZICogcmFkaXVzXTtcbiAgfTtcbiAgXG4gICQkLm1hdGguZmluZE1heFNxRGlzdGFuY2VUb09yaWdpbiA9IGZ1bmN0aW9uKHBvaW50cykge1xuICAgIHZhciBtYXhTcURpc3RhbmNlID0gMC4wMDAwMDE7XG4gICAgdmFyIHNxRGlzdGFuY2U7XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICBcbiAgICAgIHNxRGlzdGFuY2UgPSBwb2ludHNbaSAqIDJdICogcG9pbnRzW2kgKiAyXSBcbiAgICAgICAgKyBwb2ludHNbaSAqIDIgKyAxXSAqIHBvaW50c1tpICogMiArIDFdO1xuICAgICAgXG4gICAgICBpZiAoc3FEaXN0YW5jZSA+IG1heFNxRGlzdGFuY2UpIHtcbiAgICAgICAgbWF4U3FEaXN0YW5jZSA9IHNxRGlzdGFuY2U7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBtYXhTcURpc3RhbmNlO1xuICB9O1xuICBcbiAgJCQubWF0aC5maW5pdGVMaW5lc0ludGVyc2VjdCA9IGZ1bmN0aW9uKFxuICAgIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCwgaW5maW5pdGVMaW5lcykge1xuICAgIFxuICAgIHZhciB1YV90ID0gKHg0IC0geDMpICogKHkxIC0geTMpIC0gKHk0IC0geTMpICogKHgxIC0geDMpO1xuICAgIHZhciB1Yl90ID0gKHgyIC0geDEpICogKHkxIC0geTMpIC0gKHkyIC0geTEpICogKHgxIC0geDMpO1xuICAgIHZhciB1X2IgPSAoeTQgLSB5MykgKiAoeDIgLSB4MSkgLSAoeDQgLSB4MykgKiAoeTIgLSB5MSk7XG5cbiAgICBpZiAodV9iICE9PSAwKSB7XG4gICAgICB2YXIgdWEgPSB1YV90IC8gdV9iO1xuICAgICAgdmFyIHViID0gdWJfdCAvIHVfYjtcbiAgICAgIFxuICAgICAgaWYgKDAgPD0gdWEgJiYgdWEgPD0gMSAmJiAwIDw9IHViICYmIHViIDw9IDEpIHsgIFxuICAgICAgICByZXR1cm4gW3gxICsgdWEgKiAoeDIgLSB4MSksIHkxICsgdWEgKiAoeTIgLSB5MSldO1xuICAgICAgICBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghaW5maW5pdGVMaW5lcykge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gW3gxICsgdWEgKiAoeDIgLSB4MSksIHkxICsgdWEgKiAoeTIgLSB5MSldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh1YV90ID09PSAwIHx8IHViX3QgPT09IDApIHtcblxuICAgICAgICAvLyBQYXJhbGxlbCwgY29pbmNpZGVudCBsaW5lcy4gQ2hlY2sgaWYgb3ZlcmxhcFxuXG4gICAgICAgIC8vIENoZWNrIGVuZHBvaW50IG9mIHNlY29uZCBsaW5lXG4gICAgICAgIGlmIChbeDEsIHgyLCB4NF0uc29ydCgpWzFdID09PSB4NCkge1xuICAgICAgICAgIHJldHVybiBbeDQsIHk0XTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgc3RhcnQgcG9pbnQgb2Ygc2Vjb25kIGxpbmVcbiAgICAgICAgaWYgKFt4MSwgeDIsIHgzXS5zb3J0KClbMV0gPT09IHgzKSB7XG4gICAgICAgICAgcmV0dXJuIFt4MywgeTNdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBFbmRwb2ludCBvZiBmaXJzdCBsaW5lXG4gICAgICAgIGlmIChbeDMsIHg0LCB4Ml0uc29ydCgpWzFdID09PSB4Mikge1xuICAgICAgICAgIHJldHVybiBbeDIsIHkyXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgIFxuICAgICAgICAvLyBQYXJhbGxlbCwgbm9uLWNvaW5jaWRlbnRcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgXG4gIC8vIChib3hNaW5YLCBib3hNaW5ZLCBib3hNYXhYLCBib3hNYXhZLCBwYWRkaW5nLFxuICAvLyAgICAgIGNvcm5lclJhZGl1cyAqIDIsIGNvcm5lclJhZGl1cyAqIDIsIHZCb3hUb3BMZWZ0WCArIHBhZGRpbmcsIGhCb3hUb3BMZWZ0WSArIHBhZGRpbmcpKSB7XG4gIFxuICAkJC5tYXRoLmJveEludGVyc2VjdEVsbGlwc2UgPSBmdW5jdGlvbihcbiAgICB4MSwgeTEsIHgyLCB5MiwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgIFxuICAgIGlmICh4MiA8IHgxKSB7XG4gICAgICB2YXIgb2xkWDEgPSB4MTtcbiAgICAgIHgxID0geDI7XG4gICAgICB4MiA9IG9sZFgxO1xuICAgIH1cbiAgICBcbiAgICBpZiAoeTIgPCB5MSkge1xuICAgICAgdmFyIG9sZFkxID0geTE7XG4gICAgICB5MSA9IHkyO1xuICAgICAgeTIgPSBvbGRZMTtcbiAgICB9XG4gICAgXG4gICAgLy8gNCBvcnRobyBleHRyZW1lIHBvaW50c1xuICAgIHZhciB3ZXN0ID0gW2NlbnRlclggLSB3aWR0aCAvIDIgLSBwYWRkaW5nLCBjZW50ZXJZXTtcbiAgICB2YXIgZWFzdCA9IFtjZW50ZXJYICsgd2lkdGggLyAyICsgcGFkZGluZywgY2VudGVyWV07XG4gICAgdmFyIG5vcnRoID0gW2NlbnRlclgsIGNlbnRlclkgLSBoZWlnaHQgLyAyIC0gcGFkZGluZ107XG4gICAgdmFyIHNvdXRoID0gW2NlbnRlclgsIGNlbnRlclkgKyBoZWlnaHQgLyAyICsgcGFkZGluZ107XG4gICAgXG4gICAgLy8gb3V0IG9mIGJvdW5kczogcmV0dXJuIGZhbHNlXG4gICAgaWYgKHgyIDwgd2VzdFswXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoeDEgPiBlYXN0WzBdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIGlmICh5MSA+IHNvdXRoWzFdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIGlmICh5MiA8IG5vcnRoWzFdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIC8vIDEgb2YgNCBvcnRobyBleHRyZW1lIHBvaW50cyBpbiBib3g6IHJldHVybiB0cnVlXG4gICAgaWYgKHgxIDw9IGVhc3RbMF0gJiYgZWFzdFswXSA8PSB4MlxuICAgICAgICAmJiB5MSA8PSBlYXN0WzFdICYmIGVhc3RbMV0gPD0geTIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoeDEgPD0gd2VzdFswXSAmJiB3ZXN0WzBdIDw9IHgyXG4gICAgICAgICYmIHkxIDw9IHdlc3RbMV0gJiYgd2VzdFsxXSA8PSB5Mikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmICh4MSA8PSBub3J0aFswXSAmJiBub3J0aFswXSA8PSB4MlxuICAgICAgICAmJiB5MSA8PSBub3J0aFsxXSAmJiBub3J0aFsxXSA8PSB5Mikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmICh4MSA8PSBzb3V0aFswXSAmJiBzb3V0aFswXSA8PSB4MlxuICAgICAgICAmJiB5MSA8PSBzb3V0aFsxXSAmJiBzb3V0aFsxXSA8PSB5Mikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIC8vIGJveCBjb3JuZXIgaW4gZWxsaXBzZTogcmV0dXJuIHRydWUgICAgXG4gICAgeDEgPSAoeDEgLSBjZW50ZXJYKSAvICh3aWR0aCAvIDIgKyBwYWRkaW5nKTtcbiAgICB4MiA9ICh4MiAtIGNlbnRlclgpIC8gKHdpZHRoIC8gMiArIHBhZGRpbmcpO1xuICAgIFxuICAgIHkxID0gKHkxIC0gY2VudGVyWSkgLyAoaGVpZ2h0IC8gMiArIHBhZGRpbmcpO1xuICAgIHkyID0gKHkyIC0gY2VudGVyWSkgLyAoaGVpZ2h0IC8gMiArIHBhZGRpbmcpO1xuICAgIFxuICAgIGlmICh4MSAqIHgxICsgeTEgKiB5MSA8PSAxKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHgyICogeDIgKyB5MSAqIHkxIDw9IDEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoeDIgKiB4MiArIHkyICogeTIgPD0gMSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmICh4MSAqIHgxICsgeTIgKiB5MiA8PSAxKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBcbiAgJCQubWF0aC5ib3hJbnRlcnNlY3RQb2x5Z29uID0gZnVuY3Rpb24oXG4gICAgeDEsIHkxLCB4MiwgeTIsIGJhc2VQb2ludHMsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclksIGRpcmVjdGlvbiwgcGFkZGluZykge1xuICAgIFxuLy8gICAgY29uc29sZS5sb2coYXJndW1lbnRzKTtcbiAgICBcbiAgICBpZiAoeDIgPCB4MSkge1xuICAgICAgdmFyIG9sZFgxID0geDE7XG4gICAgICB4MSA9IHgyO1xuICAgICAgeDIgPSBvbGRYMTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHkyIDwgeTEpIHtcbiAgICAgIHZhciBvbGRZMSA9IHkxO1xuICAgICAgeTEgPSB5MjtcbiAgICAgIHkyID0gb2xkWTE7XG4gICAgfVxuICAgIFxuICAgIHZhciB0cmFuc2Zvcm1lZFBvaW50cyA9IG5ldyBBcnJheShiYXNlUG9pbnRzLmxlbmd0aCk7XG4gICAgXG4gICAgLy8gR2l2ZXMgbmVnYXRpdmUgb2YgYW5nbGVcbiAgICB2YXIgYW5nbGUgPSBNYXRoLmFzaW4oZGlyZWN0aW9uWzFdIC8gKE1hdGguc3FydChkaXJlY3Rpb25bMF0gKiBkaXJlY3Rpb25bMF0gXG4gICAgICArIGRpcmVjdGlvblsxXSAqIGRpcmVjdGlvblsxXSkpKTtcbiAgICBcbiAgICBpZiAoZGlyZWN0aW9uWzBdIDwgMCkge1xuICAgICAgYW5nbGUgPSBhbmdsZSArIE1hdGguUEkgLyAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbmdsZSA9IC1hbmdsZSAtIE1hdGguUEkgLyAyO1xuICAgIH1cbiAgICBcbiAgICB2YXIgY29zID0gTWF0aC5jb3MoLWFuZ2xlKTtcbiAgICB2YXIgc2luID0gTWF0aC5zaW4oLWFuZ2xlKTtcbiAgICBcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybWVkUG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDJdID0gXG4gICAgICAgIHdpZHRoIC8gMiAqIChiYXNlUG9pbnRzW2kgKiAyXSAqIGNvc1xuICAgICAgICAgIC0gYmFzZVBvaW50c1tpICogMiArIDFdICogc2luKTtcbiAgICAgIFxuICAgICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDIgKyAxXSA9IFxuICAgICAgICBoZWlnaHQgLyAyICogKGJhc2VQb2ludHNbaSAqIDIgKyAxXSAqIGNvcyBcbiAgICAgICAgICArIGJhc2VQb2ludHNbaSAqIDJdICogc2luKTtcbiAgICAgIFxuICAgICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDJdICs9IGNlbnRlclg7XG4gICAgICB0cmFuc2Zvcm1lZFBvaW50c1tpICogMiArIDFdICs9IGNlbnRlclk7XG4gICAgfVxuICAgIFxuICAgIC8vIEFzc3VtZSB0cmFuc2Zvcm1lZFBvaW50cy5sZW5ndGggPiAwLCBhbmQgY2hlY2sgaWYgaW50ZXJzZWN0aW9uIGlzIHBvc3NpYmxlXG4gICAgdmFyIG1pblRyYW5zZm9ybWVkWCA9IHRyYW5zZm9ybWVkUG9pbnRzWzBdO1xuICAgIHZhciBtYXhUcmFuc2Zvcm1lZFggPSB0cmFuc2Zvcm1lZFBvaW50c1swXTtcbiAgICB2YXIgbWluVHJhbnNmb3JtZWRZID0gdHJhbnNmb3JtZWRQb2ludHNbMV07XG4gICAgdmFyIG1heFRyYW5zZm9ybWVkWSA9IHRyYW5zZm9ybWVkUG9pbnRzWzFdO1xuICAgIFxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdHJhbnNmb3JtZWRQb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICBpZiAodHJhbnNmb3JtZWRQb2ludHNbaSAqIDJdID4gbWF4VHJhbnNmb3JtZWRYKSB7XG4gICAgICAgIG1heFRyYW5zZm9ybWVkWCA9IHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyXTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyXSA8IG1pblRyYW5zZm9ybWVkWCkge1xuICAgICAgICBtaW5UcmFuc2Zvcm1lZFggPSB0cmFuc2Zvcm1lZFBvaW50c1tpICogMl07XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmICh0cmFuc2Zvcm1lZFBvaW50c1tpICogMiArIDFdID4gbWF4VHJhbnNmb3JtZWRZKSB7XG4gICAgICAgIG1heFRyYW5zZm9ybWVkWSA9IHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyICsgMV07XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmICh0cmFuc2Zvcm1lZFBvaW50c1tpICogMiArIDFdIDwgbWluVHJhbnNmb3JtZWRZKSB7XG4gICAgICAgIG1pblRyYW5zZm9ybWVkWSA9IHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyICsgMV07XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmICh4MiA8IG1pblRyYW5zZm9ybWVkWCAtIHBhZGRpbmcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHgxID4gbWF4VHJhbnNmb3JtZWRYICsgcGFkZGluZykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoeTIgPCBtaW5UcmFuc2Zvcm1lZFkgLSBwYWRkaW5nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIGlmICh5MSA+IG1heFRyYW5zZm9ybWVkWSArIHBhZGRpbmcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ29udGludWUgY2hlY2tpbmcgd2l0aCBwYWRkaW5nLWNvcnJlY3RlZCBwb2ludHNcbiAgICB2YXIgcG9pbnRzO1xuICAgIFxuICAgIGlmIChwYWRkaW5nID4gMCkge1xuICAgICAgdmFyIGV4cGFuZGVkTGluZVNldCA9ICQkLm1hdGguZXhwYW5kUG9seWdvbihcbiAgICAgICAgdHJhbnNmb3JtZWRQb2ludHMsXG4gICAgICAgIC1wYWRkaW5nKTtcbiAgICAgIFxuICAgICAgcG9pbnRzID0gJCQubWF0aC5qb2luTGluZXMoZXhwYW5kZWRMaW5lU2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnRzID0gdHJhbnNmb3JtZWRQb2ludHM7XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGlmIGEgcG9pbnQgaXMgaW4gYm94XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1lZFBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgIGlmICh4MSA8PSB0cmFuc2Zvcm1lZFBvaW50c1tpICogMl1cbiAgICAgICAgICAmJiB0cmFuc2Zvcm1lZFBvaW50c1tpICogMl0gPD0geDIpIHtcbiAgICAgICAgXG4gICAgICAgIGlmICh5MSA8PSB0cmFuc2Zvcm1lZFBvaW50c1tpICogMiArIDFdXG4gICAgICAgICAgICAmJiB0cmFuc2Zvcm1lZFBvaW50c1tpICogMiArIDFdIDw9IHkyKSB7XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgXG4gICAgLy8gQ2hlY2sgZm9yIGludGVyc2VjdGlvbnMgd2l0aCB0aGUgc2VsZWN0aW9uIGJveFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgXG4gICAgICB2YXIgY3VycmVudFggPSBwb2ludHNbaSAqIDJdO1xuICAgICAgdmFyIGN1cnJlbnRZID0gcG9pbnRzW2kgKiAyICsgMV07XG4gICAgICB2YXIgbmV4dFg7XG4gICAgICB2YXIgbmV4dFk7XG4gICAgICBcbiAgICAgIGlmIChpIDwgcG9pbnRzLmxlbmd0aCAvIDIgLSAxKSB7XG4gICAgICAgIG5leHRYID0gcG9pbnRzWyhpICsgMSkgKiAyXTtcbiAgICAgICAgbmV4dFkgPSBwb2ludHNbKGkgKyAxKSAqIDIgKyAxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRYID0gcG9pbnRzWzBdO1xuICAgICAgICBuZXh0WSA9IHBvaW50c1sxXTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSW50ZXJzZWN0aW9uIHdpdGggdG9wIG9mIHNlbGVjdGlvbiBib3hcbiAgICAgIGlmICgkJC5tYXRoLmZpbml0ZUxpbmVzSW50ZXJzZWN0KGN1cnJlbnRYLCBjdXJyZW50WSwgbmV4dFgsIG5leHRZLCB4MSwgeTEsIHgyLCB5MSwgZmFsc2UpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEludGVyc2VjdGlvbiB3aXRoIGJvdHRvbSBvZiBzZWxlY3Rpb24gYm94XG4gICAgICBpZiAoJCQubWF0aC5maW5pdGVMaW5lc0ludGVyc2VjdChjdXJyZW50WCwgY3VycmVudFksIG5leHRYLCBuZXh0WSwgeDEsIHkyLCB4MiwgeTIsIGZhbHNlKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBJbnRlcnNlY3Rpb24gd2l0aCBsZWZ0IHNpZGUgb2Ygc2VsZWN0aW9uIGJveFxuICAgICAgaWYgKCQkLm1hdGguZmluaXRlTGluZXNJbnRlcnNlY3QoY3VycmVudFgsIGN1cnJlbnRZLCBuZXh0WCwgbmV4dFksIHgxLCB5MSwgeDEsIHkyLCBmYWxzZSkubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSW50ZXJzZWN0aW9uIHdpdGggcmlnaHQgc2lkZSBvZiBzZWxlY3Rpb24gYm94XG4gICAgICBpZiAoJCQubWF0aC5maW5pdGVMaW5lc0ludGVyc2VjdChjdXJyZW50WCwgY3VycmVudFksIG5leHRYLCBuZXh0WSwgeDIsIHkxLCB4MiwgeTIsIGZhbHNlKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgLy8gQ2hlY2sgaWYgYm94IGNvcm5lciBpbiB0aGUgcG9seWdvblxuICAgIGlmICgkJC5tYXRoLnBvaW50SW5zaWRlUG9seWdvbihcbiAgICAgIHgxLCB5MSwgcG9pbnRzLCAwLCAwLCAxLCAxLCAwLCBkaXJlY3Rpb24pKSB7XG4gICAgICBcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoJCQubWF0aC5wb2ludEluc2lkZVBvbHlnb24oXG4gICAgICB4MSwgeTIsIHBvaW50cywgMCwgMCwgMSwgMSwgMCwgZGlyZWN0aW9uKSkge1xuICAgICAgXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCQkLm1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKFxuICAgICAgeDIsIHkyLCBwb2ludHMsIDAsIDAsIDEsIDEsIDAsIGRpcmVjdGlvbikpIHtcbiAgICAgICBcbiAgICAgIHJldHVybiB0cnVlOyBcbiAgICB9IGVsc2UgaWYgKCQkLm1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKFxuICAgICAgeDIsIHkxLCBwb2ludHMsIDAsIDAsIDEsIDEsIDAsIGRpcmVjdGlvbikpIHtcbiAgICAgIFxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgICovXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBcbiAgJCQubWF0aC5wb2x5Z29uSW50ZXJzZWN0TGluZSA9IGZ1bmN0aW9uKFxuICAgIHgsIHksIGJhc2VQb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcpIHtcbiAgICBcbiAgICB2YXIgaW50ZXJzZWN0aW9ucyA9IFtdO1xuICAgIHZhciBpbnRlcnNlY3Rpb247XG4gICAgXG4gICAgdmFyIHRyYW5zZm9ybWVkUG9pbnRzID0gbmV3IEFycmF5KGJhc2VQb2ludHMubGVuZ3RoKTtcbiAgICBcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybWVkUG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDJdID0gYmFzZVBvaW50c1tpICogMl0gKiB3aWR0aCArIGNlbnRlclg7XG4gICAgICB0cmFuc2Zvcm1lZFBvaW50c1tpICogMiArIDFdID0gYmFzZVBvaW50c1tpICogMiArIDFdICogaGVpZ2h0ICsgY2VudGVyWTtcbiAgICB9XG4gICAgXG4gICAgdmFyIHBvaW50cztcbiAgICBcbiAgICBpZiAocGFkZGluZyA+IDApIHtcbiAgICAgIHZhciBleHBhbmRlZExpbmVTZXQgPSAkJC5tYXRoLmV4cGFuZFBvbHlnb24oXG4gICAgICAgIHRyYW5zZm9ybWVkUG9pbnRzLFxuICAgICAgICAtcGFkZGluZyk7XG4gICAgICBcbiAgICAgIHBvaW50cyA9ICQkLm1hdGguam9pbkxpbmVzKGV4cGFuZGVkTGluZVNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50cyA9IHRyYW5zZm9ybWVkUG9pbnRzO1xuICAgIH1cbiAgICAvLyB2YXIgcG9pbnRzID0gdHJhbnNmb3JtZWRQb2ludHM7XG4gICAgXG4gICAgdmFyIGN1cnJlbnRYLCBjdXJyZW50WSwgbmV4dFgsIG5leHRZO1xuICAgIFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgIFxuICAgICAgY3VycmVudFggPSBwb2ludHNbaSAqIDJdO1xuICAgICAgY3VycmVudFkgPSBwb2ludHNbaSAqIDIgKyAxXTtcblxuICAgICAgaWYgKGkgPCBwb2ludHMubGVuZ3RoIC8gMiAtIDEpIHtcbiAgICAgICAgbmV4dFggPSBwb2ludHNbKGkgKyAxKSAqIDJdOyBcbiAgICAgICAgbmV4dFkgPSBwb2ludHNbKGkgKyAxKSAqIDIgKyAxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRYID0gcG9pbnRzWzBdOyBcbiAgICAgICAgbmV4dFkgPSBwb2ludHNbMV07XG4gICAgICB9XG4gICAgICBcbiAgICAgIGludGVyc2VjdGlvbiA9IHRoaXMuZmluaXRlTGluZXNJbnRlcnNlY3QoXG4gICAgICAgIHgsIHksIGNlbnRlclgsIGNlbnRlclksXG4gICAgICAgIGN1cnJlbnRYLCBjdXJyZW50WSxcbiAgICAgICAgbmV4dFgsIG5leHRZKTtcbiAgICAgIFxuICAgICAgaWYgKGludGVyc2VjdGlvbi5sZW5ndGggIT09IDApIHtcbiAgICAgICAgaW50ZXJzZWN0aW9ucy5wdXNoKGludGVyc2VjdGlvblswXSwgaW50ZXJzZWN0aW9uWzFdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG4gIH07XG4gIFxuICAkJC5tYXRoLnNob3J0ZW5JbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihcbiAgICBpbnRlcnNlY3Rpb24sIG9mZnNldCwgYW1vdW50KSB7XG4gICAgXG4gICAgdmFyIGRpc3AgPSBbaW50ZXJzZWN0aW9uWzBdIC0gb2Zmc2V0WzBdLCBpbnRlcnNlY3Rpb25bMV0gLSBvZmZzZXRbMV1dO1xuICAgIFxuICAgIHZhciBsZW5ndGggPSBNYXRoLnNxcnQoZGlzcFswXSAqIGRpc3BbMF0gKyBkaXNwWzFdICogZGlzcFsxXSk7XG4gICAgXG4gICAgdmFyIGxlblJhdGlvID0gKGxlbmd0aCAtIGFtb3VudCkgLyBsZW5ndGg7XG4gICAgXG4gICAgaWYgKGxlblJhdGlvIDwgMCkge1xuICAgICAgbGVuUmF0aW8gPSAwLjAwMDAxO1xuICAgIH1cblxuICAgIHJldHVybiBbb2Zmc2V0WzBdICsgbGVuUmF0aW8gKiBkaXNwWzBdLCBvZmZzZXRbMV0gKyBsZW5SYXRpbyAqIGRpc3BbMV1dO1xuICB9O1xuXG4gICQkLm1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlID0gZnVuY3Rpb24oc2lkZXMsIHJvdGF0aW9uUmFkaWFucykge1xuICAgIHZhciBwb2ludHMgPSAkJC5tYXRoLmdlbmVyYXRlVW5pdE5nb25Qb2ludHMoc2lkZXMsIHJvdGF0aW9uUmFkaWFucyk7XG4gICAgcG9pbnRzID0gJCQubWF0aC5maXRQb2x5Z29uVG9TcXVhcmUocG9pbnRzKTtcblxuICAgIHJldHVybiBwb2ludHM7XG4gIH07XG5cbiAgJCQubWF0aC5maXRQb2x5Z29uVG9TcXVhcmUgPSBmdW5jdGlvbihwb2ludHMpe1xuICAgIHZhciB4LCB5O1xuICAgIHZhciBzaWRlcyA9IHBvaW50cy5sZW5ndGgvMjtcbiAgICB2YXIgbWluWCA9IEluZmluaXR5LCBtaW5ZID0gSW5maW5pdHksIG1heFggPSAtSW5maW5pdHksIG1heFkgPSAtSW5maW5pdHk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZGVzOyBpKyspIHtcbiAgICAgIHggPSBwb2ludHNbMiAqIGldO1xuICAgICAgeSA9IHBvaW50c1syICogaSArIDFdO1xuXG4gICAgICBtaW5YID0gTWF0aC5taW4oIG1pblgsIHggKTtcbiAgICAgIG1heFggPSBNYXRoLm1heCggbWF4WCwgeCApO1xuICAgICAgbWluWSA9IE1hdGgubWluKCBtaW5ZLCB5ICk7XG4gICAgICBtYXhZID0gTWF0aC5tYXgoIG1heFksIHkgKTtcbiAgICB9XG4gICAgXG4gICAgLy8gc3RyZXRjaCBmYWN0b3JzXG4gICAgdmFyIHN4ID0gMiAvIChtYXhYIC0gbWluWCk7XG4gICAgdmFyIHN5ID0gMiAvIChtYXhZIC0gbWluWSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZGVzOyBpKyspe1xuICAgICAgeCA9IHBvaW50c1syICogaV0gPSBwb2ludHNbMiAqIGldICogc3g7XG4gICAgICB5ID0gcG9pbnRzWzIgKiBpICsgMV0gPSBwb2ludHNbMiAqIGkgKyAxXSAqIHN5O1xuXG4gICAgICBtaW5YID0gTWF0aC5taW4oIG1pblgsIHggKTtcbiAgICAgIG1heFggPSBNYXRoLm1heCggbWF4WCwgeCApO1xuICAgICAgbWluWSA9IE1hdGgubWluKCBtaW5ZLCB5ICk7XG4gICAgICBtYXhZID0gTWF0aC5tYXgoIG1heFksIHkgKTtcbiAgICB9XG5cbiAgICBpZiggbWluWSA8IC0xICl7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZGVzOyBpKyspe1xuICAgICAgICB5ID0gcG9pbnRzWzIgKiBpICsgMV0gPSBwb2ludHNbMiAqIGkgKyAxXSArICgtMSAtbWluWSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBwb2ludHM7XG4gIH07XG5cbiAgJCQubWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzID0gZnVuY3Rpb24oc2lkZXMsIHJvdGF0aW9uUmFkaWFucykge1xuICAgIFxuICAgIHZhciBpbmNyZW1lbnQgPSAxLjAgLyBzaWRlcyAqIDIgKiBNYXRoLlBJO1xuICAgIHZhciBzdGFydEFuZ2xlID0gc2lkZXMgJSAyID09PSAwID8gXG4gICAgICBNYXRoLlBJIC8gMi4wICsgaW5jcmVtZW50IC8gMi4wIDogTWF0aC5QSSAvIDIuMDtcbi8vICAgIGNvbnNvbGUubG9nKG5vZGVTaGFwZXNbJ3NxdWFyZSddKTtcbiAgICBzdGFydEFuZ2xlICs9IHJvdGF0aW9uUmFkaWFucztcbiAgICBcbiAgICB2YXIgcG9pbnRzID0gbmV3IEFycmF5KHNpZGVzICogMik7XG5cbiAgICB2YXIgY3VycmVudEFuZ2xlLCB4LCB5O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lkZXM7IGkrKykge1xuICAgICAgY3VycmVudEFuZ2xlID0gaSAqIGluY3JlbWVudCArIHN0YXJ0QW5nbGU7XG4gICAgICBcbiAgICAgIHggPSBwb2ludHNbMiAqIGldID0gTWF0aC5jb3MoY3VycmVudEFuZ2xlKTsvLyAqICgxICsgaS8yKTtcbiAgICAgIHkgPSBwb2ludHNbMiAqIGkgKyAxXSA9IE1hdGguc2luKC1jdXJyZW50QW5nbGUpOy8vICAqICgxICsgaS8yKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHBvaW50cztcbiAgfTtcblxuICAkJC5tYXRoLmdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgIFxuICAgIC8vIFNldCB0aGUgZGVmYXVsdCByYWRpdXMsIHVubGVzcyBoYWxmIG9mIHdpZHRoIG9yIGhlaWdodCBpcyBzbWFsbGVyIHRoYW4gZGVmYXVsdFxuICAgIHJldHVybiBNYXRoLm1pbih3aWR0aCAvIDQsIGhlaWdodCAvIDQsIDgpO1xuICB9O1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gIC8vIHJlZ2lzdGVyZWQgZXh0ZW5zaW9ucyB0byBjeXRvc2NhcGUsIGluZGV4ZWQgYnkgbmFtZVxuICB2YXIgZXh0ZW5zaW9ucyA9IHt9O1xuICAkJC5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgXG4gIC8vIHJlZ2lzdGVyZWQgbW9kdWxlcyBmb3IgZXh0ZW5zaW9ucywgaW5kZXhlZCBieSBuYW1lXG4gIHZhciBtb2R1bGVzID0ge307XG4gICQkLm1vZHVsZXMgPSBtb2R1bGVzO1xuICBcbiAgZnVuY3Rpb24gc2V0RXh0ZW5zaW9uKHR5cGUsIG5hbWUsIHJlZ2lzdHJhbnQpe1xuICAgIHZhciBpbXBsID0ge307XG4gICAgaW1wbFtuYW1lXSA9IHJlZ2lzdHJhbnQ7XG4gICAgXG4gICAgc3dpdGNoKCB0eXBlICl7XG4gICAgY2FzZSAnY29yZSc6XG4gICAgY2FzZSAnY29sbGVjdGlvbic6XG4gICAgICAkJC5mblt0eXBlXSggaW1wbCApO1xuICAgIH1cbiAgICBcbiAgICAvLyBmaWxsIGluIG1pc3NpbmcgbGF5b3V0IGZ1bmN0aW9ucyBpbiB0aGUgcHJvdG90eXBlXG4gICAgaWYoIHR5cGUgPT09ICdsYXlvdXQnICl7XG4gICAgICB2YXIgbGF5b3V0UHJvdG8gPSByZWdpc3RyYW50LnByb3RvdHlwZTtcbiAgICAgIHZhciBvcHRMYXlvdXRGbnMgPSBbXTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBvcHRMYXlvdXRGbnMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGZuTmFtZSA9IG9wdExheW91dEZuc1tpXTtcblxuICAgICAgICBsYXlvdXRQcm90b1tmbk5hbWVdID0gbGF5b3V0UHJvdG9bZm5OYW1lXSB8fCBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfTtcbiAgICAgIH1cblxuICAgICAgLy8gZWl0aGVyIC5zdGFydCgpIG9yIC5ydW4oKSBpcyBkZWZpbmVkLCBzbyBhdXRvZ2VuIHRoZSBvdGhlclxuICAgICAgaWYoIGxheW91dFByb3RvLnN0YXJ0ICYmICFsYXlvdXRQcm90by5ydW4gKXtcbiAgICAgICAgbGF5b3V0UHJvdG8ucnVuID0gZnVuY3Rpb24oKXsgdGhpcy5zdGFydCgpOyByZXR1cm4gdGhpczsgfTtcbiAgICAgIH0gZWxzZSBpZiggIWxheW91dFByb3RvLnN0YXJ0ICYmIGxheW91dFByb3RvLnJ1biApe1xuICAgICAgICBsYXlvdXRQcm90by5zdGFydCA9IGZ1bmN0aW9uKCl7IHRoaXMucnVuKCk7IHJldHVybiB0aGlzOyB9O1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiggIWxheW91dFByb3RvLnN0b3AgKXtcbiAgICAgICAgbGF5b3V0UHJvdG8uc3RvcCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgdmFyIG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYoIG9wdHMgJiYgb3B0cy5hbmltYXRlICl7XG4gICAgICAgICAgICBvcHRzLmVsZXMuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgbGF5b3V0UHJvdG8ub24gPSAkJC5kZWZpbmUub24oeyBsYXlvdXQ6IHRydWUgfSk7XG4gICAgICBsYXlvdXRQcm90by5vbmUgPSAkJC5kZWZpbmUub24oeyBsYXlvdXQ6IHRydWUsIHVuYmluZFNlbGZPblRyaWdnZXI6IHRydWUgfSk7XG4gICAgICBsYXlvdXRQcm90by5vbmNlID0gJCQuZGVmaW5lLm9uKHsgbGF5b3V0OiB0cnVlLCB1bmJpbmRBbGxCaW5kZXJzT25UcmlnZ2VyOiB0cnVlIH0pO1xuICAgICAgbGF5b3V0UHJvdG8ub2ZmID0gJCQuZGVmaW5lLm9mZih7IGxheW91dDogdHJ1ZSB9KTtcbiAgICAgIGxheW91dFByb3RvLnRyaWdnZXIgPSAkJC5kZWZpbmUudHJpZ2dlcih7IGxheW91dDogdHJ1ZSB9KTtcblxuICAgICAgJCQuZGVmaW5lLmV2ZW50QWxpYXNlc09uKCBsYXlvdXRQcm90byApO1xuICAgIH1cblxuICAgIHJldHVybiAkJC51dGlsLnNldE1hcCh7XG4gICAgICBtYXA6IGV4dGVuc2lvbnMsXG4gICAgICBrZXlzOiBbIHR5cGUsIG5hbWUgXSxcbiAgICAgIHZhbHVlOiByZWdpc3RyYW50XG4gICAgfSk7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIGdldEV4dGVuc2lvbih0eXBlLCBuYW1lKXtcbiAgICByZXR1cm4gJCQudXRpbC5nZXRNYXAoe1xuICAgICAgbWFwOiBleHRlbnNpb25zLFxuICAgICAga2V5czogWyB0eXBlLCBuYW1lIF1cbiAgICB9KTtcbiAgfVxuICBcbiAgZnVuY3Rpb24gc2V0TW9kdWxlKHR5cGUsIG5hbWUsIG1vZHVsZVR5cGUsIG1vZHVsZU5hbWUsIHJlZ2lzdHJhbnQpe1xuICAgIHJldHVybiAkJC51dGlsLnNldE1hcCh7XG4gICAgICBtYXA6IG1vZHVsZXMsXG4gICAgICBrZXlzOiBbIHR5cGUsIG5hbWUsIG1vZHVsZVR5cGUsIG1vZHVsZU5hbWUgXSxcbiAgICAgIHZhbHVlOiByZWdpc3RyYW50XG4gICAgfSk7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIGdldE1vZHVsZSh0eXBlLCBuYW1lLCBtb2R1bGVUeXBlLCBtb2R1bGVOYW1lKXtcbiAgICByZXR1cm4gJCQudXRpbC5nZXRNYXAoe1xuICAgICAgbWFwOiBtb2R1bGVzLFxuICAgICAga2V5czogWyB0eXBlLCBuYW1lLCBtb2R1bGVUeXBlLCBtb2R1bGVOYW1lIF1cbiAgICB9KTtcbiAgfVxuICBcbiAgJCQuZXh0ZW5zaW9uID0gZnVuY3Rpb24oKXtcbiAgICAvLyBlLmcuICQkLmV4dGVuc2lvbigncmVuZGVyZXInLCAnc3ZnJylcbiAgICBpZiggYXJndW1lbnRzLmxlbmd0aCA9PSAyICl7XG4gICAgICByZXR1cm4gZ2V0RXh0ZW5zaW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFxuICAgIC8vIGUuZy4gJCQuZXh0ZW5zaW9uKCdyZW5kZXJlcicsICdzdmcnLCB7IC4uLiB9KVxuICAgIGVsc2UgaWYoIGFyZ3VtZW50cy5sZW5ndGggPT0gMyApe1xuICAgICAgcmV0dXJuIHNldEV4dGVuc2lvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBcbiAgICAvLyBlLmcuICQkLmV4dGVuc2lvbigncmVuZGVyZXInLCAnc3ZnJywgJ25vZGVTaGFwZScsICdlbGxpcHNlJylcbiAgICBlbHNlIGlmKCBhcmd1bWVudHMubGVuZ3RoID09IDQgKXtcbiAgICAgIHJldHVybiBnZXRNb2R1bGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgXG4gICAgLy8gZS5nLiAkJC5leHRlbnNpb24oJ3JlbmRlcmVyJywgJ3N2ZycsICdub2RlU2hhcGUnLCAnZWxsaXBzZScsIHsgLi4uIH0pXG4gICAgZWxzZSBpZiggYXJndW1lbnRzLmxlbmd0aCA9PSA1ICl7XG4gICAgICByZXR1cm4gc2V0TW9kdWxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFxuICAgIGVsc2Uge1xuICAgICAgJCQudXRpbC5lcnJvcignSW52YWxpZCBleHRlbnNpb24gYWNjZXNzIHN5bnRheCcpO1xuICAgIH1cbiAgXG4gIH07XG4gIFxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQsICQkKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgaWYoICEkICl7IHJldHVybjsgfSAvLyBubyBqcXVlcnkgPT4gZG9uJ3QgbmVlZCB0aGlzXG5cbiAgdmFyIGN5UmVnID0gZnVuY3Rpb24oICRlbGUgKXtcbiAgICB2YXIgZCA9ICRlbGVbMF0uX2N5cmVnID0gJGVsZVswXS5fY3lyZWcgfHwge307XG5cbiAgICByZXR1cm4gZDtcbiAgfTtcblxuICAvLyBhbGxvdyBjYWxscyBvbiBhIGpRdWVyeSBzZWxlY3RvciBieSBwcm94eWluZyBjYWxscyB0byAkLmN5dG9zY2FwZVxuICAvLyBlLmcuICQoXCIjZm9vXCIpLmN5dG9zY2FwZShvcHRpb25zKSA9PiAkLmN5dG9zY2FwZShvcHRpb25zKSBvbiAjZm9vXG4gICQuZm4uY3l0b3NjYXBlID0gZnVuY3Rpb24ob3B0cyl7XG4gICAgdmFyICR0aGlzID0gJCh0aGlzKTtcblxuICAgIC8vIGdldCBvYmplY3RcbiAgICBpZiggb3B0cyA9PT0gJ2dldCcgKXtcbiAgICAgIHJldHVybiBjeVJlZyggJHRoaXMgKS5jeTtcbiAgICB9XG4gICAgXG4gICAgLy8gYmluZCB0byByZWFkeVxuICAgIGVsc2UgaWYoICQkLmlzLmZuKG9wdHMpICl7XG5cbiAgICAgIHZhciByZWFkeSA9IG9wdHM7XG4gICAgICB2YXIgY3kgPSBjeVJlZyggJHRoaXMgKS5jeTtcbiAgICAgIFxuICAgICAgaWYoIGN5ICYmIGN5LmlzUmVhZHkoKSApeyAvLyBhbHJlYWR5IHJlYWR5IHNvIGp1c3QgdHJpZ2dlciBub3dcbiAgICAgICAgY3kudHJpZ2dlcigncmVhZHknLCBbXSwgcmVhZHkpO1xuXG4gICAgICB9IGVsc2UgeyAvLyBub3QgeWV0IHJlYWR5LCBzbyBhZGQgdG8gcmVhZGllcyBsaXN0XG4gICAgICAgIHZhciBkYXRhID0gY3lSZWcoICR0aGlzICk7XG4gICAgICAgIHZhciByZWFkaWVzID0gZGF0YS5yZWFkaWVzID0gZGF0YS5yZWFkaWVzIHx8IFtdO1xuXG4gICAgICAgIHJlYWRpZXMucHVzaCggcmVhZHkgKTtcbiAgICAgIH0gXG4gICAgICBcbiAgICB9XG4gICAgXG4gICAgLy8gcHJveHkgdG8gY3JlYXRlIGluc3RhbmNlXG4gICAgZWxzZSBpZiggJCQuaXMucGxhaW5PYmplY3Qob3B0cykgKXtcbiAgICAgIHJldHVybiAkdGhpcy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBvcHRpb25zID0gJC5leHRlbmQoe30sIG9wdHMsIHtcbiAgICAgICAgICBjb250YWluZXI6ICQodGhpcylbMF1cbiAgICAgICAgfSk7XG4gICAgICBcbiAgICAgICAgY3l0b3NjYXBlKG9wdGlvbnMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBcbiAgLy8gYWxsb3cgYWNjZXNzIHRvIHRoZSBnbG9iYWwgY3l0b3NjYXBlIG9iamVjdCB1bmRlciBqcXVlcnkgZm9yIGxlZ2FjeSByZWFzb25zXG4gICQuY3l0b3NjYXBlID0gY3l0b3NjYXBlO1xuICBcbiAgLy8gdXNlIHNob3J0IGFsaWFzIChjeSkgaWYgbm90IGFscmVhZHkgZGVmaW5lZFxuICBpZiggJC5mbi5jeSA9PSBudWxsICYmICQuY3kgPT0gbnVsbCApe1xuICAgICQuZm4uY3kgPSAkLmZuLmN5dG9zY2FwZTtcbiAgICAkLmN5ID0gJC5jeXRvc2NhcGU7XG4gIH1cbiAgXG59KSh0eXBlb2YgalF1ZXJ5ICE9PSAndW5kZWZpbmVkJyA/IGpRdWVyeSA6IG51bGwgLCBjeXRvc2NhcGUpO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgLy8gc2hhbWVsZXNzbHkgdGFrZW4gZnJvbSBqUXVlcnlcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvYmxvYi9tYXN0ZXIvc3JjL2V2ZW50LmpzXG5cbiAgJCQuRXZlbnQgPSBmdW5jdGlvbiggc3JjLCBwcm9wcyApIHtcbiAgICAvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcbiAgICBpZiAoICEodGhpcyBpbnN0YW5jZW9mICQkLkV2ZW50KSApIHtcbiAgICAgIHJldHVybiBuZXcgJCQuRXZlbnQoIHNyYywgcHJvcHMgKTtcbiAgICB9XG5cbiAgICAvLyBFdmVudCBvYmplY3RcbiAgICBpZiAoIHNyYyAmJiBzcmMudHlwZSApIHtcbiAgICAgIHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcbiAgICAgIHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG4gICAgICAvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuICAgICAgLy8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG4gICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9ICggc3JjLmRlZmF1bHRQcmV2ZW50ZWQgKSA/IHJldHVyblRydWUgOiByZXR1cm5GYWxzZTtcblxuICAgIC8vIEV2ZW50IHR5cGVcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50eXBlID0gc3JjO1xuICAgIH1cblxuICAgIC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG4gICAgaWYgKCBwcm9wcyApIHtcbiAgICAgIC8vICQkLnV0aWwuZXh0ZW5kKCB0aGlzLCBwcm9wcyApO1xuXG4gICAgICAvLyBtb3JlIGVmZmljaWVudCB0byBtYW51YWxseSBjb3B5IGZpZWxkcyB3ZSB1c2VcbiAgICAgIHRoaXMudHlwZSA9IHByb3BzLnR5cGUgIT09IHVuZGVmaW5lZCA/IHByb3BzLnR5cGUgOiB0aGlzLnR5cGU7XG4gICAgICB0aGlzLmN5ID0gcHJvcHMuY3k7XG4gICAgICB0aGlzLmN5VGFyZ2V0ID0gcHJvcHMuY3lUYXJnZXQ7XG4gICAgICB0aGlzLmN5UG9zaXRpb24gPSBwcm9wcy5jeVBvc2l0aW9uO1xuICAgICAgdGhpcy5jeVJlbmRlcmVkUG9zaXRpb24gPSBwcm9wcy5jeVJlbmRlcmVkUG9zaXRpb247XG4gICAgICB0aGlzLm5hbWVzcGFjZSA9IHByb3BzLm5hbWVzcGFjZTtcbiAgICAgIHRoaXMubGF5b3V0ID0gcHJvcHMubGF5b3V0O1xuICAgICAgdGhpcy5kYXRhID0gcHJvcHMuZGF0YTtcbiAgICAgIHRoaXMubWVzc2FnZSA9IHByb3BzLm1lc3NhZ2U7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcbiAgICB0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8ICtuZXcgRGF0ZSgpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4gIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxuICAkJC5FdmVudC5wcm90b3R5cGUgPSB7XG4gICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuXG4gICAgICB2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcbiAgICAgIGlmICggIWUgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgcHJldmVudERlZmF1bHQgZXhpc3RzIHJ1biBpdCBvbiB0aGUgb3JpZ2luYWwgZXZlbnRcbiAgICAgIGlmICggZS5wcmV2ZW50RGVmYXVsdCApIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG4gICAgICB2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcbiAgICAgIGlmICggIWUgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHN0b3BQcm9wYWdhdGlvbiBleGlzdHMgcnVuIGl0IG9uIHRoZSBvcmlnaW5hbCBldmVudFxuICAgICAgaWYgKCBlLnN0b3BQcm9wYWdhdGlvbiApIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcbiAgICAgIHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSxcbiAgICBpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuICAgIGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcbiAgICBpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2VcbiAgfTtcbiAgXG4gIFxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIHVzZSB0aGlzIG1vZHVsZSB0byBjaGVycnkgcGljayBmdW5jdGlvbnMgaW50byB5b3VyIHByb3RvdHlwZVxuICAvLyAodXNlZnVsIGZvciBmdW5jdGlvbnMgc2hhcmVkIGJldHdlZW4gdGhlIGNvcmUgYW5kIGNvbGxlY3Rpb25zLCBmb3IgZXhhbXBsZSlcblxuICAvLyBlLmcuXG4gIC8vICQkLmZuLmNvbGxlY3Rpb24oe1xuICAvLyAgIGZvbzogJCQuZGVmaW5lLmZvbyh7IC8qIHBhcmFtcy4uLiAqLyB9KVxuICAvLyB9KTtcblxuICAkJC5kZWZpbmUgPSB7XG5cbiAgICAvLyBhY2Nlc3MgZGF0YSBmaWVsZFxuICAgIGRhdGE6IGZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgICAgIHZhciBkZWZhdWx0cyA9IHsgXG4gICAgICAgIGZpZWxkOiAnZGF0YScsXG4gICAgICAgIGJpbmRpbmdFdmVudDogJ2RhdGEnLFxuICAgICAgICBhbGxvd0JpbmRpbmc6IGZhbHNlLFxuICAgICAgICBhbGxvd1NldHRpbmc6IGZhbHNlLFxuICAgICAgICBhbGxvd0dldHRpbmc6IGZhbHNlLFxuICAgICAgICBzZXR0aW5nRXZlbnQ6ICdkYXRhJyxcbiAgICAgICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IGZhbHNlLFxuICAgICAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgICAgIGltbXV0YWJsZUtleXM6IHt9LCAvLyBrZXkgPT4gdHJ1ZSBpZiBpbW11dGFibGVcbiAgICAgICAgdXBkYXRlU3R5bGU6IGZhbHNlLFxuICAgICAgICBvblNldDogZnVuY3Rpb24oIHNlbGYgKXt9LFxuICAgICAgICBjYW5TZXQ6IGZ1bmN0aW9uKCBzZWxmICl7IHJldHVybiB0cnVlOyB9XG4gICAgICB9O1xuICAgICAgcGFyYW1zID0gJCQudXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBwYXJhbXMpO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gZGF0YUltcGwoIG5hbWUsIHZhbHVlICl7XG4gICAgICAgIHZhciBwID0gcGFyYW1zO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFtzZWxmXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG4gICAgICAgIHZhciBzaW5nbGUgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmWzBdIDogc2VsZjtcblxuICAgICAgICAvLyAuZGF0YSgnZm9vJywgLi4uKVxuICAgICAgICBpZiggJCQuaXMuc3RyaW5nKG5hbWUpICl7IC8vIHNldCBvciBnZXQgcHJvcGVydHlcblxuICAgICAgICAgIC8vIC5kYXRhKCdmb28nKVxuICAgICAgICAgIGlmKCBwLmFsbG93R2V0dGluZyAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICl7IC8vIGdldFxuXG4gICAgICAgICAgICB2YXIgcmV0O1xuICAgICAgICAgICAgaWYoIHNpbmdsZSApe1xuICAgICAgICAgICAgICByZXQgPSBzaW5nbGUuX3ByaXZhdGVbIHAuZmllbGQgXVsgbmFtZSBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyAuZGF0YSgnZm9vJywgJ2JhcicpXG4gICAgICAgICAgfSBlbHNlIGlmKCBwLmFsbG93U2V0dGluZyAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkICkgeyAvLyBzZXRcbiAgICAgICAgICAgIHZhciB2YWxpZCA9ICFwLmltbXV0YWJsZUtleXNbbmFtZV07XG4gICAgICAgICAgICBpZiggdmFsaWQgKXtcbiAgICAgICAgICAgICAgZm9yKCB2YXIgaSA9IDAsIGwgPSBhbGwubGVuZ3RoOyBpIDwgbDsgaSsrICl7XG4gICAgICAgICAgICAgICAgaWYoIHAuY2FuU2V0KCBhbGxbaV0gKSApe1xuICAgICAgICAgICAgICAgICAgYWxsW2ldLl9wcml2YXRlWyBwLmZpZWxkIF1bIG5hbWUgXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIHVwZGF0ZSBtYXBwZXJzIGlmIGFza2VkXG4gICAgICAgICAgICAgIGlmKCBwLnVwZGF0ZVN0eWxlICl7IHNlbGYudXBkYXRlU3R5bGUoKTsgfVxuXG4gICAgICAgICAgICAgIC8vIGNhbGwgb25TZXQgY2FsbGJhY2tcbiAgICAgICAgICAgICAgcC5vblNldCggc2VsZiApO1xuXG4gICAgICAgICAgICAgIGlmKCBwLnNldHRpbmdUcmlnZ2Vyc0V2ZW50ICl7XG4gICAgICAgICAgICAgICAgc2VsZlsgcC50cmlnZ2VyRm5OYW1lIF0oIHAuc2V0dGluZ0V2ZW50ICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgLy8gLmRhdGEoeyAnZm9vJzogJ2JhcicgfSlcbiAgICAgICAgfSBlbHNlIGlmKCBwLmFsbG93U2V0dGluZyAmJiAkJC5pcy5wbGFpbk9iamVjdChuYW1lKSApeyAvLyBleHRlbmRcbiAgICAgICAgICB2YXIgb2JqID0gbmFtZTtcbiAgICAgICAgICB2YXIgaywgdjtcblxuICAgICAgICAgIGZvciggayBpbiBvYmogKXtcbiAgICAgICAgICAgIHYgPSBvYmpbIGsgXTtcblxuICAgICAgICAgICAgdmFyIHZhbGlkID0gIXAuaW1tdXRhYmxlS2V5c1trXTtcbiAgICAgICAgICAgIGlmKCB2YWxpZCApe1xuICAgICAgICAgICAgICBmb3IoIHZhciBpID0gMCwgbCA9IGFsbC5sZW5ndGg7IGkgPCBsOyBpKysgKXtcbiAgICAgICAgICAgICAgICBpZiggcC5jYW5TZXQoIGFsbFtpXSApICl7XG4gICAgICAgICAgICAgICAgICBhbGxbaV0uX3ByaXZhdGVbIHAuZmllbGQgXVsgayBdID0gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gdXBkYXRlIG1hcHBlcnMgaWYgYXNrZWRcbiAgICAgICAgICBpZiggcC51cGRhdGVTdHlsZSApeyBzZWxmLnVwZGF0ZVN0eWxlKCk7IH1cblxuICAgICAgICAgIC8vIGNhbGwgb25TZXQgY2FsbGJhY2tcbiAgICAgICAgICBwLm9uU2V0KCBzZWxmICk7XG5cbiAgICAgICAgICBpZiggcC5zZXR0aW5nVHJpZ2dlcnNFdmVudCApe1xuICAgICAgICAgICAgc2VsZlsgcC50cmlnZ2VyRm5OYW1lIF0oIHAuc2V0dGluZ0V2ZW50ICk7XG4gICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gLmRhdGEoZnVuY3Rpb24oKXsgLi4uIH0pXG4gICAgICAgIH0gZWxzZSBpZiggcC5hbGxvd0JpbmRpbmcgJiYgJCQuaXMuZm4obmFtZSkgKXsgLy8gYmluZCB0byBldmVudFxuICAgICAgICAgIHZhciBmbiA9IG5hbWU7XG4gICAgICAgICAgc2VsZi5iaW5kKCBwLmJpbmRpbmdFdmVudCwgZm4gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIC5kYXRhKClcbiAgICAgICAgfSBlbHNlIGlmKCBwLmFsbG93R2V0dGluZyAmJiBuYW1lID09PSB1bmRlZmluZWQgKXsgLy8gZ2V0IHdob2xlIG9iamVjdFxuICAgICAgICAgIHZhciByZXQ7XG4gICAgICAgICAgaWYoIHNpbmdsZSApe1xuICAgICAgICAgICAgcmV0ID0gc2luZ2xlLl9wcml2YXRlWyBwLmZpZWxkIF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZjsgLy8gbWFpbnRhaW4gY2hhaW5hYmlsaXR5XG4gICAgICB9OyAvLyBmdW5jdGlvblxuICAgIH0sIC8vIGRhdGFcblxuICAgIC8vIHJlbW92ZSBkYXRhIGZpZWxkXG4gICAgcmVtb3ZlRGF0YTogZnVuY3Rpb24oIHBhcmFtcyApe1xuICAgICAgdmFyIGRlZmF1bHRzID0geyBcbiAgICAgICAgZmllbGQ6ICdkYXRhJyxcbiAgICAgICAgZXZlbnQ6ICdkYXRhJyxcbiAgICAgICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgICAgICB0cmlnZ2VyRXZlbnQ6IGZhbHNlLFxuICAgICAgICBpbW11dGFibGVLZXlzOiB7fSAvLyBrZXkgPT4gdHJ1ZSBpZiBpbW11dGFibGVcbiAgICAgIH07XG4gICAgICBwYXJhbXMgPSAkJC51dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIHBhcmFtcyk7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiByZW1vdmVEYXRhSW1wbCggbmFtZXMgKXtcbiAgICAgICAgdmFyIHAgPSBwYXJhbXM7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgICAgXG4gICAgICAgIC8vIC5yZW1vdmVEYXRhKCdmb28gYmFyJylcbiAgICAgICAgaWYoICQkLmlzLnN0cmluZyhuYW1lcykgKXsgLy8gdGhlbiBnZXQgdGhlIGxpc3Qgb2Yga2V5cywgYW5kIGRlbGV0ZSB0aGVtXG4gICAgICAgICAgdmFyIGtleXMgPSBuYW1lcy5zcGxpdCgvXFxzKy8pO1xuICAgICAgICAgIHZhciBsID0ga2V5cy5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGw7IGkrKyApeyAvLyBkZWxldGUgZWFjaCBub24tZW1wdHkga2V5XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGlmKCAkJC5pcy5lbXB0eVN0cmluZyhrZXkpICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICAgIHZhciB2YWxpZCA9ICFwLmltbXV0YWJsZUtleXNbIGtleSBdOyAvLyBub3QgdmFsaWQgaWYgaW1tdXRhYmxlXG4gICAgICAgICAgICBpZiggdmFsaWQgKXtcbiAgICAgICAgICAgICAgZm9yKCB2YXIgaV9hID0gMCwgbF9hID0gYWxsLmxlbmd0aDsgaV9hIDwgbF9hOyBpX2ErKyApe1xuICAgICAgICAgICAgICAgIGFsbFsgaV9hIF0uX3ByaXZhdGVbIHAuZmllbGQgXVsga2V5IF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggcC50cmlnZ2VyRXZlbnQgKXtcbiAgICAgICAgICAgIHNlbGZbIHAudHJpZ2dlckZuTmFtZSBdKCBwLmV2ZW50ICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIC8vIC5yZW1vdmVEYXRhKClcbiAgICAgICAgfSBlbHNlIGlmKCBuYW1lcyA9PT0gdW5kZWZpbmVkICl7IC8vIHRoZW4gZGVsZXRlIGFsbCBrZXlzXG5cbiAgICAgICAgICBmb3IoIHZhciBpX2EgPSAwLCBsX2EgPSBhbGwubGVuZ3RoOyBpX2EgPCBsX2E7IGlfYSsrICl7XG4gICAgICAgICAgICB2YXIgX3ByaXZhdGVGaWVsZHMgPSBhbGxbIGlfYSBdLl9wcml2YXRlWyBwLmZpZWxkIF07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZvciggdmFyIGtleSBpbiBfcHJpdmF0ZUZpZWxkcyApe1xuICAgICAgICAgICAgICB2YXIgdmFsaWRLZXlUb0RlbGV0ZSA9ICFwLmltbXV0YWJsZUtleXNbIGtleSBdO1xuXG4gICAgICAgICAgICAgIGlmKCB2YWxpZEtleVRvRGVsZXRlICl7XG4gICAgICAgICAgICAgICAgX3ByaXZhdGVGaWVsZHNbIGtleSBdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIHAudHJpZ2dlckV2ZW50ICl7XG4gICAgICAgICAgICBzZWxmWyBwLnRyaWdnZXJGbk5hbWUgXSggcC5ldmVudCApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmOyAvLyBtYWludGFpbiBjaGFpbmluZ1xuICAgICAgfTsgLy8gZnVuY3Rpb25cbiAgICB9LCAvLyByZW1vdmVEYXRhXG5cbiAgICAvLyBldmVudCBmdW5jdGlvbiByZXVzYWJsZSBzdHVmZlxuICAgIGV2ZW50OiB7XG4gICAgICByZWdleDogLyhcXHcrKShcXC5cXHcrKT8vLCAvLyByZWdleCBmb3IgbWF0Y2hpbmcgZXZlbnQgc3RyaW5ncyAoZS5nLiBcImNsaWNrLm5hbWVzcGFjZVwiKVxuICAgICAgb3B0aW9uYWxUeXBlUmVnZXg6IC8oXFx3Kyk/KFxcLlxcdyspPy8sXG4gICAgICBmYWxzZUNhbGxiYWNrOiBmdW5jdGlvbigpeyByZXR1cm4gZmFsc2U7IH1cbiAgICB9LFxuXG4gICAgLy8gZXZlbnQgYmluZGluZ1xuICAgIG9uOiBmdW5jdGlvbiggcGFyYW1zICl7XG4gICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgIHVuYmluZFNlbGZPblRyaWdnZXI6IGZhbHNlLFxuICAgICAgICB1bmJpbmRBbGxCaW5kZXJzT25UcmlnZ2VyOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIHBhcmFtcyA9ICQkLnV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgcGFyYW1zKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIG9uSW1wbChldmVudHMsIHNlbGVjdG9yLCBkYXRhLCBjYWxsYmFjayl7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgICAgdmFyIGV2ZW50c0lzU3RyaW5nID0gJCQuaXMuc3RyaW5nKGV2ZW50cyk7XG4gICAgICAgIHZhciBwID0gcGFyYW1zO1xuXG4gICAgICAgIGlmKCAkJC5pcy5wbGFpbk9iamVjdChzZWxlY3RvcikgKXsgLy8gc2VsZWN0b3IgaXMgYWN0dWFsbHkgZGF0YVxuICAgICAgICAgIGNhbGxiYWNrID0gZGF0YTtcbiAgICAgICAgICBkYXRhID0gc2VsZWN0b3I7XG4gICAgICAgICAgc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSBpZiggJCQuaXMuZm4oc2VsZWN0b3IpIHx8IHNlbGVjdG9yID09PSBmYWxzZSApeyAvLyBzZWxlY3RvciBpcyBhY3R1YWxseSBjYWxsYmFja1xuICAgICAgICAgIGNhbGxiYWNrID0gc2VsZWN0b3I7XG4gICAgICAgICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBzZWxlY3RvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCAkJC5pcy5mbihkYXRhKSB8fCBkYXRhID09PSBmYWxzZSApeyAvLyBkYXRhIGlzIGFjdHVhbGx5IGNhbGxiYWNrXG4gICAgICAgICAgY2FsbGJhY2sgPSBkYXRhO1xuICAgICAgICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGVyZSBpc24ndCBhIGNhbGxiYWNrLCB3ZSBjYW4ndCByZWFsbHkgZG8gYW55dGhpbmdcbiAgICAgICAgLy8gKGNhbid0IHNwZWFrIGZvciBtYXBwZWQgZXZlbnRzIGFyZyB2ZXJzaW9uKVxuICAgICAgICBpZiggISgkJC5pcy5mbihjYWxsYmFjaykgfHwgY2FsbGJhY2sgPT09IGZhbHNlKSAmJiBldmVudHNJc1N0cmluZyApe1xuICAgICAgICAgIHJldHVybiBzZWxmOyAvLyBtYWludGFpbiBjaGFpbmluZ1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIGV2ZW50c0lzU3RyaW5nICl7IC8vIHRoZW4gY29udmVydCB0byBtYXBcbiAgICAgICAgICB2YXIgbWFwID0ge307XG4gICAgICAgICAgbWFwWyBldmVudHMgXSA9IGNhbGxiYWNrO1xuICAgICAgICAgIGV2ZW50cyA9IG1hcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciggdmFyIGV2dHMgaW4gZXZlbnRzICl7XG4gICAgICAgICAgY2FsbGJhY2sgPSBldmVudHNbZXZ0c107XG4gICAgICAgICAgaWYoIGNhbGxiYWNrID09PSBmYWxzZSApe1xuICAgICAgICAgICAgY2FsbGJhY2sgPSAkJC5kZWZpbmUuZXZlbnQuZmFsc2VDYWxsYmFjaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggISQkLmlzLmZuKGNhbGxiYWNrKSApeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgZXZ0cyA9IGV2dHMuc3BsaXQoL1xccysvKTtcbiAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGV2dHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgIHZhciBldnQgPSBldnRzW2ldO1xuICAgICAgICAgICAgaWYoICQkLmlzLmVtcHR5U3RyaW5nKGV2dCkgKXsgY29udGludWU7IH1cblxuICAgICAgICAgICAgdmFyIG1hdGNoID0gZXZ0Lm1hdGNoKCAkJC5kZWZpbmUuZXZlbnQucmVnZXggKTsgLy8gdHlwZVsubmFtZXNwYWNlXVxuXG4gICAgICAgICAgICBpZiggbWF0Y2ggKXtcbiAgICAgICAgICAgICAgdmFyIHR5cGUgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgICAgdmFyIG5hbWVzcGFjZSA9IG1hdGNoWzJdID8gbWF0Y2hbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjaywgLy8gY2FsbGJhY2sgdG8gcnVuXG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YSwgLy8gZXh0cmEgZGF0YSBpbiBldmVudE9iai5kYXRhXG4gICAgICAgICAgICAgICAgZGVsZWdhdGVkOiBzZWxlY3RvciA/IHRydWUgOiBmYWxzZSwgLy8gd2hldGhlciB0aGUgZXZ0IGlzIGRlbGVnYXRlZFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBzZWxlY3RvciwgLy8gdGhlIHNlbGVjdG9yIHRvIG1hdGNoIGZvciBkZWxlZ2F0ZWQgZXZlbnRzXG4gICAgICAgICAgICAgICAgc2VsT2JqOiBuZXcgJCQuU2VsZWN0b3Ioc2VsZWN0b3IpLCAvLyBjYWNoZWQgc2VsZWN0b3Igb2JqZWN0IHRvIHNhdmUgcmVidWlsZGluZ1xuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsIC8vIHRoZSBldmVudCB0eXBlIChlLmcuICdjbGljaycpXG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2UsIC8vIHRoZSBldmVudCBuYW1lc3BhY2UgKGUuZy4gXCIuZm9vXCIpXG4gICAgICAgICAgICAgICAgdW5iaW5kU2VsZk9uVHJpZ2dlcjogcC51bmJpbmRTZWxmT25UcmlnZ2VyLFxuICAgICAgICAgICAgICAgIHVuYmluZEFsbEJpbmRlcnNPblRyaWdnZXI6IHAudW5iaW5kQWxsQmluZGVyc09uVHJpZ2dlcixcbiAgICAgICAgICAgICAgICBiaW5kZXJzOiBhbGwgLy8gd2hvIGJvdW5kIHRvZ2V0aGVyXG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBhbGwubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICAgICAgICB2YXIgX3AgPSBhbGxbal0uX3ByaXZhdGU7XG5cbiAgICAgICAgICAgICAgICBfcC5saXN0ZW5lcnMgPSBfcC5saXN0ZW5lcnMgfHwgW107XG4gICAgICAgICAgICAgICAgX3AubGlzdGVuZXJzLnB1c2goIGxpc3RlbmVyICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIGZvciBldmVudHMgYXJyYXlcbiAgICAgICAgfSAvLyBmb3IgZXZlbnRzIG1hcFxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHNlbGY7IC8vIG1haW50YWluIGNoYWluaW5nXG4gICAgICB9OyAvLyBmdW5jdGlvblxuICAgIH0sIC8vIG9uXG5cbiAgICBldmVudEFsaWFzZXNPbjogZnVuY3Rpb24oIHByb3RvICl7XG4gICAgICB2YXIgcCA9IHByb3RvO1xuXG4gICAgICBwLmFkZExpc3RlbmVyID0gcC5saXN0ZW4gPSBwLmJpbmQgPSBwLm9uO1xuICAgICAgcC5yZW1vdmVMaXN0ZW5lciA9IHAudW5saXN0ZW4gPSBwLnVuYmluZCA9IHAub2ZmO1xuICAgICAgcC5lbWl0ID0gcC50cmlnZ2VyO1xuXG4gICAgICAvLyB0aGlzIGlzIGp1c3QgYSB3cmFwcGVyIGFsaWFzIG9mIC5vbigpXG4gICAgICBwLnBvbiA9IHAucHJvbWlzZU9uID0gZnVuY3Rpb24oIGV2ZW50cywgc2VsZWN0b3IgKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMsIDAgKTtcblxuICAgICAgICByZXR1cm4gbmV3ICQkLlByb21pc2UoZnVuY3Rpb24oIHJlc29sdmUsIHJlamVjdCApe1xuICAgICAgICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uKCBlICl7XG4gICAgICAgICAgICBzZWxmLm9mZi5hcHBseSggc2VsZiwgb2ZmQXJncyApO1xuXG4gICAgICAgICAgICByZXNvbHZlKCBlICk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciBvbkFyZ3MgPSBhcmdzLmNvbmNhdChbIGNhbGxiYWNrIF0pO1xuICAgICAgICAgIHZhciBvZmZBcmdzID0gb25BcmdzLmNvbmNhdChbXSk7XG5cbiAgICAgICAgICBzZWxmLm9uLmFwcGx5KCBzZWxmLCBvbkFyZ3MgKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICBvZmY6IGZ1bmN0aW9uIG9mZkltcGwoIHBhcmFtcyApe1xuICAgICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgfTtcbiAgICAgIHBhcmFtcyA9ICQkLnV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgcGFyYW1zKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGV2ZW50cywgc2VsZWN0b3IsIGNhbGxiYWNrKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgICB2YXIgZXZlbnRzSXNTdHJpbmcgPSAkJC5pcy5zdHJpbmcoZXZlbnRzKTtcblxuICAgICAgICBpZiggYXJndW1lbnRzLmxlbmd0aCA9PT0gMCApeyAvLyB0aGVuIHVuYmluZCBhbGxcblxuICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICBhbGxbaV0uX3ByaXZhdGUubGlzdGVuZXJzID0gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHNlbGY7IC8vIG1haW50YWluIGNoYWluaW5nXG4gICAgICAgIH1cblxuICAgICAgICBpZiggJCQuaXMuZm4oc2VsZWN0b3IpIHx8IHNlbGVjdG9yID09PSBmYWxzZSApeyAvLyBzZWxlY3RvciBpcyBhY3R1YWxseSBjYWxsYmFja1xuICAgICAgICAgIGNhbGxiYWNrID0gc2VsZWN0b3I7XG4gICAgICAgICAgc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggZXZlbnRzSXNTdHJpbmcgKXsgLy8gdGhlbiBjb252ZXJ0IHRvIG1hcFxuICAgICAgICAgIHZhciBtYXAgPSB7fTtcbiAgICAgICAgICBtYXBbIGV2ZW50cyBdID0gY2FsbGJhY2s7XG4gICAgICAgICAgZXZlbnRzID0gbWFwO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKCB2YXIgZXZ0cyBpbiBldmVudHMgKXtcbiAgICAgICAgICBjYWxsYmFjayA9IGV2ZW50c1tldnRzXTtcblxuICAgICAgICAgIGlmKCBjYWxsYmFjayA9PT0gZmFsc2UgKXtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gJCQuZGVmaW5lLmV2ZW50LmZhbHNlQ2FsbGJhY2s7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXZ0cyA9IGV2dHMuc3BsaXQoL1xccysvKTtcbiAgICAgICAgICBmb3IoIHZhciBoID0gMDsgaCA8IGV2dHMubGVuZ3RoOyBoKysgKXtcbiAgICAgICAgICAgIHZhciBldnQgPSBldnRzW2hdO1xuICAgICAgICAgICAgaWYoICQkLmlzLmVtcHR5U3RyaW5nKGV2dCkgKXsgY29udGludWU7IH1cblxuICAgICAgICAgICAgdmFyIG1hdGNoID0gZXZ0Lm1hdGNoKCAkJC5kZWZpbmUuZXZlbnQub3B0aW9uYWxUeXBlUmVnZXggKTsgLy8gW3R5cGVdWy5uYW1lc3BhY2VdXG4gICAgICAgICAgICBpZiggbWF0Y2ggKXtcbiAgICAgICAgICAgICAgdmFyIHR5cGUgPSBtYXRjaFsxXSA/IG1hdGNoWzFdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB2YXIgbmFtZXNwYWNlID0gbWF0Y2hbMl0gPyBtYXRjaFsyXSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKyApeyAvL1xuICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSBhbGxbaV0uX3ByaXZhdGUubGlzdGVuZXJzID0gYWxsW2ldLl9wcml2YXRlLmxpc3RlbmVycyB8fCBbXTtcblxuICAgICAgICAgICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgbGlzdGVuZXJzLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbal07XG4gICAgICAgICAgICAgICAgICB2YXIgbnNNYXRjaGVzID0gIW5hbWVzcGFjZSB8fCBuYW1lc3BhY2UgPT09IGxpc3RlbmVyLm5hbWVzcGFjZTtcbiAgICAgICAgICAgICAgICAgIHZhciB0eXBlTWF0Y2hlcyA9ICF0eXBlIHx8IGxpc3RlbmVyLnR5cGUgPT09IHR5cGU7XG4gICAgICAgICAgICAgICAgICB2YXIgY2JNYXRjaGVzID0gIWNhbGxiYWNrIHx8IGNhbGxiYWNrID09PSBsaXN0ZW5lci5jYWxsYmFjaztcbiAgICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lck1hdGNoZXMgPSBuc01hdGNoZXMgJiYgdHlwZU1hdGNoZXMgJiYgY2JNYXRjaGVzO1xuXG4gICAgICAgICAgICAgICAgICAvLyBkZWxldGUgbGlzdGVuZXIgaWYgaXQgbWF0Y2hlc1xuICAgICAgICAgICAgICAgICAgaWYoIGxpc3RlbmVyTWF0Y2hlcyApe1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBmb3IgbGlzdGVuZXJzXG4gICAgICAgICAgICAgIH0gLy8gZm9yIGFsbFxuICAgICAgICAgICAgfSAvLyBpZiBtYXRjaFxuICAgICAgICAgIH0gLy8gZm9yIGV2ZW50cyBhcnJheVxuXG4gICAgICAgIH0gLy8gZm9yIGV2ZW50cyBtYXBcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBzZWxmOyAvLyBtYWludGFpbiBjaGFpbmluZ1xuICAgICAgfTsgLy8gZnVuY3Rpb25cbiAgICB9LCAvLyBvZmZcblxuICAgIHRyaWdnZXI6IGZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgICAgIHZhciBkZWZhdWx0cyA9IHt9O1xuICAgICAgcGFyYW1zID0gJCQudXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBwYXJhbXMpO1xuICAgICAgXG4gICAgICByZXR1cm4gZnVuY3Rpb24gdHJpZ2dlckltcGwoZXZlbnRzLCBleHRyYVBhcmFtcywgZm5Ub1RyaWdnZXIpe1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFtzZWxmXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG4gICAgICAgIHZhciBldmVudHNJc1N0cmluZyA9ICQkLmlzLnN0cmluZyhldmVudHMpO1xuICAgICAgICB2YXIgZXZlbnRzSXNPYmplY3QgPSAkJC5pcy5wbGFpbk9iamVjdChldmVudHMpO1xuICAgICAgICB2YXIgZXZlbnRzSXNFdmVudCA9ICQkLmlzLmV2ZW50KGV2ZW50cyk7XG4gICAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgKCAkJC5pcy5jb3JlKHRoaXMpID8gdGhpcyA6IG51bGwgKTtcbiAgICAgICAgdmFyIGhhc0NvbXBvdW5kcyA9IGN5ID8gY3kuaGFzQ29tcG91bmROb2RlcygpIDogZmFsc2U7XG5cbiAgICAgICAgaWYoIGV2ZW50c0lzU3RyaW5nICl7IC8vIHRoZW4gbWFrZSBhIHBsYWluIGV2ZW50IG9iamVjdCBmb3IgZWFjaCBldmVudCBuYW1lXG4gICAgICAgICAgdmFyIGV2dHMgPSBldmVudHMuc3BsaXQoL1xccysvKTtcbiAgICAgICAgICBldmVudHMgPSBbXTtcblxuICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZXZ0cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgdmFyIGV2dCA9IGV2dHNbaV07XG4gICAgICAgICAgICBpZiggJCQuaXMuZW1wdHlTdHJpbmcoZXZ0KSApeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBldnQubWF0Y2goICQkLmRlZmluZS5ldmVudC5yZWdleCApOyAvLyB0eXBlWy5uYW1lc3BhY2VdXG4gICAgICAgICAgICB2YXIgdHlwZSA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgdmFyIG5hbWVzcGFjZSA9IG1hdGNoWzJdID8gbWF0Y2hbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIGV2ZW50cy5wdXNoKCB7XG4gICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlXG4gICAgICAgICAgICB9ICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYoIGV2ZW50c0lzT2JqZWN0ICl7IC8vIHB1dCBpbiBsZW5ndGggMSBhcnJheVxuICAgICAgICAgIHZhciBldmVudEFyZ09iaiA9IGV2ZW50cztcblxuICAgICAgICAgIGV2ZW50cyA9IFsgZXZlbnRBcmdPYmogXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBleHRyYVBhcmFtcyApe1xuICAgICAgICAgIGlmKCAhJCQuaXMuYXJyYXkoZXh0cmFQYXJhbXMpICl7IC8vIG1ha2Ugc3VyZSBleHRyYSBwYXJhbXMgYXJlIGluIGFuIGFycmF5IGlmIHNwZWNpZmllZFxuICAgICAgICAgICAgZXh0cmFQYXJhbXMgPSBbIGV4dHJhUGFyYW1zIF07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgeyAvLyBvdGhlcndpc2UsIHdlJ3ZlIGdvdCBub3RoaW5nXG4gICAgICAgICAgZXh0cmFQYXJhbXMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrICl7IC8vIHRyaWdnZXIgZWFjaCBldmVudCBpbiBvcmRlclxuICAgICAgICAgIHZhciBldnRPYmogPSBldmVudHNbaV07XG4gICAgICAgICAgXG4gICAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBhbGwubGVuZ3RoOyBqKysgKXsgLy8gZm9yIGVhY2hcbiAgICAgICAgICAgIHZhciB0cmlnZ2VyZXIgPSBhbGxbal07XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gdHJpZ2dlcmVyLl9wcml2YXRlLmxpc3RlbmVycyA9IHRyaWdnZXJlci5fcHJpdmF0ZS5saXN0ZW5lcnMgfHwgW107XG4gICAgICAgICAgICB2YXIgdHJpZ2dlcmVySXNFbGVtZW50ID0gJCQuaXMuZWxlbWVudCh0cmlnZ2VyZXIpO1xuICAgICAgICAgICAgdmFyIGJ1YmJsZVVwID0gdHJpZ2dlcmVySXNFbGVtZW50IHx8IHBhcmFtcy5sYXlvdXQ7XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgZXZlbnQgZm9yIHRoaXMgZWxlbWVudCBmcm9tIHRoZSBldmVudCBvYmplY3RcbiAgICAgICAgICAgIHZhciBldnQ7XG5cbiAgICAgICAgICAgIGlmKCBldmVudHNJc0V2ZW50ICl7IC8vIHRoZW4ganVzdCBnZXQgdGhlIG9iamVjdFxuICAgICAgICAgICAgICBldnQgPSBldnRPYmo7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBldnQuY3lUYXJnZXQgPSBldnQuY3lUYXJnZXQgfHwgdHJpZ2dlcmVyO1xuICAgICAgICAgICAgICBldnQuY3kgPSBldnQuY3kgfHwgY3k7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIHRoZW4gd2UgaGF2ZSB0byBtYWtlIG9uZVxuICAgICAgICAgICAgICBldnQgPSBuZXcgJCQuRXZlbnQoIGV2dE9iaiwge1xuICAgICAgICAgICAgICAgIGN5VGFyZ2V0OiB0cmlnZ2VyZXIsXG4gICAgICAgICAgICAgICAgY3k6IGN5LFxuICAgICAgICAgICAgICAgIG5hbWVzcGFjZTogZXZ0T2JqLm5hbWVzcGFjZVxuICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIGEgbGF5b3V0IHdhcyBzcGVjaWZpZWQsIHRoZW4gcHV0IGl0IGluIHRoZSB0eXBlZCBldmVudFxuICAgICAgICAgICAgaWYoIGV2dE9iai5sYXlvdXQgKXtcbiAgICAgICAgICAgICAgZXZ0LmxheW91dCA9IGV2dE9iai5sYXlvdXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRyaWdnZXJlZCBieSBsYXlvdXQsIHB1dCBpbiBldmVudFxuICAgICAgICAgICAgaWYoIHBhcmFtcy5sYXlvdXQgKXtcbiAgICAgICAgICAgICAgZXZ0LmxheW91dCA9IHRyaWdnZXJlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY3JlYXRlIGEgcmVuZGVyZWQgcG9zaXRpb24gYmFzZWQgb24gdGhlIHBhc3NlZCBwb3NpdGlvblxuICAgICAgICAgICAgaWYoIGV2dC5jeVBvc2l0aW9uICl7XG4gICAgICAgICAgICAgIHZhciBwb3MgPSBldnQuY3lQb3NpdGlvbjtcbiAgICAgICAgICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgICAgICAgICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcblxuICAgICAgICAgICAgICBldnQuY3lSZW5kZXJlZFBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgIHg6IHBvcy54ICogem9vbSArIHBhbi54LFxuICAgICAgICAgICAgICAgIHk6IHBvcy55ICogem9vbSArIHBhbi55XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCBmblRvVHJpZ2dlciApeyAvLyB0aGVuIG92ZXJyaWRlIHRoZSBsaXN0ZW5lcnMgbGlzdCB3aXRoIGp1c3QgdGhlIG9uZSB3ZSBzcGVjaWZpZWRcbiAgICAgICAgICAgICAgbGlzdGVuZXJzID0gW3tcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2U6IGV2dC5uYW1lc3BhY2UsXG4gICAgICAgICAgICAgICAgdHlwZTogZXZ0LnR5cGUsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGZuVG9UcmlnZ2VyXG4gICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IoIHZhciBrID0gMDsgayA8IGxpc3RlbmVycy5sZW5ndGg7IGsrKyApeyAvLyBjaGVjayBlYWNoIGxpc3RlbmVyXG4gICAgICAgICAgICAgIHZhciBsaXMgPSBsaXN0ZW5lcnNba107XG4gICAgICAgICAgICAgIHZhciBuc01hdGNoZXMgPSAhbGlzLm5hbWVzcGFjZSB8fCBsaXMubmFtZXNwYWNlID09PSBldnQubmFtZXNwYWNlO1xuICAgICAgICAgICAgICB2YXIgdHlwZU1hdGNoZXMgPSBsaXMudHlwZSA9PT0gZXZ0LnR5cGU7XG4gICAgICAgICAgICAgIHZhciB0YXJnZXRNYXRjaGVzID0gbGlzLmRlbGVnYXRlZCA/ICggdHJpZ2dlcmVyICE9PSBldnQuY3lUYXJnZXQgJiYgJCQuaXMuZWxlbWVudChldnQuY3lUYXJnZXQpICYmIGxpcy5zZWxPYmoubWF0Y2hlcyhldnQuY3lUYXJnZXQpICkgOiAodHJ1ZSk7IC8vIHdlJ3JlIG5vdCBnb2luZyB0byB2YWxpZGF0ZSB0aGUgaGllcmFyY2h5OyB0aGF0J3MgdG9vIGV4cGVuc2l2ZVxuICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJNYXRjaGVzID0gbnNNYXRjaGVzICYmIHR5cGVNYXRjaGVzICYmIHRhcmdldE1hdGNoZXM7XG5cbiAgICAgICAgICAgICAgaWYoIGxpc3RlbmVyTWF0Y2hlcyApeyAvLyB0aGVuIHRyaWdnZXIgaXRcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFsgZXZ0IF07XG4gICAgICAgICAgICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KCBleHRyYVBhcmFtcyApOyAvLyBhZGQgZXh0cmEgcGFyYW1zIHRvIGFyZ3MgbGlzdFxuXG4gICAgICAgICAgICAgICAgaWYoIGxpcy5kYXRhICl7IC8vIGFkZCBvbiBkYXRhIHBsdWdnZWQgaW50byBiaW5kaW5nXG4gICAgICAgICAgICAgICAgICBldnQuZGF0YSA9IGxpcy5kYXRhO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIG9yIGNsZWFyIGl0IGluIGNhc2UgdGhlIGV2ZW50IG9iaiBpcyByZXVzZWRcbiAgICAgICAgICAgICAgICAgIGV2dC5kYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKCBsaXMudW5iaW5kU2VsZk9uVHJpZ2dlciB8fCBsaXMudW5iaW5kQWxsQmluZGVyc09uVHJpZ2dlciApeyAvLyB0aGVuIHJlbW92ZSBsaXN0ZW5lclxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShrLCAxKTtcbiAgICAgICAgICAgICAgICAgIGstLTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiggbGlzLnVuYmluZEFsbEJpbmRlcnNPblRyaWdnZXIgKXsgLy8gdGhlbiBkZWxldGUgdGhlIGxpc3RlbmVyIGZvciBhbGwgYmluZGVyc1xuICAgICAgICAgICAgICAgICAgdmFyIGJpbmRlcnMgPSBsaXMuYmluZGVycztcbiAgICAgICAgICAgICAgICAgIGZvciggdmFyIGwgPSAwOyBsIDwgYmluZGVycy5sZW5ndGg7IGwrKyApe1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmluZGVyID0gYmluZGVyc1tsXTtcbiAgICAgICAgICAgICAgICAgICAgaWYoICFiaW5kZXIgfHwgYmluZGVyID09PSB0cmlnZ2VyZXIgKXsgY29udGludWU7IH0gLy8gYWxyZWFkeSBoYW5kbGVkIHRyaWdnZXJlciBvciB3ZSBjYW4ndCBoYW5kbGUgaXRcblxuICAgICAgICAgICAgICAgICAgICB2YXIgYmluZGVyTGlzdGVuZXJzID0gYmluZGVyLl9wcml2YXRlLmxpc3RlbmVycztcbiAgICAgICAgICAgICAgICAgICAgZm9yKCB2YXIgbSA9IDA7IG0gPCBiaW5kZXJMaXN0ZW5lcnMubGVuZ3RoOyBtKysgKXtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgYmluZGVyTGlzdGVuZXIgPSBiaW5kZXJMaXN0ZW5lcnNbbV07XG5cbiAgICAgICAgICAgICAgICAgICAgICBpZiggYmluZGVyTGlzdGVuZXIgPT09IGxpcyApeyAvLyBkZWxldGUgbGlzdGVuZXIgZnJvbSBsaXN0XG4gICAgICAgICAgICAgICAgICAgICAgICBiaW5kZXJMaXN0ZW5lcnMuc3BsaWNlKG0sIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbS0tO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHJ1biB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IGxpcy5kZWxlZ2F0ZWQgPyBldnQuY3lUYXJnZXQgOiB0cmlnZ2VyZXI7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IGxpcy5jYWxsYmFjay5hcHBseSggY29udGV4dCwgYXJncyApO1xuXG4gICAgICAgICAgICAgICAgaWYoIHJldCA9PT0gZmFsc2UgfHwgZXZ0LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKXtcbiAgICAgICAgICAgICAgICAgIC8vIHRoZW4gZG9uJ3QgYnViYmxlXG4gICAgICAgICAgICAgICAgICBidWJibGVVcCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICBpZiggcmV0ID09PSBmYWxzZSApe1xuICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5pbmcgZmFsc2UgaXMgYSBzaG9ydGhhbmQgZm9yIHN0b3BwaW5nIHByb3BhZ2F0aW9uIGFuZCBwcmV2ZW50aW5nIHRoZSBkZWYuIGFjdGlvblxuICAgICAgICAgICAgICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSAvLyBpZiBsaXN0ZW5lciBtYXRjaGVzXG4gICAgICAgICAgICB9IC8vIGZvciBlYWNoIGxpc3RlbmVyXG5cbiAgICAgICAgICAgIC8vIGJ1YmJsZSB1cCBldmVudCBmb3IgZWxlbWVudHNcbiAgICAgICAgICAgIGlmKCBidWJibGVVcCApe1xuICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gaGFzQ29tcG91bmRzID8gdHJpZ2dlcmVyLl9wcml2YXRlLnBhcmVudCA6IG51bGw7XG4gICAgICAgICAgICAgIHZhciBoYXNQYXJlbnQgPSBwYXJlbnQgIT0gbnVsbCAmJiBwYXJlbnQubGVuZ3RoICE9PSAwO1xuXG4gICAgICAgICAgICAgIGlmKCBoYXNQYXJlbnQgKXsgLy8gdGhlbiBidWJibGUgdXAgdG8gcGFyZW50XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50WzBdO1xuICAgICAgICAgICAgICAgIHBhcmVudC50cmlnZ2VyKGV2dCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7IC8vIG90aGVyd2lzZSwgYnViYmxlIHVwIHRvIHRoZSBjb3JlXG4gICAgICAgICAgICAgICAgY3kudHJpZ2dlcihldnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IC8vIGZvciBlYWNoIG9mIGFsbFxuICAgICAgICB9IC8vIGZvciBlYWNoIGV2ZW50XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gc2VsZjsgLy8gbWFpbnRhaW4gY2hhaW5pbmdcbiAgICAgIH07IC8vIGZ1bmN0aW9uXG4gICAgfSwgLy8gdHJpZ2dlclxuXG5cbiAgICBhbmltYXRlZDogZnVuY3Rpb24oIGZuUGFyYW1zICl7XG4gICAgICB2YXIgZGVmYXVsdHMgPSB7fTtcbiAgICAgIGZuUGFyYW1zID0gJCQudXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBmblBhcmFtcyk7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiBhbmltYXRlZEltcGwoKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG5cbiAgICAgICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gZmFsc2U7IH1cblxuICAgICAgICB2YXIgZWxlID0gYWxsWzBdO1xuXG4gICAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgICByZXR1cm4gZWxlLl9wcml2YXRlLmFuaW1hdGlvbi5jdXJyZW50Lmxlbmd0aCA+IDA7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSwgLy8gYW5pbWF0ZWRcblxuICAgIGNsZWFyUXVldWU6IGZ1bmN0aW9uKCBmblBhcmFtcyApe1xuICAgICAgdmFyIGRlZmF1bHRzID0ge307XG4gICAgICBmblBhcmFtcyA9ICQkLnV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgZm5QYXJhbXMpO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gY2xlYXJRdWV1ZUltcGwoKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG5cbiAgICAgICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IGFsbFtpXTtcbiAgICAgICAgICBlbGUuX3ByaXZhdGUuYW5pbWF0aW9uLnF1ZXVlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgfSwgLy8gY2xlYXJRdWV1ZVxuXG4gICAgZGVsYXk6IGZ1bmN0aW9uKCBmblBhcmFtcyApe1xuICAgICAgdmFyIGRlZmF1bHRzID0ge307XG4gICAgICBmblBhcmFtcyA9ICQkLnV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgZm5QYXJhbXMpO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gZGVsYXlJbXBsKCB0aW1lLCBjb21wbGV0ZSApe1xuICAgICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG5cbiAgICAgICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgICAgIHRoaXMuYW5pbWF0ZSh7XG4gICAgICAgICAgZGVsYXk6IHRpbWVcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aW1lLFxuICAgICAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgfSwgLy8gZGVsYXlcblxuICAgIGFuaW1hdGU6IGZ1bmN0aW9uKCBmblBhcmFtcyApe1xuICAgICAgdmFyIGRlZmF1bHRzID0ge307XG4gICAgICBmblBhcmFtcyA9ICQkLnV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgZm5QYXJhbXMpO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gYW5pbWF0ZUltcGwoIHByb3BlcnRpZXMsIHBhcmFtcyApe1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFtzZWxmXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG4gICAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcbiAgICAgICAgdmFyIGlzQ29yZSA9ICFzZWxmSXNBcnJheUxpa2U7XG4gICAgICAgIHZhciBpc0VsZXMgPSAhaXNDb3JlO1xuXG4gICAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIHRoaXM7IH1cblxuICAgICAgICB2YXIgY2FsbFRpbWUgPSArbmV3IERhdGUoKTtcbiAgICAgICAgdmFyIHN0eWxlID0gY3kuc3R5bGUoKTtcbiAgICAgICAgdmFyIHE7XG4gICAgICAgIFxuICAgICAgICBpZiggcGFyYW1zID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICBwYXJhbXMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBwYXJhbXMuZHVyYXRpb24gPT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgIHBhcmFtcy5kdXJhdGlvbiA9IDQwMDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgc3dpdGNoKCBwYXJhbXMuZHVyYXRpb24gKXtcbiAgICAgICAgY2FzZSAnc2xvdyc6XG4gICAgICAgICAgcGFyYW1zLmR1cmF0aW9uID0gNjAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmYXN0JzpcbiAgICAgICAgICBwYXJhbXMuZHVyYXRpb24gPSAyMDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBwcm9wZXJ0aWVzRW1wdHkgPSB0cnVlO1xuICAgICAgICBpZiggcHJvcGVydGllcyApeyBmb3IoIHZhciBpIGluIHByb3BlcnRpZXMgKXtcbiAgICAgICAgICBwcm9wZXJ0aWVzRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSB9XG5cbiAgICAgICAgaWYoIHByb3BlcnRpZXNFbXB0eSApe1xuICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBub3RoaW5nIHRvIGFuaW1hdGVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBwcm9wZXJ0aWVzLmNzcyAmJiBpc0VsZXMgKXtcbiAgICAgICAgICBwcm9wZXJ0aWVzLmNzcyA9IHN0eWxlLmdldFZhbHVlU3R5bGUoIHByb3BlcnRpZXMuY3NzLCB7IGFycmF5OiB0cnVlIH0gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBwcm9wZXJ0aWVzLnJlbmRlcmVkUG9zaXRpb24gJiYgaXNFbGVzICl7XG4gICAgICAgICAgdmFyIHJwb3MgPSBwcm9wZXJ0aWVzLnJlbmRlcmVkUG9zaXRpb247XG4gICAgICAgICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgICAgICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuXG4gICAgICAgICAgcHJvcGVydGllcy5wb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIHg6ICggcnBvcy54IC0gcGFuLnggKSAvem9vbSxcbiAgICAgICAgICAgIHk6ICggcnBvcy55IC0gcGFuLnkgKSAvem9vbVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvdmVycmlkZSBwYW4gdy8gcGFuQnkgaWYgc2V0XG4gICAgICAgIGlmKCBwcm9wZXJ0aWVzLnBhbkJ5ICYmIGlzQ29yZSApe1xuICAgICAgICAgIHZhciBwYW5CeSA9IHByb3BlcnRpZXMucGFuQnk7XG4gICAgICAgICAgdmFyIGN5UGFuID0gY3kucGFuKCk7XG5cbiAgICAgICAgICBwcm9wZXJ0aWVzLnBhbiA9IHtcbiAgICAgICAgICAgIHg6IGN5UGFuLnggKyBwYW5CeS54LFxuICAgICAgICAgICAgeTogY3lQYW4ueSArIHBhbkJ5LnlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb3ZlcnJpZGUgcGFuIHcvIGNlbnRlciBpZiBzZXRcbiAgICAgICAgdmFyIGNlbnRlciA9IHByb3BlcnRpZXMuY2VudGVyIHx8IHByb3BlcnRpZXMuY2VudHJlO1xuICAgICAgICBpZiggY2VudGVyICYmIGlzQ29yZSApe1xuICAgICAgICAgIHZhciBjZW50ZXJQYW4gPSBjeS5nZXRDZW50ZXJQYW4oIGNlbnRlci5lbGVzLCBwcm9wZXJ0aWVzLnpvb20gKTtcblxuICAgICAgICAgIGlmKCBjZW50ZXJQYW4gKXtcbiAgICAgICAgICAgIHByb3BlcnRpZXMucGFuID0gY2VudGVyUGFuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG92ZXJyaWRlIHBhbiAmIHpvb20gdy8gZml0IGlmIHNldFxuICAgICAgICBpZiggcHJvcGVydGllcy5maXQgJiYgaXNDb3JlICl7XG4gICAgICAgICAgdmFyIGZpdCA9IHByb3BlcnRpZXMuZml0O1xuICAgICAgICAgIHZhciBmaXRWcCA9IGN5LmdldEZpdFZpZXdwb3J0KCBmaXQuZWxlcyB8fCBmaXQuYm91bmRpbmdCb3gsIGZpdC5wYWRkaW5nICk7XG5cbiAgICAgICAgICBpZiggZml0VnAgKXtcbiAgICAgICAgICAgIHByb3BlcnRpZXMucGFuID0gZml0VnAucGFuOyAvL3sgeDogZml0VnAucGFuLngsIHk6IGZpdFZwLnBhbi55IH07XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnpvb20gPSBmaXRWcC56b29tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IGFsbFtpXTtcbiAgICAgICAgIFxuICAgICAgICAgIGlmKCBlbGUuYW5pbWF0ZWQoKSAmJiAocGFyYW1zLnF1ZXVlID09PSB1bmRlZmluZWQgfHwgcGFyYW1zLnF1ZXVlKSApe1xuICAgICAgICAgICAgcSA9IGVsZS5fcHJpdmF0ZS5hbmltYXRpb24ucXVldWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHEgPSBlbGUuX3ByaXZhdGUuYW5pbWF0aW9uLmN1cnJlbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcS5wdXNoKHtcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG4gICAgICAgICAgICBkdXJhdGlvbjogcGFyYW1zLmR1cmF0aW9uLFxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgICBjYWxsVGltZTogY2FsbFRpbWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBpc0VsZXMgKXtcbiAgICAgICAgICBjeS5hZGRUb0FuaW1hdGlvblBvb2woIHRoaXMgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgICAgfTtcbiAgICB9LCAvLyBhbmltYXRlXG5cbiAgICBzdG9wOiBmdW5jdGlvbiggZm5QYXJhbXMgKXtcbiAgICAgIHZhciBkZWZhdWx0cyA9IHt9O1xuICAgICAgZm5QYXJhbXMgPSAkJC51dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIGZuUGFyYW1zKTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHN0b3BJbXBsKCBjbGVhclF1ZXVlLCBqdW1wVG9FbmQgKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG5cbiAgICAgICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IGFsbFtpXTtcbiAgICAgICAgICB2YXIgYW5pcyA9IGVsZS5fcHJpdmF0ZS5hbmltYXRpb24uY3VycmVudDtcblxuICAgICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgYW5pcy5sZW5ndGg7IGorKyApe1xuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IGFuaXNbal07ICAgIFxuICAgICAgICAgICAgaWYoIGp1bXBUb0VuZCApe1xuICAgICAgICAgICAgICAvLyBuZXh0IGl0ZXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uIGxvb3AsIHRoZSBhbmltYXRpb25cbiAgICAgICAgICAgICAgLy8gd2lsbCBnbyBzdHJhaWdodCB0byB0aGUgZW5kIGFuZCBiZSByZW1vdmVkXG4gICAgICAgICAgICAgIGFuaW1hdGlvbi5kdXJhdGlvbiA9IDA7IFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBjbGVhciB0aGUgcXVldWUgb2YgZnV0dXJlIGFuaW1hdGlvbnNcbiAgICAgICAgICBpZiggY2xlYXJRdWV1ZSApe1xuICAgICAgICAgICAgZWxlLl9wcml2YXRlLmFuaW1hdGlvbi5xdWV1ZSA9IFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCAhanVtcFRvRW5kICl7XG4gICAgICAgICAgICBlbGUuX3ByaXZhdGUuYW5pbWF0aW9uLmN1cnJlbnQgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIHdlIGhhdmUgdG8gbm90aWZ5ICh0aGUgYW5pbWF0aW9uIGxvb3AgZG9lc24ndCBkbyBpdCBmb3IgdXMgb24gYHN0b3BgKVxuICAgICAgICBjeS5ub3RpZnkoe1xuICAgICAgICAgIGNvbGxlY3Rpb246IHRoaXMsXG4gICAgICAgICAgdHlwZTogJ2RyYXcnXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgIH0gLy8gc3RvcFxuXG4gIH07IC8vIGRlZmluZVxuXG4gIFxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gICQkLmZuLnNlbGVjdG9yID0gZnVuY3Rpb24obWFwLCBvcHRpb25zKXtcbiAgICBmb3IoIHZhciBuYW1lIGluIG1hcCApe1xuICAgICAgdmFyIGZuID0gbWFwW25hbWVdO1xuICAgICAgJCQuU2VsZWN0b3IucHJvdG90eXBlWyBuYW1lIF0gPSBmbjtcbiAgICB9XG4gIH07XG5cbiAgJCQuU2VsZWN0b3IgPSBmdW5jdGlvbihvbmx5VGhpc0dyb3VwLCBzZWxlY3Rvcil7XG4gICAgXG4gICAgaWYoICEodGhpcyBpbnN0YW5jZW9mICQkLlNlbGVjdG9yKSApe1xuICAgICAgcmV0dXJuIG5ldyAkJC5TZWxlY3Rvcihvbmx5VGhpc0dyb3VwLCBzZWxlY3Rvcik7XG4gICAgfVxuICBcbiAgICBpZiggc2VsZWN0b3IgPT09IHVuZGVmaW5lZCAmJiBvbmx5VGhpc0dyb3VwICE9PSB1bmRlZmluZWQgKXtcbiAgICAgIHNlbGVjdG9yID0gb25seVRoaXNHcm91cDtcbiAgICAgIG9ubHlUaGlzR3JvdXAgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIFxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBcbiAgICBzZWxmLl9wcml2YXRlID0ge1xuICAgICAgc2VsZWN0b3JUZXh0OiBudWxsLFxuICAgICAgaW52YWxpZDogdHJ1ZVxuICAgIH07XG4gICAgXG4gICAgaWYoICFzZWxlY3RvciB8fCAoICQkLmlzLnN0cmluZyhzZWxlY3RvcikgJiYgc2VsZWN0b3IubWF0Y2goL15cXHMqJC8pICkgKXtcbiAgICAgIFxuICAgICAgaWYoIG9ubHlUaGlzR3JvdXAgPT0gbnVsbCApe1xuICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgc2VsZi5sZW5ndGggPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZlswXSA9IG5ld1F1ZXJ5KCk7XG4gICAgICAgIHNlbGZbMF0uZ3JvdXAgPSBvbmx5VGhpc0dyb3VwO1xuICAgICAgICBzZWxmLmxlbmd0aCA9IDE7XG4gICAgICB9XG4gICAgICAgICAgICAgIFxuICAgIH0gZWxzZSBpZiggJCQuaXMuZWxlbWVudCggc2VsZWN0b3IgKSApe1xuICAgICAgdmFyIGNvbGxlY3Rpb24gPSBuZXcgJCQuQ29sbGVjdGlvbihzZWxmLmN5KCksIFsgc2VsZWN0b3IgXSk7XG4gICAgICBcbiAgICAgIHNlbGZbMF0gPSBuZXdRdWVyeSgpO1xuICAgICAgc2VsZlswXS5jb2xsZWN0aW9uID0gY29sbGVjdGlvbjtcbiAgICAgIHNlbGYubGVuZ3RoID0gMTtcbiAgICAgIFxuICAgIH0gZWxzZSBpZiggJCQuaXMuY29sbGVjdGlvbiggc2VsZWN0b3IgKSApe1xuICAgICAgc2VsZlswXSA9IG5ld1F1ZXJ5KCk7XG4gICAgICBzZWxmWzBdLmNvbGxlY3Rpb24gPSBzZWxlY3RvcjtcbiAgICAgIHNlbGYubGVuZ3RoID0gMTtcbiAgICAgIFxuICAgIH0gZWxzZSBpZiggJCQuaXMuZm4oIHNlbGVjdG9yICkgKSB7XG4gICAgICBzZWxmWzBdID0gbmV3UXVlcnkoKTtcbiAgICAgIHNlbGZbMF0uZmlsdGVyID0gc2VsZWN0b3I7XG4gICAgICBzZWxmLmxlbmd0aCA9IDE7XG4gICAgICBcbiAgICB9IGVsc2UgaWYoICQkLmlzLnN0cmluZyggc2VsZWN0b3IgKSApe1xuXG4gICAgICAvLyB0aGUgY3VycmVudCBzdWJqZWN0IGluIHRoZSBxdWVyeVxuICAgICAgdmFyIGN1cnJlbnRTdWJqZWN0ID0gbnVsbDtcbiAgICAgIFxuICAgICAgLy8gc3RvcmFnZSBmb3IgcGFyc2VkIHF1ZXJpZXNcbiAgICAgIHZhciBuZXdRdWVyeSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2xhc3NlczogW10sIFxuICAgICAgICAgIGNvbG9uU2VsZWN0b3JzOiBbXSxcbiAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICBncm91cDogbnVsbCxcbiAgICAgICAgICBpZHM6IFtdLFxuICAgICAgICAgIG1ldGE6IFtdLFxuXG4gICAgICAgICAgLy8gZmFrZSBzZWxlY3RvcnNcbiAgICAgICAgICBjb2xsZWN0aW9uOiBudWxsLCAvLyBhIGNvbGxlY3Rpb24gdG8gbWF0Y2ggYWdhaW5zdFxuICAgICAgICAgIGZpbHRlcjogbnVsbCwgLy8gZmlsdGVyIGZ1bmN0aW9uXG5cbiAgICAgICAgICAvLyB0aGVzZSBhcmUgZGVmaW5lZCBpbiB0aGUgdXB3YXJkIGRpcmVjdGlvbiByYXRoZXIgdGhhbiBkb3duIChlLmcuIGNoaWxkKVxuICAgICAgICAgIC8vIGJlY2F1c2Ugd2UgbmVlZCB0byBnbyB1cCBpbiBTZWxlY3Rvci5maWx0ZXIoKVxuICAgICAgICAgIHBhcmVudDogbnVsbCwgLy8gcGFyZW50IHF1ZXJ5IG9ialxuICAgICAgICAgIGFuY2VzdG9yOiBudWxsLCAvLyBhbmNlc3RvciBxdWVyeSBvYmpcbiAgICAgICAgICBzdWJqZWN0OiBudWxsLCAvLyBkZWZpbmVzIHN1YmplY3QgaW4gY29tcG91bmQgcXVlcnkgKHN1YmplY3QgcXVlcnkgb2JqOyBwb2ludHMgdG8gc2VsZiBpZiBzdWJqZWN0KVxuXG4gICAgICAgICAgLy8gdXNlIHRoZXNlIG9ubHkgd2hlbiBzdWJqZWN0IGhhcyBiZWVuIGRlZmluZWRcbiAgICAgICAgICBjaGlsZDogbnVsbCxcbiAgICAgICAgICBkZXNjZW5kYW50OiBudWxsXG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICAvLyB0b2tlbnMgaW4gdGhlIHF1ZXJ5IGxhbmd1YWdlXG4gICAgICB2YXIgdG9rZW5zID0ge1xuICAgICAgICBtZXRhQ2hhcjogJ1tcXFxcIVxcXFxcIlxcXFwjXFxcXCRcXFxcJVxcXFwmXFxcXFxcJ1xcXFwoXFxcXClcXFxcKlxcXFwrXFxcXCxcXFxcLlxcXFwvXFxcXDpcXFxcO1xcXFw8XFxcXD1cXFxcPlxcXFw/XFxcXEBcXFxcW1xcXFxdXFxcXF5cXFxcYFxcXFx7XFxcXHxcXFxcfVxcXFx+XScsIC8vIGNoYXJzIHdlIG5lZWQgdG8gZXNjYXBlIGluIHZhciBuYW1lcywgZXRjXG4gICAgICAgIGNvbXBhcmF0b3JPcDogJz18XFxcXCE9fD58Pj18PHw8PXxcXFxcJD18XFxcXF49fFxcXFwqPScsIC8vIGJpbmFyeSBjb21wYXJpc29uIG9wICh1c2VkIGluIGRhdGEgc2VsZWN0b3JzKVxuICAgICAgICBib29sT3A6ICdcXFxcP3xcXFxcIXxcXFxcXicsIC8vIGJvb2xlYW4gKHVuYXJ5KSBvcGVyYXRvcnMgKHVzZWQgaW4gZGF0YSBzZWxlY3RvcnMpXG4gICAgICAgIHN0cmluZzogJ1wiKD86XFxcXFxcXFxcInxbXlwiXSkrXCInICsgJ3wnICsgXCInKD86XFxcXFxcXFwnfFteJ10pKydcIiwgLy8gc3RyaW5nIGxpdGVyYWxzICh1c2VkIGluIGRhdGEgc2VsZWN0b3JzKSAtLSBkb3VibGVxdW90ZXMgfCBzaW5nbGVxdW90ZXNcbiAgICAgICAgbnVtYmVyOiAkJC51dGlsLnJlZ2V4Lm51bWJlciwgLy8gbnVtYmVyIGxpdGVyYWwgKHVzZWQgaW4gZGF0YSBzZWxlY3RvcnMpIC0tLSBlLmcuIDAuMTIzNCwgMTIzNCwgMTJlMTIzXG4gICAgICAgIG1ldGE6ICdkZWdyZWV8aW5kZWdyZWV8b3V0ZGVncmVlJywgLy8gYWxsb3dlZCBtZXRhZGF0YSBmaWVsZHMgKGkuZS4gYWxsb3dlZCBmdW5jdGlvbnMgdG8gdXNlIGZyb20gJCQuQ29sbGVjdGlvbilcbiAgICAgICAgc2VwYXJhdG9yOiAnXFxcXHMqLFxcXFxzKicsIC8vIHF1ZXJpZXMgYXJlIHNlcGFyYXRlZCBieSBjb21tYXMsIGUuZy4gZWRnZVtmb28gPSAnYmFyJ10sIG5vZGUuc29tZUNsYXNzXG4gICAgICAgIGRlc2NlbmRhbnQ6ICdcXFxccysnLFxuICAgICAgICBjaGlsZDogJ1xcXFxzKz5cXFxccysnLFxuICAgICAgICBzdWJqZWN0OiAnXFxcXCQnXG4gICAgICB9O1xuICAgICAgdG9rZW5zLnZhcmlhYmxlID0gJyg/OltcXFxcdy1dfCg/OlxcXFxcXFxcJysgdG9rZW5zLm1ldGFDaGFyICsnKSkrJzsgLy8gYSB2YXJpYWJsZSBuYW1lXG4gICAgICB0b2tlbnMudmFsdWUgPSB0b2tlbnMuc3RyaW5nICsgJ3wnICsgdG9rZW5zLm51bWJlcjsgLy8gYSB2YWx1ZSBsaXRlcmFsLCBlaXRoZXIgYSBzdHJpbmcgb3IgbnVtYmVyXG4gICAgICB0b2tlbnMuY2xhc3NOYW1lID0gdG9rZW5zLnZhcmlhYmxlOyAvLyBhIGNsYXNzIG5hbWUgKGZvbGxvd3MgdmFyaWFibGUgY29udmVudGlvbnMpXG4gICAgICB0b2tlbnMuaWQgPSB0b2tlbnMudmFyaWFibGU7IC8vIGFuIGVsZW1lbnQgaWQgKGZvbGxvd3MgdmFyaWFibGUgY29udmVudGlvbnMpXG5cbiAgICAgIC8vIHdoZW4gYSB0b2tlbiBsaWtlIGEgdmFyaWFibGUgaGFzIGVzY2FwZWQgbWV0YSBjaGFyYWN0ZXJzLCB3ZSBuZWVkIHRvIGNsZWFuIHRoZSBiYWNrc2xhc2hlcyBvdXRcbiAgICAgIC8vIHNvIHRoYXQgdmFsdWVzIGdldCBjb21wYXJlZCBwcm9wZXJseSBpbiBTZWxlY3Rvci5maWx0ZXIoKVxuICAgICAgdmFyIGNsZWFuTWV0YUNoYXJzID0gZnVuY3Rpb24oc3RyKXtcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcXFxcXFxcKCcgKyB0b2tlbnMubWV0YUNoYXIgKyAnKScsICdnJyksIGZ1bmN0aW9uKG1hdGNoLCAkMSwgb2Zmc2V0LCBvcmlnaW5hbCl7XG4gICAgICAgICAgcmV0dXJuICQxO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIGFkZCBAIHZhcmlhbnRzIHRvIGNvbXBhcmF0b3JPcFxuICAgICAgdmFyIG9wcyA9IHRva2Vucy5jb21wYXJhdG9yT3Auc3BsaXQoJ3wnKTtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgb3BzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBvcCA9IG9wc1tpXTtcbiAgICAgICAgdG9rZW5zLmNvbXBhcmF0b3JPcCArPSAnfEAnICsgb3A7XG4gICAgICB9XG5cbiAgICAgIC8vIGFkZCAhIHZhcmlhbnRzIHRvIGNvbXBhcmF0b3JPcFxuICAgICAgdmFyIG9wcyA9IHRva2Vucy5jb21wYXJhdG9yT3Auc3BsaXQoJ3wnKTtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgb3BzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBvcCA9IG9wc1tpXTtcblxuICAgICAgICBpZiggb3AuaW5kZXhPZignIScpID49IDAgKXsgY29udGludWU7IH0gLy8gc2tpcCBvcHMgdGhhdCBleHBsaWNpdGx5IGNvbnRhaW4gIVxuICAgICAgICBpZiggb3AgPT09ICc9JyApeyBjb250aW51ZTsgfSAvLyBza2lwID0gYi9jICE9IGlzIGV4cGxpY2l0bHkgZGVmaW5lZFxuXG4gICAgICAgIHRva2Vucy5jb21wYXJhdG9yT3AgKz0gJ3xcXFxcIScgKyBvcDtcbiAgICAgIH1cblxuICAgICAgLy8gTk9URTogYWRkIG5ldyBleHByZXNzaW9uIHN5bnRheCBoZXJlIHRvIGhhdmUgaXQgcmVjb2duaXNlZCBieSB0aGUgcGFyc2VyO1xuICAgICAgLy8gLSBhIHF1ZXJ5IGNvbnRhaW5zIGFsbCBhZGphY2VudCAoaS5lLiBubyBzZXBhcmF0b3IgaW4gYmV0d2VlbikgZXhwcmVzc2lvbnM7XG4gICAgICAvLyAtIHRoZSBjdXJyZW50IHF1ZXJ5IGlzIHN0b3JlZCBpbiBzZWxmW2ldIC0tLSB5b3UgY2FuIHVzZSB0aGUgcmVmZXJlbmNlIHRvIGB0aGlzYCBpbiB0aGUgcG9wdWxhdGUgZnVuY3Rpb247XG4gICAgICAvLyAtIHlvdSBuZWVkIHRvIGNoZWNrIHRoZSBxdWVyeSBvYmplY3RzIGluIFNlbGVjdG9yLmZpbHRlcigpIGZvciBpdCBhY3R1YWxseSBmaWx0ZXIgcHJvcGVybHksIGJ1dCB0aGF0J3MgcHJldHR5IHN0cmFpZ2h0IGZvcndhcmRcbiAgICAgIC8vIC0gd2hlbiB5b3UgYWRkIHNvbWV0aGluZyBoZXJlLCBhbHNvIGFkZCB0byBTZWxlY3Rvci50b1N0cmluZygpXG4gICAgICB2YXIgZXhwcnMgPSB7XG4gICAgICAgIGdyb3VwOiB7XG4gICAgICAgICAgcXVlcnk6IHRydWUsXG4gICAgICAgICAgcmVnZXg6ICcobm9kZXxlZGdlfFxcXFwqKScsXG4gICAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCBncm91cCApe1xuICAgICAgICAgICAgdGhpcy5ncm91cCA9IGdyb3VwID09IFwiKlwiID8gZ3JvdXAgOiBncm91cCArICdzJztcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBzdGF0ZToge1xuICAgICAgICAgIHF1ZXJ5OiB0cnVlLFxuICAgICAgICAgIC8vIE5COiBpZiBvbmUgY29sb24gc2VsZWN0b3IgaXMgYSBzdWJzdHJpbmcgb2YgYW5vdGhlciBmcm9tIGl0cyBzdGFydCwgcGxhY2UgdGhlIGxvbmdlciBvbmUgZmlyc3RcbiAgICAgICAgICAvLyBlLmcuIDpmb29iYXJ8OmZvb1xuICAgICAgICAgIHJlZ2V4OiAnKDpzZWxlY3RlZHw6dW5zZWxlY3RlZHw6bG9ja2VkfDp1bmxvY2tlZHw6dmlzaWJsZXw6aGlkZGVufDp0cmFuc3BhcmVudHw6Z3JhYmJlZHw6ZnJlZXw6cmVtb3ZlZHw6aW5zaWRlfDpncmFiYmFibGV8OnVuZ3JhYmJhYmxlfDphbmltYXRlZHw6dW5hbmltYXRlZHw6c2VsZWN0YWJsZXw6dW5zZWxlY3RhYmxlfDpvcnBoYW58Om5vbm9ycGhhbnw6cGFyZW50fDpjaGlsZHw6bG9vcHw6c2ltcGxlfDphY3RpdmV8OmluYWN0aXZlfDp0b3VjaHw6YmFja2dyb3VuZGluZ3w6bm9uYmFja2dyb3VuZGluZyknLFxuICAgICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbiggc3RhdGUgKXtcbiAgICAgICAgICAgIHRoaXMuY29sb25TZWxlY3RvcnMucHVzaCggc3RhdGUgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBpZDoge1xuICAgICAgICAgIHF1ZXJ5OiB0cnVlLFxuICAgICAgICAgIHJlZ2V4OiAnXFxcXCMoJysgdG9rZW5zLmlkICsnKScsXG4gICAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCBpZCApe1xuICAgICAgICAgICAgdGhpcy5pZHMucHVzaCggY2xlYW5NZXRhQ2hhcnMoaWQpICk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgY2xhc3NOYW1lOiB7XG4gICAgICAgICAgcXVlcnk6IHRydWUsXG4gICAgICAgICAgcmVnZXg6ICdcXFxcLignKyB0b2tlbnMuY2xhc3NOYW1lICsnKScsXG4gICAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKXtcbiAgICAgICAgICAgIHRoaXMuY2xhc3Nlcy5wdXNoKCBjbGVhbk1ldGFDaGFycyhjbGFzc05hbWUpICk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgZGF0YUV4aXN0czoge1xuICAgICAgICAgIHF1ZXJ5OiB0cnVlLFxuICAgICAgICAgIHJlZ2V4OiAnXFxcXFtcXFxccyooJysgdG9rZW5zLnZhcmlhYmxlICsnKVxcXFxzKlxcXFxdJyxcbiAgICAgICAgICBwb3B1bGF0ZTogZnVuY3Rpb24oIHZhcmlhYmxlICl7XG4gICAgICAgICAgICB0aGlzLmRhdGEucHVzaCh7XG4gICAgICAgICAgICAgIGZpZWxkOiBjbGVhbk1ldGFDaGFycyh2YXJpYWJsZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIGRhdGFDb21wYXJlOiB7XG4gICAgICAgICAgcXVlcnk6IHRydWUsXG4gICAgICAgICAgcmVnZXg6ICdcXFxcW1xcXFxzKignKyB0b2tlbnMudmFyaWFibGUgKycpXFxcXHMqKCcrIHRva2Vucy5jb21wYXJhdG9yT3AgKycpXFxcXHMqKCcrIHRva2Vucy52YWx1ZSArJylcXFxccypcXFxcXScsXG4gICAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCB2YXJpYWJsZSwgY29tcGFyYXRvck9wLCB2YWx1ZSApeyBcbiAgICAgICAgICAgIHZhciB2YWx1ZUlzU3RyaW5nID0gbmV3IFJlZ0V4cCgnXicgKyB0b2tlbnMuc3RyaW5nICsgJyQnKS5leGVjKHZhbHVlKSAhPSBudWxsO1xuXG4gICAgICAgICAgICBpZiggdmFsdWVJc1N0cmluZyApe1xuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygxLCB2YWx1ZS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgZmllbGQ6IGNsZWFuTWV0YUNoYXJzKHZhcmlhYmxlKSxcbiAgICAgICAgICAgICAgb3BlcmF0b3I6IGNvbXBhcmF0b3JPcCxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBkYXRhQm9vbDoge1xuICAgICAgICAgIHF1ZXJ5OiB0cnVlLFxuICAgICAgICAgIHJlZ2V4OiAnXFxcXFtcXFxccyooJysgdG9rZW5zLmJvb2xPcCArJylcXFxccyooJysgdG9rZW5zLnZhcmlhYmxlICsnKVxcXFxzKlxcXFxdJyxcbiAgICAgICAgICBwb3B1bGF0ZTogZnVuY3Rpb24oIGJvb2xPcCwgdmFyaWFibGUgKXtcbiAgICAgICAgICAgIHRoaXMuZGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgZmllbGQ6IGNsZWFuTWV0YUNoYXJzKHZhcmlhYmxlKSxcbiAgICAgICAgICAgICAgb3BlcmF0b3I6IGJvb2xPcFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgbWV0YUNvbXBhcmU6IHtcbiAgICAgICAgICBxdWVyeTogdHJ1ZSxcbiAgICAgICAgICByZWdleDogJ1xcXFxbXFxcXFtcXFxccyooJysgdG9rZW5zLm1ldGEgKycpXFxcXHMqKCcrIHRva2Vucy5jb21wYXJhdG9yT3AgKycpXFxcXHMqKCcrIHRva2Vucy5udW1iZXIgKycpXFxcXHMqXFxcXF1cXFxcXScsXG4gICAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCBtZXRhLCBjb21wYXJhdG9yT3AsIG51bWJlciApe1xuICAgICAgICAgICAgdGhpcy5tZXRhLnB1c2goe1xuICAgICAgICAgICAgICBmaWVsZDogY2xlYW5NZXRhQ2hhcnMobWV0YSksXG4gICAgICAgICAgICAgIG9wZXJhdG9yOiBjb21wYXJhdG9yT3AsXG4gICAgICAgICAgICAgIHZhbHVlOiBwYXJzZUZsb2F0KG51bWJlcilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBuZXh0UXVlcnk6IHtcbiAgICAgICAgICBzZXBhcmF0b3I6IHRydWUsXG4gICAgICAgICAgcmVnZXg6IHRva2Vucy5zZXBhcmF0b3IsXG4gICAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAvLyBnbyBvbiB0byBuZXh0IHF1ZXJ5XG4gICAgICAgICAgICBzZWxmWysraV0gPSBuZXdRdWVyeSgpO1xuICAgICAgICAgICAgY3VycmVudFN1YmplY3QgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBjaGlsZDoge1xuICAgICAgICAgIHNlcGFyYXRvcjogdHJ1ZSxcbiAgICAgICAgICByZWdleDogdG9rZW5zLmNoaWxkLFxuICAgICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgLy8gdGhpcyBxdWVyeSBpcyB0aGUgcGFyZW50IG9mIHRoZSBmb2xsb3dpbmcgcXVlcnlcbiAgICAgICAgICAgIHZhciBjaGlsZFF1ZXJ5ID0gbmV3UXVlcnkoKTtcbiAgICAgICAgICAgIGNoaWxkUXVlcnkucGFyZW50ID0gdGhpcztcbiAgICAgICAgICAgIGNoaWxkUXVlcnkuc3ViamVjdCA9IGN1cnJlbnRTdWJqZWN0O1xuXG4gICAgICAgICAgICAvLyB3ZSdyZSBub3cgcG9wdWxhdGluZyB0aGUgY2hpbGQgcXVlcnkgd2l0aCBleHByZXNzaW9ucyB0aGF0IGZvbGxvd1xuICAgICAgICAgICAgc2VsZltpXSA9IGNoaWxkUXVlcnk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRlc2NlbmRhbnQ6IHtcbiAgICAgICAgICBzZXBhcmF0b3I6IHRydWUsXG4gICAgICAgICAgcmVnZXg6IHRva2Vucy5kZXNjZW5kYW50LFxuICAgICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgLy8gdGhpcyBxdWVyeSBpcyB0aGUgYW5jZXN0b3Igb2YgdGhlIGZvbGxvd2luZyBxdWVyeVxuICAgICAgICAgICAgdmFyIGRlc2NlbmRhbnRRdWVyeSA9IG5ld1F1ZXJ5KCk7XG4gICAgICAgICAgICBkZXNjZW5kYW50UXVlcnkuYW5jZXN0b3IgPSB0aGlzO1xuICAgICAgICAgICAgZGVzY2VuZGFudFF1ZXJ5LnN1YmplY3QgPSBjdXJyZW50U3ViamVjdDtcblxuICAgICAgICAgICAgLy8gd2UncmUgbm93IHBvcHVsYXRpbmcgdGhlIGRlc2NlbmRhbnQgcXVlcnkgd2l0aCBleHByZXNzaW9ucyB0aGF0IGZvbGxvd1xuICAgICAgICAgICAgc2VsZltpXSA9IGRlc2NlbmRhbnRRdWVyeTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3ViamVjdDoge1xuICAgICAgICAgIG1vZGlmaWVyOiB0cnVlLFxuICAgICAgICAgIHJlZ2V4OiB0b2tlbnMuc3ViamVjdCxcbiAgICAgICAgICBwb3B1bGF0ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGlmKCBjdXJyZW50U3ViamVjdCAhPSBudWxsICYmIHRoaXMuc3ViamVjdCAhPSB0aGlzICl7XG4gICAgICAgICAgICAgICQkLnV0aWwuZXJyb3IoJ1JlZGVmaW5pdGlvbiBvZiBzdWJqZWN0IGluIHNlbGVjdG9yIGAnICsgc2VsZWN0b3IgKyAnYCcpO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnJlbnRTdWJqZWN0ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuc3ViamVjdCA9IHRoaXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBqID0gMDtcbiAgICAgIGZvciggdmFyIG5hbWUgaW4gZXhwcnMgKXtcbiAgICAgICAgZXhwcnNbal0gPSBleHByc1tuYW1lXTtcbiAgICAgICAgZXhwcnNbal0ubmFtZSA9IG5hbWU7XG5cbiAgICAgICAgaisrO1xuICAgICAgfVxuICAgICAgZXhwcnMubGVuZ3RoID0gajtcblxuICAgICAgc2VsZi5fcHJpdmF0ZS5zZWxlY3RvclRleHQgPSBzZWxlY3RvcjtcbiAgICAgIHZhciByZW1haW5pbmcgPSBzZWxlY3RvcjtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIFxuICAgICAgLy8gb2YgYWxsIHRoZSBleHByZXNzaW9ucywgZmluZCB0aGUgZmlyc3QgbWF0Y2ggaW4gdGhlIHJlbWFpbmluZyB0ZXh0XG4gICAgICB2YXIgY29uc3VtZUV4cHIgPSBmdW5jdGlvbiggZXhwZWN0YXRpb24gKXtcbiAgICAgICAgdmFyIGV4cHI7XG4gICAgICAgIHZhciBtYXRjaDtcbiAgICAgICAgdmFyIG5hbWU7XG4gICAgICAgIFxuICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGV4cHJzLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgdmFyIGUgPSBleHByc1tqXTtcbiAgICAgICAgICB2YXIgbiA9IGUubmFtZTtcblxuICAgICAgICAgIC8vIGlnbm9yZSB0aGlzIGV4cHJlc3Npb24gaWYgaXQgZG9lc24ndCBtZWV0IHRoZSBleHBlY3RhdGlvbiBmdW5jdGlvblxuICAgICAgICAgIGlmKCAkJC5pcy5mbiggZXhwZWN0YXRpb24gKSAmJiAhZXhwZWN0YXRpb24obiwgZSkgKXsgY29udGludWU7IH1cblxuICAgICAgICAgIHZhciBtID0gcmVtYWluaW5nLm1hdGNoKG5ldyBSZWdFeHAoICdeJyArIGUucmVnZXggKSk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYoIG0gIT0gbnVsbCApe1xuICAgICAgICAgICAgbWF0Y2ggPSBtO1xuICAgICAgICAgICAgZXhwciA9IGU7XG4gICAgICAgICAgICBuYW1lID0gbjtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGNvbnN1bWVkID0gbVswXTtcbiAgICAgICAgICAgIHJlbWFpbmluZyA9IHJlbWFpbmluZy5zdWJzdHJpbmcoIGNvbnN1bWVkLmxlbmd0aCApOyAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgYnJlYWs7IC8vIHdlJ3ZlIGNvbnN1bWVkIG9uZSBleHByLCBzbyB3ZSBjYW4gcmV0dXJuIG5vd1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBleHByOiBleHByLFxuICAgICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBjb25zdW1lIGFsbCBsZWFkaW5nIHdoaXRlc3BhY2VcbiAgICAgIHZhciBjb25zdW1lV2hpdGVzcGFjZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBtYXRjaCA9IHJlbWFpbmluZy5tYXRjaCgvXlxccysvKTtcbiAgICAgICAgXG4gICAgICAgIGlmKCBtYXRjaCApe1xuICAgICAgICAgIHZhciBjb25zdW1lZCA9IG1hdGNoWzBdO1xuICAgICAgICAgIHJlbWFpbmluZyA9IHJlbWFpbmluZy5zdWJzdHJpbmcoIGNvbnN1bWVkLmxlbmd0aCApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgXG4gICAgICBzZWxmWzBdID0gbmV3UXVlcnkoKTsgLy8gZ2V0IHN0YXJ0ZWRcblxuICAgICAgY29uc3VtZVdoaXRlc3BhY2UoKTsgLy8gZ2V0IHJpZCBvZiBsZWFkaW5nIHdoaXRlc3BhY2VcbiAgICAgIGZvcig7Oyl7ICAgICAgICBcbiAgICAgICAgdmFyIGNoZWNrID0gY29uc3VtZUV4cHIoKTtcbiAgICAgICAgXG4gICAgICAgIGlmKCBjaGVjay5leHByID09IG51bGwgKXtcbiAgICAgICAgICAkJC51dGlsLmVycm9yKCdUaGUgc2VsZWN0b3IgYCcrIHNlbGVjdG9yICsnYGlzIGludmFsaWQnKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICBmb3IodmFyIGogPSAxOyBqIDwgY2hlY2subWF0Y2gubGVuZ3RoOyBqKyspe1xuICAgICAgICAgICAgYXJncy5wdXNoKCBjaGVjay5tYXRjaFtqXSApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBsZXQgdGhlIHRva2VuIHBvcHVsYXRlIHRoZSBzZWxlY3RvciBvYmplY3QgKGkuZS4gaW4gc2VsZltpXSlcbiAgICAgICAgICB2YXIgcmV0ID0gY2hlY2suZXhwci5wb3B1bGF0ZS5hcHBseSggc2VsZltpXSwgYXJncyApO1xuXG4gICAgICAgICAgaWYoIHJldCA9PT0gZmFsc2UgKXsgcmV0dXJuOyB9IC8vIGV4aXQgaWYgcG9wdWxhdGlvbiBmYWlsZWRcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gd2UncmUgZG9uZSB3aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIHBhcnNlXG4gICAgICAgIGlmKCByZW1haW5pbmcubWF0Y2goL15cXHMqJC8pICl7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgc2VsZi5sZW5ndGggPSBpICsgMTtcblxuICAgICAgLy8gYWRqdXN0IHJlZmVyZW5jZXMgZm9yIHN1YmplY3RcbiAgICAgIGZvcihqID0gMDsgaiA8IHNlbGYubGVuZ3RoOyBqKyspe1xuICAgICAgICB2YXIgcXVlcnkgPSBzZWxmW2pdO1xuXG4gICAgICAgIGlmKCBxdWVyeS5zdWJqZWN0ICE9IG51bGwgKXtcbiAgICAgICAgICAvLyBnbyB1cCB0aGUgdHJlZSB1bnRpbCB3ZSByZWFjaCB0aGUgc3ViamVjdFxuICAgICAgICAgIGZvcig7Oyl7XG4gICAgICAgICAgICBpZiggcXVlcnkuc3ViamVjdCA9PSBxdWVyeSApeyBicmVhazsgfSAvLyBkb25lIGlmIHN1YmplY3QgaXMgc2VsZlxuXG4gICAgICAgICAgICBpZiggcXVlcnkucGFyZW50ICE9IG51bGwgKXsgLy8gc3dhcCBwYXJlbnQvY2hpbGQgcmVmZXJlbmNlXG4gICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBxdWVyeS5wYXJlbnQ7XG4gICAgICAgICAgICAgIHZhciBjaGlsZCA9IHF1ZXJ5O1xuXG4gICAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICAgIHBhcmVudC5jaGlsZCA9IGNoaWxkO1xuXG4gICAgICAgICAgICAgIHF1ZXJ5ID0gcGFyZW50OyAvLyBnbyB1cCB0aGUgdHJlZVxuICAgICAgICAgICAgfSBlbHNlIGlmKCBxdWVyeS5hbmNlc3RvciAhPSBudWxsICl7IC8vIHN3YXAgYW5jZXN0b3IvZGVzY2VuZGFudFxuICAgICAgICAgICAgICB2YXIgYW5jZXN0b3IgPSBxdWVyeS5hbmNlc3RvcjtcbiAgICAgICAgICAgICAgdmFyIGRlc2NlbmRhbnQgPSBxdWVyeTtcblxuICAgICAgICAgICAgICBkZXNjZW5kYW50LmFuY2VzdG9yID0gbnVsbDtcbiAgICAgICAgICAgICAgYW5jZXN0b3IuZGVzY2VuZGFudCA9IGRlc2NlbmRhbnQ7XG5cbiAgICAgICAgICAgICAgcXVlcnkgPSBhbmNlc3RvcjsgLy8gZ28gdXAgdGhlIHRyZWVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICQkLnV0aWwuZXJyb3IoJ1doZW4gYWRqdXN0aW5nIHJlZmVyZW5jZXMgZm9yIHRoZSBzZWxlY3RvciBgJysgcXVlcnkgKydgLCBuZWl0aGVyIHBhcmVudCBub3IgYW5jZXN0b3Igd2FzIGZvdW5kJyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gZm9yXG5cbiAgICAgICAgICBzZWxmW2pdID0gcXVlcnkuc3ViamVjdDsgLy8gc3ViamVjdCBzaG91bGQgYmUgdGhlIHJvb3QgcXVlcnlcbiAgICAgICAgfSAvLyBpZlxuICAgICAgfSAvLyBmb3JcblxuICAgICAgLy8gbWFrZSBzdXJlIGZvciBlYWNoIHF1ZXJ5IHRoYXQgdGhlIHN1YmplY3QgZ3JvdXAgbWF0Y2hlcyB0aGUgaW1wbGljaXQgZ3JvdXAgaWYgYW55XG4gICAgICBpZiggb25seVRoaXNHcm91cCAhPSBudWxsICl7XG4gICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBzZWxmLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICBpZiggc2VsZltqXS5ncm91cCAhPSBudWxsICYmIHNlbGZbal0uZ3JvdXAgIT0gb25seVRoaXNHcm91cCApe1xuICAgICAgICAgICAgJCQudXRpbC5lcnJvcignR3JvdXAgYCcrIHNlbGZbal0uZ3JvdXAgKydgIGNvbmZsaWN0cyB3aXRoIGltcGxpY2l0IGdyb3VwIGAnKyBvbmx5VGhpc0dyb3VwICsnYCBpbiBzZWxlY3RvciBgJysgc2VsZWN0b3IgKydgJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZltqXS5ncm91cCA9IG9ubHlUaGlzR3JvdXA7IC8vIHNldCB0byBpbXBsaWNpdCBncm91cFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICB9IGVsc2Uge1xuICAgICAgJCQudXRpbC5lcnJvcignQSBzZWxlY3RvciBtdXN0IGJlIGNyZWF0ZWQgZnJvbSBhIHN0cmluZzsgZm91bmQgJyArIHNlbGVjdG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZWxmLl9wcml2YXRlLmludmFsaWQgPSBmYWxzZTtcbiAgICBcbiAgfTtcblxuICAkJC5zZWxmbiA9ICQkLlNlbGVjdG9yLnByb3RvdHlwZTtcbiAgXG4gICQkLnNlbGZuLnNpemUgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgfTtcbiAgXG4gICQkLnNlbGZuLmVxID0gZnVuY3Rpb24oaSl7XG4gICAgcmV0dXJuIHRoaXNbaV07XG4gIH07XG4gIFxuICAvLyBnZXQgZWxlbWVudHMgZnJvbSB0aGUgY29yZSBhbmQgdGhlbiBmaWx0ZXIgdGhlbVxuICAkJC5zZWxmbi5maW5kID0gZnVuY3Rpb24oKXtcbiAgICAvLyBUT0RPIGltcGwgaWYgd2UgZGVjaWRlIHRvIHVzZSBhIERCIGZvciBzdG9yaW5nIGVsZW1lbnRzXG4gIH07XG4gIFxuICB2YXIgcXVlcnlNYXRjaGVzID0gZnVuY3Rpb24ocXVlcnksIGVsZW1lbnQpe1xuICAgIC8vIGNoZWNrIGdyb3VwXG4gICAgaWYoIHF1ZXJ5Lmdyb3VwICE9IG51bGwgJiYgcXVlcnkuZ3JvdXAgIT0gJyonICYmIHF1ZXJ5Lmdyb3VwICE9IGVsZW1lbnQuX3ByaXZhdGUuZ3JvdXAgKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgY3kgPSBlbGVtZW50LmN5KCk7XG4gICAgXG4gICAgLy8gY2hlY2sgY29sb24gc2VsZWN0b3JzXG4gICAgdmFyIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSB0cnVlO1xuICAgIGZvcih2YXIgayA9IDA7IGsgPCBxdWVyeS5jb2xvblNlbGVjdG9ycy5sZW5ndGg7IGsrKyl7XG4gICAgICB2YXIgc2VsID0gcXVlcnkuY29sb25TZWxlY3RvcnNba107XG4gICAgICBcbiAgICAgIHN3aXRjaChzZWwpe1xuICAgICAgY2FzZSAnOnNlbGVjdGVkJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZW1lbnQuc2VsZWN0ZWQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6dW5zZWxlY3RlZCc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSAhZWxlbWVudC5zZWxlY3RlZCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzpzZWxlY3RhYmxlJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZW1lbnQuc2VsZWN0YWJsZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzp1bnNlbGVjdGFibGUnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gIWVsZW1lbnQuc2VsZWN0YWJsZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzpsb2NrZWQnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlbWVudC5sb2NrZWQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6dW5sb2NrZWQnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gIWVsZW1lbnQubG9ja2VkKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOnZpc2libGUnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlbWVudC52aXNpYmxlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOmhpZGRlbic6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSAhZWxlbWVudC52aXNpYmxlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOnRyYW5zcGFyZW50JzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZW1lbnQudHJhbnNwYXJlbnQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6Z3JhYmJlZCc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGVtZW50LmdyYWJiZWQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6ZnJlZSc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSAhZWxlbWVudC5ncmFiYmVkKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOnJlbW92ZWQnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlbWVudC5yZW1vdmVkKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOmluc2lkZSc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSAhZWxlbWVudC5yZW1vdmVkKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOmdyYWJiYWJsZSc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGVtZW50LmdyYWJiYWJsZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzp1bmdyYWJiYWJsZSc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSAhZWxlbWVudC5ncmFiYmFibGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6YW5pbWF0ZWQnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlbWVudC5hbmltYXRlZCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzp1bmFuaW1hdGVkJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9ICFlbGVtZW50LmFuaW1hdGVkKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOnBhcmVudCc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGVtZW50LmlzTm9kZSgpICYmIGVsZW1lbnQuY2hpbGRyZW4oKS5ub25lbXB0eSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzpjaGlsZCc6XG4gICAgICBjYXNlICc6bm9ub3JwaGFuJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZW1lbnQuaXNOb2RlKCkgJiYgZWxlbWVudC5wYXJlbnQoKS5ub25lbXB0eSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzpvcnBoYW4nOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlbWVudC5pc05vZGUoKSAmJiBlbGVtZW50LnBhcmVudCgpLmVtcHR5KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOmxvb3AnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlbWVudC5pc0VkZ2UoKSAmJiBlbGVtZW50LmRhdGEoJ3NvdXJjZScpID09PSBlbGVtZW50LmRhdGEoJ3RhcmdldCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzpzaW1wbGUnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlbWVudC5pc0VkZ2UoKSAmJiBlbGVtZW50LmRhdGEoJ3NvdXJjZScpICE9PSBlbGVtZW50LmRhdGEoJ3RhcmdldCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzphY3RpdmUnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlbWVudC5hY3RpdmUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6aW5hY3RpdmUnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gIWVsZW1lbnQuYWN0aXZlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOnRvdWNoJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9ICQkLmlzLnRvdWNoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOmJhY2tncm91bmRpbmcnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlbWVudC5iYWNrZ3JvdW5kaW5nKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOm5vbmJhY2tncm91bmRpbmcnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gIWVsZW1lbnQuYmFja2dyb3VuZGluZygpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYoICFhbGxDb2xvblNlbGVjdG9yc01hdGNoICkgYnJlYWs7XG4gICAgfVxuICAgIGlmKCAhYWxsQ29sb25TZWxlY3RvcnNNYXRjaCApIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICAvLyBjaGVjayBpZFxuICAgIHZhciBhbGxJZHNNYXRjaCA9IHRydWU7XG4gICAgZm9yKHZhciBrID0gMDsgayA8IHF1ZXJ5Lmlkcy5sZW5ndGg7IGsrKyl7XG4gICAgICB2YXIgaWQgPSBxdWVyeS5pZHNba107XG4gICAgICB2YXIgYWN0dWFsSWQgPSBlbGVtZW50Ll9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICBcbiAgICAgIGFsbElkc01hdGNoID0gYWxsSWRzTWF0Y2ggJiYgKGlkID09IGFjdHVhbElkKTtcbiAgICAgIFxuICAgICAgaWYoICFhbGxJZHNNYXRjaCApIGJyZWFrO1xuICAgIH1cbiAgICBpZiggIWFsbElkc01hdGNoICkgcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgIC8vIGNoZWNrIGNsYXNzZXNcbiAgICB2YXIgYWxsQ2xhc3Nlc01hdGNoID0gdHJ1ZTtcbiAgICBmb3IodmFyIGsgPSAwOyBrIDwgcXVlcnkuY2xhc3Nlcy5sZW5ndGg7IGsrKyl7XG4gICAgICB2YXIgY2xzID0gcXVlcnkuY2xhc3Nlc1trXTtcbiAgICAgIFxuICAgICAgYWxsQ2xhc3Nlc01hdGNoID0gYWxsQ2xhc3Nlc01hdGNoICYmIGVsZW1lbnQuaGFzQ2xhc3MoY2xzKTtcbiAgICAgIFxuICAgICAgaWYoICFhbGxDbGFzc2VzTWF0Y2ggKSBicmVhaztcbiAgICB9XG4gICAgaWYoICFhbGxDbGFzc2VzTWF0Y2ggKSByZXR1cm4gZmFsc2U7XG4gICAgXG4gICAgLy8gZ2VuZXJpYyBjaGVja2luZyBmb3IgZGF0YS9tZXRhZGF0YVxuICAgIHZhciBvcGVyYW5kc01hdGNoID0gZnVuY3Rpb24ocGFyYW1zKXtcbiAgICAgIHZhciBhbGxEYXRhTWF0Y2hlcyA9IHRydWU7XG4gICAgICBmb3IodmFyIGsgPSAwOyBrIDwgcXVlcnlbcGFyYW1zLm5hbWVdLmxlbmd0aDsgaysrKXtcbiAgICAgICAgdmFyIGRhdGEgPSBxdWVyeVtwYXJhbXMubmFtZV1ba107XG4gICAgICAgIHZhciBvcGVyYXRvciA9IGRhdGEub3BlcmF0b3I7XG4gICAgICAgIHZhciB2YWx1ZSA9IGRhdGEudmFsdWU7XG4gICAgICAgIHZhciBmaWVsZCA9IGRhdGEuZmllbGQ7XG4gICAgICAgIHZhciBtYXRjaGVzO1xuICAgICAgICBcbiAgICAgICAgaWYoIG9wZXJhdG9yICE9IG51bGwgJiYgdmFsdWUgIT0gbnVsbCApe1xuICAgICAgICAgIFxuICAgICAgICAgIHZhciBmaWVsZFZhbCA9IHBhcmFtcy5maWVsZFZhbHVlKGZpZWxkKTtcbiAgICAgICAgICB2YXIgZmllbGRTdHIgPSAhJCQuaXMuc3RyaW5nKGZpZWxkVmFsKSAmJiAhJCQuaXMubnVtYmVyKGZpZWxkVmFsKSA/ICcnIDogJycgKyBmaWVsZFZhbDtcbiAgICAgICAgICB2YXIgdmFsU3RyID0gJycgKyB2YWx1ZTtcbiAgICAgICAgICBcbiAgICAgICAgICB2YXIgY2FzZUluc2Vuc2l0aXZlID0gZmFsc2U7XG4gICAgICAgICAgaWYoIG9wZXJhdG9yLmluZGV4T2YoJ0AnKSA+PSAwICl7XG4gICAgICAgICAgICBmaWVsZFN0ciA9IGZpZWxkU3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB2YWxTdHIgPSB2YWxTdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgb3BlcmF0b3IgPSBvcGVyYXRvci5yZXBsYWNlKCdAJywgJycpO1xuICAgICAgICAgICAgY2FzZUluc2Vuc2l0aXZlID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbm90RXhwciA9IGZhbHNlO1xuICAgICAgICAgIHZhciBoYW5kbGVkTm90RXhwciA9IGZhbHNlO1xuICAgICAgICAgIGlmKCBvcGVyYXRvci5pbmRleE9mKCchJykgPj0gMCApe1xuICAgICAgICAgICAgb3BlcmF0b3IgPSBvcGVyYXRvci5yZXBsYWNlKCchJywgJycpO1xuICAgICAgICAgICAgbm90RXhwciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIGlmIHdlJ3JlIGRvaW5nIGEgY2FzZSBpbnNlbnNpdGl2ZSBjb21wYXJpc29uLCB0aGVuIHdlJ3JlIHVzaW5nIGEgU1RSSU5HIGNvbXBhcmlzb25cbiAgICAgICAgICAvLyBldmVuIGlmIHdlJ3JlIGNvbXBhcmluZyBudW1iZXJzXG4gICAgICAgICAgaWYoIGNhc2VJbnNlbnNpdGl2ZSApe1xuICAgICAgICAgICAgdmFsdWUgPSB2YWxTdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGZpZWxkVmFsID0gZmllbGRTdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzd2l0Y2gob3BlcmF0b3Ipe1xuICAgICAgICAgIGNhc2UgJyo9JzpcbiAgICAgICAgICAgIG1hdGNoZXMgPSBmaWVsZFN0ci5zZWFyY2godmFsU3RyKSA+PSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnJD0nOlxuICAgICAgICAgICAgbWF0Y2hlcyA9IG5ldyBSZWdFeHAodmFsU3RyICsgJyQnKS5leGVjKGZpZWxkU3RyKSAhPSBudWxsO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnXj0nOlxuICAgICAgICAgICAgbWF0Y2hlcyA9IG5ldyBSZWdFeHAoJ14nICsgdmFsU3RyKS5leGVjKGZpZWxkU3RyKSAhPSBudWxsO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnPSc6XG4gICAgICAgICAgICBtYXRjaGVzID0gZmllbGRWYWwgPT09IHZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnIT0nOlxuICAgICAgICAgICAgbWF0Y2hlcyA9IGZpZWxkVmFsICE9PSB2YWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgbWF0Y2hlcyA9ICFub3RFeHByID8gZmllbGRWYWwgPiB2YWx1ZSA6IGZpZWxkVmFsIDw9IHZhbHVlO1xuICAgICAgICAgICAgaGFuZGxlZE5vdEV4cHIgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnPj0nOlxuICAgICAgICAgICAgbWF0Y2hlcyA9ICFub3RFeHByID8gZmllbGRWYWwgPj0gdmFsdWUgOiBmaWVsZFZhbCA8IHZhbHVlO1xuICAgICAgICAgICAgaGFuZGxlZE5vdEV4cHIgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICBtYXRjaGVzID0gIW5vdEV4cHIgPyBmaWVsZFZhbCA8IHZhbHVlIDogZmllbGRWYWwgPj0gdmFsdWU7XG4gICAgICAgICAgICBoYW5kbGVkTm90RXhwciA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgICAgICBtYXRjaGVzID0gIW5vdEV4cHIgPyBmaWVsZFZhbCA8PSB2YWx1ZSA6IGZpZWxkVmFsID4gdmFsdWU7XG4gICAgICAgICAgICBoYW5kbGVkTm90RXhwciA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgbWF0Y2hlcyA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiggb3BlcmF0b3IgIT0gbnVsbCApe1xuICAgICAgICAgIHN3aXRjaChvcGVyYXRvcil7XG4gICAgICAgICAgY2FzZSAnPyc6XG4gICAgICAgICAgICBtYXRjaGVzID0gcGFyYW1zLmZpZWxkVHJ1dGh5KGZpZWxkKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJyEnOlxuICAgICAgICAgICAgbWF0Y2hlcyA9ICFwYXJhbXMuZmllbGRUcnV0aHkoZmllbGQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnXic6XG4gICAgICAgICAgICBtYXRjaGVzID0gcGFyYW1zLmZpZWxkVW5kZWZpbmVkKGZpZWxkKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHsgICBcbiAgICAgICAgICBtYXRjaGVzID0gIXBhcmFtcy5maWVsZFVuZGVmaW5lZChmaWVsZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggbm90RXhwciAmJiAhaGFuZGxlZE5vdEV4cHIgKXtcbiAgICAgICAgICBtYXRjaGVzID0gIW1hdGNoZXM7XG4gICAgICAgICAgaGFuZGxlZE5vdEV4cHIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiggIW1hdGNoZXMgKXtcbiAgICAgICAgICBhbGxEYXRhTWF0Y2hlcyA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IC8vIGZvclxuICAgICAgXG4gICAgICByZXR1cm4gYWxsRGF0YU1hdGNoZXM7XG4gICAgfTsgLy8gb3BlcmFuZHNNYXRjaFxuICAgIFxuICAgIC8vIGNoZWNrIGRhdGEgbWF0Y2hlc1xuICAgIHZhciBhbGxEYXRhTWF0Y2hlcyA9IG9wZXJhbmRzTWF0Y2goe1xuICAgICAgbmFtZTogJ2RhdGEnLFxuICAgICAgZmllbGRWYWx1ZTogZnVuY3Rpb24oZmllbGQpe1xuICAgICAgICByZXR1cm4gZWxlbWVudC5fcHJpdmF0ZS5kYXRhW2ZpZWxkXTtcbiAgICAgIH0sXG4gICAgICBmaWVsZFJlZjogZnVuY3Rpb24oZmllbGQpe1xuICAgICAgICByZXR1cm4gJ2VsZW1lbnQuX3ByaXZhdGUuZGF0YS4nICsgZmllbGQ7XG4gICAgICB9LFxuICAgICAgZmllbGRVbmRlZmluZWQ6IGZ1bmN0aW9uKGZpZWxkKXtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuX3ByaXZhdGUuZGF0YVtmaWVsZF0gPT09IHVuZGVmaW5lZDtcbiAgICAgIH0sXG4gICAgICBmaWVsZFRydXRoeTogZnVuY3Rpb24oZmllbGQpe1xuICAgICAgICBpZiggZWxlbWVudC5fcHJpdmF0ZS5kYXRhW2ZpZWxkXSApe1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBpZiggIWFsbERhdGFNYXRjaGVzICl7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIC8vIGNoZWNrIG1ldGFkYXRhIG1hdGNoZXNcbiAgICB2YXIgYWxsTWV0YU1hdGNoZXMgPSBvcGVyYW5kc01hdGNoKHtcbiAgICAgIG5hbWU6ICdtZXRhJyxcbiAgICAgIGZpZWxkVmFsdWU6IGZ1bmN0aW9uKGZpZWxkKXtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRbZmllbGRdKCk7XG4gICAgICB9LFxuICAgICAgZmllbGRSZWY6IGZ1bmN0aW9uKGZpZWxkKXtcbiAgICAgICAgcmV0dXJuICdlbGVtZW50LicgKyBmaWVsZCArICcoKSc7XG4gICAgICB9LFxuICAgICAgZmllbGRVbmRlZmluZWQ6IGZ1bmN0aW9uKGZpZWxkKXtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRbZmllbGRdKCkgPT0gbnVsbDtcbiAgICAgIH0sXG4gICAgICBmaWVsZFRydXRoeTogZnVuY3Rpb24oZmllbGQpe1xuICAgICAgICBpZiggZWxlbWVudFtmaWVsZF0oKSApe1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBpZiggIWFsbE1ldGFNYXRjaGVzICl7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIC8vIGNoZWNrIGNvbGxlY3Rpb25cbiAgICBpZiggcXVlcnkuY29sbGVjdGlvbiAhPSBudWxsICl7XG4gICAgICB2YXIgbWF0Y2hlc0FueSA9IHF1ZXJ5LmNvbGxlY3Rpb24uX3ByaXZhdGUuaWRzWyBlbGVtZW50LmlkKCkgXSAhPSBudWxsO1xuICAgICAgXG4gICAgICBpZiggIW1hdGNoZXNBbnkgKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBjaGVjayBmaWx0ZXIgZnVuY3Rpb25cbiAgICBpZiggcXVlcnkuZmlsdGVyICE9IG51bGwgJiYgZWxlbWVudC5jb2xsZWN0aW9uKCkuZmlsdGVyKCBxdWVyeS5maWx0ZXIgKS5zaXplKCkgPT09IDAgKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG5cbiAgICAvLyBjaGVjayBwYXJlbnQvY2hpbGQgcmVsYXRpb25zXG4gICAgdmFyIGNvbmZpcm1SZWxhdGlvbnMgPSBmdW5jdGlvbiggcXVlcnksIGVsZW1lbnRzICl7XG4gICAgICBpZiggcXVlcnkgIT0gbnVsbCApe1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IGZhbHNlO1xuXG4gICAgICAgIGlmKCAhY3kuaGFzQ29tcG91bmROb2RlcygpICl7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudHMgPSBlbGVtZW50cygpOyAvLyBtYWtlIGVsZW1lbnRzIGZ1bmN0aW9uYWwgc28gd2Ugc2F2ZSBjeWNsZXMgaWYgcXVlcnkgPT0gbnVsbFxuXG4gICAgICAgIC8vIHF1ZXJ5IG11c3QgbWF0Y2ggZm9yIGF0IGxlYXN0IG9uZSBlbGVtZW50IChtYXkgYmUgcmVjdXJzaXZlKVxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgIGlmKCBxdWVyeU1hdGNoZXMoIHF1ZXJ5LCBlbGVtZW50c1tpXSApICl7XG4gICAgICAgICAgICBtYXRjaGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmICghIGNvbmZpcm1SZWxhdGlvbnMocXVlcnkucGFyZW50LCBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIGVsZW1lbnQucGFyZW50KCk7XG4gICAgfSkgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICBpZiAoISBjb25maXJtUmVsYXRpb25zKHF1ZXJ5LmFuY2VzdG9yLCBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIGVsZW1lbnQucGFyZW50cygpO1xuICAgIH0pICl7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgaWYgKCEgY29uZmlybVJlbGF0aW9ucyhxdWVyeS5jaGlsZCwgZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBlbGVtZW50LmNoaWxkcmVuKCk7XG4gICAgfSkgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICBpZiAoISBjb25maXJtUmVsYXRpb25zKHF1ZXJ5LmRlc2NlbmRhbnQsIGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gZWxlbWVudC5kZXNjZW5kYW50cygpO1xuICAgIH0pICl7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgLy8gd2UndmUgcmVhY2hlZCB0aGUgZW5kLCBzbyB3ZSd2ZSBtYXRjaGVkIGV2ZXJ5dGhpbmcgZm9yIHRoaXMgcXVlcnlcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTsgLy8gcXVlcnlNYXRjaGVzXG5cbiAgLy8gZmlsdGVyIGFuIGV4aXN0aW5nIGNvbGxlY3Rpb25cbiAgJCQuc2VsZm4uZmlsdGVyID0gZnVuY3Rpb24oY29sbGVjdGlvbil7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjeSA9IGNvbGxlY3Rpb24uY3koKTtcbiAgICBcbiAgICAvLyBkb24ndCBib3RoZXIgdHJ5aW5nIGlmIGl0J3MgaW52YWxpZFxuICAgIGlmKCBzZWxmLl9wcml2YXRlLmludmFsaWQgKXtcbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggY3kgKTtcbiAgICB9XG4gIFxuICAgIHZhciBzZWxlY3RvckZ1bmN0aW9uID0gZnVuY3Rpb24oaSwgZWxlbWVudCl7XG4gICAgICBmb3IodmFyIGogPSAwOyBqIDwgc2VsZi5sZW5ndGg7IGorKyl7XG4gICAgICAgIHZhciBxdWVyeSA9IHNlbGZbal07XG4gICAgICAgIFxuICAgICAgICBpZiggcXVlcnlNYXRjaGVzKHF1ZXJ5LCBlbGVtZW50KSApe1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFxuICAgIGlmKCBzZWxmLl9wcml2YXRlLnNlbGVjdG9yVGV4dCA9PSBudWxsICl7XG4gICAgICBzZWxlY3RvckZ1bmN0aW9uID0gZnVuY3Rpb24oKXsgcmV0dXJuIHRydWU7IH07XG4gICAgfVxuICAgIFxuICAgIHZhciBmaWx0ZXJlZENvbGxlY3Rpb24gPSBjb2xsZWN0aW9uLmZpbHRlciggc2VsZWN0b3JGdW5jdGlvbiApO1xuICAgIFxuICAgIHJldHVybiBmaWx0ZXJlZENvbGxlY3Rpb247XG4gIH07IC8vIGZpbHRlclxuXG4gIC8vIGRvZXMgc2VsZWN0b3IgbWF0Y2ggYSBzaW5nbGUgZWxlbWVudD9cbiAgJCQuc2VsZm4ubWF0Y2hlcyA9IGZ1bmN0aW9uKGVsZSl7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIFxuICAgIC8vIGRvbid0IGJvdGhlciB0cnlpbmcgaWYgaXQncyBpbnZhbGlkXG4gICAgaWYoIHNlbGYuX3ByaXZhdGUuaW52YWxpZCApe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgXG4gICAgZm9yKHZhciBqID0gMDsgaiA8IHNlbGYubGVuZ3RoOyBqKyspe1xuICAgICAgdmFyIHF1ZXJ5ID0gc2VsZltqXTtcbiAgICAgIFxuICAgICAgaWYoIHF1ZXJ5TWF0Y2hlcyhxdWVyeSwgZWxlKSApe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9OyAvLyBmaWx0ZXJcbiAgXG4gIC8vIGl0aCBxdWVyeSB0byBzdHJpbmdcbiAgJCQuc2VsZm4udG9TdHJpbmcgPSAkJC5zZWxmbi5zZWxlY3RvciA9IGZ1bmN0aW9uKCl7XG4gICAgXG4gICAgdmFyIHN0ciA9ICcnO1xuICAgIFxuICAgIHZhciBjbGVhbiA9IGZ1bmN0aW9uKG9iaiwgaXNWYWx1ZSl7XG4gICAgICBpZiggJCQuaXMuc3RyaW5nKG9iaikgKXtcbiAgICAgICAgcmV0dXJuIGlzVmFsdWUgPyAnXCInICsgb2JqICsgJ1wiJyA6IG9iajtcbiAgICAgIH0gXG4gICAgICByZXR1cm4gJyc7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgcXVlcnlUb1N0cmluZyA9IGZ1bmN0aW9uKHF1ZXJ5KXtcbiAgICAgIHZhciBzdHIgPSAnJztcblxuICAgICAgaWYoIHF1ZXJ5LnN1YmplY3QgPT09IHF1ZXJ5ICl7XG4gICAgICAgIHN0ciArPSAnJCc7XG4gICAgICB9XG5cbiAgICAgIHZhciBncm91cCA9IGNsZWFuKHF1ZXJ5Lmdyb3VwKTtcbiAgICAgIHN0ciArPSBncm91cC5zdWJzdHJpbmcoMCwgZ3JvdXAubGVuZ3RoIC0gMSk7XG4gICAgICBcbiAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBxdWVyeS5kYXRhLmxlbmd0aDsgaisrKXtcbiAgICAgICAgdmFyIGRhdGEgPSBxdWVyeS5kYXRhW2pdO1xuICAgICAgICBcbiAgICAgICAgaWYoIGRhdGEudmFsdWUgKXtcbiAgICAgICAgICBzdHIgKz0gJ1snICsgZGF0YS5maWVsZCArIGNsZWFuKGRhdGEub3BlcmF0b3IpICsgY2xlYW4oZGF0YS52YWx1ZSwgdHJ1ZSkgKyAnXSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyICs9ICdbJyArIGNsZWFuKGRhdGEub3BlcmF0b3IpICsgZGF0YS5maWVsZCArICddJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IodmFyIGogPSAwOyBqIDwgcXVlcnkubWV0YS5sZW5ndGg7IGorKyl7XG4gICAgICAgIHZhciBtZXRhID0gcXVlcnkubWV0YVtqXTtcbiAgICAgICAgc3RyICs9ICdbWycgKyBtZXRhLmZpZWxkICsgY2xlYW4obWV0YS5vcGVyYXRvcikgKyBjbGVhbihtZXRhLnZhbHVlLCB0cnVlKSArICddXSc7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBxdWVyeS5jb2xvblNlbGVjdG9ycy5sZW5ndGg7IGorKyl7XG4gICAgICAgIHZhciBzZWwgPSBxdWVyeS5jb2xvblNlbGVjdG9yc1tpXTtcbiAgICAgICAgc3RyICs9IHNlbDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZm9yKHZhciBqID0gMDsgaiA8IHF1ZXJ5Lmlkcy5sZW5ndGg7IGorKyl7XG4gICAgICAgIHZhciBzZWwgPSAnIycgKyBxdWVyeS5pZHNbaV07XG4gICAgICAgIHN0ciArPSBzZWw7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBxdWVyeS5jbGFzc2VzLmxlbmd0aDsgaisrKXtcbiAgICAgICAgdmFyIHNlbCA9ICcuJyArIHF1ZXJ5LmNsYXNzZXNbaV07XG4gICAgICAgIHN0ciArPSBzZWw7XG4gICAgICB9XG5cbiAgICAgIGlmKCBxdWVyeS5wYXJlbnQgIT0gbnVsbCApe1xuICAgICAgICBzdHIgPSBxdWVyeVRvU3RyaW5nKCBxdWVyeS5wYXJlbnQgKSArICcgPiAnICsgc3RyOyBcbiAgICAgIH1cblxuICAgICAgaWYoIHF1ZXJ5LmFuY2VzdG9yICE9IG51bGwgKXtcbiAgICAgICAgc3RyID0gcXVlcnlUb1N0cmluZyggcXVlcnkuYW5jZXN0b3IgKSArICcgJyArIHN0cjsgXG4gICAgICB9XG5cbiAgICAgIGlmKCBxdWVyeS5jaGlsZCAhPSBudWxsICl7XG4gICAgICAgIHN0ciArPSAnID4gJyArIHF1ZXJ5VG9TdHJpbmcoIHF1ZXJ5LmNoaWxkICk7IFxuICAgICAgfVxuXG4gICAgICBpZiggcXVlcnkuZGVzY2VuZGFudCAhPSBudWxsICl7XG4gICAgICAgIHN0ciArPSAnICcgKyBxdWVyeVRvU3RyaW5nKCBxdWVyeS5kZXNjZW5kYW50ICk7IFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyO1xuICAgIH07XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyl7XG4gICAgICB2YXIgcXVlcnkgPSB0aGlzW2ldO1xuICAgICAgXG4gICAgICBzdHIgKz0gcXVlcnlUb1N0cmluZyggcXVlcnkgKTtcbiAgICAgIFxuICAgICAgaWYoIHRoaXMubGVuZ3RoID4gMSAmJiBpIDwgdGhpcy5sZW5ndGggLSAxICl7XG4gICAgICAgIHN0ciArPSAnLCAnO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gc3RyO1xuICB9O1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICAkJC5TdHlsZSA9IGZ1bmN0aW9uKCBjeSApe1xuXG4gICAgaWYoICEodGhpcyBpbnN0YW5jZW9mICQkLlN0eWxlKSApe1xuICAgICAgcmV0dXJuIG5ldyAkJC5TdHlsZShjeSk7XG4gICAgfVxuXG4gICAgaWYoICEkJC5pcy5jb3JlKGN5KSApe1xuICAgICAgJCQudXRpbC5lcnJvcignQSBzdHlsZSBtdXN0IGhhdmUgYSBjb3JlIHJlZmVyZW5jZScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3ByaXZhdGUgPSB7XG4gICAgICBjeTogY3ksXG4gICAgICBjb3JlU3R5bGU6IHt9LFxuICAgICAgbmV3U3R5bGU6IHRydWVcbiAgICB9O1xuXG4gICAgdGhpcy5sZW5ndGggPSAwO1xuXG4gICAgdGhpcy5hZGREZWZhdWx0U3R5bGVzaGVldCgpO1xuICB9O1xuXG4gIC8vIG5pY2UtdG8taGF2ZSBhbGlhc2VzXG4gICQkLnN0eWxlID0gJCQuU3R5bGU7XG4gICQkLnN0eWZuID0gJCQuU3R5bGUucHJvdG90eXBlO1xuXG4gIC8vIGRlZmluZSBmdW5jdGlvbnMgaW4gdGhlIFN0eWxlIHByb3RvdHlwZVxuICAkJC5mbi5zdHlsZSA9IGZ1bmN0aW9uKCBmbk1hcCwgb3B0aW9ucyApe1xuICAgIGZvciggdmFyIGZuTmFtZSBpbiBmbk1hcCApe1xuICAgICAgdmFyIGZuID0gZm5NYXBbIGZuTmFtZSBdO1xuICAgICAgJCQuU3R5bGUucHJvdG90eXBlID0gZm47XG4gICAgfVxuICB9O1xuXG4gIChmdW5jdGlvbigpe1xuICAgIHZhciBudW1iZXIgPSAkJC51dGlsLnJlZ2V4Lm51bWJlcjtcbiAgICB2YXIgcmdiYSA9ICQkLnV0aWwucmVnZXgucmdiYU5vQmFja1JlZnM7XG4gICAgdmFyIGhzbGEgPSAkJC51dGlsLnJlZ2V4LmhzbGFOb0JhY2tSZWZzO1xuICAgIHZhciBoZXgzID0gJCQudXRpbC5yZWdleC5oZXgzO1xuICAgIHZhciBoZXg2ID0gJCQudXRpbC5yZWdleC5oZXg2O1xuICAgIHZhciBkYXRhID0gZnVuY3Rpb24oIHByZWZpeCApeyByZXR1cm4gJ14nICsgcHJlZml4ICsgJ1xcXFxzKlxcXFwoXFxcXHMqKFtcXFxcd1xcXFwuXSspXFxcXHMqXFxcXCkkJzsgfTtcbiAgICB2YXIgbWFwRGF0YSA9IGZ1bmN0aW9uKCBwcmVmaXggKXsgcmV0dXJuICdeJyArIHByZWZpeCArICdcXFxccypcXFxcKChbXFxcXHdcXFxcLl0rKVxcXFxzKlxcXFwsXFxcXHMqKCcgKyBudW1iZXIgKyAnKVxcXFxzKlxcXFwsXFxcXHMqKCcgKyBudW1iZXIgKyAnKVxcXFxzKixcXFxccyooJyArIG51bWJlciArICd8XFxcXHcrfCcgKyByZ2JhICsgJ3wnICsgaHNsYSArICd8JyArIGhleDMgKyAnfCcgKyBoZXg2ICsgJylcXFxccypcXFxcLFxcXFxzKignICsgbnVtYmVyICsgJ3xcXFxcdyt8JyArIHJnYmEgKyAnfCcgKyBoc2xhICsgJ3wnICsgaGV4MyArICd8JyArIGhleDYgKyAnKVxcXFwpJCc7IH07XG5cbiAgICAvLyBlYWNoIHZpc3VhbCBzdHlsZSBwcm9wZXJ0eSBoYXMgYSB0eXBlIGFuZCBuZWVkcyB0byBiZSB2YWxpZGF0ZWQgYWNjb3JkaW5nIHRvIGl0XG4gICAgJCQuc3R5bGUudHlwZXMgPSB7XG4gICAgICB0aW1lOiB7IG51bWJlcjogdHJ1ZSwgbWluOiAwLCB1bml0czogJ3N8bXMnLCBpbXBsaWNpdFVuaXRzOiAnbXMnIH0sXG4gICAgICBwZXJjZW50OiB7IG51bWJlcjogdHJ1ZSwgbWluOiAwLCBtYXg6IDEwMCwgdW5pdHM6ICclJyB9LFxuICAgICAgemVyb09uZU51bWJlcjogeyBudW1iZXI6IHRydWUsIG1pbjogMCwgbWF4OiAxLCB1bml0bGVzczogdHJ1ZSB9LFxuICAgICAgbk9uZU9uZU51bWJlcjogeyBudW1iZXI6IHRydWUsIG1pbjogLTEsIG1heDogMSwgdW5pdGxlc3M6IHRydWUgfSxcbiAgICAgIG5vbk5lZ2F0aXZlSW50OiB7IG51bWJlcjogdHJ1ZSwgbWluOiAwLCBpbnRlZ2VyOiB0cnVlLCB1bml0bGVzczogdHJ1ZSB9LFxuICAgICAgcG9zaXRpb246IHsgZW51bXM6IFsncGFyZW50JywgJ29yaWdpbiddIH0sXG4gICAgICBhdXRvU2l6ZTogeyBudW1iZXI6IHRydWUsIG1pbjogMCwgZW51bXM6IFsnYXV0byddIH0sXG4gICAgICBudW1iZXI6IHsgbnVtYmVyOiB0cnVlIH0sXG4gICAgICBzaXplOiB7IG51bWJlcjogdHJ1ZSwgbWluOiAwIH0sXG4gICAgICBiZ1NpemU6IHsgbnVtYmVyOiB0cnVlLCBtaW46IDAsIGFsbG93UGVyY2VudDogdHJ1ZSB9LFxuICAgICAgYmdXSDogeyBudW1iZXI6IHRydWUsIG1pbjogMCwgYWxsb3dQZXJjZW50OiB0cnVlLCBlbnVtczogWydhdXRvJ10gfSxcbiAgICAgIGJnUG9zOiB7IG51bWJlcjogdHJ1ZSwgYWxsb3dQZXJjZW50OiB0cnVlIH0sXG4gICAgICBiZ1JlcGVhdDogeyBlbnVtczogWydyZXBlYXQnLCAncmVwZWF0LXgnLCAncmVwZWF0LXknLCAnbm8tcmVwZWF0J10gfSxcbiAgICAgIGJnRml0OiB7IGVudW1zOiBbJ25vbmUnLCAnY29udGFpbicsICdjb3ZlciddIH0sXG4gICAgICBiZ0NsaXA6IHsgZW51bXM6IFsnbm9uZScsICdub2RlJ10gfSxcbiAgICAgIGNvbG9yOiB7IGNvbG9yOiB0cnVlIH0sXG4gICAgICBsaW5lU3R5bGU6IHsgZW51bXM6IFsnc29saWQnLCAnZG90dGVkJywgJ2Rhc2hlZCddIH0sXG4gICAgICBib3JkZXJTdHlsZTogeyBlbnVtczogWydzb2xpZCcsICdkb3R0ZWQnLCAnZGFzaGVkJywgJ2RvdWJsZSddIH0sXG4gICAgICBjdXJ2ZVN0eWxlOiB7IGVudW1zOiBbJ2JlemllcicsICd1bmJ1bmRsZWQtYmV6aWVyJywgJ2hheXN0YWNrJ10gfSxcbiAgICAgIGZvbnRGYW1pbHk6IHsgcmVnZXg6ICdeKFtcXFxcdy0gXFxcXFwiXSsoPzpcXFxccyosXFxcXHMqW1xcXFx3LSBcXFxcXCJdKykqKSQnIH0sXG4gICAgICBmb250VmFyaWFudDogeyBlbnVtczogWydzbWFsbC1jYXBzJywgJ25vcm1hbCddIH0sXG4gICAgICBmb250U3R5bGU6IHsgZW51bXM6IFsnaXRhbGljJywgJ25vcm1hbCcsICdvYmxpcXVlJ10gfSxcbiAgICAgIGZvbnRXZWlnaHQ6IHsgZW51bXM6IFsnbm9ybWFsJywgJ2JvbGQnLCAnYm9sZGVyJywgJ2xpZ2h0ZXInLCAnMTAwJywgJzIwMCcsICczMDAnLCAnNDAwJywgJzUwMCcsICc2MDAnLCAnODAwJywgJzkwMCcsIDEwMCwgMjAwLCAzMDAsIDQwMCwgNTAwLCA2MDAsIDcwMCwgODAwLCA5MDBdIH0sXG4gICAgICB0ZXh0RGVjb3JhdGlvbjogeyBlbnVtczogWydub25lJywgJ3VuZGVybGluZScsICdvdmVybGluZScsICdsaW5lLXRocm91Z2gnXSB9LFxuICAgICAgdGV4dFRyYW5zZm9ybTogeyBlbnVtczogWydub25lJywgJ3VwcGVyY2FzZScsICdsb3dlcmNhc2UnXSB9LFxuICAgICAgdGV4dFdyYXA6IHsgZW51bXM6IFsnbm9uZScsICd3cmFwJ10gfSxcbiAgICAgIHRleHRCYWNrZ3JvdW5kU2hhcGU6IHsgZW51bXM6IFsncmVjdGFuZ2xlJywgJ3JvdW5kcmVjdGFuZ2xlJ119LFxuICAgICAgbm9kZVNoYXBlOiB7IGVudW1zOiBbJ3JlY3RhbmdsZScsICdyb3VuZHJlY3RhbmdsZScsICdlbGxpcHNlJywgJ3RyaWFuZ2xlJywgJ3NxdWFyZScsICdwZW50YWdvbicsICdoZXhhZ29uJywgJ2hlcHRhZ29uJywgJ29jdGFnb24nLCAnc3RhcicsICdkaWFtb25kJywgJ3ZlZScsICdyaG9tYm9pZCddIH0sXG4gICAgICBjb21wb3VuZEluY2x1ZGVMYWJlbHM6IHsgZW51bXM6IFsnaW5jbHVkZScsICdleGNsdWRlJ10gfSxcbiAgICAgIGFycm93U2hhcGU6IHsgZW51bXM6IFsndGVlJywgJ3RyaWFuZ2xlJywgJ3RyaWFuZ2xlLXRlZScsICd0cmlhbmdsZS1iYWNrY3VydmUnLCAnaGFsZi10cmlhbmdsZS1vdmVyc2hvdCcsICdzcXVhcmUnLCAnY2lyY2xlJywgJ2RpYW1vbmQnLCAnbm9uZSddIH0sXG4gICAgICBhcnJvd0ZpbGw6IHsgZW51bXM6IFsnZmlsbGVkJywgJ2hvbGxvdyddIH0sXG4gICAgICBkaXNwbGF5OiB7IGVudW1zOiBbJ2VsZW1lbnQnLCAnbm9uZSddIH0sXG4gICAgICB2aXNpYmlsaXR5OiB7IGVudW1zOiBbJ2hpZGRlbicsICd2aXNpYmxlJ10gfSxcbiAgICAgIHZhbGlnbjogeyBlbnVtczogWyd0b3AnLCAnY2VudGVyJywgJ2JvdHRvbSddIH0sXG4gICAgICBoYWxpZ246IHsgZW51bXM6IFsnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnXSB9LFxuICAgICAgdGV4dDogeyBzdHJpbmc6IHRydWUgfSxcbiAgICAgIGRhdGE6IHsgbWFwcGluZzogdHJ1ZSwgcmVnZXg6IGRhdGEoJ2RhdGEnKSB9LFxuICAgICAgbGF5b3V0RGF0YTogeyBtYXBwaW5nOiB0cnVlLCByZWdleDogZGF0YSgnbGF5b3V0RGF0YScpIH0sXG4gICAgICBzY3JhdGNoOiB7IG1hcHBpbmc6IHRydWUsIHJlZ2V4OiBkYXRhKCdzY3JhdGNoJykgfSxcbiAgICAgIG1hcERhdGE6IHsgbWFwcGluZzogdHJ1ZSwgcmVnZXg6IG1hcERhdGEoJ21hcERhdGEnKSB9LFxuICAgICAgbWFwTGF5b3V0RGF0YTogeyBtYXBwaW5nOiB0cnVlLCByZWdleDogbWFwRGF0YSgnbWFwTGF5b3V0RGF0YScpIH0sXG4gICAgICBtYXBTY3JhdGNoOiB7IG1hcHBpbmc6IHRydWUsIHJlZ2V4OiBtYXBEYXRhKCdtYXBTY3JhdGNoJykgfSxcbiAgICAgIGZuOiB7IG1hcHBpbmc6IHRydWUsIGZuOiB0cnVlIH0sXG4gICAgICB1cmw6IHsgcmVnZXg6ICdedXJsXFxcXHMqXFxcXChcXFxccyooW15cXFxcc10rKVxcXFxzKlxcXFxzKlxcXFwpfG5vbmV8KC4rKSQnIH0sXG4gICAgICBwcm9wTGlzdDogeyBwcm9wTGlzdDogdHJ1ZSB9LFxuICAgICAgYW5nbGU6IHsgbnVtYmVyOiB0cnVlLCB1bml0czogJ2RlZ3xyYWQnIH0sXG4gICAgICB0ZXh0Um90YXRpb246IHsgZW51bXM6IFsnbm9uZScsICdhdXRvcm90YXRlJ10gfVxuICAgIH07XG5cbiAgICAvLyBkZWZpbmUgdmlzdWFsIHN0eWxlIHByb3BlcnRpZXNcbiAgICB2YXIgdCA9ICQkLnN0eWxlLnR5cGVzO1xuICAgIHZhciBwcm9wcyA9ICQkLnN0eWxlLnByb3BlcnRpZXMgPSBbXG4gICAgICAvLyBsYWJlbHNcbiAgICAgIHsgbmFtZTogJ3RleHQtdmFsaWduJywgdHlwZTogdC52YWxpZ24gfSxcbiAgICAgIHsgbmFtZTogJ3RleHQtaGFsaWduJywgdHlwZTogdC5oYWxpZ24gfSxcbiAgICAgIHsgbmFtZTogJ2NvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgICAgeyBuYW1lOiAnY29udGVudCcsIHR5cGU6IHQudGV4dCB9LFxuICAgICAgeyBuYW1lOiAndGV4dC1vdXRsaW5lLWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgICAgeyBuYW1lOiAndGV4dC1vdXRsaW5lLXdpZHRoJywgdHlwZTogdC5zaXplIH0sXG4gICAgICB7IG5hbWU6ICd0ZXh0LW91dGxpbmUtb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgICAgeyBuYW1lOiAndGV4dC1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG4gICAgICB7IG5hbWU6ICd0ZXh0LWJhY2tncm91bmQtY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgICB7IG5hbWU6ICd0ZXh0LWJhY2tncm91bmQtb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgICAgeyBuYW1lOiAndGV4dC1ib3JkZXItb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgICAgeyBuYW1lOiAndGV4dC1ib3JkZXItY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgICB7IG5hbWU6ICd0ZXh0LWJvcmRlci13aWR0aCcsIHR5cGU6IHQuc2l6ZSB9LFxuICAgICAgeyBuYW1lOiAndGV4dC1ib3JkZXItc3R5bGUnLCB0eXBlOiB0LmJvcmRlclN0eWxlIH0sXG4gICAgICB7IG5hbWU6ICd0ZXh0LWJhY2tncm91bmQtc2hhcGUnLCB0eXBlOiB0LnRleHRCYWNrZ3JvdW5kU2hhcGV9LFxuICAgICAgLy8geyBuYW1lOiAndGV4dC1kZWNvcmF0aW9uJywgdHlwZTogdC50ZXh0RGVjb3JhdGlvbiB9LCAvLyBub3Qgc3VwcG9ydGVkIGluIGNhbnZhc1xuICAgICAgeyBuYW1lOiAndGV4dC10cmFuc2Zvcm0nLCB0eXBlOiB0LnRleHRUcmFuc2Zvcm0gfSxcbiAgICAgIHsgbmFtZTogJ3RleHQtd3JhcCcsIHR5cGU6IHQudGV4dFdyYXAgfSxcbiAgICAgIHsgbmFtZTogJ3RleHQtbWF4LXdpZHRoJywgdHlwZTogdC5zaXplIH0sXG5cbiAgICAgIC8vIHsgbmFtZTogJ3RleHQtcm90YXRpb24nLCB0eXBlOiB0LmFuZ2xlIH0sIC8vIFRPRE8gZGlzYWJsZWQgYi9jIHJvdGF0aW9uIGJyZWFrcyBib3VuZGluZyBib3hlc1xuICAgICAgeyBuYW1lOiAnZm9udC1mYW1pbHknLCB0eXBlOiB0LmZvbnRGYW1pbHkgfSxcbiAgICAgIHsgbmFtZTogJ2ZvbnQtc3R5bGUnLCB0eXBlOiB0LmZvbnRTdHlsZSB9LFxuICAgICAgLy8geyBuYW1lOiAnZm9udC12YXJpYW50JywgdHlwZTogdC5mb250VmFyaWFudCB9LCAvLyBub3QgdXNlZnVsXG4gICAgICB7IG5hbWU6ICdmb250LXdlaWdodCcsIHR5cGU6IHQuZm9udFdlaWdodCB9LFxuICAgICAgeyBuYW1lOiAnZm9udC1zaXplJywgdHlwZTogdC5zaXplIH0sXG4gICAgICB7IG5hbWU6ICdtaW4tem9vbWVkLWZvbnQtc2l6ZScsIHR5cGU6IHQuc2l6ZSB9LFxuICAgICAgeyBuYW1lOiAnZWRnZS10ZXh0LXJvdGF0aW9uJywgdHlwZTogdC50ZXh0Um90YXRpb24gfSxcblxuICAgICAgLy8gdmlzaWJpbGl0eVxuICAgICAgeyBuYW1lOiAnZGlzcGxheScsIHR5cGU6IHQuZGlzcGxheSB9LFxuICAgICAgeyBuYW1lOiAndmlzaWJpbGl0eScsIHR5cGU6IHQudmlzaWJpbGl0eSB9LFxuICAgICAgeyBuYW1lOiAnb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgICAgeyBuYW1lOiAnei1pbmRleCcsIHR5cGU6IHQubm9uTmVnYXRpdmVJbnQgfSxcblxuICAgICAgLy8gb3ZlcmxheXNcbiAgICAgIHsgbmFtZTogJ292ZXJsYXktcGFkZGluZycsIHR5cGU6IHQuc2l6ZSB9LFxuICAgICAgeyBuYW1lOiAnb3ZlcmxheS1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICAgIHsgbmFtZTogJ292ZXJsYXktb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuXG4gICAgICAvLyBzaGFkb3dzXG4gICAgICB7IG5hbWU6ICdzaGFkb3ctYmx1cicsIHR5cGU6IHQuc2l6ZSB9LFxuICAgICAgeyBuYW1lOiAnc2hhZG93LWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgICAgeyBuYW1lOiAnc2hhZG93LW9wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSxcbiAgICAgIHsgbmFtZTogJ3NoYWRvdy1vZmZzZXQteCcsIHR5cGU6IHQubnVtYmVyIH0sXG4gICAgICB7IG5hbWU6ICdzaGFkb3ctb2Zmc2V0LXknLCB0eXBlOiB0Lm51bWJlciB9LFxuXG4gICAgICAvLyBsYWJlbCBzaGFkb3dzXG4gICAgICB7IG5hbWU6ICd0ZXh0LXNoYWRvdy1ibHVyJywgdHlwZTogdC5zaXplIH0sXG4gICAgICB7IG5hbWU6ICd0ZXh0LXNoYWRvdy1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICAgIHsgbmFtZTogJ3RleHQtc2hhZG93LW9wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSxcbiAgICAgIHsgbmFtZTogJ3RleHQtc2hhZG93LW9mZnNldC14JywgdHlwZTogdC5udW1iZXIgfSxcbiAgICAgIHsgbmFtZTogJ3RleHQtc2hhZG93LW9mZnNldC15JywgdHlwZTogdC5udW1iZXIgfSxcblxuICAgICAgLy8gdHJhbnNpdGlvbiBhbmlzXG4gICAgICB7IG5hbWU6ICd0cmFuc2l0aW9uLXByb3BlcnR5JywgdHlwZTogdC5wcm9wTGlzdCB9LFxuICAgICAgeyBuYW1lOiAndHJhbnNpdGlvbi1kdXJhdGlvbicsIHR5cGU6IHQudGltZSB9LFxuICAgICAgeyBuYW1lOiAndHJhbnNpdGlvbi1kZWxheScsIHR5cGU6IHQudGltZSB9LFxuXG4gICAgICAvLyBub2RlIGJvZHlcbiAgICAgIHsgbmFtZTogJ2hlaWdodCcsIHR5cGU6IHQuYXV0b1NpemUgfSxcbiAgICAgIHsgbmFtZTogJ3dpZHRoJywgdHlwZTogdC5hdXRvU2l6ZSB9LFxuICAgICAgeyBuYW1lOiAnc2hhcGUnLCB0eXBlOiB0Lm5vZGVTaGFwZSB9LFxuICAgICAgeyBuYW1lOiAnYmFja2dyb3VuZC1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICAgIHsgbmFtZTogJ2JhY2tncm91bmQtb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgICAgeyBuYW1lOiAnYmFja2dyb3VuZC1ibGFja2VuJywgdHlwZTogdC5uT25lT25lTnVtYmVyIH0sXG5cbiAgICAgIC8vIG5vZGUgYm9yZGVyXG4gICAgICB7IG5hbWU6ICdib3JkZXItY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgICB7IG5hbWU6ICdib3JkZXItb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgICAgeyBuYW1lOiAnYm9yZGVyLXdpZHRoJywgdHlwZTogdC5zaXplIH0sXG4gICAgICB7IG5hbWU6ICdib3JkZXItc3R5bGUnLCB0eXBlOiB0LmJvcmRlclN0eWxlIH0sXG5cbiAgICAgIC8vIG5vZGUgYmFja2dyb3VuZCBpbWFnZXNcbiAgICAgIHsgbmFtZTogJ2JhY2tncm91bmQtaW1hZ2UnLCB0eXBlOiB0LnVybCB9LFxuICAgICAgeyBuYW1lOiAnYmFja2dyb3VuZC1pbWFnZS1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG4gICAgICB7IG5hbWU6ICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXgnLCB0eXBlOiB0LmJnUG9zIH0sXG4gICAgICB7IG5hbWU6ICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXknLCB0eXBlOiB0LmJnUG9zIH0sXG4gICAgICB7IG5hbWU6ICdiYWNrZ3JvdW5kLXJlcGVhdCcsIHR5cGU6IHQuYmdSZXBlYXQgfSxcbiAgICAgIHsgbmFtZTogJ2JhY2tncm91bmQtZml0JywgdHlwZTogdC5iZ0ZpdCB9LFxuICAgICAgeyBuYW1lOiAnYmFja2dyb3VuZC1jbGlwJywgdHlwZTogdC5iZ0NsaXAgfSxcbiAgICAgIHsgbmFtZTogJ2JhY2tncm91bmQtd2lkdGgnLCB0eXBlOiB0LmJnV0ggfSxcbiAgICAgIHsgbmFtZTogJ2JhY2tncm91bmQtaGVpZ2h0JywgdHlwZTogdC5iZ1dIIH0sXG5cbiAgICAgIC8vIGNvbXBvdW5kIHByb3BzXG4gICAgICB7IG5hbWU6ICdwYWRkaW5nLWxlZnQnLCB0eXBlOiB0LnNpemUgfSxcbiAgICAgIHsgbmFtZTogJ3BhZGRpbmctcmlnaHQnLCB0eXBlOiB0LnNpemUgfSxcbiAgICAgIHsgbmFtZTogJ3BhZGRpbmctdG9wJywgdHlwZTogdC5zaXplIH0sXG4gICAgICB7IG5hbWU6ICdwYWRkaW5nLWJvdHRvbScsIHR5cGU6IHQuc2l6ZSB9LFxuICAgICAgeyBuYW1lOiAncG9zaXRpb24nLCB0eXBlOiB0LnBvc2l0aW9uIH0sXG4gICAgICB7IG5hbWU6ICdjb21wb3VuZC1zaXppbmctd3J0LWxhYmVscycsIHR5cGU6IHQuY29tcG91bmRJbmNsdWRlTGFiZWxzIH0sXG5cbiAgICAgIC8vIGVkZ2UgbGluZVxuICAgICAgeyBuYW1lOiAnbGluZS1zdHlsZScsIHR5cGU6IHQubGluZVN0eWxlIH0sXG4gICAgICB7IG5hbWU6ICdsaW5lLWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgICAgeyBuYW1lOiAnY29udHJvbC1wb2ludC1zdGVwLXNpemUnLCB0eXBlOiB0LnNpemUgfSxcbiAgICAgIHsgbmFtZTogJ2NvbnRyb2wtcG9pbnQtZGlzdGFuY2UnLCB0eXBlOiB0Lm51bWJlciB9LFxuICAgICAgeyBuYW1lOiAnY29udHJvbC1wb2ludC13ZWlnaHQnLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSxcbiAgICAgIHsgbmFtZTogJ2N1cnZlLXN0eWxlJywgdHlwZTogdC5jdXJ2ZVN0eWxlIH0sXG4gICAgICB7IG5hbWU6ICdoYXlzdGFjay1yYWRpdXMnLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSxcblxuICAgICAgLy8gZWRnZSBhcnJvd3NcbiAgICAgIHsgbmFtZTogJ3NvdXJjZS1hcnJvdy1zaGFwZScsIHR5cGU6IHQuYXJyb3dTaGFwZSB9LFxuICAgICAgeyBuYW1lOiAndGFyZ2V0LWFycm93LXNoYXBlJywgdHlwZTogdC5hcnJvd1NoYXBlIH0sXG4gICAgICB7IG5hbWU6ICdtaWQtc291cmNlLWFycm93LXNoYXBlJywgdHlwZTogdC5hcnJvd1NoYXBlIH0sXG4gICAgICB7IG5hbWU6ICdtaWQtdGFyZ2V0LWFycm93LXNoYXBlJywgdHlwZTogdC5hcnJvd1NoYXBlIH0sXG4gICAgICB7IG5hbWU6ICdzb3VyY2UtYXJyb3ctY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgICB7IG5hbWU6ICd0YXJnZXQtYXJyb3ctY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgICB7IG5hbWU6ICdtaWQtc291cmNlLWFycm93LWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgICAgeyBuYW1lOiAnbWlkLXRhcmdldC1hcnJvdy1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICAgIHsgbmFtZTogJ3NvdXJjZS1hcnJvdy1maWxsJywgdHlwZTogdC5hcnJvd0ZpbGwgfSxcbiAgICAgIHsgbmFtZTogJ3RhcmdldC1hcnJvdy1maWxsJywgdHlwZTogdC5hcnJvd0ZpbGwgfSxcbiAgICAgIHsgbmFtZTogJ21pZC1zb3VyY2UtYXJyb3ctZmlsbCcsIHR5cGU6IHQuYXJyb3dGaWxsIH0sXG4gICAgICB7IG5hbWU6ICdtaWQtdGFyZ2V0LWFycm93LWZpbGwnLCB0eXBlOiB0LmFycm93RmlsbCB9LFxuXG4gICAgICAvLyB0aGVzZSBhcmUganVzdCBmb3IgdGhlIGNvcmVcbiAgICAgIHsgbmFtZTogJ3NlbGVjdGlvbi1ib3gtY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgICB7IG5hbWU6ICdzZWxlY3Rpb24tYm94LW9wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSxcbiAgICAgIHsgbmFtZTogJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgICAgeyBuYW1lOiAnc2VsZWN0aW9uLWJveC1ib3JkZXItd2lkdGgnLCB0eXBlOiB0LnNpemUgfSxcbiAgICAgIHsgbmFtZTogJ2FjdGl2ZS1iZy1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICAgIHsgbmFtZTogJ2FjdGl2ZS1iZy1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG4gICAgICB7IG5hbWU6ICdhY3RpdmUtYmctc2l6ZScsIHR5cGU6IHQuc2l6ZSB9LFxuICAgICAgeyBuYW1lOiAnb3V0c2lkZS10ZXh0dXJlLWJnLWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgICAgeyBuYW1lOiAnb3V0c2lkZS10ZXh0dXJlLWJnLW9wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfVxuICAgIF07XG5cbiAgICAvLyBwaWUgYmFja2dyb3VuZHMgZm9yIG5vZGVzXG4gICAgJCQuc3R5bGUucGllQmFja2dyb3VuZE4gPSAxNjsgLy8gYmVjYXVzZSB0aGUgcGllIHByb3BlcnRpZXMgYXJlIG51bWJlcmVkLCBnaXZlIGFjY2VzcyB0byBhIGNvbnN0YW50IE4gKGZvciByZW5kZXJlciB1c2UpXG4gICAgcHJvcHMucHVzaCh7IG5hbWU6ICdwaWUtc2l6ZScsIHR5cGU6IHQuYmdTaXplIH0pO1xuICAgIGZvciggdmFyIGkgPSAxOyBpIDw9ICQkLnN0eWxlLnBpZUJhY2tncm91bmROOyBpKysgKXtcbiAgICAgIHByb3BzLnB1c2goeyBuYW1lOiAncGllLScraSsnLWJhY2tncm91bmQtY29sb3InLCB0eXBlOiB0LmNvbG9yIH0pO1xuICAgICAgcHJvcHMucHVzaCh7IG5hbWU6ICdwaWUtJytpKyctYmFja2dyb3VuZC1zaXplJywgdHlwZTogdC5wZXJjZW50IH0pO1xuICAgICAgcHJvcHMucHVzaCh7IG5hbWU6ICdwaWUtJytpKyctYmFja2dyb3VuZC1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0pO1xuICAgIH1cblxuICAgIC8vIGFsbG93IGFjY2VzcyBvZiBwcm9wZXJ0aWVzIGJ5IG5hbWUgKCBlLmcuICQkLnN0eWxlLnByb3BlcnRpZXMuaGVpZ2h0IClcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuXG4gICAgICBwcm9wc1sgcHJvcC5uYW1lIF0gPSBwcm9wOyAvLyBhbGxvdyBsb29rdXAgYnkgbmFtZVxuICAgIH1cbiAgfSkoKTtcblxuICAvLyBhZGRzIHRoZSBkZWZhdWx0IHN0eWxlc2hlZXQgdG8gdGhlIGN1cnJlbnQgc3R5bGVcbiAgJCQuc3R5Zm4uYWRkRGVmYXVsdFN0eWxlc2hlZXQgPSBmdW5jdGlvbigpe1xuICAgIC8vIHRvIGJlIG5pY2UsIHdlIGJ1aWxkIGZvbnQgcmVsYXRlZCBzdHlsZSBwcm9wZXJ0aWVzIGZyb20gdGhlIGNvcmUgY29udGFpbmVyXG4gICAgLy8gc28gdGhhdCBjeXRvc2NhcGUgbWF0Y2hlcyB0aGUgc3R5bGUgb2YgaXRzIGNvbnRhaW5lciBieSBkZWZhdWx0XG4gICAgLy9cbiAgICAvLyB1bmZvcnR1bmF0ZWx5LCB0aGlzIGRvZXNuJ3Qgc2VlbSB3b3JrIGNvbnNpc3RlbnRseSBhbmQgY2FuIGdyYWIgdGhlIGRlZmF1bHQgc3R5bGVzaGVldCB2YWx1ZXNcbiAgICAvLyBpbnN0ZWFkIG9mIHRoZSBkZXZlbG9wZXIncyB2YWx1ZXMgc28gbGV0J3MganVzdCBtYWtlIGl0IGV4cGxpY2l0IGZvciB0aGUgZGV2IGZvciBub3dcbiAgICAvL1xuICAgIC8vIGRlbGF5aW5nIHRoZSByZWFkIG9mIHRoZXNlIHZhbCdzIGlzIG5vdCBhbiBvcHQnbjogdGhhdCB3b3VsZCBkZWxheSBpbml0J2wgbG9hZCB0aW1lXG4gICAgdmFyIGZvbnRGYW1pbHkgPSAnSGVsdmV0aWNhJyB8fCB0aGlzLmNvbnRhaW5lclByb3BlcnR5QXNTdHJpbmcoJ2ZvbnQtZmFtaWx5JykgfHwgJ3NhbnMtc2VyaWYnO1xuICAgIHZhciBmb250U3R5bGUgPSAnbm9ybWFsJyB8fCB0aGlzLmNvbnRhaW5lclByb3BlcnR5QXNTdHJpbmcoJ2ZvbnQtc3R5bGUnKSB8fCAnbm9ybWFsJztcbiAgICAvLyB2YXIgZm9udFZhcmlhbnQgPSAnbm9ybWFsJyB8fCB0aGlzLmNvbnRhaW5lclByb3BlcnR5QXNTdHJpbmcoJ2ZvbnQtdmFyaWFudCcpIHx8ICdub3JtYWwnO1xuICAgIHZhciBmb250V2VpZ2h0ID0gJ25vcm1hbCcgfHwgdGhpcy5jb250YWluZXJQcm9wZXJ0eUFzU3RyaW5nKCdmb250LXdlaWdodCcpIHx8ICdub3JtYWwnO1xuICAgIHZhciBjb2xvciA9ICcjMDAwJyB8fCB0aGlzLmNvbnRhaW5lclByb3BlcnR5QXNTdHJpbmcoJ2NvbG9yJykgfHwgJyMwMDAnO1xuICAgIHZhciB0ZXh0VHJhbnNmb3JtID0gJ25vbmUnIHx8IHRoaXMuY29udGFpbmVyUHJvcGVydHlBc1N0cmluZygndGV4dC10cmFuc2Zvcm0nKSB8fCAnbm9uZSc7XG4gICAgdmFyIGZvbnRTaXplID0gMTYgfHwgdGhpcy5jb250YWluZXJQcm9wZXJ0eUFzU3RyaW5nKCdmb250LXNpemUnKSB8fCAxNjtcbiAgICB2YXIgdGV4dE1heFdpZHRoID0gOTk5OSB8fCB0aGlzLmNvbnRhaW5lclByb3BlcnR5QXNTdHJpbmcoJ3RleHQtbWF4LXdpZHRoJykgfHwgOTk5OTtcblxuICAgIC8vIGZpbGwgdGhlIHN0eWxlIHdpdGggdGhlIGRlZmF1bHQgc3R5bGVzaGVldFxuICAgIHRoaXNcbiAgICAgIC5zZWxlY3Rvcignbm9kZSwgZWRnZScpIC8vIGNvbW1vbiBwcm9wZXJ0aWVzXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICd0ZXh0LXZhbGlnbic6ICd0b3AnLFxuICAgICAgICAgICd0ZXh0LWhhbGlnbic6ICdjZW50ZXInLFxuICAgICAgICAgICdjb2xvcic6IGNvbG9yLFxuICAgICAgICAgICd0ZXh0LW91dGxpbmUtY29sb3InOiAnIzAwMCcsXG4gICAgICAgICAgJ3RleHQtb3V0bGluZS13aWR0aCc6IDAsXG4gICAgICAgICAgJ3RleHQtb3V0bGluZS1vcGFjaXR5JzogMSxcbiAgICAgICAgICAndGV4dC1vcGFjaXR5JzogMSxcbiAgICAgICAgICAndGV4dC1kZWNvcmF0aW9uJzogJ25vbmUnLFxuICAgICAgICAgICd0ZXh0LXRyYW5zZm9ybSc6IHRleHRUcmFuc2Zvcm0sXG4gICAgICAgICAgJ3RleHQtd3JhcCc6ICdub25lJyxcbiAgICAgICAgICAndGV4dC1tYXgtd2lkdGgnOiB0ZXh0TWF4V2lkdGgsXG4gICAgICAgICAgJ3RleHQtYmFja2dyb3VuZC1jb2xvcic6ICcjMDAwJyxcbiAgICAgICAgICAndGV4dC1iYWNrZ3JvdW5kLW9wYWNpdHknOiAwLFxuICAgICAgICAgICd0ZXh0LWJvcmRlci1vcGFjaXR5JzogMCxcbiAgICAgICAgICAndGV4dC1ib3JkZXItd2lkdGgnOiAwLFxuICAgICAgICAgICd0ZXh0LWJvcmRlci1zdHlsZSc6ICdzb2xpZCcsXG4gICAgICAgICAgJ3RleHQtYm9yZGVyLWNvbG9yJzonIzAwMCcsXG4gICAgICAgICAgJ3RleHQtYmFja2dyb3VuZC1zaGFwZSc6J3JlY3RhbmdsZScsXG4gICAgICAgICAgJ2ZvbnQtZmFtaWx5JzogZm9udEZhbWlseSxcbiAgICAgICAgICAnZm9udC1zdHlsZSc6IGZvbnRTdHlsZSxcbiAgICAgICAgICAvLyAnZm9udC12YXJpYW50JzogZm9udFZhcmlhbnQsXG4gICAgICAgICAgJ2ZvbnQtd2VpZ2h0JzogZm9udFdlaWdodCxcbiAgICAgICAgICAnZm9udC1zaXplJzogZm9udFNpemUsXG4gICAgICAgICAgJ21pbi16b29tZWQtZm9udC1zaXplJzogMCxcbiAgICAgICAgICAnZWRnZS10ZXh0LXJvdGF0aW9uJzogJ25vbmUnLFxuICAgICAgICAgICd2aXNpYmlsaXR5JzogJ3Zpc2libGUnLFxuICAgICAgICAgICdkaXNwbGF5JzogJ2VsZW1lbnQnLFxuICAgICAgICAgICdvcGFjaXR5JzogMSxcbiAgICAgICAgICAnei1pbmRleCc6IDAsXG4gICAgICAgICAgJ2NvbnRlbnQnOiAnJyxcbiAgICAgICAgICAnb3ZlcmxheS1vcGFjaXR5JzogMCxcbiAgICAgICAgICAnb3ZlcmxheS1jb2xvcic6ICcjMDAwJyxcbiAgICAgICAgICAnb3ZlcmxheS1wYWRkaW5nJzogMTAsXG4gICAgICAgICAgJ3NoYWRvdy1vcGFjaXR5JzogMCxcbiAgICAgICAgICAnc2hhZG93LWNvbG9yJzogJyMwMDAnLFxuICAgICAgICAgICdzaGFkb3ctYmx1cic6IDEwLFxuICAgICAgICAgICdzaGFkb3ctb2Zmc2V0LXgnOiAwLFxuICAgICAgICAgICdzaGFkb3ctb2Zmc2V0LXknOiAwLFxuICAgICAgICAgICd0ZXh0LXNoYWRvdy1vcGFjaXR5JzogMCxcbiAgICAgICAgICAndGV4dC1zaGFkb3ctY29sb3InOiAnIzAwMCcsXG4gICAgICAgICAgJ3RleHQtc2hhZG93LWJsdXInOiA1LFxuICAgICAgICAgICd0ZXh0LXNoYWRvdy1vZmZzZXQteCc6IDAsXG4gICAgICAgICAgJ3RleHQtc2hhZG93LW9mZnNldC15JzogMCxcbiAgICAgICAgICAndHJhbnNpdGlvbi1wcm9wZXJ0eSc6ICdub25lJyxcbiAgICAgICAgICAndHJhbnNpdGlvbi1kdXJhdGlvbic6IDAsXG4gICAgICAgICAgJ3RyYW5zaXRpb24tZGVsYXknOiAwLFxuXG4gICAgICAgICAgLy8gbm9kZSBwcm9wc1xuICAgICAgICAgICdiYWNrZ3JvdW5kLWJsYWNrZW4nOiAwLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJyM4ODgnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLW9wYWNpdHknOiAxLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWltYWdlJzogJ25vbmUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWltYWdlLW9wYWNpdHknOiAxLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXgnOiAnNTAlJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1wb3NpdGlvbi15JzogJzUwJScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtcmVwZWF0JzogJ25vLXJlcGVhdCcsXG4gICAgICAgICAgJ2JhY2tncm91bmQtZml0JzogJ25vbmUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWNsaXAnOiAnbm9kZScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtd2lkdGgnOiAnYXV0bycsXG4gICAgICAgICAgJ2JhY2tncm91bmQtaGVpZ2h0JzogJ2F1dG8nLFxuICAgICAgICAgICdib3JkZXItY29sb3InOiAnIzAwMCcsXG4gICAgICAgICAgJ2JvcmRlci1vcGFjaXR5JzogMSxcbiAgICAgICAgICAnYm9yZGVyLXdpZHRoJzogMCxcbiAgICAgICAgICAnYm9yZGVyLXN0eWxlJzogJ3NvbGlkJyxcbiAgICAgICAgICAnaGVpZ2h0JzogMzAsXG4gICAgICAgICAgJ3dpZHRoJzogMzAsXG4gICAgICAgICAgJ3NoYXBlJzogJ2VsbGlwc2UnLFxuXG4gICAgICAgICAgLy8gY29tcG91bmQgcHJvcHNcbiAgICAgICAgICAncGFkZGluZy10b3AnOiAwLFxuICAgICAgICAgICdwYWRkaW5nLWJvdHRvbSc6IDAsXG4gICAgICAgICAgJ3BhZGRpbmctbGVmdCc6IDAsXG4gICAgICAgICAgJ3BhZGRpbmctcmlnaHQnOiAwLFxuICAgICAgICAgICdwb3NpdGlvbic6ICdvcmlnaW4nLFxuICAgICAgICAgICdjb21wb3VuZC1zaXppbmctd3J0LWxhYmVscyc6ICdpbmNsdWRlJyxcblxuXG4gICAgICAgICAgLy8gbm9kZSBwaWUgYmdcbiAgICAgICAgICAncGllLXNpemUnOiAnMTAwJScsXG4gICAgICAgICAgJ3BpZS0xLWJhY2tncm91bmQtY29sb3InOiAnYmxhY2snLFxuICAgICAgICAgICdwaWUtMi1iYWNrZ3JvdW5kLWNvbG9yJzogJ2JsYWNrJyxcbiAgICAgICAgICAncGllLTMtYmFja2dyb3VuZC1jb2xvcic6ICdibGFjaycsXG4gICAgICAgICAgJ3BpZS00LWJhY2tncm91bmQtY29sb3InOiAnYmxhY2snLFxuICAgICAgICAgICdwaWUtNS1iYWNrZ3JvdW5kLWNvbG9yJzogJ2JsYWNrJyxcbiAgICAgICAgICAncGllLTYtYmFja2dyb3VuZC1jb2xvcic6ICdibGFjaycsXG4gICAgICAgICAgJ3BpZS03LWJhY2tncm91bmQtY29sb3InOiAnYmxhY2snLFxuICAgICAgICAgICdwaWUtOC1iYWNrZ3JvdW5kLWNvbG9yJzogJ2JsYWNrJyxcbiAgICAgICAgICAncGllLTktYmFja2dyb3VuZC1jb2xvcic6ICdibGFjaycsXG4gICAgICAgICAgJ3BpZS0xMC1iYWNrZ3JvdW5kLWNvbG9yJzogJ2JsYWNrJyxcbiAgICAgICAgICAncGllLTExLWJhY2tncm91bmQtY29sb3InOiAnYmxhY2snLFxuICAgICAgICAgICdwaWUtMTItYmFja2dyb3VuZC1jb2xvcic6ICdibGFjaycsXG4gICAgICAgICAgJ3BpZS0xMy1iYWNrZ3JvdW5kLWNvbG9yJzogJ2JsYWNrJyxcbiAgICAgICAgICAncGllLTE0LWJhY2tncm91bmQtY29sb3InOiAnYmxhY2snLFxuICAgICAgICAgICdwaWUtMTUtYmFja2dyb3VuZC1jb2xvcic6ICdibGFjaycsXG4gICAgICAgICAgJ3BpZS0xNi1iYWNrZ3JvdW5kLWNvbG9yJzogJ2JsYWNrJyxcbiAgICAgICAgICAncGllLTEtYmFja2dyb3VuZC1zaXplJzogJzAlJyxcbiAgICAgICAgICAncGllLTItYmFja2dyb3VuZC1zaXplJzogJzAlJyxcbiAgICAgICAgICAncGllLTMtYmFja2dyb3VuZC1zaXplJzogJzAlJyxcbiAgICAgICAgICAncGllLTQtYmFja2dyb3VuZC1zaXplJzogJzAlJyxcbiAgICAgICAgICAncGllLTUtYmFja2dyb3VuZC1zaXplJzogJzAlJyxcbiAgICAgICAgICAncGllLTYtYmFja2dyb3VuZC1zaXplJzogJzAlJyxcbiAgICAgICAgICAncGllLTctYmFja2dyb3VuZC1zaXplJzogJzAlJyxcbiAgICAgICAgICAncGllLTgtYmFja2dyb3VuZC1zaXplJzogJzAlJyxcbiAgICAgICAgICAncGllLTktYmFja2dyb3VuZC1zaXplJzogJzAlJyxcbiAgICAgICAgICAncGllLTEwLWJhY2tncm91bmQtc2l6ZSc6ICcwJScsXG4gICAgICAgICAgJ3BpZS0xMS1iYWNrZ3JvdW5kLXNpemUnOiAnMCUnLFxuICAgICAgICAgICdwaWUtMTItYmFja2dyb3VuZC1zaXplJzogJzAlJyxcbiAgICAgICAgICAncGllLTEzLWJhY2tncm91bmQtc2l6ZSc6ICcwJScsXG4gICAgICAgICAgJ3BpZS0xNC1iYWNrZ3JvdW5kLXNpemUnOiAnMCUnLFxuICAgICAgICAgICdwaWUtMTUtYmFja2dyb3VuZC1zaXplJzogJzAlJyxcbiAgICAgICAgICAncGllLTE2LWJhY2tncm91bmQtc2l6ZSc6ICcwJScsXG4gICAgICAgICAgJ3BpZS0xLWJhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3BpZS0yLWJhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3BpZS0zLWJhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3BpZS00LWJhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3BpZS01LWJhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3BpZS02LWJhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3BpZS03LWJhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3BpZS04LWJhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3BpZS05LWJhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3BpZS0xMC1iYWNrZ3JvdW5kLW9wYWNpdHknOiAxLFxuICAgICAgICAgICdwaWUtMTEtYmFja2dyb3VuZC1vcGFjaXR5JzogMSxcbiAgICAgICAgICAncGllLTEyLWJhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3BpZS0xMy1iYWNrZ3JvdW5kLW9wYWNpdHknOiAxLFxuICAgICAgICAgICdwaWUtMTQtYmFja2dyb3VuZC1vcGFjaXR5JzogMSxcbiAgICAgICAgICAncGllLTE1LWJhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3BpZS0xNi1iYWNrZ3JvdW5kLW9wYWNpdHknOiAxLFxuXG4gICAgICAgICAgLy8gZWRnZSBwcm9wc1xuICAgICAgICAgICdzb3VyY2UtYXJyb3ctc2hhcGUnOiAnbm9uZScsXG4gICAgICAgICAgJ21pZC1zb3VyY2UtYXJyb3ctc2hhcGUnOiAnbm9uZScsXG4gICAgICAgICAgJ3RhcmdldC1hcnJvdy1zaGFwZSc6ICdub25lJyxcbiAgICAgICAgICAnbWlkLXRhcmdldC1hcnJvdy1zaGFwZSc6ICdub25lJyxcbiAgICAgICAgICAnc291cmNlLWFycm93LWNvbG9yJzogJyNkZGQnLFxuICAgICAgICAgICdtaWQtc291cmNlLWFycm93LWNvbG9yJzogJyNkZGQnLFxuICAgICAgICAgICd0YXJnZXQtYXJyb3ctY29sb3InOiAnI2RkZCcsXG4gICAgICAgICAgJ21pZC10YXJnZXQtYXJyb3ctY29sb3InOiAnI2RkZCcsXG4gICAgICAgICAgJ3NvdXJjZS1hcnJvdy1maWxsJzogJ2ZpbGxlZCcsXG4gICAgICAgICAgJ21pZC1zb3VyY2UtYXJyb3ctZmlsbCc6ICdmaWxsZWQnLFxuICAgICAgICAgICd0YXJnZXQtYXJyb3ctZmlsbCc6ICdmaWxsZWQnLFxuICAgICAgICAgICdtaWQtdGFyZ2V0LWFycm93LWZpbGwnOiAnZmlsbGVkJyxcbiAgICAgICAgICAnbGluZS1zdHlsZSc6ICdzb2xpZCcsXG4gICAgICAgICAgJ2xpbmUtY29sb3InOiAnI2RkZCcsXG4gICAgICAgICAgJ2NvbnRyb2wtcG9pbnQtc3RlcC1zaXplJzogNDAsXG4gICAgICAgICAgJ2NvbnRyb2wtcG9pbnQtd2VpZ2h0JzogMC41LFxuICAgICAgICAgICdjdXJ2ZS1zdHlsZSc6ICdiZXppZXInLFxuICAgICAgICAgICdoYXlzdGFjay1yYWRpdXMnOiAwLjhcbiAgICAgICAgfSlcbiAgICAgIC5zZWxlY3RvcignJG5vZGUgPiBub2RlJykgLy8gY29tcG91bmQgKHBhcmVudCkgbm9kZSBwcm9wZXJ0aWVzXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICd3aWR0aCc6ICdhdXRvJyxcbiAgICAgICAgICAnaGVpZ2h0JzogJ2F1dG8nLFxuICAgICAgICAgICdzaGFwZSc6ICdyZWN0YW5nbGUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLW9wYWNpdHknOiAwLjUsXG4gICAgICAgICAgJ3BhZGRpbmctdG9wJzogMTAsXG4gICAgICAgICAgJ3BhZGRpbmctcmlnaHQnOiAxMCxcbiAgICAgICAgICAncGFkZGluZy1sZWZ0JzogMTAsXG4gICAgICAgICAgJ3BhZGRpbmctYm90dG9tJzogMTBcbiAgICAgICAgfSlcbiAgICAgIC5zZWxlY3RvcignZWRnZScpIC8vIGp1c3QgZWRnZSBwcm9wZXJ0aWVzXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICd3aWR0aCc6IDFcbiAgICAgICAgfSlcbiAgICAgIC5zZWxlY3RvcignOmFjdGl2ZScpXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICdvdmVybGF5LWNvbG9yJzogJ2JsYWNrJyxcbiAgICAgICAgICAnb3ZlcmxheS1wYWRkaW5nJzogMTAsXG4gICAgICAgICAgJ292ZXJsYXktb3BhY2l0eSc6IDAuMjVcbiAgICAgICAgfSlcbiAgICAgIC5zZWxlY3RvcignY29yZScpIC8vIGp1c3QgY29yZSBwcm9wZXJ0aWVzXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICdzZWxlY3Rpb24tYm94LWNvbG9yJzogJyNkZGQnLFxuICAgICAgICAgICdzZWxlY3Rpb24tYm94LW9wYWNpdHknOiAwLjY1LFxuICAgICAgICAgICdzZWxlY3Rpb24tYm94LWJvcmRlci1jb2xvcic6ICcjYWFhJyxcbiAgICAgICAgICAnc2VsZWN0aW9uLWJveC1ib3JkZXItd2lkdGgnOiAxLFxuICAgICAgICAgICdhY3RpdmUtYmctY29sb3InOiAnYmxhY2snLFxuICAgICAgICAgICdhY3RpdmUtYmctb3BhY2l0eSc6IDAuMTUsXG4gICAgICAgICAgJ2FjdGl2ZS1iZy1zaXplJzogMzAsXG4gICAgICAgICAgJ291dHNpZGUtdGV4dHVyZS1iZy1jb2xvcic6ICcjMDAwJyxcbiAgICAgICAgICAnb3V0c2lkZS10ZXh0dXJlLWJnLW9wYWNpdHknOiAwLjEyNVxuICAgICAgICB9KVxuICAgIDtcblxuICAgIHRoaXMuZGVmYXVsdExlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICB9O1xuXG4gIC8vIHJlbW92ZSBhbGwgY29udGV4dHNcbiAgJCQuc3R5Zm4uY2xlYXIgPSBmdW5jdGlvbigpe1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdGhpc1tpXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX3ByaXZhdGUubmV3U3R5bGUgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG5cbiAgJCQuc3R5Zm4ucmVzZXRUb0RlZmF1bHQgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuY2xlYXIoKTtcbiAgICB0aGlzLmFkZERlZmF1bHRTdHlsZXNoZWV0KCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBidWlsZHMgYSBzdHlsZSBvYmplY3QgZm9yIHRoZSAnY29yZScgc2VsZWN0b3JcbiAgJCQuc3R5Zm4uY29yZSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuY29yZVN0eWxlO1xuICB9O1xuXG4gIC8vIHBhcnNlIGEgcHJvcGVydHk7IHJldHVybiBudWxsIG9uIGludmFsaWQ7IHJldHVybiBwYXJzZWQgcHJvcGVydHkgb3RoZXJ3aXNlXG4gIC8vIGZpZWxkcyA6XG4gIC8vIC0gbmFtZSA6IHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eVxuICAvLyAtIHZhbHVlIDogdGhlIHBhcnNlZCwgbmF0aXZlLXR5cGVkIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eVxuICAvLyAtIHN0clZhbHVlIDogYSBzdHJpbmcgdmFsdWUgdGhhdCByZXByZXNlbnRzIHRoZSBwcm9wZXJ0eSB2YWx1ZSBpbiB2YWxpZCBjc3NcbiAgLy8gLSBieXBhc3MgOiB0cnVlIGlmZiB0aGUgcHJvcGVydHkgaXMgYSBieXBhc3MgcHJvcGVydHlcbiAgJCQuc3R5Zm4ucGFyc2UgPSBmdW5jdGlvbiggbmFtZSwgdmFsdWUsIHByb3BJc0J5cGFzcywgcHJvcElzRmxhdCApe1xuXG4gICAgbmFtZSA9ICQkLnV0aWwuY2FtZWwyZGFzaCggbmFtZSApOyAvLyBtYWtlIHN1cmUgdGhlIHByb3BlcnR5IG5hbWUgaXMgaW4gZGFzaCBmb3JtIChlLmcuICdwcm9wZXJ0eS1uYW1lJyBub3QgJ3Byb3BlcnR5TmFtZScpXG4gICAgdmFyIHByb3BlcnR5ID0gJCQuc3R5bGUucHJvcGVydGllc1sgbmFtZSBdO1xuICAgIHZhciBwYXNzZWRWYWx1ZSA9IHZhbHVlO1xuICAgIHZhciB0eXBlcyA9ICQkLnN0eWxlLnR5cGVzO1xuXG4gICAgaWYoICFwcm9wZXJ0eSApeyByZXR1cm4gbnVsbDsgfSAvLyByZXR1cm4gbnVsbCBvbiBwcm9wZXJ0eSBvZiB1bmtub3duIG5hbWVcbiAgICBpZiggdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCApeyByZXR1cm4gbnVsbDsgfSAvLyBjYW4ndCBhc3NpZ24gbnVsbFxuXG4gICAgdmFyIHZhbHVlSXNTdHJpbmcgPSAkJC5pcy5zdHJpbmcodmFsdWUpO1xuICAgIGlmKCB2YWx1ZUlzU3RyaW5nICl7IC8vIHRyaW0gdGhlIHZhbHVlIHRvIG1ha2UgcGFyc2luZyBlYXNpZXJcbiAgICAgIHZhbHVlID0gJCQudXRpbC50cmltKCB2YWx1ZSApO1xuICAgIH1cblxuICAgIHZhciB0eXBlID0gcHJvcGVydHkudHlwZTtcbiAgICBpZiggIXR5cGUgKXsgcmV0dXJuIG51bGw7IH0gLy8gbm8gdHlwZSwgbm8gbHVja1xuXG4gICAgLy8gY2hlY2sgaWYgYnlwYXNzIGlzIG51bGwgb3IgZW1wdHkgc3RyaW5nIChpLmUuIGluZGljYXRpb24gdG8gZGVsZXRlIGJ5cGFzcyBwcm9wZXJ0eSlcbiAgICBpZiggcHJvcElzQnlwYXNzICYmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IG51bGwpICl7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGJ5cGFzczogdHJ1ZSxcbiAgICAgICAgZGVsZXRlQnlwYXNzOiB0cnVlXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBoYXNQaWUgPSBuYW1lLm1hdGNoKC9waWUtKFxcZCspLWJhY2tncm91bmQtc2l6ZS8pO1xuXG4gICAgLy8gY2hlY2sgaWYgdmFsdWUgaXMgYSBmdW5jdGlvbiB1c2VkIGFzIGEgbWFwcGVyXG4gICAgaWYoICQkLmlzLmZuKHZhbHVlKSApe1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBzdHJWYWx1ZTogJ2ZuJyxcbiAgICAgICAgbWFwcGVkOiB0eXBlcy5mbixcbiAgICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3MsXG4gICAgICAgIGhhc1BpZTogaGFzUGllXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIHZhbHVlIGlzIG1hcHBlZFxuICAgIHZhciBkYXRhLCBtYXBEYXRhLCBsYXlvdXREYXRhLCBtYXBMYXlvdXREYXRhLCBzY3JhdGNoLCBtYXBTY3JhdGNoO1xuICAgIGlmKCAhdmFsdWVJc1N0cmluZyB8fCBwcm9wSXNGbGF0ICl7XG4gICAgICAvLyB0aGVuIGRvbid0IGJvdGhlciB0byBkbyB0aGUgZXhwZW5zaXZlIHJlZ2V4IGNoZWNrc1xuXG4gICAgfSBlbHNlIGlmKFxuICAgICAgKCBkYXRhID0gbmV3IFJlZ0V4cCggdHlwZXMuZGF0YS5yZWdleCApLmV4ZWMoIHZhbHVlICkgKSB8fFxuICAgICAgKCBsYXlvdXREYXRhID0gbmV3IFJlZ0V4cCggdHlwZXMubGF5b3V0RGF0YS5yZWdleCApLmV4ZWMoIHZhbHVlICkgKSB8fFxuICAgICAgKCBzY3JhdGNoID0gbmV3IFJlZ0V4cCggdHlwZXMuc2NyYXRjaC5yZWdleCApLmV4ZWMoIHZhbHVlICkgKVxuICAgICl7XG4gICAgICBpZiggcHJvcElzQnlwYXNzICl7IHJldHVybiBmYWxzZTsgfSAvLyBtYXBwZXJzIG5vdCBhbGxvd2VkIGluIGJ5cGFzc1xuXG4gICAgICB2YXIgbWFwcGVkO1xuICAgICAgaWYoIGRhdGEgKXtcbiAgICAgICAgbWFwcGVkID0gdHlwZXMuZGF0YTtcbiAgICAgIH0gZWxzZSBpZiggbGF5b3V0RGF0YSApe1xuICAgICAgICBtYXBwZWQgPSB0eXBlcy5sYXlvdXREYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFwcGVkID0gdHlwZXMuc2NyYXRjaDtcbiAgICAgIH1cblxuICAgICAgZGF0YSA9IGRhdGEgfHwgbGF5b3V0RGF0YSB8fCBzY3JhdGNoO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB2YWx1ZTogZGF0YSxcbiAgICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICAgIG1hcHBlZDogbWFwcGVkLFxuICAgICAgICBmaWVsZDogZGF0YVsxXSxcbiAgICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3MsXG4gICAgICAgIGhhc1BpZTogaGFzUGllXG4gICAgICB9O1xuXG4gICAgfSBlbHNlIGlmKFxuICAgICAgKCBtYXBEYXRhID0gbmV3IFJlZ0V4cCggdHlwZXMubWFwRGF0YS5yZWdleCApLmV4ZWMoIHZhbHVlICkgKSB8fFxuICAgICAgKCBtYXBMYXlvdXREYXRhID0gbmV3IFJlZ0V4cCggdHlwZXMubWFwTGF5b3V0RGF0YS5yZWdleCApLmV4ZWMoIHZhbHVlICkgKSB8fFxuICAgICAgKCBtYXBTY3JhdGNoID0gbmV3IFJlZ0V4cCggdHlwZXMubWFwU2NyYXRjaC5yZWdleCApLmV4ZWMoIHZhbHVlICkgKVxuICAgICl7XG4gICAgICBpZiggcHJvcElzQnlwYXNzICl7IHJldHVybiBmYWxzZTsgfSAvLyBtYXBwZXJzIG5vdCBhbGxvd2VkIGluIGJ5cGFzc1xuXG4gICAgICB2YXIgbWFwcGVkO1xuICAgICAgaWYoIG1hcERhdGEgKXtcbiAgICAgICAgbWFwcGVkID0gdHlwZXMubWFwRGF0YTtcbiAgICAgIH0gZWxzZSBpZiggbWFwTGF5b3V0RGF0YSApe1xuICAgICAgICBtYXBwZWQgPSB0eXBlcy5tYXBMYXlvdXREYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFwcGVkID0gdHlwZXMubWFwU2NyYXRjaDtcbiAgICAgIH1cblxuICAgICAgbWFwRGF0YSA9IG1hcERhdGEgfHwgbWFwTGF5b3V0RGF0YSB8fCBtYXBTY3JhdGNoO1xuXG4gICAgICAvLyB3ZSBjYW4gbWFwIG9ubHkgaWYgdGhlIHR5cGUgaXMgYSBjb2xvdXIgb3IgYSBudW1iZXJcbiAgICAgIGlmKCAhKHR5cGUuY29sb3IgfHwgdHlwZS5udW1iZXIpICl7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgICB2YXIgdmFsdWVNaW4gPSB0aGlzLnBhcnNlKCBuYW1lLCBtYXBEYXRhWzRdKTsgLy8gcGFyc2UgdG8gdmFsaWRhdGVcbiAgICAgIGlmKCAhdmFsdWVNaW4gfHwgdmFsdWVNaW4ubWFwcGVkICl7IHJldHVybiBmYWxzZTsgfSAvLyBjYW4ndCBiZSBpbnZhbGlkIG9yIG1hcHBlZFxuXG4gICAgICB2YXIgdmFsdWVNYXggPSB0aGlzLnBhcnNlKCBuYW1lLCBtYXBEYXRhWzVdKTsgLy8gcGFyc2UgdG8gdmFsaWRhdGVcbiAgICAgIGlmKCAhdmFsdWVNYXggfHwgdmFsdWVNYXgubWFwcGVkICl7IHJldHVybiBmYWxzZTsgfSAvLyBjYW4ndCBiZSBpbnZhbGlkIG9yIG1hcHBlZFxuXG4gICAgICAvLyBjaGVjayBpZiB2YWx1ZU1pbiBhbmQgdmFsdWVNYXggYXJlIHRoZSBzYW1lXG4gICAgICBpZiggdmFsdWVNaW4udmFsdWUgPT09IHZhbHVlTWF4LnZhbHVlICl7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gY2FuJ3QgbWFrZSBtdWNoIG9mIGEgbWFwcGVyIHdpdGhvdXQgYSByYW5nZVxuXG4gICAgICB9IGVsc2UgaWYoIHR5cGUuY29sb3IgKXtcbiAgICAgICAgdmFyIGMxID0gdmFsdWVNaW4udmFsdWU7XG4gICAgICAgIHZhciBjMiA9IHZhbHVlTWF4LnZhbHVlO1xuXG4gICAgICAgIHZhciBzYW1lID0gYzFbMF0gPT09IGMyWzBdIC8vIHJlZFxuICAgICAgICAgICYmIGMxWzFdID09PSBjMlsxXSAvLyBncmVlblxuICAgICAgICAgICYmIGMxWzJdID09PSBjMlsyXSAvLyBibHVlXG4gICAgICAgICAgJiYgKCAvLyBvcHRpb25hbCBhbHBoYVxuICAgICAgICAgICAgYzFbM10gPT09IGMyWzNdIC8vIHNhbWUgYWxwaGEgb3V0cmlnaHRcbiAgICAgICAgICAgIHx8IChcbiAgICAgICAgICAgICAgKGMxWzNdID09IG51bGwgfHwgYzFbM10gPT09IDEpIC8vIGZ1bGwgb3BhY2l0eSBmb3IgY29sb3VyIDE/XG4gICAgICAgICAgICAgICYmXG4gICAgICAgICAgICAgIChjMlszXSA9PSBudWxsIHx8IGMyWzNdID09PSAxKSAvLyBmdWxsIG9wYWNpdHkgZm9yIGNvbG91ciAyP1xuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgO1xuXG4gICAgICAgIGlmKCBzYW1lICl7IHJldHVybiBmYWxzZTsgfSAvLyBjYW4ndCBtYWtlIGEgbWFwcGVyIHdpdGhvdXQgYSByYW5nZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB2YWx1ZTogbWFwRGF0YSxcbiAgICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICAgIG1hcHBlZDogbWFwcGVkLFxuICAgICAgICBmaWVsZDogbWFwRGF0YVsxXSxcbiAgICAgICAgZmllbGRNaW46IHBhcnNlRmxvYXQoIG1hcERhdGFbMl0gKSwgLy8gbWluICYgbWF4IGFyZSBudW1lcmljXG4gICAgICAgIGZpZWxkTWF4OiBwYXJzZUZsb2F0KCBtYXBEYXRhWzNdICksXG4gICAgICAgIHZhbHVlTWluOiB2YWx1ZU1pbi52YWx1ZSxcbiAgICAgICAgdmFsdWVNYXg6IHZhbHVlTWF4LnZhbHVlLFxuICAgICAgICBieXBhc3M6IHByb3BJc0J5cGFzcyxcbiAgICAgICAgaGFzUGllOiBoYXNQaWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgdGhlIHR5cGUgYW5kIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgb2JqZWN0XG4gICAgaWYoIHR5cGUubnVtYmVyICl7XG4gICAgICB2YXIgdW5pdHM7XG4gICAgICB2YXIgaW1wbGljaXRVbml0cyA9ICdweCc7IC8vIG5vdCBzZXQgPT4gcHhcblxuICAgICAgaWYoIHR5cGUudW5pdHMgKXsgLy8gdXNlIHNwZWNpZmllZCB1bml0cyBpZiBzZXRcbiAgICAgICAgdW5pdHMgPSB0eXBlLnVuaXRzO1xuICAgICAgfVxuXG4gICAgICBpZiggdHlwZS5pbXBsaWNpdFVuaXRzICl7XG4gICAgICAgIGltcGxpY2l0VW5pdHMgPSB0eXBlLmltcGxpY2l0VW5pdHM7XG4gICAgICB9XG5cbiAgICAgIGlmKCAhdHlwZS51bml0bGVzcyApe1xuICAgICAgICBpZiggdmFsdWVJc1N0cmluZyApe1xuICAgICAgICAgIHZhciB1bml0c1JlZ2V4ID0gJ3B4fGVtJyArICh0eXBlLmFsbG93UGVyY2VudCA/ICd8XFxcXCUnIDogJycpO1xuICAgICAgICAgIGlmKCB1bml0cyApeyB1bml0c1JlZ2V4ID0gdW5pdHM7IH0gLy8gb25seSBhbGxvdyBleHBsaWNpdCB1bml0cyBpZiBzbyBzZXRcbiAgICAgICAgICB2YXIgbWF0Y2ggPSB2YWx1ZS5tYXRjaCggJ14oJyArICQkLnV0aWwucmVnZXgubnVtYmVyICsgJykoJyArIHVuaXRzUmVnZXggKyAnKT8nICsgJyQnICk7XG5cbiAgICAgICAgICBpZiggbWF0Y2ggKXtcbiAgICAgICAgICAgIHZhbHVlID0gbWF0Y2hbMV07XG4gICAgICAgICAgICB1bml0cyA9IG1hdGNoWzJdIHx8IGltcGxpY2l0VW5pdHM7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiggIXVuaXRzIHx8IHR5cGUuaW1wbGljaXRVbml0cyApIHtcbiAgICAgICAgICB1bml0cyA9IGltcGxpY2l0VW5pdHM7IC8vIGltcGxpY2l0bHkgcHggaWYgdW5zcGVjaWZpZWRcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQoIHZhbHVlICk7XG5cbiAgICAgIC8vIGlmIG5vdCBhIG51bWJlciBhbmQgZW51bXMgbm90IGFsbG93ZWQsIHRoZW4gdGhlIHZhbHVlIGlzIGludmFsaWRcbiAgICAgIGlmKCBpc05hTih2YWx1ZSkgJiYgdHlwZS5lbnVtcyA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBjaGVjayBpZiB0aGlzIG51bWJlciB0eXBlIGFsc28gYWNjZXB0cyBzcGVjaWFsIGtleXdvcmRzIGluIHBsYWNlIG9mIG51bWJlcnNcbiAgICAgIC8vIChpLmUuIGBsZWZ0YCwgYGF1dG9gLCBldGMpXG4gICAgICBpZiggaXNOYU4odmFsdWUpICYmIHR5cGUuZW51bXMgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICB2YWx1ZSA9IHBhc3NlZFZhbHVlO1xuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdHlwZS5lbnVtcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlbiA9IHR5cGUuZW51bXNbaV07XG5cbiAgICAgICAgICBpZiggZW4gPT09IHZhbHVlICl7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgICAgICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDsgLy8gZmFpbGVkIG9uIGVudW0gYWZ0ZXIgZmFpbGluZyBvbiBudW1iZXJcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgaWYgdmFsdWUgbXVzdCBiZSBhbiBpbnRlZ2VyXG4gICAgICBpZiggdHlwZS5pbnRlZ2VyICYmICEkJC5pcy5pbnRlZ2VyKHZhbHVlKSApe1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgdmFsdWUgaXMgd2l0aGluIHJhbmdlXG4gICAgICBpZiggKHR5cGUubWluICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgPCB0eXBlLm1pbilcbiAgICAgIHx8ICh0eXBlLm1heCAhPT0gdW5kZWZpbmVkICYmIHZhbHVlID4gdHlwZS5tYXgpXG4gICAgICApe1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSArICh1bml0cyA/IHVuaXRzIDogJycpLFxuICAgICAgICB1bml0czogdW5pdHMsXG4gICAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzLFxuICAgICAgICBoYXNQaWU6IGhhc1BpZSAmJiB2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSAwICYmIHZhbHVlICE9PSAnJ1xuICAgICAgfTtcblxuICAgICAgLy8gbm9ybWFsaXNlIHZhbHVlIGluIHBpeGVsc1xuICAgICAgaWYoIHR5cGUudW5pdGxlc3MgfHwgKHVuaXRzICE9PSAncHgnICYmIHVuaXRzICE9PSAnZW0nKSApe1xuICAgICAgICAvLyB0aGVuIHB4VmFsdWUgZG9lcyBub3QgYXBwbHlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldC5weFZhbHVlID0gKCB1bml0cyA9PT0gJ3B4JyB8fCAhdW5pdHMgPyAodmFsdWUpIDogKHRoaXMuZ2V0RW1TaXplSW5QaXhlbHMoKSAqIHZhbHVlKSApO1xuICAgICAgfVxuXG4gICAgICAvLyBub3JtYWxpc2UgdmFsdWUgaW4gbXNcbiAgICAgIGlmKCB1bml0cyA9PT0gJ21zJyB8fCB1bml0cyA9PT0gJ3MnICl7XG4gICAgICAgIHJldC5tc1ZhbHVlID0gdW5pdHMgPT09ICdtcycgPyB2YWx1ZSA6IDEwMDAgKiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcblxuICAgIH0gZWxzZSBpZiggdHlwZS5wcm9wTGlzdCApIHtcblxuICAgICAgdmFyIHByb3BzID0gW107XG4gICAgICB2YXIgcHJvcHNTdHIgPSAnJyArIHZhbHVlO1xuXG4gICAgICBpZiggcHJvcHNTdHIgPT09ICdub25lJyApe1xuICAgICAgICAvLyBsZWF2ZSBlbXB0eVxuXG4gICAgICB9IGVsc2UgeyAvLyBnbyBvdmVyIGVhY2ggcHJvcFxuXG4gICAgICAgIHZhciBwcm9wc1NwbGl0ID0gcHJvcHNTdHIuc3BsaXQoJywnKTtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwcm9wc1NwbGl0Lmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIHByb3BOYW1lID0gJCQudXRpbC50cmltKCBwcm9wc1NwbGl0W2ldICk7XG5cbiAgICAgICAgICBpZiggJCQuc3R5bGUucHJvcGVydGllc1twcm9wTmFtZV0gKXtcbiAgICAgICAgICAgIHByb3BzLnB1c2goIHByb3BOYW1lICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoIHByb3BzLmxlbmd0aCA9PT0gMCApeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHZhbHVlOiBwcm9wcyxcbiAgICAgICAgc3RyVmFsdWU6IHByb3BzLmxlbmd0aCA9PT0gMCA/ICdub25lJyA6IHByb3BzLmpvaW4oJywgJyksXG4gICAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgICB9O1xuXG4gICAgfSBlbHNlIGlmKCB0eXBlLmNvbG9yICl7XG4gICAgICB2YXIgdHVwbGUgPSAkJC51dGlsLmNvbG9yMnR1cGxlKCB2YWx1ZSApO1xuXG4gICAgICBpZiggIXR1cGxlICl7IHJldHVybiBudWxsOyB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHZhbHVlOiB0dXBsZSxcbiAgICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgICB9O1xuXG4gICAgfSBlbHNlIGlmKCB0eXBlLmVudW1zICl7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHR5cGUuZW51bXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVuID0gdHlwZS5lbnVtc1tpXTtcblxuICAgICAgICBpZiggZW4gPT09IHZhbHVlICl7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSxcbiAgICAgICAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIH0gZWxzZSBpZiggdHlwZS5yZWdleCApe1xuICAgICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCggdHlwZS5yZWdleCApOyAvLyBtYWtlIGEgcmVnZXggZnJvbSB0aGUgdHlwZVxuICAgICAgdmFyIG0gPSByZWdleC5leGVjKCB2YWx1ZSApO1xuXG4gICAgICBpZiggbSApeyAvLyByZWdleCBtYXRjaGVzXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICB2YWx1ZTogbSxcbiAgICAgICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSxcbiAgICAgICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHsgLy8gcmVnZXggZG9lc24ndCBtYXRjaFxuICAgICAgICByZXR1cm4gbnVsbDsgLy8gZGlkbid0IG1hdGNoIHRoZSByZWdleCBzbyB0aGUgdmFsdWUgaXMgYm9ndXNcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiggdHlwZS5zdHJpbmcgKXtcbiAgICAgIC8vIGp1c3QgcmV0dXJuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgICAgfTtcblxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDsgLy8gbm90IGEgdHlwZSB3ZSBjYW4gaGFuZGxlXG4gICAgfVxuXG4gIH07XG5cbiAgLy8gY3JlYXRlIGEgbmV3IGNvbnRleHQgZnJvbSB0aGUgc3BlY2lmaWVkIHNlbGVjdG9yIHN0cmluZyBhbmQgc3dpdGNoIHRvIHRoYXQgY29udGV4dFxuICAkJC5zdHlmbi5zZWxlY3RvciA9IGZ1bmN0aW9uKCBzZWxlY3RvclN0ciApe1xuICAgIC8vICdjb3JlJyBpcyBhIHNwZWNpYWwgY2FzZSBhbmQgZG9lcyBub3QgbmVlZCBhIHNlbGVjdG9yXG4gICAgdmFyIHNlbGVjdG9yID0gc2VsZWN0b3JTdHIgPT09ICdjb3JlJyA/IG51bGwgOiBuZXcgJCQuU2VsZWN0b3IoIHNlbGVjdG9yU3RyICk7XG5cbiAgICB2YXIgaSA9IHRoaXMubGVuZ3RoKys7IC8vIG5ldyBjb250ZXh0IG1lYW5zIG5ldyBpbmRleFxuICAgIHRoaXNbaV0gPSB7XG4gICAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXG4gICAgICBwcm9wZXJ0aWVzOiBbXSxcbiAgICAgIG1hcHBlZFByb3BlcnRpZXM6IFtdLFxuICAgICAgaW5kZXg6IGlcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG5cbiAgLy8gYWRkIG9uZSBvciBtYW55IGNzcyBydWxlcyB0byB0aGUgY3VycmVudCBjb250ZXh0XG4gICQkLnN0eWZuLmNzcyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICBzd2l0Y2goIGFyZ3MubGVuZ3RoICl7XG4gICAgY2FzZSAxOlxuICAgICAgdmFyIG1hcCA9IGFyZ3NbMF07XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgJCQuc3R5bGUucHJvcGVydGllcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgcHJvcCA9ICQkLnN0eWxlLnByb3BlcnRpZXNbaV07XG4gICAgICAgIHZhciBtYXBWYWwgPSBtYXBbIHByb3AubmFtZSBdO1xuXG4gICAgICAgIGlmKCBtYXBWYWwgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgIG1hcFZhbCA9IG1hcFsgJCQudXRpbC5kYXNoMmNhbWVsKHByb3AubmFtZSkgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBtYXBWYWwgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgIHRoaXMuY3NzUnVsZSggcHJvcC5uYW1lLCBtYXBWYWwgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMjpcbiAgICAgIHRoaXMuY3NzUnVsZSggYXJnc1swXSwgYXJnc1sxXSApO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7IC8vIGRvIG5vdGhpbmcgaWYgYXJncyBhcmUgaW52YWxpZFxuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuICAkJC5zdHlmbi5zdHlsZSA9ICQkLnN0eWZuLmNzcztcblxuICAvLyBhZGQgYSBzaW5nbGUgY3NzIHJ1bGUgdG8gdGhlIGN1cnJlbnQgY29udGV4dFxuICAkJC5zdHlmbi5jc3NSdWxlID0gZnVuY3Rpb24oIG5hbWUsIHZhbHVlICl7XG4gICAgLy8gbmFtZS12YWx1ZSBwYWlyXG4gICAgdmFyIHByb3BlcnR5ID0gdGhpcy5wYXJzZSggbmFtZSwgdmFsdWUgKTtcblxuICAgIC8vIGFkZCBwcm9wZXJ0eSB0byBjdXJyZW50IGNvbnRleHQgaWYgdmFsaWRcbiAgICBpZiggcHJvcGVydHkgKXtcbiAgICAgIHZhciBpID0gdGhpcy5sZW5ndGggLSAxO1xuICAgICAgdGhpc1tpXS5wcm9wZXJ0aWVzLnB1c2goIHByb3BlcnR5ICk7XG4gICAgICB0aGlzW2ldLnByb3BlcnRpZXNbIHByb3BlcnR5Lm5hbWUgXSA9IHByb3BlcnR5OyAvLyBhbGxvdyBhY2Nlc3MgYnkgbmFtZSBhcyB3ZWxsXG5cbiAgICAgIGlmKCBwcm9wZXJ0eS5oYXNQaWUgKXtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5oYXNQaWUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiggcHJvcGVydHkubWFwcGVkICl7XG4gICAgICAgIHRoaXNbaV0ubWFwcGVkUHJvcGVydGllcy5wdXNoKCBwcm9wZXJ0eSApO1xuICAgICAgfVxuXG4gICAgICAvLyBhZGQgdG8gY29yZSBzdHlsZSBpZiBuZWNlc3NhcnlcbiAgICAgIHZhciBjdXJyZW50U2VsZWN0b3JJc0NvcmUgPSAhdGhpc1tpXS5zZWxlY3RvcjtcbiAgICAgIGlmKCBjdXJyZW50U2VsZWN0b3JJc0NvcmUgKXtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5jb3JlU3R5bGVbIHByb3BlcnR5Lm5hbWUgXSA9IHByb3BlcnR5O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgLy8gKHBvdGVudGlhbGx5IGV4cGVuc2l2ZSBjYWxjdWxhdGlvbilcbiAgLy8gYXBwbHkgdGhlIHN0eWxlIHRvIHRoZSBlbGVtZW50IGJhc2VkIG9uXG4gIC8vIC0gaXRzIGJ5cGFzc1xuICAvLyAtIHdoYXQgc2VsZWN0b3JzIG1hdGNoIGl0XG4gICQkLnN0eWZuLmFwcGx5ID0gZnVuY3Rpb24oIGVsZXMgKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiggc2VsZi5fcHJpdmF0ZS5uZXdTdHlsZSApeyAvLyBjbGVhciBzdHlsZSBjYWNoZXNcbiAgICAgIHRoaXMuX3ByaXZhdGUuY29udGV4dFN0eWxlcyA9IHt9O1xuICAgICAgdGhpcy5fcHJpdmF0ZS5wcm9wRGlmZnMgPSB7fTtcbiAgICB9XG5cbiAgICBmb3IoIHZhciBpZSA9IDA7IGllIDwgZWxlcy5sZW5ndGg7IGllKysgKXtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2llXTtcbiAgICAgIHZhciBjeHRNZXRhID0gc2VsZi5nZXRDb250ZXh0TWV0YSggZWxlICk7XG4gICAgICB2YXIgY3h0U3R5bGUgPSBzZWxmLmdldENvbnRleHRTdHlsZSggY3h0TWV0YSApO1xuICAgICAgdmFyIGFwcCA9IHNlbGYuYXBwbHlDb250ZXh0U3R5bGUoIGN4dE1ldGEsIGN4dFN0eWxlLCBlbGUgKTtcblxuICAgICAgc2VsZi51cGRhdGVUcmFuc2l0aW9ucyggZWxlLCBhcHAuZGlmZlByb3BzICk7XG4gICAgICBzZWxmLnVwZGF0ZVN0eWxlSGludHMoIGVsZSApO1xuXG4gICAgfSAvLyBmb3IgZWxlbWVudHNcblxuICAgIHNlbGYuX3ByaXZhdGUubmV3U3R5bGUgPSBmYWxzZTtcbiAgfTtcblxuICAkJC5zdHlmbi5nZXRQcm9wZXJ0aWVzRGlmZiA9IGZ1bmN0aW9uKCBvbGRDeHRLZXksIG5ld0N4dEtleSApe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2FjaGUgPSBzZWxmLl9wcml2YXRlLnByb3BEaWZmcyA9IHNlbGYuX3ByaXZhdGUucHJvcERpZmZzIHx8IHt9O1xuICAgIHZhciBkdWFsQ3h0S2V5ID0gb2xkQ3h0S2V5ICsgJy0nICsgbmV3Q3h0S2V5O1xuICAgIHZhciBjYWNoZWRWYWwgPSBjYWNoZVtkdWFsQ3h0S2V5XTtcblxuICAgIGlmKCBjYWNoZWRWYWwgKXtcbiAgICAgIHJldHVybiBjYWNoZWRWYWw7XG4gICAgfVxuXG4gICAgdmFyIGRpZmZQcm9wcyA9IFtdO1xuICAgIHZhciBhZGRlZFByb3AgPSB7fTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGN4dCA9IHNlbGZbaV07XG4gICAgICB2YXIgb2xkSGFzQ3h0ID0gb2xkQ3h0S2V5W2ldID09PSAndCc7XG4gICAgICB2YXIgbmV3SGFzQ3h0ID0gbmV3Q3h0S2V5W2ldID09PSAndCc7XG4gICAgICB2YXIgY3h0SGFzRGlmZmVkID0gb2xkSGFzQ3h0ICE9PSBuZXdIYXNDeHQ7XG4gICAgICB2YXIgY3h0SGFzTWFwcGVkUHJvcHMgPSBjeHQubWFwcGVkUHJvcGVydGllcy5sZW5ndGggPiAwO1xuXG4gICAgICBpZiggY3h0SGFzRGlmZmVkIHx8IGN4dEhhc01hcHBlZFByb3BzICl7XG4gICAgICAgIHZhciBwcm9wcztcblxuICAgICAgICBpZiggY3h0SGFzRGlmZmVkICYmIGN4dEhhc01hcHBlZFByb3BzICl7XG4gICAgICAgICAgcHJvcHMgPSBjeHQucHJvcGVydGllczsgLy8gc3VmZmljZXMgYi9jIG1hcHBlZFByb3BlcnRpZXMgaXMgYSBzdWJzZXQgb2YgcHJvcGVydGllc1xuICAgICAgICB9IGVsc2UgaWYoIGN4dEhhc0RpZmZlZCApe1xuICAgICAgICAgIHByb3BzID0gY3h0LnByb3BlcnRpZXM7IC8vIG5lZWQgdG8gY2hlY2sgdGhlbSBhbGxcbiAgICAgICAgfSBlbHNlIGlmKCBjeHRIYXNNYXBwZWRQcm9wcyApe1xuICAgICAgICAgIHByb3BzID0gY3h0Lm1hcHBlZFByb3BlcnRpZXM7IC8vIG9ubHkgbmVlZCB0byBjaGVjayBtYXBwZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgcHJvcHMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICB2YXIgcHJvcCA9IHByb3BzW2pdO1xuICAgICAgICAgIHZhciBuYW1lID0gcHJvcC5uYW1lO1xuXG4gICAgICAgICAgLy8gaWYgYSBsYXRlciBjb250ZXh0IG92ZXJyaWRlcyB0aGlzIHByb3BlcnR5LCB0aGVuIHRoZSBmYWN0IHRoYXQgdGhpcyBjb250ZXh0IGhhcyBzd2l0Y2hlZC9kaWZmZWQgZG9lc24ndCBtYXR0ZXJcbiAgICAgICAgICAvLyAoc2VtaSBleHBlbnNpdmUgY2hlY2sgc2luY2UgaXQgbWFrZXMgdGhpcyBmdW5jdGlvbiBPKG5eMikgb24gY29udGV4dCBsZW5ndGgsIGJ1dCB3b3J0aCBpdCBzaW5jZSBvdmVyYWxsIHJlc3VsdFxuICAgICAgICAgIC8vIGlzIGNhY2hlZClcbiAgICAgICAgICB2YXIgbGF0ZXJDeHRPdmVycmlkZXMgPSBmYWxzZTtcbiAgICAgICAgICBmb3IoIHZhciBrID0gaSArIDE7IGsgPCBzZWxmLmxlbmd0aDsgaysrICl7XG4gICAgICAgICAgICB2YXIgbGF0ZXJDeHQgPSBzZWxmW2tdO1xuICAgICAgICAgICAgdmFyIGhhc0xhdGVyQ3h0ID0gbmV3Q3h0S2V5W2tdID09PSAndCc7XG5cbiAgICAgICAgICAgIGlmKCAhaGFzTGF0ZXJDeHQgKXsgY29udGludWU7IH0gLy8gY2FuJ3Qgb3ZlcnJpZGUgdW5sZXNzIHRoZSBjb250ZXh0IGlzIGFjdGl2ZVxuXG4gICAgICAgICAgICBsYXRlckN4dE92ZXJyaWRlcyA9IGxhdGVyQ3h0LnByb3BlcnRpZXNbIHByb3AubmFtZSBdICE9IG51bGw7XG5cbiAgICAgICAgICAgIGlmKCBsYXRlckN4dE92ZXJyaWRlcyApeyBicmVhazsgfSAvLyBleGl0IGVhcmx5IGFzIGxvbmcgYXMgb25lIGxhdGVyIGNvbnRleHQgb3ZlcnJpZGVzXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoICFhZGRlZFByb3BbbmFtZV0gJiYgIWxhdGVyQ3h0T3ZlcnJpZGVzICl7XG4gICAgICAgICAgICBhZGRlZFByb3BbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgZGlmZlByb3BzLnB1c2goIG5hbWUgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gZm9yIHByb3BzXG4gICAgICB9IC8vIGlmXG5cbiAgICB9IC8vIGZvciBjb250ZXh0c1xuXG4gICAgY2FjaGVbIGR1YWxDeHRLZXkgXSA9IGRpZmZQcm9wcztcbiAgICByZXR1cm4gZGlmZlByb3BzO1xuICB9O1xuXG4gICQkLnN0eWZuLmdldENvbnRleHRNZXRhID0gZnVuY3Rpb24oIGVsZSApe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY3h0S2V5ID0gJyc7XG4gICAgdmFyIGRpZmZQcm9wcztcbiAgICB2YXIgcHJldktleSA9IGVsZS5fcHJpdmF0ZS5zdHlsZUN4dEtleSB8fCAnJztcblxuICAgIGlmKCBzZWxmLl9wcml2YXRlLm5ld1N0eWxlICl7XG4gICAgICBwcmV2S2V5ID0gJyc7IC8vIHNpbmNlIHdlIG5lZWQgdG8gYXBwbHkgYWxsIHN0eWxlIGlmIGEgZnJlc2ggc3R5bGVzaGVldFxuICAgIH1cblxuICAgIC8vIGdldCB0aGUgY3h0IGtleVxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGNvbnRleHQgPSBzZWxmW2ldO1xuICAgICAgdmFyIGNvbnRleHRTZWxlY3Rvck1hdGNoZXMgPSBjb250ZXh0LnNlbGVjdG9yICYmIGNvbnRleHQuc2VsZWN0b3IubWF0Y2hlcyggZWxlICk7IC8vIE5COiBjb250ZXh0LnNlbGVjdG9yIG1heSBiZSBudWxsIGZvciAnY29yZSdcblxuICAgICAgaWYoIGNvbnRleHRTZWxlY3Rvck1hdGNoZXMgKXtcbiAgICAgICAgY3h0S2V5ICs9ICd0JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN4dEtleSArPSAnZic7XG4gICAgICB9XG4gICAgfSAvLyBmb3IgY29udGV4dFxuXG4gICAgZGlmZlByb3BzID0gc2VsZi5nZXRQcm9wZXJ0aWVzRGlmZiggcHJldktleSwgY3h0S2V5ICk7XG5cbiAgICBlbGUuX3ByaXZhdGUuc3R5bGVDeHRLZXkgPSBjeHRLZXk7XG5cbiAgICByZXR1cm4ge1xuICAgICAga2V5OiBjeHRLZXksXG4gICAgICBkaWZmUHJvcE5hbWVzOiBkaWZmUHJvcHNcbiAgICB9O1xuICB9O1xuXG4gIC8vIGdldHMgYSBjb21wdXRlZCBlbGUgc3R5bGUgb2JqZWN0IGJhc2VkIG9uIG1hdGNoZWQgY29udGV4dHNcbiAgJCQuc3R5Zm4uZ2V0Q29udGV4dFN0eWxlID0gZnVuY3Rpb24oIGN4dE1ldGEgKXtcbiAgICB2YXIgY3h0S2V5ID0gY3h0TWV0YS5rZXk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjeHRTdHlsZXMgPSB0aGlzLl9wcml2YXRlLmNvbnRleHRTdHlsZXMgPSB0aGlzLl9wcml2YXRlLmNvbnRleHRTdHlsZXMgfHwge307XG5cbiAgICAvLyBpZiBhbHJlYWR5IGNvbXB1dGVkIHN0eWxlLCByZXR1cm5lZCBjYWNoZWQgY29weVxuICAgIGlmKCBjeHRTdHlsZXNbY3h0S2V5XSApeyByZXR1cm4gY3h0U3R5bGVzW2N4dEtleV07IH1cblxuICAgIHZhciBzdHlsZSA9IHtcbiAgICAgIF9wcml2YXRlOiB7XG4gICAgICAgIGtleTogY3h0S2V5XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGN4dCA9IHNlbGZbaV07XG4gICAgICB2YXIgaGFzQ3h0ID0gY3h0S2V5W2ldID09PSAndCc7XG5cbiAgICAgIGlmKCAhaGFzQ3h0ICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgY3h0LnByb3BlcnRpZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgdmFyIHByb3AgPSBjeHQucHJvcGVydGllc1tqXTtcbiAgICAgICAgdmFyIHN0eVByb3AgPSBzdHlsZVsgcHJvcC5uYW1lIF0gPSBwcm9wO1xuXG4gICAgICAgIHN0eVByb3AuY29udGV4dCA9IGN4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjeHRTdHlsZXNbY3h0S2V5XSA9IHN0eWxlO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfTtcblxuICAkJC5zdHlmbi5hcHBseUNvbnRleHRTdHlsZSA9IGZ1bmN0aW9uKCBjeHRNZXRhLCBjeHRTdHlsZSwgZWxlICl7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBkaWZmUHJvcHMgPSBjeHRNZXRhLmRpZmZQcm9wTmFtZXM7XG4gICAgdmFyIHJldERpZmZQcm9wcyA9IHt9O1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBkaWZmUHJvcHMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBkaWZmUHJvcE5hbWUgPSBkaWZmUHJvcHNbaV07XG4gICAgICB2YXIgY3h0UHJvcCA9IGN4dFN0eWxlWyBkaWZmUHJvcE5hbWUgXTtcbiAgICAgIHZhciBlbGVQcm9wID0gZWxlLl9wcml2YXRlLnN0eWxlWyBkaWZmUHJvcE5hbWUgXTtcblxuICAgICAgLy8gc2F2ZSBjeWNsZXMgd2hlbiB0aGUgY29udGV4dCBwcm9wIGRvZXNuJ3QgbmVlZCB0byBiZSBhcHBsaWVkXG4gICAgICBpZiggIWN4dFByb3AgfHwgZWxlUHJvcCA9PT0gY3h0UHJvcCApeyBjb250aW51ZTsgfVxuXG4gICAgICB2YXIgcmV0RGlmZlByb3AgPSByZXREaWZmUHJvcHNbIGRpZmZQcm9wTmFtZSBdID0ge1xuICAgICAgICBwcmV2OiBlbGVQcm9wXG4gICAgICB9O1xuXG4gICAgICBzZWxmLmFwcGx5UGFyc2VkUHJvcGVydHkoIGVsZSwgY3h0UHJvcCApO1xuXG4gICAgICByZXREaWZmUHJvcC5uZXh0ID0gZWxlLl9wcml2YXRlLnN0eWxlWyBkaWZmUHJvcE5hbWUgXTtcblxuICAgICAgaWYoIHJldERpZmZQcm9wLm5leHQgJiYgcmV0RGlmZlByb3AubmV4dC5ieXBhc3MgKXtcbiAgICAgICAgcmV0RGlmZlByb3AubmV4dCA9IHJldERpZmZQcm9wLm5leHQuYnlwYXNzZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRpZmZQcm9wczogcmV0RGlmZlByb3BzXG4gICAgfTtcbiAgfTtcblxuICAkJC5zdHlmbi51cGRhdGVTdHlsZUhpbnRzID0gZnVuY3Rpb24oZWxlKXtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBzdHlsZSA9IF9wLnN0eWxlO1xuXG4gICAgLy8gc2V0IHdoZXRoZXIgaGFzIHBpZSBvciBub3Q7IGZvciBncmVhdGVyIGVmZmljaWVuY3lcbiAgICB2YXIgaGFzUGllID0gZmFsc2U7XG4gICAgaWYoIF9wLmdyb3VwID09PSAnbm9kZXMnICYmIHNlbGYuX3ByaXZhdGUuaGFzUGllICl7XG4gICAgICBmb3IoIHZhciBpID0gMTsgaSA8PSAkJC5zdHlsZS5waWVCYWNrZ3JvdW5kTjsgaSsrICl7IC8vIDEuLk5cbiAgICAgICAgdmFyIHNpemUgPSBfcC5zdHlsZVsncGllLScgKyBpICsgJy1iYWNrZ3JvdW5kLXNpemUnXS52YWx1ZTtcblxuICAgICAgICBpZiggc2l6ZSA+IDAgKXtcbiAgICAgICAgICBoYXNQaWUgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3AuaGFzUGllID0gaGFzUGllO1xuXG4gICAgdmFyIHRyYW5zZm9ybSA9IHN0eWxlWyd0ZXh0LXRyYW5zZm9ybSddLnN0clZhbHVlO1xuICAgIHZhciBjb250ZW50ID0gc3R5bGVbJ2NvbnRlbnQnXS5zdHJWYWx1ZTtcbiAgICB2YXIgZlN0eWxlID0gc3R5bGVbJ2ZvbnQtc3R5bGUnXS5zdHJWYWx1ZTtcbiAgICB2YXIgc2l6ZSA9IHN0eWxlWydmb250LXNpemUnXS5weFZhbHVlICsgJ3B4JztcbiAgICB2YXIgZmFtaWx5ID0gc3R5bGVbJ2ZvbnQtZmFtaWx5J10uc3RyVmFsdWU7XG4gICAgLy8gdmFyIHZhcmlhbnQgPSBzdHlsZVsnZm9udC12YXJpYW50J10uc3RyVmFsdWU7XG4gICAgdmFyIHdlaWdodCA9IHN0eWxlWydmb250LXdlaWdodCddLnN0clZhbHVlO1xuICAgIHZhciB2YWxpZ24gPSBzdHlsZVsndGV4dC12YWxpZ24nXS5zdHJWYWx1ZTtcbiAgICB2YXIgaGFsaWduID0gc3R5bGVbJ3RleHQtdmFsaWduJ10uc3RyVmFsdWU7XG4gICAgdmFyIG9XaWR0aCA9IHN0eWxlWyd0ZXh0LW91dGxpbmUtd2lkdGgnXS5weFZhbHVlO1xuICAgIHZhciB3cmFwID0gc3R5bGVbJ3RleHQtd3JhcCddLnN0clZhbHVlO1xuICAgIHZhciB3cmFwVyA9IHN0eWxlWyd0ZXh0LW1heC13aWR0aCddLnB4VmFsdWU7XG4gICAgX3AubGFiZWxLZXkgPSBmU3R5bGUgKyckJysgc2l6ZSArJyQnKyBmYW1pbHkgKyckJysgd2VpZ2h0ICsnJCcrIGNvbnRlbnQgKyckJysgdHJhbnNmb3JtICsnJCcrIHZhbGlnbiArJyQnKyBoYWxpZ24gKyckJysgb1dpZHRoICsgJyQnICsgd3JhcCArICckJyArIHdyYXBXO1xuICAgIF9wLmZvbnRLZXkgPSBmU3R5bGUgKyckJysgd2VpZ2h0ICsnJCcrIHNpemUgKyckJysgZmFtaWx5O1xuXG4gICAgdmFyIHdpZHRoID0gc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZTtcbiAgICB2YXIgaGVpZ2h0ID0gc3R5bGVbJ2hlaWdodCddLnB4VmFsdWU7XG4gICAgdmFyIGJvcmRlclcgPSBzdHlsZVsnYm9yZGVyLXdpZHRoJ10ucHhWYWx1ZTtcbiAgICBfcC5ib3VuZGluZ0JveEtleSA9IHdpZHRoICsnJCcrIGhlaWdodCArJyQnKyBib3JkZXJXO1xuXG4gICAgaWYoIGVsZS5fcHJpdmF0ZS5ncm91cCA9PT0gJ2VkZ2VzJyApe1xuICAgICAgdmFyIGNwc3MgPSBzdHlsZVsnY29udHJvbC1wb2ludC1zdGVwLXNpemUnXS5weFZhbHVlO1xuICAgICAgdmFyIGNwZCA9IHN0eWxlWydjb250cm9sLXBvaW50LWRpc3RhbmNlJ10gPyBzdHlsZVsnY29udHJvbC1wb2ludC1kaXN0YW5jZSddLnB4VmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgY3B3ID0gc3R5bGVbJ2NvbnRyb2wtcG9pbnQtd2VpZ2h0J10udmFsdWU7XG4gICAgICB2YXIgY3VydmUgPSBzdHlsZVsnY3VydmUtc3R5bGUnXS5zdHJWYWx1ZTtcblxuICAgICAgX3AuYm91bmRpbmdCb3hLZXkgKz0gJyQnKyBjcHNzICsnJCcrIGNwZCArJyQnKyBjcHcgKyckJysgY3VydmU7XG4gICAgfVxuXG4gICAgX3Auc3R5bGVLZXkgPSBEYXRlLm5vdygpOyAvLyBwcm9iYWJseSBzYWZlIHRvIHVzZSBhcHBsaWVkIHRpbWUgYW5kIG11Y2ggZmFzdGVyXG4gICAgLy8gZm9yKCB2YXIgaSA9IDA7IGkgPCAkJC5zdHlsZS5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrICl7XG4gICAgLy8gICB2YXIgcHJvcCA9ICQkLnN0eWxlLnByb3BlcnRpZXNbaV07XG4gICAgLy8gICB2YXIgZWxlUHJvcCA9IF9wLnN0eWxlWyBwcm9wLm5hbWUgXTtcbiAgICAvLyAgIHZhciB2YWwgPSBlbGVQcm9wICYmIGVsZVByb3Auc3RyVmFsdWUgPyBlbGVQcm9wLnN0clZhbHVlIDogJ3VuZGVmaW5lZCc7XG5cbiAgICAvLyAgIF9wLnN0eWxlS2V5ICs9ICckJyArIHZhbDtcbiAgICAvLyB9XG4gIH07XG5cbiAgLy8gYXBwbHkgYSBwcm9wZXJ0eSB0byB0aGUgc3R5bGUgKGZvciBpbnRlcm5hbCB1c2UpXG4gIC8vIHJldHVybnMgd2hldGhlciBhcHBsaWNhdGlvbiB3YXMgc3VjY2Vzc2Z1bFxuICAvL1xuICAvLyBub3csIHRoaXMgZnVuY3Rpb24gZmxhdHRlbnMgdGhlIHByb3BlcnR5LCBhbmQgaGVyZSdzIGhvdzpcbiAgLy9cbiAgLy8gZm9yIHBhcnNlZFByb3A6eyBieXBhc3M6IHRydWUsIGRlbGV0ZUJ5cGFzczogdHJ1ZSB9XG4gIC8vIG5vIHByb3BlcnR5IGlzIGdlbmVyYXRlZCwgaW5zdGVhZCB0aGUgYnlwYXNzIHByb3BlcnR5IGluIHRoZVxuICAvLyBlbGVtZW50J3Mgc3R5bGUgaXMgcmVwbGFjZWQgYnkgd2hhdCdzIHBvaW50ZWQgdG8gYnkgdGhlIGBieXBhc3NlZGBcbiAgLy8gZmllbGQgaW4gdGhlIGJ5cGFzcyBwcm9wZXJ0eSAoaS5lLiByZXN0b3JpbmcgdGhlIHByb3BlcnR5IHRoZVxuICAvLyBieXBhc3Mgd2FzIG92ZXJyaWRpbmcpXG4gIC8vXG4gIC8vIGZvciBwYXJzZWRQcm9wOnsgbWFwcGVkOiB0cnV0aHkgfVxuICAvLyB0aGUgZ2VuZXJhdGVkIGZsYXR0ZW5lZFByb3A6eyBtYXBwaW5nOiBwcm9wIH1cbiAgLy9cbiAgLy8gZm9yIHBhcnNlZFByb3A6eyBieXBhc3M6IHRydWUgfVxuICAvLyB0aGUgZ2VuZXJhdGVkIGZsYXR0ZW5lZFByb3A6eyBieXBhc3NlZDogcGFyc2VkUHJvcCB9XG4gICQkLnN0eWZuLmFwcGx5UGFyc2VkUHJvcGVydHkgPSBmdW5jdGlvbiggZWxlLCBwYXJzZWRQcm9wICl7XG4gICAgdmFyIHByb3AgPSBwYXJzZWRQcm9wO1xuICAgIHZhciBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcbiAgICB2YXIgZmllbGRWYWwsIGZsYXRQcm9wO1xuICAgIHZhciB0eXBlcyA9ICQkLnN0eWxlLnR5cGVzO1xuICAgIHZhciB0eXBlID0gJCQuc3R5bGUucHJvcGVydGllc1sgcHJvcC5uYW1lIF0udHlwZTtcbiAgICB2YXIgcHJvcElzQnlwYXNzID0gcHJvcC5ieXBhc3M7XG4gICAgdmFyIG9yaWdQcm9wID0gc3R5bGVbIHByb3AubmFtZSBdO1xuICAgIHZhciBvcmlnUHJvcElzQnlwYXNzID0gb3JpZ1Byb3AgJiYgb3JpZ1Byb3AuYnlwYXNzO1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcblxuICAgIC8vIGNhbid0IGFwcGx5IGF1dG8gdG8gd2lkdGggb3IgaGVpZ2h0IHVubGVzcyBpdCdzIGEgcGFyZW50IG5vZGVcbiAgICBpZiggKHBhcnNlZFByb3AubmFtZSA9PT0gJ2hlaWdodCcgfHwgcGFyc2VkUHJvcC5uYW1lID09PSAnd2lkdGgnKSAmJiBlbGUuaXNOb2RlKCkgKXtcbiAgICAgIGlmKCBwYXJzZWRQcm9wLnZhbHVlID09PSAnYXV0bycgJiYgIWVsZS5pc1BhcmVudCgpICl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiggcGFyc2VkUHJvcC52YWx1ZSAhPT0gJ2F1dG8nICYmIGVsZS5pc1BhcmVudCgpICl7XG4gICAgICAgIHByb3AgPSBwYXJzZWRQcm9wID0gdGhpcy5wYXJzZSggcGFyc2VkUHJvcC5uYW1lLCAnYXV0bycsIHByb3BJc0J5cGFzcyApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gZGVsZXRlIHRoZSBjdXJyZW50IGJ5cGFzc1xuICAgIGlmKCBwcm9wSXNCeXBhc3MgJiYgcHJvcC5kZWxldGVCeXBhc3MgKXsgLy8gdGhlbiB0aGlzIHByb3BlcnR5IGlzIGp1c3QgaGVyZSB0byBpbmRpY2F0ZSB3ZSBuZWVkIHRvIGRlbGV0ZVxuICAgICAgdmFyIGN1cnJlbnRQcm9wID0gc3R5bGVbIHByb3AubmFtZSBdO1xuXG4gICAgICAvLyBjYW4gb25seSBkZWxldGUgaWYgdGhlIGN1cnJlbnQgcHJvcCBpcyBhIGJ5cGFzcyBhbmQgaXQgcG9pbnRzIHRvIHRoZSBwcm9wZXJ0eSBpdCB3YXMgb3ZlcnJpZGluZ1xuICAgICAgaWYoICFjdXJyZW50UHJvcCApe1xuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gcHJvcGVydHkgaXMgYWxyZWFkeSBub3QgZGVmaW5lZFxuICAgICAgfSBlbHNlIGlmKCBjdXJyZW50UHJvcC5ieXBhc3MgJiYgY3VycmVudFByb3AuYnlwYXNzZWQgKXsgLy8gdGhlbiByZXBsYWNlIHRoZSBieXBhc3MgcHJvcGVydHkgd2l0aCB0aGUgb3JpZ2luYWxcblxuICAgICAgICAvLyBiZWNhdXNlIHRoZSBieXBhc3NlZCBwcm9wZXJ0eSB3YXMgYWxyZWFkeSBhcHBsaWVkIChhbmQgdGhlcmVmb3JlIHBhcnNlZCksIHdlIGNhbiBqdXN0IHJlcGxhY2UgaXQgKG5vIHJlYXBwbHlpbmcgbmVjZXNzYXJ5KVxuICAgICAgICBzdHlsZVsgcHJvcC5uYW1lIF0gPSBjdXJyZW50UHJvcC5ieXBhc3NlZDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gd2UncmUgdW5zdWNjZXNzZnVsIGRlbGV0aW5nIHRoZSBieXBhc3NcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJpbnRNYXBwaW5nRXJyID0gZnVuY3Rpb24oKXtcbiAgICAgICQkLnV0aWwuZXJyb3IoJ0RvIG5vdCBhc3NpZ24gbWFwcGluZ3MgdG8gZWxlbWVudHMgd2l0aG91dCBjb3JyZXNwb25kaW5nIGRhdGEgKGUuZy4gZWxlIGAnKyBlbGUuaWQoKSArJ2AgZm9yIHByb3BlcnR5IGAnKyBwcm9wLm5hbWUgKydgIHdpdGggZGF0YSBmaWVsZCBgJysgcHJvcC5maWVsZCArJ2ApOyB0cnkgYSBgWycrIHByb3AuZmllbGQgKyddYCBzZWxlY3RvciB0byBsaW1pdCBzY29wZSB0byBlbGVtZW50cyB3aXRoIGAnKyBwcm9wLmZpZWxkICsnYCBkZWZpbmVkJyk7XG4gICAgfTtcblxuICAgIC8vIHB1dCB0aGUgcHJvcGVydHkgaW4gdGhlIHN0eWxlIG9iamVjdHNcbiAgICBzd2l0Y2goIHByb3AubWFwcGVkICl7IC8vIGZsYXR0ZW4gdGhlIHByb3BlcnR5IGlmIG1hcHBlZFxuICAgIGNhc2UgdHlwZXMubWFwRGF0YTpcbiAgICBjYXNlIHR5cGVzLm1hcExheW91dERhdGE6XG4gICAgY2FzZSB0eXBlcy5tYXBTY3JhdGNoOlxuXG4gICAgICB2YXIgaXNMYXlvdXQgPSBwcm9wLm1hcHBlZCA9PT0gdHlwZXMubWFwTGF5b3V0RGF0YTtcbiAgICAgIHZhciBpc1NjcmF0Y2ggPSBwcm9wLm1hcHBlZCA9PT0gdHlwZXMubWFwU2NyYXRjaDtcblxuICAgICAgLy8gZmxhdHRlbiB0aGUgZmllbGQgKGUuZy4gZGF0YS5mb28uYmFyKVxuICAgICAgdmFyIGZpZWxkcyA9IHByb3AuZmllbGQuc3BsaXQoXCIuXCIpO1xuICAgICAgdmFyIGZpZWxkVmFsO1xuXG4gICAgICBpZiggaXNTY3JhdGNoIHx8IGlzTGF5b3V0ICl7XG4gICAgICAgIGZpZWxkVmFsID0gX3Auc2NyYXRjaDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpZWxkVmFsID0gX3AuZGF0YTtcbiAgICAgIH1cblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoICYmIGZpZWxkVmFsOyBpKysgKXtcbiAgICAgICAgdmFyIGZpZWxkID0gZmllbGRzW2ldO1xuICAgICAgICBmaWVsZFZhbCA9IGZpZWxkVmFsWyBmaWVsZCBdO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGVyY2VudDtcbiAgICAgIGlmKCAhJCQuaXMubnVtYmVyKGZpZWxkVmFsKSApeyAvLyB0aGVuIGtlZXAgdGhlIG1hcHBpbmcgYnV0IGFzc3VtZSAwJSBmb3Igbm93XG4gICAgICAgIHBlcmNlbnQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVyY2VudCA9IChmaWVsZFZhbCAtIHByb3AuZmllbGRNaW4pIC8gKHByb3AuZmllbGRNYXggLSBwcm9wLmZpZWxkTWluKTtcbiAgICAgIH1cblxuICAgICAgLy8gbWFrZSBzdXJlIHRvIGJvdW5kIHBlcmNlbnQgdmFsdWVcbiAgICAgIGlmKCBwZXJjZW50IDwgMCApe1xuICAgICAgICBwZXJjZW50ID0gMDtcbiAgICAgIH0gZWxzZSBpZiggcGVyY2VudCA+IDEgKXtcbiAgICAgICAgcGVyY2VudCA9IDE7XG4gICAgICB9XG5cbiAgICAgIGlmKCB0eXBlLmNvbG9yICl7XG4gICAgICAgIHZhciByMSA9IHByb3AudmFsdWVNaW5bMF07XG4gICAgICAgIHZhciByMiA9IHByb3AudmFsdWVNYXhbMF07XG4gICAgICAgIHZhciBnMSA9IHByb3AudmFsdWVNaW5bMV07XG4gICAgICAgIHZhciBnMiA9IHByb3AudmFsdWVNYXhbMV07XG4gICAgICAgIHZhciBiMSA9IHByb3AudmFsdWVNaW5bMl07XG4gICAgICAgIHZhciBiMiA9IHByb3AudmFsdWVNYXhbMl07XG4gICAgICAgIHZhciBhMSA9IHByb3AudmFsdWVNaW5bM10gPT0gbnVsbCA/IDEgOiBwcm9wLnZhbHVlTWluWzNdO1xuICAgICAgICB2YXIgYTIgPSBwcm9wLnZhbHVlTWF4WzNdID09IG51bGwgPyAxIDogcHJvcC52YWx1ZU1heFszXTtcblxuICAgICAgICB2YXIgY2xyID0gW1xuICAgICAgICAgIE1hdGgucm91bmQoIHIxICsgKHIyIC0gcjEpKnBlcmNlbnQgKSxcbiAgICAgICAgICBNYXRoLnJvdW5kKCBnMSArIChnMiAtIGcxKSpwZXJjZW50ICksXG4gICAgICAgICAgTWF0aC5yb3VuZCggYjEgKyAoYjIgLSBiMSkqcGVyY2VudCApLFxuICAgICAgICAgIE1hdGgucm91bmQoIGExICsgKGEyIC0gYTEpKnBlcmNlbnQgKVxuICAgICAgICBdO1xuXG4gICAgICAgIGZsYXRQcm9wID0geyAvLyBjb2xvdXJzIGFyZSBzaW1wbGUsIHNvIGp1c3QgY3JlYXRlIHRoZSBmbGF0IHByb3BlcnR5IGluc3RlYWQgb2YgZXhwZW5zaXZlIHN0cmluZyBwYXJzaW5nXG4gICAgICAgICAgYnlwYXNzOiBwcm9wLmJ5cGFzcywgLy8gd2UncmUgYSBieXBhc3MgaWYgdGhlIG1hcHBpbmcgcHJvcGVydHkgaXMgYSBieXBhc3NcbiAgICAgICAgICBuYW1lOiBwcm9wLm5hbWUsXG4gICAgICAgICAgdmFsdWU6IGNscixcbiAgICAgICAgICBzdHJWYWx1ZTogJ3JnYignICsgY2xyWzBdICsgJywgJyArIGNsclsxXSArICcsICcgKyBjbHJbMl0gKyAnKSdcbiAgICAgICAgfTtcblxuICAgICAgfSBlbHNlIGlmKCB0eXBlLm51bWJlciApe1xuICAgICAgICB2YXIgY2FsY1ZhbHVlID0gcHJvcC52YWx1ZU1pbiArIChwcm9wLnZhbHVlTWF4IC0gcHJvcC52YWx1ZU1pbikgKiBwZXJjZW50O1xuICAgICAgICBmbGF0UHJvcCA9IHRoaXMucGFyc2UoIHByb3AubmFtZSwgY2FsY1ZhbHVlLCBwcm9wLmJ5cGFzcywgdHJ1ZSApO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGNhbiBvbmx5IG1hcCB0byBjb2xvdXJzIGFuZCBudW1iZXJzXG4gICAgICB9XG5cbiAgICAgIGlmKCAhZmxhdFByb3AgKXsgLy8gaWYgd2UgY2FuJ3QgZmxhdHRlbiB0aGUgcHJvcGVydHksIHRoZW4gdXNlIHRoZSBvcmlnUHJvcCBzbyB3ZSBzdGlsbCBrZWVwIHRoZSBtYXBwaW5nIGl0c2VsZlxuICAgICAgICBmbGF0UHJvcCA9IHRoaXMucGFyc2UoIHByb3AubmFtZSwgb3JpZ1Byb3Auc3RyVmFsdWUsIHByb3AuYnlwYXNzLCB0cnVlICk7XG4gICAgICB9XG5cbiAgICAgIGlmKCAhZmxhdFByb3AgKXsgcHJpbnRNYXBwaW5nRXJyKCk7IH1cbiAgICAgIGZsYXRQcm9wLm1hcHBpbmcgPSBwcm9wOyAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBtYXBwaW5nXG4gICAgICBwcm9wID0gZmxhdFByb3A7IC8vIHRoZSBmbGF0dGVuZWQgKG1hcHBlZCkgcHJvcGVydHkgaXMgdGhlIG9uZSB3ZSB3YW50XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgLy8gZGlyZWN0IG1hcHBpbmdcbiAgICBjYXNlIHR5cGVzLmRhdGE6XG4gICAgY2FzZSB0eXBlcy5sYXlvdXREYXRhOlxuICAgIGNhc2UgdHlwZXMuc2NyYXRjaDpcbiAgICAgIHZhciBpc0xheW91dCA9IHByb3AubWFwcGVkID09PSB0eXBlcy5sYXlvdXREYXRhO1xuICAgICAgdmFyIGlzU2NyYXRjaCA9IHByb3AubWFwcGVkID09PSB0eXBlcy5zY3JhdGNoO1xuXG4gICAgICAvLyBmbGF0dGVuIHRoZSBmaWVsZCAoZS5nLiBkYXRhLmZvby5iYXIpXG4gICAgICB2YXIgZmllbGRzID0gcHJvcC5maWVsZC5zcGxpdChcIi5cIik7XG4gICAgICB2YXIgZmllbGRWYWw7XG5cbiAgICAgIGlmKCBpc1NjcmF0Y2ggfHwgaXNMYXlvdXQgKXtcbiAgICAgICAgZmllbGRWYWwgPSBfcC5zY3JhdGNoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmllbGRWYWwgPSBfcC5kYXRhO1xuICAgICAgfVxuXG4gICAgICBpZiggZmllbGRWYWwgKXsgZm9yKCB2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGZpZWxkID0gZmllbGRzW2ldO1xuICAgICAgICBmaWVsZFZhbCA9IGZpZWxkVmFsWyBmaWVsZCBdO1xuICAgICAgfSB9XG5cbiAgICAgIGZsYXRQcm9wID0gdGhpcy5wYXJzZSggcHJvcC5uYW1lLCBmaWVsZFZhbCwgcHJvcC5ieXBhc3MsIHRydWUgKTtcblxuICAgICAgaWYoICFmbGF0UHJvcCApeyAvLyBpZiB3ZSBjYW4ndCBmbGF0dGVuIHRoZSBwcm9wZXJ0eSwgdGhlbiB1c2UgdGhlIG9yaWdQcm9wIHNvIHdlIHN0aWxsIGtlZXAgdGhlIG1hcHBpbmcgaXRzZWxmXG4gICAgICAgIHZhciBmbGF0UHJvcFZhbCA9IG9yaWdQcm9wID8gb3JpZ1Byb3Auc3RyVmFsdWUgOiAnJztcblxuICAgICAgICBmbGF0UHJvcCA9IHRoaXMucGFyc2UoIHByb3AubmFtZSwgZmxhdFByb3BWYWwsIHByb3AuYnlwYXNzLCB0cnVlICk7XG4gICAgICB9XG5cbiAgICAgIGlmKCAhZmxhdFByb3AgKXsgcHJpbnRNYXBwaW5nRXJyKCk7IH1cbiAgICAgIGZsYXRQcm9wLm1hcHBpbmcgPSBwcm9wOyAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBtYXBwaW5nXG4gICAgICBwcm9wID0gZmxhdFByb3A7IC8vIHRoZSBmbGF0dGVuZWQgKG1hcHBlZCkgcHJvcGVydHkgaXMgdGhlIG9uZSB3ZSB3YW50XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSB0eXBlcy5mbjpcbiAgICAgIHZhciBmbiA9IHByb3AudmFsdWU7XG4gICAgICB2YXIgZm5SZXRWYWwgPSBmbiggZWxlICk7XG5cbiAgICAgIGZsYXRQcm9wID0gdGhpcy5wYXJzZSggcHJvcC5uYW1lLCBmblJldFZhbCwgcHJvcC5ieXBhc3MsIHRydWUgKTtcbiAgICAgIGZsYXRQcm9wLm1hcHBpbmcgPSBwcm9wOyAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBtYXBwaW5nXG4gICAgICBwcm9wID0gZmxhdFByb3A7IC8vIHRoZSBmbGF0dGVuZWQgKG1hcHBlZCkgcHJvcGVydHkgaXMgdGhlIG9uZSB3ZSB3YW50XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICBicmVhazsgLy8ganVzdCBzZXQgdGhlIHByb3BlcnR5XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBub3QgYSB2YWxpZCBtYXBwaW5nXG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIHByb3BlcnR5IGlzIGEgYnlwYXNzIHByb3BlcnR5LCB0aGVuIGxpbmsgdGhlIHJlc3VsdGFudCBwcm9wZXJ0eSB0byB0aGUgb3JpZ2luYWwgb25lXG4gICAgaWYoIHByb3BJc0J5cGFzcyApe1xuICAgICAgaWYoIG9yaWdQcm9wSXNCeXBhc3MgKXsgLy8gdGhlbiB0aGlzIGJ5cGFzcyBvdmVycmlkZXMgdGhlIGV4aXN0aW5nIG9uZVxuICAgICAgICBwcm9wLmJ5cGFzc2VkID0gb3JpZ1Byb3AuYnlwYXNzZWQ7IC8vIHN0ZWFsIGJ5cGFzc2VkIHByb3AgZnJvbSBvbGQgYnlwYXNzXG4gICAgICB9IGVsc2UgeyAvLyB0aGVuIGxpbmsgdGhlIG9yaWcgcHJvcCB0byB0aGUgbmV3IGJ5cGFzc1xuICAgICAgICBwcm9wLmJ5cGFzc2VkID0gb3JpZ1Byb3A7XG4gICAgICB9XG5cbiAgICAgIHN0eWxlWyBwcm9wLm5hbWUgXSA9IHByb3A7IC8vIGFuZCBzZXRcblxuICAgIH0gZWxzZSB7IC8vIHByb3AgaXMgbm90IGJ5cGFzc1xuICAgICAgaWYoIG9yaWdQcm9wSXNCeXBhc3MgKXsgLy8gdGhlbiBrZWVwIHRoZSBvcmlnIHByb3AgKHNpbmNlIGl0J3MgYSBieXBhc3MpIGFuZCBsaW5rIHRvIHRoZSBuZXcgcHJvcFxuICAgICAgICBvcmlnUHJvcC5ieXBhc3NlZCA9IHByb3A7XG4gICAgICB9IGVsc2UgeyAvLyB0aGVuIGp1c3QgcmVwbGFjZSB0aGUgb2xkIHByb3Agd2l0aCB0aGUgbmV3IG9uZVxuICAgICAgICBzdHlsZVsgcHJvcC5uYW1lIF0gPSBwcm9wO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIHVwZGF0ZXMgdGhlIHZpc3VhbCBzdHlsZSBmb3IgYWxsIGVsZW1lbnRzICh1c2VmdWwgZm9yIG1hbnVhbCBzdHlsZSBtb2RpZmljYXRpb24gYWZ0ZXIgaW5pdClcbiAgJCQuc3R5Zm4udXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgIHZhciBlbGVzID0gY3kuZWxlbWVudHMoKTtcblxuICAgIGVsZXMudXBkYXRlU3R5bGUoKTtcbiAgfTtcblxuICAvLyBqdXN0IHVwZGF0ZSB0aGUgZnVuY3Rpb25hbCBwcm9wZXJ0aWVzIChpLmUuIG1hcHBpbmdzKSBpbiB0aGUgZWxlbWVudHMnXG4gIC8vIHN0eWxlcyAobGVzcyBleHBlbnNpdmUgdGhhbiByZWNhbGN1bGF0aW9uKVxuICAkJC5zdHlmbi51cGRhdGVNYXBwZXJzID0gZnVuY3Rpb24oIGVsZXMgKXtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXsgLy8gZm9yIGVhY2ggZWxlXG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgIHZhciBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcblxuICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCAkJC5zdHlsZS5wcm9wZXJ0aWVzLmxlbmd0aDsgaisrICl7IC8vIGZvciBlYWNoIHByb3BcbiAgICAgICAgdmFyIHByb3AgPSAkJC5zdHlsZS5wcm9wZXJ0aWVzW2pdO1xuICAgICAgICB2YXIgcHJvcEluU3R5bGUgPSBzdHlsZVsgcHJvcC5uYW1lIF07XG5cbiAgICAgICAgaWYoIHByb3BJblN0eWxlICYmIHByb3BJblN0eWxlLm1hcHBpbmcgKXtcbiAgICAgICAgICB2YXIgbWFwcGluZyA9IHByb3BJblN0eWxlLm1hcHBpbmc7XG4gICAgICAgICAgdGhpcy5hcHBseVBhcnNlZFByb3BlcnR5KCBlbGUsIG1hcHBpbmcgKTsgLy8gcmVhcHBseSB0aGUgbWFwcGluZyBwcm9wZXJ0eVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlU3R5bGVIaW50cyggZWxlICk7XG4gICAgfVxuICB9O1xuXG4gIC8vIGRpZmZQcm9wcyA6IHsgbmFtZSA9PiB7IHByZXYsIG5leHQgfSB9XG4gICQkLnN0eWZuLnVwZGF0ZVRyYW5zaXRpb25zID0gZnVuY3Rpb24oIGVsZSwgZGlmZlByb3BzLCBpc0J5cGFzcyApe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgc3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG5cbiAgICB2YXIgcHJvcHMgPSBzdHlsZVsndHJhbnNpdGlvbi1wcm9wZXJ0eSddLnZhbHVlO1xuICAgIHZhciBkdXJhdGlvbiA9IHN0eWxlWyd0cmFuc2l0aW9uLWR1cmF0aW9uJ10ubXNWYWx1ZTtcbiAgICB2YXIgZGVsYXkgPSBzdHlsZVsndHJhbnNpdGlvbi1kZWxheSddLm1zVmFsdWU7XG4gICAgdmFyIGNzcyA9IHt9O1xuXG4gICAgaWYoIHByb3BzLmxlbmd0aCA+IDAgJiYgZHVyYXRpb24gPiAwICl7XG5cbiAgICAgIC8vIGJ1aWxkIHVwIHRoZSBzdHlsZSB0byBhbmltYXRlIHRvd2FyZHNcbiAgICAgIHZhciBhbnlQcmV2ID0gZmFsc2U7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgICAgIHZhciBzdHlQcm9wID0gc3R5bGVbIHByb3AgXTtcbiAgICAgICAgdmFyIGRpZmZQcm9wID0gZGlmZlByb3BzWyBwcm9wIF07XG5cbiAgICAgICAgaWYoICFkaWZmUHJvcCApeyBjb250aW51ZTsgfVxuXG4gICAgICAgIHZhciBwcmV2UHJvcCA9IGRpZmZQcm9wLnByZXY7XG4gICAgICAgIHZhciBmcm9tUHJvcCA9IHByZXZQcm9wO1xuICAgICAgICB2YXIgdG9Qcm9wID0gZGlmZlByb3AubmV4dCAhPSBudWxsID8gZGlmZlByb3AubmV4dCA6IHN0eVByb3A7XG4gICAgICAgIHZhciBkaWZmID0gZmFsc2U7XG5cbiAgICAgICAgaWYoICFmcm9tUHJvcCApeyBjb250aW51ZTsgfVxuXG4gICAgICAgIC8vIGNvbnNpZGVyIHB4IHZhbHVlc1xuICAgICAgICBpZiggJCQuaXMubnVtYmVyKCBmcm9tUHJvcC5weFZhbHVlICkgJiYgJCQuaXMubnVtYmVyKCB0b1Byb3AucHhWYWx1ZSApICl7XG4gICAgICAgICAgZGlmZiA9IGZyb21Qcm9wLnB4VmFsdWUgIT09IHRvUHJvcC5weFZhbHVlO1xuXG4gICAgICAgIC8vIGNvbnNpZGVyIG51bWVyaWNhbCB2YWx1ZXNcbiAgICAgICAgfSBlbHNlIGlmKCAkJC5pcy5udW1iZXIoIGZyb21Qcm9wLnZhbHVlICkgJiYgJCQuaXMubnVtYmVyKCB0b1Byb3AudmFsdWUgKSApe1xuICAgICAgICAgIGRpZmYgPSBmcm9tUHJvcC52YWx1ZSAhPT0gdG9Qcm9wLnZhbHVlO1xuXG4gICAgICAgIC8vIGNvbnNpZGVyIGNvbG91ciB2YWx1ZXNcbiAgICAgICAgfSBlbHNlIGlmKCAkJC5pcy5hcnJheSggZnJvbVByb3AudmFsdWUgKSAmJiAkJC5pcy5hcnJheSggdG9Qcm9wLnZhbHVlICkgKXtcbiAgICAgICAgICBkaWZmID0gZnJvbVByb3AudmFsdWVbMF0gIT09IHRvUHJvcC52YWx1ZVswXVxuICAgICAgICAgICAgfHwgZnJvbVByb3AudmFsdWVbMV0gIT09IHRvUHJvcC52YWx1ZVsxXVxuICAgICAgICAgICAgfHwgZnJvbVByb3AudmFsdWVbMl0gIT09IHRvUHJvcC52YWx1ZVsyXVxuICAgICAgICAgIDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoZSBwcmV2aW91cyB2YWx1ZSBpcyBnb29kIGZvciBhbiBhbmltYXRpb24gb25seSBpZiBpdCdzIGRpZmZlcmVudFxuICAgICAgICBpZiggZGlmZiApe1xuICAgICAgICAgIGNzc1sgcHJvcCBdID0gdG9Qcm9wLnN0clZhbHVlOyAvLyB0byB2YWxcbiAgICAgICAgICB0aGlzLmFwcGx5QnlwYXNzKGVsZSwgcHJvcCwgZnJvbVByb3Auc3RyVmFsdWUpOyAvLyBmcm9tIHZhbFxuICAgICAgICAgIGFueVByZXYgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgIH0gLy8gZW5kIGlmIHByb3BzIGFsbG93IGFuaVxuXG4gICAgICAvLyBjYW4ndCB0cmFuc2l0aW9uIGlmIHRoZXJlJ3Mgbm90aGluZyBwcmV2aW91cyB0byB0cmFuc2l0aW9uIGZyb21cbiAgICAgIGlmKCAhYW55UHJldiApeyByZXR1cm47IH1cblxuICAgICAgZWxlLl9wcml2YXRlLnRyYW5zaXRpb25pbmcgPSB0cnVlO1xuXG4gICAgICBlbGUuc3RvcCgpO1xuXG4gICAgICBpZiggZGVsYXkgPiAwICl7XG4gICAgICAgIGVsZS5kZWxheSggZGVsYXkgKTtcbiAgICAgIH1cblxuICAgICAgZWxlLmFuaW1hdGUoe1xuICAgICAgICBjc3M6IGNzc1xuICAgICAgfSwge1xuICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgIHF1ZXVlOiBmYWxzZSxcbiAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgaWYoICFpc0J5cGFzcyApe1xuICAgICAgICAgICAgc2VsZi5yZW1vdmVCeXBhc3NlcyggZWxlLCBwcm9wcyApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVsZS5fcHJpdmF0ZS50cmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgfSBlbHNlIGlmKCBlbGUuX3ByaXZhdGUudHJhbnNpdGlvbmluZyApe1xuICAgICAgZWxlLnN0b3AoKTtcblxuICAgICAgdGhpcy5yZW1vdmVCeXBhc3NlcyggZWxlLCBwcm9wcyApO1xuXG4gICAgICBlbGUuX3ByaXZhdGUudHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIGJ5cGFzc2VzIGFyZSBhcHBsaWVkIHRvIGFuIGV4aXN0aW5nIHN0eWxlIG9uIGFuIGVsZW1lbnQsIGFuZCBqdXN0IHRhY2tlZCBvbiB0ZW1wb3JhcmlseVxuICAvLyByZXR1cm5zIHRydWUgaWZmIGFwcGxpY2F0aW9uIHdhcyBzdWNjZXNzZnVsIGZvciBhdCBsZWFzdCAxIHNwZWNpZmllZCBwcm9wZXJ0eVxuICAkJC5zdHlmbi5hcHBseUJ5cGFzcyA9IGZ1bmN0aW9uKCBlbGVzLCBuYW1lLCB2YWx1ZSwgdXBkYXRlVHJhbnNpdGlvbnMgKXtcbiAgICB2YXIgcHJvcHMgPSBbXTtcbiAgICB2YXIgaXNCeXBhc3MgPSB0cnVlO1xuICAgIFxuICAgIC8vIHB1dCBhbGwgdGhlIHByb3BlcnRpZXMgKGNhbiBzcGVjaWZ5IG9uZSBvciBtYW55KSBpbiBhbiBhcnJheSBhZnRlciBwYXJzaW5nIHRoZW1cbiAgICBpZiggbmFtZSA9PT0gXCIqXCIgfHwgbmFtZSA9PT0gXCIqKlwiICl7IC8vIGFwcGx5IHRvIGFsbCBwcm9wZXJ0eSBuYW1lc1xuXG4gICAgICBpZiggdmFsdWUgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8ICQkLnN0eWxlLnByb3BlcnRpZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgcHJvcCA9ICQkLnN0eWxlLnByb3BlcnRpZXNbaV07XG4gICAgICAgICAgdmFyIG5hbWUgPSBwcm9wLm5hbWU7XG5cbiAgICAgICAgICB2YXIgcGFyc2VkUHJvcCA9IHRoaXMucGFyc2UobmFtZSwgdmFsdWUsIHRydWUpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmKCBwYXJzZWRQcm9wICl7XG4gICAgICAgICAgICBwcm9wcy5wdXNoKCBwYXJzZWRQcm9wICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYoICQkLmlzLnN0cmluZyhuYW1lKSApeyAvLyB0aGVuIHBhcnNlIHRoZSBzaW5nbGUgcHJvcGVydHlcbiAgICAgIHZhciBwYXJzZWRQcm9wID0gdGhpcy5wYXJzZShuYW1lLCB2YWx1ZSwgdHJ1ZSk7XG5cbiAgICAgIGlmKCBwYXJzZWRQcm9wICl7XG4gICAgICAgIHByb3BzLnB1c2goIHBhcnNlZFByb3AgKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoICQkLmlzLnBsYWluT2JqZWN0KG5hbWUpICl7IC8vIHRoZW4gcGFyc2UgZWFjaCBwcm9wZXJ0eVxuICAgICAgdmFyIHNwZWNpZmllZFByb3BzID0gbmFtZTtcbiAgICAgIHVwZGF0ZVRyYW5zaXRpb25zID0gdmFsdWU7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgJCQuc3R5bGUucHJvcGVydGllcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgcHJvcCA9ICQkLnN0eWxlLnByb3BlcnRpZXNbaV07XG4gICAgICAgIHZhciBuYW1lID0gcHJvcC5uYW1lO1xuICAgICAgICB2YXIgdmFsdWUgPSBzcGVjaWZpZWRQcm9wc1sgbmFtZSBdO1xuXG4gICAgICAgIGlmKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICl7IC8vIHRyeSBjYW1lbCBjYXNlIG5hbWUgdG9vXG4gICAgICAgICAgdmFsdWUgPSBzcGVjaWZpZWRQcm9wc1sgJCQudXRpbC5kYXNoMmNhbWVsKG5hbWUpIF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiggdmFsdWUgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgIHZhciBwYXJzZWRQcm9wID0gdGhpcy5wYXJzZShuYW1lLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYoIHBhcnNlZFByb3AgKXtcbiAgICAgICAgICAgIHByb3BzLnB1c2goIHBhcnNlZFByb3AgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyBjYW4ndCBkbyBhbnl0aGluZyB3aXRob3V0IHdlbGwgZGVmaW5lZCBwcm9wZXJ0aWVzXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gd2UndmUgZmFpbGVkIGlmIHRoZXJlIGFyZSBubyB2YWxpZCBwcm9wZXJ0aWVzXG4gICAgaWYoIHByb3BzLmxlbmd0aCA9PT0gMCApeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIC8vIG5vdywgYXBwbHkgdGhlIGJ5cGFzcyBwcm9wZXJ0aWVzIG9uIHRoZSBlbGVtZW50c1xuICAgIHZhciByZXQgPSBmYWxzZTsgLy8gcmV0dXJuIHRydWUgaWYgYXQgbGVhc3Qgb25lIHN1Y2Nlc2Z1bCBieXBhc3MgYXBwbGllZFxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApeyAvLyBmb3IgZWFjaCBlbGVcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgdmFyIHN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuICAgICAgdmFyIGRpZmZQcm9wcyA9IHt9O1xuICAgICAgdmFyIGRpZmZQcm9wO1xuXG4gICAgICBmb3IoIHZhciBqID0gMDsgaiA8IHByb3BzLmxlbmd0aDsgaisrICl7IC8vIGZvciBlYWNoIHByb3BcbiAgICAgICAgdmFyIHByb3AgPSBwcm9wc1tqXTtcblxuICAgICAgICBpZiggdXBkYXRlVHJhbnNpdGlvbnMgKXtcbiAgICAgICAgICB2YXIgcHJldlByb3AgPSBzdHlsZVsgcHJvcC5uYW1lIF07XG4gICAgICAgICAgZGlmZlByb3AgPSBkaWZmUHJvcHNbIHByb3AubmFtZSBdID0geyBwcmV2OiBwcmV2UHJvcCB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0ID0gdGhpcy5hcHBseVBhcnNlZFByb3BlcnR5KCBlbGUsIHByb3AgKSB8fCByZXQ7XG5cbiAgICAgICAgaWYoIHVwZGF0ZVRyYW5zaXRpb25zICl7XG4gICAgICAgICAgZGlmZlByb3AubmV4dCA9IHN0eWxlWyBwcm9wLm5hbWUgXTtcbiAgICAgICAgfVxuXG4gICAgICB9IC8vIGZvciBwcm9wc1xuXG4gICAgICBpZiggdXBkYXRlVHJhbnNpdGlvbnMgKXtcbiAgICAgICAgdGhpcy51cGRhdGVUcmFuc2l0aW9ucyggZWxlLCBkaWZmUHJvcHMsIGlzQnlwYXNzICk7XG4gICAgICB9XG4gICAgfSAvLyBmb3IgZWxlc1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICAvLyBvbmx5IHVzZWZ1bCBpbiBzcGVjaWZpYyBjYXNlcyBsaWtlIGFuaW1hdGlvblxuICAkJC5zdHlmbi5vdmVycmlkZUJ5cGFzcyA9IGZ1bmN0aW9uKCBlbGVzLCBuYW1lLCB2YWx1ZSApe1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICB2YXIgcHJvcCA9IGVsZS5fcHJpdmF0ZS5zdHlsZVsgJCQudXRpbC5jYW1lbDJkYXNoKG5hbWUpIF07XG5cbiAgICAgIGlmKCAhcHJvcC5ieXBhc3MgKXsgLy8gbmVlZCBhIGJ5cGFzcyBpZiBvbmUgZG9lc24ndCBleGlzdFxuICAgICAgICB0aGlzLmFwcGx5QnlwYXNzKCBlbGUsIG5hbWUsIHZhbHVlICk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBwcm9wLnZhbHVlID0gdmFsdWU7XG4gICAgICBwcm9wLnB4VmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gIH07XG5cbiAgJCQuc3R5Zm4ucmVtb3ZlQWxsQnlwYXNzZXMgPSBmdW5jdGlvbiggZWxlcywgdXBkYXRlVHJhbnNpdGlvbnMgKXtcbiAgICB2YXIgaXNCeXBhc3MgPSB0cnVlO1xuXG4gICAgZm9yKCB2YXIgaiA9IDA7IGogPCBlbGVzLmxlbmd0aDsgaisrICl7XG4gICAgICB2YXIgZWxlID0gZWxlc1tqXTtcbiAgICAgIHZhciBkaWZmUHJvcHMgPSB7fTtcbiAgICAgIHZhciBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCAkJC5zdHlsZS5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBwcm9wID0gJCQuc3R5bGUucHJvcGVydGllc1tpXTtcbiAgICAgICAgdmFyIG5hbWUgPSBwcm9wLm5hbWU7XG4gICAgICAgIHZhciB2YWx1ZSA9ICcnOyAvLyBlbXB0eSA9PiByZW1vdmUgYnlwYXNzXG4gICAgICAgIHZhciBwYXJzZWRQcm9wID0gdGhpcy5wYXJzZShuYW1lLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgIHZhciBwcmV2UHJvcCA9IHN0eWxlWyBwcm9wLm5hbWUgXTtcbiAgICAgICAgdmFyIGRpZmZQcm9wID0gZGlmZlByb3BzWyBwcm9wLm5hbWUgXSA9IHsgcHJldjogcHJldlByb3AgfTtcblxuICAgICAgICB0aGlzLmFwcGx5UGFyc2VkUHJvcGVydHkoZWxlLCBwYXJzZWRQcm9wKTtcblxuICAgICAgICBkaWZmUHJvcC5uZXh0ID0gc3R5bGVbIHByb3AubmFtZSBdO1xuICAgICAgfSAvLyBmb3IgcHJvcHNcblxuICAgICAgaWYoIHVwZGF0ZVRyYW5zaXRpb25zICl7XG4gICAgICAgIHRoaXMudXBkYXRlVHJhbnNpdGlvbnMoIGVsZSwgZGlmZlByb3BzLCBpc0J5cGFzcyApO1xuICAgICAgfVxuICAgIH0gLy8gZm9yIGVsZXNcbiAgfTtcblxuICAkJC5zdHlmbi5yZW1vdmVCeXBhc3NlcyA9IGZ1bmN0aW9uKCBlbGVzLCBwcm9wcywgdXBkYXRlVHJhbnNpdGlvbnMgKXtcbiAgICB2YXIgaXNCeXBhc3MgPSB0cnVlO1xuXG4gICAgZm9yKCB2YXIgaiA9IDA7IGogPCBlbGVzLmxlbmd0aDsgaisrICl7XG4gICAgICB2YXIgZWxlID0gZWxlc1tqXTtcbiAgICAgIHZhciBkaWZmUHJvcHMgPSB7fTtcbiAgICAgIHZhciBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgbmFtZSA9IHByb3BzW2ldO1xuICAgICAgICB2YXIgcHJvcCA9ICQkLnN0eWxlLnByb3BlcnRpZXNbIG5hbWUgXTtcbiAgICAgICAgdmFyIHZhbHVlID0gJyc7IC8vIGVtcHR5ID0+IHJlbW92ZSBieXBhc3NcbiAgICAgICAgdmFyIHBhcnNlZFByb3AgPSB0aGlzLnBhcnNlKG5hbWUsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgdmFyIHByZXZQcm9wID0gc3R5bGVbIHByb3AubmFtZSBdO1xuICAgICAgICB2YXIgZGlmZlByb3AgPSBkaWZmUHJvcHNbIHByb3AubmFtZSBdID0geyBwcmV2OiBwcmV2UHJvcCB9O1xuXG4gICAgICAgIHRoaXMuYXBwbHlQYXJzZWRQcm9wZXJ0eShlbGUsIHBhcnNlZFByb3ApO1xuXG4gICAgICAgIGRpZmZQcm9wLm5leHQgPSBzdHlsZVsgcHJvcC5uYW1lIF07XG4gICAgICB9IC8vIGZvciBwcm9wc1xuXG4gICAgICBpZiggdXBkYXRlVHJhbnNpdGlvbnMgKXtcbiAgICAgICAgdGhpcy51cGRhdGVUcmFuc2l0aW9ucyggZWxlLCBkaWZmUHJvcHMsIGlzQnlwYXNzICk7XG4gICAgICB9XG4gICAgfSAvLyBmb3IgZWxlc1xuICB9O1xuXG59KSggY3l0b3NjYXBlICk7XG47KGZ1bmN0aW9uKCQkLCB3aW5kb3cpeyAndXNlIHN0cmljdCc7XG5cbiAgLy8gZ2V0cyB3aGF0IGFuIGVtIHNpemUgY29ycmVzcG9uZHMgdG8gaW4gcGl4ZWxzIHJlbGF0aXZlIHRvIGEgZG9tIGVsZW1lbnRcbiAgJCQuc3R5Zm4uZ2V0RW1TaXplSW5QaXhlbHMgPSBmdW5jdGlvbigpe1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgdmFyIGRvbUVsZW1lbnQgPSBjeS5jb250YWluZXIoKTtcblxuICAgIGlmKCB3aW5kb3cgJiYgZG9tRWxlbWVudCAmJiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSApe1xuICAgICAgdmFyIHB4QXNTdHIgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb21FbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKCdmb250LXNpemUnKTtcbiAgICAgIHZhciBweCA9IHBhcnNlRmxvYXQoIHB4QXNTdHIgKTtcbiAgICAgIHJldHVybiBweDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDE7IC8vIGluIGNhc2Ugd2UncmUgcnVubmluZyBvdXRzaWRlIG9mIHRoZSBicm93c2VyXG4gICAgfVxuICB9O1xuXG4gIC8vIGdldHMgY3NzIHByb3BlcnR5IGZyb20gdGhlIGNvcmUgY29udGFpbmVyXG4gICQkLnN0eWZuLmNvbnRhaW5lckNzcyA9IGZ1bmN0aW9uKCBwcm9wTmFtZSApe1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgdmFyIGRvbUVsZW1lbnQgPSBjeS5jb250YWluZXIoKTtcblxuICAgIGlmKCB3aW5kb3cgJiYgZG9tRWxlbWVudCAmJiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSApe1xuICAgICAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvbUVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoIHByb3BOYW1lICk7XG4gICAgfVxuICB9O1xuXG4gICQkLnN0eWZuLmNvbnRhaW5lclByb3BlcnR5ID0gZnVuY3Rpb24oIHByb3BOYW1lICl7XG4gICAgdmFyIHByb3BTdHIgPSB0aGlzLmNvbnRhaW5lckNzcyggcHJvcE5hbWUgKTtcbiAgICB2YXIgcHJvcCA9IHRoaXMucGFyc2UoIHByb3BOYW1lLCBwcm9wU3RyICk7XG4gICAgcmV0dXJuIHByb3A7XG4gIH07XG5cbiAgJCQuc3R5Zm4uY29udGFpbmVyUHJvcGVydHlBc1N0cmluZyA9IGZ1bmN0aW9uKCBwcm9wTmFtZSApe1xuICAgIHZhciBwcm9wID0gdGhpcy5jb250YWluZXJQcm9wZXJ0eSggcHJvcE5hbWUgKTtcblxuICAgIGlmKCBwcm9wICl7XG4gICAgICByZXR1cm4gcHJvcC5zdHJWYWx1ZTtcbiAgICB9XG4gIH07XG5cbn0pKCBjeXRvc2NhcGUsIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHdpbmRvdyApO1xuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICAvLyBnZXRzIHRoZSByZW5kZXJlZCBzdHlsZSBmb3IgYW4gZWxlbWVudFxuICAkJC5zdHlmbi5nZXRSZW5kZXJlZFN0eWxlID0gZnVuY3Rpb24oIGVsZSApe1xuICAgIHZhciBlbGUgPSBlbGVbMF07IC8vIGluc3VyZSBpdCdzIGFuIGVsZW1lbnRcblxuICAgIGlmKCBlbGUgKXtcbiAgICAgIHZhciByc3R5bGUgPSB7fTtcbiAgICAgIHZhciBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCAkJC5zdHlsZS5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBwcm9wID0gJCQuc3R5bGUucHJvcGVydGllc1tpXTtcbiAgICAgICAgdmFyIHN0eWxlUHJvcCA9IHN0eWxlWyBwcm9wLm5hbWUgXTtcblxuICAgICAgICBpZiggc3R5bGVQcm9wICl7XG4gICAgICAgICAgdmFyIHZhbCA9IHN0eWxlUHJvcC51bml0bGVzcyA/IHN0eWxlUHJvcC5zdHJWYWx1ZSA6IChzdHlsZVByb3AucHhWYWx1ZSAqIHpvb20pICsgJ3B4JztcbiAgICAgICAgICByc3R5bGVbIHByb3AubmFtZSBdID0gdmFsO1xuICAgICAgICAgIHJzdHlsZVsgJCQudXRpbC5kYXNoMmNhbWVsKHByb3AubmFtZSkgXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcnN0eWxlO1xuICAgIH1cbiAgfTtcblxuICAvLyBnZXRzIHRoZSByYXcgc3R5bGUgZm9yIGFuIGVsZW1lbnRcbiAgJCQuc3R5Zm4uZ2V0UmF3U3R5bGUgPSBmdW5jdGlvbiggZWxlICl7XG4gICAgdmFyIGVsZSA9IGVsZVswXTsgLy8gaW5zdXJlIGl0J3MgYW4gZWxlbWVudFxuXG4gICAgaWYoIGVsZSApe1xuICAgICAgdmFyIHJzdHlsZSA9IHt9O1xuICAgICAgdmFyIHN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8ICQkLnN0eWxlLnByb3BlcnRpZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIHByb3AgPSAkJC5zdHlsZS5wcm9wZXJ0aWVzW2ldO1xuICAgICAgICB2YXIgc3R5bGVQcm9wID0gc3R5bGVbIHByb3AubmFtZSBdO1xuXG4gICAgICAgIGlmKCBzdHlsZVByb3AgKXtcbiAgICAgICAgICByc3R5bGVbIHByb3AubmFtZSBdID0gc3R5bGVQcm9wLnN0clZhbHVlO1xuICAgICAgICAgIHJzdHlsZVsgJCQudXRpbC5kYXNoMmNhbWVsKHByb3AubmFtZSkgXSA9IHN0eWxlUHJvcC5zdHJWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcnN0eWxlO1xuICAgIH1cbiAgfTtcblxuICAvLyBnZXRzIHRoZSB2YWx1ZSBzdHlsZSBmb3IgYW4gZWxlbWVudCAodXNlZnVsIGZvciB0aGluZ3MgbGlrZSBhbmltYXRpb25zKVxuICAkJC5zdHlmbi5nZXRWYWx1ZVN0eWxlID0gZnVuY3Rpb24oIGVsZSwgb3B0cyApe1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgdmFyIHJzdHlsZSA9IG9wdHMuYXJyYXkgPyBbXSA6IHt9OyBcbiAgICB2YXIgc3R5bGU7XG5cbiAgICBpZiggJCQuaXMuZWxlbWVudChlbGUpICl7XG4gICAgICBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTsgICAgXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlID0gZWxlOyAvLyBqdXN0IHBhc3NlZCB0aGUgc3R5bGUgaXRzZWxmXG4gICAgfVxuXG4gICAgaWYoIHN0eWxlICl7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8ICQkLnN0eWxlLnByb3BlcnRpZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIHByb3AgPSAkJC5zdHlsZS5wcm9wZXJ0aWVzW2ldO1xuICAgICAgICB2YXIgc3R5bGVQcm9wID0gc3R5bGVbIHByb3AubmFtZSBdIHx8IHN0eWxlWyAkJC51dGlsLmRhc2gyY2FtZWwocHJvcC5uYW1lKSBdO1xuXG4gICAgICAgIGlmKCBzdHlsZVByb3AgIT09IHVuZGVmaW5lZCAmJiAhJCQuaXMucGxhaW5PYmplY3QoIHN0eWxlUHJvcCApICl7IC8vIHRoZW4gbWFrZSBhIHByb3Agb2YgaXRcbiAgICAgICAgICBzdHlsZVByb3AgPSB0aGlzLnBhcnNlKHByb3AubmFtZSwgc3R5bGVQcm9wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBzdHlsZVByb3AgKXtcbiAgICAgICAgICBpZiggb3B0cy5hcnJheSApe1xuICAgICAgICAgICAgcnN0eWxlLnB1c2goIHN0eWxlUHJvcCApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByc3R5bGVbIHByb3AubmFtZSBdID0gc3R5bGVQcm9wO1xuICAgICAgICAgICAgcnN0eWxlWyAkJC51dGlsLmRhc2gyY2FtZWwocHJvcC5uYW1lKSBdID0gc3R5bGVQcm9wO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByc3R5bGU7XG4gIH07XG5cbn0pKCBjeXRvc2NhcGUgKTtcbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgJCQuc3R5bGUuYXBwbHlGcm9tSnNvbiA9IGZ1bmN0aW9uKCBzdHlsZSwganNvbiApe1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwganNvbi5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGNvbnRleHQgPSBqc29uW2ldO1xuICAgICAgdmFyIHNlbGVjdG9yID0gY29udGV4dC5zZWxlY3RvcjtcbiAgICAgIHZhciBwcm9wcyA9IGNvbnRleHQuc3R5bGUgfHwgY29udGV4dC5jc3M7XG5cbiAgICAgIHN0eWxlLnNlbGVjdG9yKCBzZWxlY3RvciApOyAvLyBhcHBseSBzZWxlY3RvclxuXG4gICAgICBmb3IoIHZhciBuYW1lIGluIHByb3BzICl7XG4gICAgICAgIHZhciB2YWx1ZSA9IHByb3BzW25hbWVdO1xuXG4gICAgICAgIHN0eWxlLmNzcyggbmFtZSwgdmFsdWUgKTsgLy8gYXBwbHkgcHJvcGVydHlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3R5bGU7XG4gIH07XG5cbiAgLy8gc3RhdGljIGZ1bmN0aW9uXG4gICQkLnN0eWxlLmZyb21Kc29uID0gZnVuY3Rpb24oIGN5LCBqc29uICl7XG4gICAgdmFyIHN0eWxlID0gbmV3ICQkLlN0eWxlKGN5KTtcblxuICAgICQkLnN0eWxlLmFwcGx5RnJvbUpzb24oIHN0eWxlLCBqc29uICk7XG5cbiAgICByZXR1cm4gc3R5bGU7XG4gIH07XG5cbiAgLy8gYWNjZXNzaWJsZSBjeS5zdHlsZSgpIGZ1bmN0aW9uXG4gICQkLnN0eWZuLmZyb21Kc29uID0gZnVuY3Rpb24oIGpzb24gKXtcbiAgICB2YXIgc3R5bGUgPSB0aGlzO1xuXG4gICAgc3R5bGUucmVzZXRUb0RlZmF1bHQoKTtcblxuICAgICQkLnN0eWxlLmFwcGx5RnJvbUpzb24oIHN0eWxlLCBqc29uICk7XG5cbiAgICByZXR1cm4gc3R5bGU7XG4gIH07XG5cbiAgLy8gZ2V0IGpzb24gZnJvbSBjeS5zdHlsZSgpIGFwaVxuICAkJC5zdHlmbi5qc29uID0gZnVuY3Rpb24oKXtcbiAgICB2YXIganNvbiA9IFtdO1xuXG4gICAgZm9yKCB2YXIgaSA9IHRoaXMuZGVmYXVsdExlbmd0aDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBjeHQgPSB0aGlzW2ldO1xuICAgICAgdmFyIHNlbGVjdG9yID0gY3h0LnNlbGVjdG9yO1xuICAgICAgdmFyIHByb3BzID0gY3h0LnByb3BlcnRpZXM7XG4gICAgICB2YXIgY3NzID0ge307XG5cbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgcHJvcHMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgdmFyIHByb3AgPSBwcm9wc1tqXTtcbiAgICAgICAgY3NzWyBwcm9wLm5hbWUgXSA9IHByb3Auc3RyVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGpzb24ucHVzaCh7XG4gICAgICAgIHNlbGVjdG9yOiAhc2VsZWN0b3IgPyAnY29yZScgOiBzZWxlY3Rvci50b1N0cmluZygpLFxuICAgICAgICBzdHlsZTogY3NzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4ganNvbjtcbiAgfTtcblxufSkoIGN5dG9zY2FwZSApO1xuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICAkJC5zdHlsZS5hcHBseUZyb21TdHJpbmcgPSBmdW5jdGlvbiggc3R5bGUsIHN0cmluZyApe1xuICAgIHZhciByZW1haW5pbmcgPSAnJyArIHN0cmluZztcbiAgICB2YXIgc2VsQW5kQmxvY2tTdHI7XG4gICAgdmFyIGJsb2NrUmVtO1xuICAgIHZhciBwcm9wQW5kVmFsU3RyO1xuXG4gICAgLy8gcmVtb3ZlIGNvbW1lbnRzIGZyb20gdGhlIHN0eWxlIHN0cmluZ1xuICAgIHJlbWFpbmluZyA9IHJlbWFpbmluZy5yZXBsYWNlKC9bL11bKl0oXFxzfC4pKz9bKl1bL10vZywgJycpO1xuXG4gICAgZnVuY3Rpb24gcmVtb3ZlU2VsQW5kQmxvY2tGcm9tUmVtYWluaW5nKCl7XG4gICAgICAvLyByZW1vdmUgdGhlIHBhcnNlZCBzZWxlY3RvciBhbmQgYmxvY2sgZnJvbSB0aGUgcmVtYWluaW5nIHRleHQgdG8gcGFyc2VcbiAgICAgIGlmKCByZW1haW5pbmcubGVuZ3RoID4gc2VsQW5kQmxvY2tTdHIubGVuZ3RoICl7XG4gICAgICAgIHJlbWFpbmluZyA9IHJlbWFpbmluZy5zdWJzdHIoIHNlbEFuZEJsb2NrU3RyLmxlbmd0aCApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtYWluaW5nID0gJyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlUHJvcEFuZFZhbEZyb21SZW0oKXtcbiAgICAgIC8vIHJlbW92ZSB0aGUgcGFyc2VkIHByb3BlcnR5IGFuZCB2YWx1ZSBmcm9tIHRoZSByZW1haW5pbmcgYmxvY2sgdGV4dCB0byBwYXJzZVxuICAgICAgaWYoIGJsb2NrUmVtLmxlbmd0aCA+IHByb3BBbmRWYWxTdHIubGVuZ3RoICl7XG4gICAgICAgIGJsb2NrUmVtID0gYmxvY2tSZW0uc3Vic3RyKCBwcm9wQW5kVmFsU3RyLmxlbmd0aCApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmxvY2tSZW0gPSAnJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aGlsZSh0cnVlKXtcbiAgICAgIHZhciBub3RoaW5nTGVmdFRvUGFyc2UgPSByZW1haW5pbmcubWF0Y2goL15cXHMqJC8pO1xuICAgICAgaWYoIG5vdGhpbmdMZWZ0VG9QYXJzZSApeyBicmVhazsgfVxuXG4gICAgICB2YXIgc2VsQW5kQmxvY2sgPSByZW1haW5pbmcubWF0Y2goL15cXHMqKCg/Oi58XFxzKSs/KVxccypcXHsoKD86LnxcXHMpKz8pXFx9Lyk7XG5cbiAgICAgIGlmKCAhc2VsQW5kQmxvY2sgKXtcbiAgICAgICAgJCQudXRpbC5lcnJvcignSGFsdGluZyBzdHlsZXNoZWV0IHBhcnNpbmc6IFN0cmluZyBzdHlsZXNoZWV0IGNvbnRhaW5zIG1vcmUgdG8gcGFyc2UgYnV0IG5vIHNlbGVjdG9yIGFuZCBibG9jayBmb3VuZCBpbjogJyArIHJlbWFpbmluZyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBzZWxBbmRCbG9ja1N0ciA9IHNlbEFuZEJsb2NrWzBdO1xuXG4gICAgICAvLyBwYXJzZSB0aGUgc2VsZWN0b3JcbiAgICAgIHZhciBzZWxlY3RvclN0ciA9IHNlbEFuZEJsb2NrWzFdO1xuICAgICAgaWYoIHNlbGVjdG9yU3RyICE9PSAnY29yZScgKXtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gbmV3ICQkLlNlbGVjdG9yKCBzZWxlY3RvclN0ciApO1xuICAgICAgICBpZiggc2VsZWN0b3IuX3ByaXZhdGUuaW52YWxpZCApe1xuICAgICAgICAgICQkLnV0aWwuZXJyb3IoJ1NraXBwaW5nIHBhcnNpbmcgb2YgYmxvY2s6IEludmFsaWQgc2VsZWN0b3IgZm91bmQgaW4gc3RyaW5nIHN0eWxlc2hlZXQ6ICcgKyBzZWxlY3RvclN0cik7XG5cbiAgICAgICAgICAvLyBza2lwIHRoaXMgc2VsZWN0b3IgYW5kIGJsb2NrXG4gICAgICAgICAgcmVtb3ZlU2VsQW5kQmxvY2tGcm9tUmVtYWluaW5nKCk7XG4gICAgICAgICAgY29udGludWU7IFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHBhcnNlIHRoZSBibG9jayBvZiBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXNcbiAgICAgIHZhciBibG9ja1N0ciA9IHNlbEFuZEJsb2NrWzJdO1xuICAgICAgdmFyIGludmFsaWRCbG9jayA9IGZhbHNlO1xuICAgICAgYmxvY2tSZW0gPSBibG9ja1N0cjtcbiAgICAgIHZhciBwcm9wcyA9IFtdO1xuXG4gICAgICB3aGlsZSh0cnVlKXtcbiAgICAgICAgdmFyIG5vdGhpbmdMZWZ0VG9QYXJzZSA9IGJsb2NrUmVtLm1hdGNoKC9eXFxzKiQvKTtcbiAgICAgICAgaWYoIG5vdGhpbmdMZWZ0VG9QYXJzZSApeyBicmVhazsgfVxuXG4gICAgICAgIHZhciBwcm9wQW5kVmFsID0gYmxvY2tSZW0ubWF0Y2goL15cXHMqKC4rPylcXHMqOlxccyooLis/KVxccyo7Lyk7XG5cbiAgICAgICAgaWYoICFwcm9wQW5kVmFsICl7XG4gICAgICAgICAgJCQudXRpbC5lcnJvcignU2tpcHBpbmcgcGFyc2luZyBvZiBibG9jazogSW52YWxpZCBmb3JtYXR0aW5nIG9mIHN0eWxlIHByb3BlcnR5IGFuZCB2YWx1ZSBkZWZpbml0aW9ucyBmb3VuZCBpbjonICsgYmxvY2tTdHIpO1xuICAgICAgICAgIGludmFsaWRCbG9jayA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9wQW5kVmFsU3RyID0gcHJvcEFuZFZhbFswXTtcbiAgICAgICAgdmFyIHByb3BTdHIgPSBwcm9wQW5kVmFsWzFdO1xuICAgICAgICB2YXIgdmFsU3RyID0gcHJvcEFuZFZhbFsyXTtcblxuICAgICAgICB2YXIgcHJvcCA9ICQkLnN0eWxlLnByb3BlcnRpZXNbIHByb3BTdHIgXTtcbiAgICAgICAgaWYoICFwcm9wICl7XG4gICAgICAgICAgJCQudXRpbC5lcnJvcignU2tpcHBpbmcgcHJvcGVydHk6IEludmFsaWQgcHJvcGVydHkgbmFtZSBpbjogJyArIHByb3BBbmRWYWxTdHIpO1xuXG4gICAgICAgICAgLy8gc2tpcCB0aGlzIHByb3BlcnR5IGluIHRoZSBibG9ja1xuICAgICAgICAgIHJlbW92ZVByb3BBbmRWYWxGcm9tUmVtKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFyc2VkUHJvcCA9IHN0eWxlLnBhcnNlKCBwcm9wU3RyLCB2YWxTdHIgKTtcblxuICAgICAgICBpZiggIXBhcnNlZFByb3AgKXtcbiAgICAgICAgICAkJC51dGlsLmVycm9yKCdTa2lwcGluZyBwcm9wZXJ0eTogSW52YWxpZCBwcm9wZXJ0eSBkZWZpbml0aW9uIGluOiAnICsgcHJvcEFuZFZhbFN0cik7XG5cbiAgICAgICAgICAvLyBza2lwIHRoaXMgcHJvcGVydHkgaW4gdGhlIGJsb2NrXG4gICAgICAgICAgcmVtb3ZlUHJvcEFuZFZhbEZyb21SZW0oKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb3BzLnB1c2goe1xuICAgICAgICAgIG5hbWU6IHByb3BTdHIsXG4gICAgICAgICAgdmFsOiB2YWxTdHJcbiAgICAgICAgfSk7XG4gICAgICAgIHJlbW92ZVByb3BBbmRWYWxGcm9tUmVtKCk7XG4gICAgICB9XG5cbiAgICAgIGlmKCBpbnZhbGlkQmxvY2sgKXtcbiAgICAgICAgcmVtb3ZlU2VsQW5kQmxvY2tGcm9tUmVtYWluaW5nKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyBwdXQgdGhlIHBhcnNlZCBibG9jayBpbiB0aGUgc3R5bGVcbiAgICAgIHN0eWxlLnNlbGVjdG9yKCBzZWxlY3RvclN0ciApO1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgICBzdHlsZS5jc3MoIHByb3AubmFtZSwgcHJvcC52YWwgKTtcbiAgICAgIH1cblxuICAgICAgcmVtb3ZlU2VsQW5kQmxvY2tGcm9tUmVtYWluaW5nKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlO1xuICB9O1xuXG4gICQkLnN0eWxlLmZyb21TdHJpbmcgPSBmdW5jdGlvbiggY3ksIHN0cmluZyApe1xuICAgIHZhciBzdHlsZSA9IG5ldyAkJC5TdHlsZShjeSk7XG4gICAgXG4gICAgJCQuc3R5bGUuYXBwbHlGcm9tU3RyaW5nKCBzdHlsZSwgc3RyaW5nICk7XG5cbiAgICByZXR1cm4gc3R5bGU7XG4gIH07XG5cbiAgJCQuc3R5Zm4uZnJvbVN0cmluZyA9IGZ1bmN0aW9uKCBzdHJpbmcgKXtcbiAgICB2YXIgc3R5bGUgPSB0aGlzO1xuXG4gICAgc3R5bGUucmVzZXRUb0RlZmF1bHQoKTtcblxuICAgICQkLnN0eWxlLmFwcGx5RnJvbVN0cmluZyggc3R5bGUsIHN0cmluZyApO1xuXG4gICAgcmV0dXJuIHN0eWxlO1xuICB9O1xuXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgLy8gYSBkdW1teSBzdHlsZXNoZWV0IG9iamVjdCB0aGF0IGRvZXNuJ3QgbmVlZCBhIHJlZmVyZW5jZSB0byB0aGUgY29yZVxuICAvLyAodXNlZnVsIGZvciBpbml0KVxuICAkJC5zdHlsZXNoZWV0ID0gJCQuU3R5bGVzaGVldCA9IGZ1bmN0aW9uKCl7XG4gICAgaWYoICEodGhpcyBpbnN0YW5jZW9mICQkLlN0eWxlc2hlZXQpICl7XG4gICAgICByZXR1cm4gbmV3ICQkLlN0eWxlc2hlZXQoKTtcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH07XG5cbiAgJCQuc2hlZXRmbiA9ICQkLlN0eWxlc2hlZXQucHJvdG90eXBlO1xuXG4gIC8vIGp1c3Qgc3RvcmUgdGhlIHNlbGVjdG9yIHRvIGJlIHBhcnNlZCBsYXRlclxuICAkJC5zaGVldGZuLnNlbGVjdG9yID0gZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgdmFyIGkgPSB0aGlzLmxlbmd0aCsrO1xuXG4gICAgdGhpc1tpXSA9IHtcbiAgICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICAgIHByb3BlcnRpZXM6IFtdXG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuXG4gIC8vIGp1c3Qgc3RvcmUgdGhlIHByb3BlcnR5IHRvIGJlIHBhcnNlZCBsYXRlclxuICAkJC5zaGVldGZuLmNzcyA9IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApe1xuICAgIHZhciBpID0gdGhpcy5sZW5ndGggLSAxO1xuXG4gICAgaWYoICQkLmlzLnN0cmluZyhuYW1lKSApe1xuICAgICAgdGhpc1tpXS5wcm9wZXJ0aWVzLnB1c2goe1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiggJCQuaXMucGxhaW5PYmplY3QobmFtZSkgKXtcbiAgICAgIHZhciBtYXAgPSBuYW1lO1xuXG4gICAgICBmb3IoIHZhciBqID0gMDsgaiA8ICQkLnN0eWxlLnByb3BlcnRpZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgdmFyIHByb3AgPSAkJC5zdHlsZS5wcm9wZXJ0aWVzW2pdO1xuICAgICAgICB2YXIgbWFwVmFsID0gbWFwWyBwcm9wLm5hbWUgXTtcblxuICAgICAgICBpZiggbWFwVmFsID09PSB1bmRlZmluZWQgKXsgLy8gYWxzbyB0cnkgY2FtZWwgY2FzZSBuYW1lXG4gICAgICAgICAgbWFwVmFsID0gbWFwWyAkJC51dGlsLmRhc2gyY2FtZWwocHJvcC5uYW1lKSBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIG1hcFZhbCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgdmFyIG5hbWUgPSBwcm9wLm5hbWU7XG4gICAgICAgICAgdmFyIHZhbHVlID0gbWFwVmFsO1xuXG4gICAgICAgICAgdGhpc1tpXS5wcm9wZXJ0aWVzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG5cbiAgJCQuc2hlZXRmbi5zdHlsZSA9ICQkLnNoZWV0Zm4uY3NzO1xuXG4gIC8vIGdlbmVyYXRlIGEgcmVhbCBzdHlsZSBvYmplY3QgZnJvbSB0aGUgZHVtbXkgc3R5bGVzaGVldFxuICAkJC5zaGVldGZuLmdlbmVyYXRlU3R5bGUgPSBmdW5jdGlvbiggY3kgKXtcbiAgICB2YXIgc3R5bGUgPSBuZXcgJCQuU3R5bGUoY3kpO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXNbaV07XG4gICAgICB2YXIgc2VsZWN0b3IgPSBjb250ZXh0LnNlbGVjdG9yO1xuICAgICAgdmFyIHByb3BzID0gY29udGV4dC5wcm9wZXJ0aWVzO1xuXG4gICAgICBzdHlsZS5zZWxlY3RvcihzZWxlY3Rvcik7IC8vIGFwcGx5IHNlbGVjdG9yXG5cbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgcHJvcHMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgdmFyIHByb3AgPSBwcm9wc1tqXTtcblxuICAgICAgICBzdHlsZS5jc3MoIHByb3AubmFtZSwgcHJvcC52YWx1ZSApOyAvLyBhcHBseSBwcm9wZXJ0eVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHlsZTtcbiAgfTtcblxufSkoIGN5dG9zY2FwZSApO1xuLy8gY3Jvc3MtZW52IHRocmVhZC93b3JrZXJcbi8vIE5CIDogdXNlcyAoaGVhdnl3ZWlnaHQpIHByb2Nlc3NlcyBvbiBub2RlanMgc28gYmVzdCBub3QgdG8gY3JlYXRlIHRvbyBtYW55IHRocmVhZHNcblxuOyhmdW5jdGlvbigkJCwgd2luZG93KXsgJ3VzZSBzdHJpY3QnO1xuXG4gICQkLlRocmVhZCA9IGZ1bmN0aW9uKCBmbiApe1xuICAgIGlmKCAhKHRoaXMgaW5zdGFuY2VvZiAkJC5UaHJlYWQpICl7XG4gICAgICByZXR1cm4gbmV3ICQkLlRocmVhZCggZm4gKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wcml2YXRlID0ge1xuICAgICAgcmVxdWlyZXM6IFtdLFxuICAgICAgZmlsZXM6IFtdLFxuICAgICAgcXVldWU6IG51bGwsXG4gICAgICBwYXNzOiBbXVxuICAgIH07XG5cbiAgICBpZiggZm4gKXtcbiAgICAgIHRoaXMucnVuKCBmbiApO1xuICAgIH1cblxuICB9O1xuXG4gICQkLnRocmVhZCA9ICQkLlRocmVhZDtcbiAgJCQudGhkZm4gPSAkJC5UaHJlYWQucHJvdG90eXBlOyAvLyBzaG9ydCBhbGlhc1xuXG4gICQkLmZuLnRocmVhZCA9IGZ1bmN0aW9uKCBmbk1hcCwgb3B0aW9ucyApe1xuICAgIGZvciggdmFyIG5hbWUgaW4gZm5NYXAgKXtcbiAgICAgIHZhciBmbiA9IGZuTWFwW25hbWVdO1xuICAgICAgJCQuVGhyZWFkLnByb3RvdHlwZVsgbmFtZSBdID0gZm47XG4gICAgfVxuICB9O1xuXG4gIHZhciBzdHJpbmdpZnlGaWVsZFZhbCA9IGZ1bmN0aW9uKCB2YWwgKXtcbiAgICB2YXIgdmFsU3RyID0gJCQuaXMuZm4oIHZhbCApID8gdmFsLnRvU3RyaW5nKCkgOiAnSlNPTi5wYXJzZShcIicgKyBKU09OLnN0cmluZ2lmeSh2YWwpICsgJ1wiKSc7XG5cbiAgICByZXR1cm4gdmFsU3RyO1xuICB9O1xuXG4gIC8vIGFsbG93cyBmb3IgcmVxdWlyZXMgd2l0aCBwcm90b3R5cGVzIGFuZCBzdWJvYmpzIGV0Y1xuICB2YXIgZm5Bc1JlcXVpcmUgPSBmdW5jdGlvbiggZm4gKXtcbiAgICB2YXIgcmVxO1xuICAgIHZhciBmbk5hbWU7XG5cbiAgICBpZiggJCQuaXMub2JqZWN0KGZuKSAmJiBmbi5mbiApeyAvLyBtYW51YWwgZm5cbiAgICAgIHJlcSA9IGZuQXMoIGZuLmZuLCBmbi5uYW1lICk7XG4gICAgICBmbk5hbWUgPSBmbi5uYW1lO1xuICAgICAgZm4gPSBmbi5mbjtcbiAgICB9IGVsc2UgaWYoICQkLmlzLmZuKGZuKSApeyAvLyBhdXRvIGZuXG4gICAgICByZXEgPSBmbi50b1N0cmluZygpO1xuICAgICAgZm5OYW1lID0gZm4ubmFtZTtcbiAgICB9IGVsc2UgaWYoICQkLmlzLnN0cmluZyhmbikgKXsgLy8gc3RyaW5naWZpZWQgZm5cbiAgICAgIHJlcSA9IGZuO1xuICAgIH0gZWxzZSBpZiggJCQuaXMub2JqZWN0KGZuKSApeyAvLyBwbGFpbiBvYmplY3RcbiAgICAgIGlmKCBmbi5wcm90byApe1xuICAgICAgICByZXEgPSAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcSA9IGZuLm5hbWUgKyAnID0ge307JztcbiAgICAgIH1cblxuICAgICAgZm5OYW1lID0gZm4ubmFtZTtcbiAgICAgIGZuID0gZm4ub2JqO1xuICAgIH1cblxuICAgIHJlcSArPSAnXFxuJztcblxuICAgIHZhciBwcm90b3JlcSA9IGZ1bmN0aW9uKCB2YWwsIHN1Ym5hbWUgKXtcbiAgICAgIGlmKCB2YWwucHJvdG90eXBlICl7XG4gICAgICAgIHZhciBwcm90b05vbmVtcHR5ID0gZmFsc2U7XG4gICAgICAgIGZvciggdmFyIHByb3AgaW4gdmFsLnByb3RvdHlwZSApeyBwcm90b05vbmVtcHR5ID0gdHJ1ZTsgYnJlYWs7IH1cblxuICAgICAgICBpZiggcHJvdG9Ob25lbXB0eSApe1xuICAgICAgICAgIHJlcSArPSBmbkFzUmVxdWlyZSgge1xuICAgICAgICAgICAgbmFtZTogc3VibmFtZSxcbiAgICAgICAgICAgIG9iajogdmFsLFxuICAgICAgICAgICAgcHJvdG86IHRydWVcbiAgICAgICAgICB9LCB2YWwgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBwdWxsIGluIHByb3RvdHlwZVxuICAgIGlmKCBmbi5wcm90b3R5cGUgJiYgZm5OYW1lICE9IG51bGwgKXtcblxuICAgICAgZm9yKCB2YXIgbmFtZSBpbiBmbi5wcm90b3R5cGUgKXtcbiAgICAgICAgdmFyIHByb3RvU3RyID0gJyc7XG5cbiAgICAgICAgdmFyIHZhbCA9IGZuLnByb3RvdHlwZVsgbmFtZSBdO1xuICAgICAgICB2YXIgdmFsU3RyID0gc3RyaW5naWZ5RmllbGRWYWwoIHZhbCApO1xuICAgICAgICB2YXIgc3VibmFtZSA9IGZuTmFtZSArICcucHJvdG90eXBlLicgKyBuYW1lO1xuXG4gICAgICAgIHByb3RvU3RyICs9IHN1Ym5hbWUgKyAnID0gJyArIHZhbFN0ciArICc7XFxuJztcblxuICAgICAgICBpZiggcHJvdG9TdHIgKXtcbiAgICAgICAgICByZXEgKz0gcHJvdG9TdHI7XG4gICAgICAgIH1cblxuICAgICAgICBwcm90b3JlcSggdmFsLCBzdWJuYW1lICk7IC8vIHN1Ym9iamVjdCB3aXRoIHByb3RvdHlwZVxuICAgICAgfVxuICBcbiAgICB9XG5cbiAgICAvLyBwdWxsIGluIHByb3BlcnRpZXMgZm9yIG9iai9mbnNcbiAgICBpZiggISQkLmlzLnN0cmluZyhmbikgKXsgZm9yKCB2YXIgbmFtZSBpbiBmbiApe1xuICAgICAgdmFyIHByb3BzU3RyID0gJyc7XG5cbiAgICAgIGlmKCBmbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSApe1xuICAgICAgICB2YXIgdmFsID0gZm5bIG5hbWUgXTtcbiAgICAgICAgdmFyIHZhbFN0ciA9IHN0cmluZ2lmeUZpZWxkVmFsKCB2YWwgKTtcbiAgICAgICAgdmFyIHN1Ym5hbWUgPSBmbk5hbWUgKyAnW1wiJyArIG5hbWUgKyAnXCJdJztcblxuICAgICAgICBwcm9wc1N0ciArPSBzdWJuYW1lICsgJyA9ICcgKyB2YWxTdHIgKyAnO1xcbic7XG4gICAgICB9XG5cbiAgICAgIGlmKCBwcm9wc1N0ciApe1xuICAgICAgICByZXEgKz0gcHJvcHNTdHI7XG4gICAgICB9XG5cbiAgICAgIHByb3RvcmVxKCB2YWwsIHN1Ym5hbWUgKTsgLy8gc3Vib2JqZWN0IHdpdGggcHJvdG90eXBlXG4gICAgfSB9XG5cbiAgICByZXR1cm4gcmVxO1xuICB9O1xuICBcbiAgdmFyIGlzUGF0aFN0ciA9IGZ1bmN0aW9uKCBzdHIgKXtcbiAgICByZXR1cm4gJCQuaXMuc3RyaW5nKHN0cikgJiYgc3RyLm1hdGNoKC9cXC5qcyQvKTtcbiAgfTtcblxuICAkJC5mbi50aHJlYWQoe1xuXG4gICAgcmVxdWlyZTogZnVuY3Rpb24oIGZuLCBhcyApe1xuICAgICAgaWYoIGlzUGF0aFN0cihmbikgKXtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5maWxlcy5wdXNoKCBmbiApO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICAgIFxuICAgICAgaWYoIGFzICl7XG4gICAgICAgIGlmKCAkJC5pcy5mbihmbikgKXtcbiAgICAgICAgICAvLyBkaXNhYmxlZCBiL2MgZG9lc24ndCB3b3JrIHdpdGggZm9yY2VkIG5hbWVzIG9uIGZ1bmN0aW9ucyB3LyBwcm90b3R5cGVzXG4gICAgICAgICAgLy9mbiA9IGZuQXMoIGZuLCBhcyApO1xuXG4gICAgICAgICAgYXMgPSBhcyB8fCBmbi5uYW1lO1xuXG4gICAgICAgICAgZm4gPSB7IG5hbWU6IGFzLCBmbjogZm4gfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmbiA9IHsgbmFtZTogYXMsIG9iajogZm4gfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9wcml2YXRlLnJlcXVpcmVzLnB1c2goIGZuICk7XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICBwYXNzOiBmdW5jdGlvbiggZGF0YSApe1xuICAgICAgdGhpcy5fcHJpdmF0ZS5wYXNzLnB1c2goIGRhdGEgKTtcblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIHJ1bjogZnVuY3Rpb24oIGZuLCBwYXNzICl7IC8vIGZuIHVzZWQgbGlrZSBtYWluKClcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgICBwYXNzID0gcGFzcyB8fCBfcC5wYXNzLnNoaWZ0KCk7XG5cbiAgICAgIGlmKCBfcC5zdG9wcGVkICl7XG4gICAgICAgICQkLnV0aWwuZXJyb3IoJ0F0dGVtcHRlZCB0byBydW4gYSBzdG9wcGVkIHRocmVhZCEgIFN0YXJ0IGEgbmV3IHRocmVhZCBvciBkbyBub3Qgc3RvcCB0aGUgZXhpc3RpbmcgdGhyZWFkIGFuZCByZXVzZSBpdC4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiggX3AucnVubmluZyApe1xuICAgICAgICByZXR1cm4gX3AucXVldWUgPSBfcC5xdWV1ZS50aGVuKGZ1bmN0aW9uKCl7IC8vIGluZHVjdGl2ZSBzdGVwXG4gICAgICAgICAgcmV0dXJuIHNlbGYucnVuKCBmbiwgcGFzcyApO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIHVzZVdXID0gd2luZG93ICE9IG51bGw7XG4gICAgICB2YXIgdXNlTm9kZSA9IHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnO1xuXG4gICAgICBzZWxmLnRyaWdnZXIoJ3J1bicpO1xuXG4gICAgICB2YXIgcnVuUCA9IG5ldyAkJC5Qcm9taXNlKGZ1bmN0aW9uKCByZXNvbHZlLCByZWplY3QgKXtcblxuICAgICAgICBfcC5ydW5uaW5nID0gdHJ1ZTtcblxuICAgICAgICB2YXIgdGhyZWFkVGVjaEFscmVhZHlFeGlzdHMgPSBfcC5yYW47XG5cbiAgICAgICAgdmFyIGZuSW1wbFN0ciA9ICQkLmlzLnN0cmluZyggZm4gKSA/IGZuIDogZm4udG9TdHJpbmcoKTtcblxuICAgICAgICAvLyB3b3JrZXIgY29kZSB0byBleGVjXG4gICAgICAgIHZhciBmblN0ciA9ICdcXG4nICsgKCBfcC5yZXF1aXJlcy5tYXAoZnVuY3Rpb24oIHIgKXtcbiAgICAgICAgICByZXR1cm4gZm5Bc1JlcXVpcmUoIHIgKTtcbiAgICAgICAgfSkgKS5jb25jYXQoIF9wLmZpbGVzLm1hcChmdW5jdGlvbiggZiApe1xuICAgICAgICAgIGlmKCB1c2VXVyApe1xuICAgICAgICAgICAgdmFyIHd3aWZ5RmlsZSA9IGZ1bmN0aW9uKCBmaWxlICl7XG4gICAgICAgICAgICAgIGlmKCBmaWxlLm1hdGNoKC9eXFwuXFwvLykgfHwgZmlsZS5tYXRjaCgvXlxcLlxcLi8pICl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gKyB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyBmaWxlO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYoIGZpbGUubWF0Y2goL15cXC8vKSApe1xuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cubG9jYXRpb24ub3JpZ2luICsgJy8nICsgZmlsZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiAnaW1wb3J0U2NyaXB0cyhcIicgKyB3d2lmeUZpbGUoZikgKyAnXCIpOyc7XG4gICAgICAgICAgfSBlbHNlIGlmKCB1c2VOb2RlICkge1xuICAgICAgICAgICAgcmV0dXJuICdldmFsKCByZXF1aXJlKFwiZnNcIikucmVhZEZpbGVTeW5jKFwiJyArIGYgKyAnXCIsIHsgZW5jb2Rpbmc6IFwidXRmOFwiIH0pICk7JztcbiAgICAgICAgICB9XG4gICAgICAgIH0pICkuY29uY2F0KFtcbiAgICAgICAgICAnKCBmdW5jdGlvbigpeycsXG4gICAgICAgICAgICAndmFyIHJldCA9ICgnICsgZm5JbXBsU3RyICsgJykoJyArIEpTT04uc3RyaW5naWZ5KHBhc3MpICsgJyk7JyxcbiAgICAgICAgICAgICdpZiggcmV0ICE9PSB1bmRlZmluZWQgKXsgcmVzb2x2ZShyZXQpOyB9JywgLy8gYXNzdW1lIGlmIHJhbiBmbiByZXR1cm5zIGRlZmluZWQgdmFsdWUgKGluY2wuIG51bGwpLCB0aGF0IHdlIHdhbnQgdG8gcmVzb2x2ZSB0byBpdFxuICAgICAgICAgICd9ICkoKVxcbidcbiAgICAgICAgXSkuam9pbignXFxuJyk7XG5cbiAgICAgICAgLy8gYmVjYXVzZSB3ZSd2ZSBub3cgY29uc3VtZWQgdGhlIHJlcXVpcmVzLCBlbXB0eSB0aGUgbGlzdCBzbyB3ZSBkb24ndCBkdXBlIG9uIG5leHQgcnVuKClcbiAgICAgICAgX3AucmVxdWlyZXMgPSBbXTtcbiAgICAgICAgX3AuZmlsZXMgPSBbXTtcblxuICAgICAgICBpZiggdXNlV1cgKXtcbiAgICAgICAgICB2YXIgZm5CbG9iLCBmblVybDtcblxuICAgICAgICAgIC8vIGFkZCBub3JtYWxpc2VkIHRocmVhZCBhcGkgZnVuY3Rpb25zXG4gICAgICAgICAgaWYoICF0aHJlYWRUZWNoQWxyZWFkeUV4aXN0cyApe1xuICAgICAgICAgICAgdmFyIGZuUHJlID0gZm5TdHIgKyAnJztcblxuICAgICAgICAgICAgZm5TdHIgPSBbXG4gICAgICAgICAgICAgICdmdW5jdGlvbiBicm9hZGNhc3QobSl7IHJldHVybiBtZXNzYWdlKG0pOyB9OycsIC8vIGFsaWFzXG4gICAgICAgICAgICAgICdmdW5jdGlvbiBtZXNzYWdlKG0peyBwb3N0TWVzc2FnZShtKTsgfTsnLFxuICAgICAgICAgICAgICAnZnVuY3Rpb24gbGlzdGVuKGZuKXsnLFxuICAgICAgICAgICAgICAnICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGZ1bmN0aW9uKG0peyAnLFxuICAgICAgICAgICAgICAnICAgIGlmKCB0eXBlb2YgbSA9PT0gXCJvYmplY3RcIiAmJiAobS5kYXRhLiQkZXZhbCB8fCBtLmRhdGEgPT09IFwiJCRzdGFydFwiKSApeycsXG4gICAgICAgICAgICAgICcgICAgfSBlbHNlIHsgJyxcbiAgICAgICAgICAgICAgJyAgICAgIGZuKCBtLmRhdGEgKTsnLFxuICAgICAgICAgICAgICAnICAgIH0nLFxuICAgICAgICAgICAgICAnICB9KTsnLFxuICAgICAgICAgICAgICAnfTsnLCBcbiAgICAgICAgICAgICAgJ3NlbGYuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZnVuY3Rpb24obSl7ICBpZiggbS5kYXRhLiQkZXZhbCApeyBldmFsKCBtLmRhdGEuJCRldmFsICk7IH0gIH0pOycsXG4gICAgICAgICAgICAgICdmdW5jdGlvbiByZXNvbHZlKHYpeyBwb3N0TWVzc2FnZSh7ICQkcmVzb2x2ZTogdiB9KTsgfTsnLCBcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIHJlamVjdCh2KXsgcG9zdE1lc3NhZ2UoeyAkJHJlamVjdDogdiB9KTsgfTsnXG4gICAgICAgICAgICBdLmpvaW4oJ1xcbicpO1xuICAgICAgICAgIFxuICAgICAgICAgICAgZm5TdHIgKz0gZm5QcmU7XG5cbiAgICAgICAgICAgIGZuQmxvYiA9IG5ldyBCbG9iKFsgZm5TdHIgXSwge1xuICAgICAgICAgICAgICB0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm5VcmwgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTCggZm5CbG9iICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGNyZWF0ZSB3ZWJ3b3JrZXIgYW5kIGxldCBpdCBleGVjIHRoZSBzZXJpYWxpc2VkIGNvZGVcbiAgICAgICAgICB2YXIgd3cgPSBfcC53ZWJ3b3JrZXIgPSBfcC53ZWJ3b3JrZXIgfHwgbmV3IFdvcmtlciggZm5VcmwgKTtcblxuICAgICAgICAgIGlmKCB0aHJlYWRUZWNoQWxyZWFkeUV4aXN0cyApeyAvLyB0aGVuIGp1c3QgZXhlYyBuZXcgcnVuKCkgY29kZVxuICAgICAgICAgICAgd3cucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAkJGV2YWw6IGZuU3RyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB3b3JrZXIgbWVzc2FnZXMgPT4gZXZlbnRzXG4gICAgICAgICAgdmFyIGNiO1xuICAgICAgICAgIHd3LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBjYiA9IGZ1bmN0aW9uKCBtICl7XG4gICAgICAgICAgICB2YXIgaXNPYmplY3QgPSAkJC5pcy5vYmplY3QobSkgJiYgJCQuaXMub2JqZWN0KCBtLmRhdGEgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoIGlzT2JqZWN0ICYmICgnJCRyZXNvbHZlJyBpbiBtLmRhdGEpICl7XG4gICAgICAgICAgICAgIHd3LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBjYik7IC8vIGRvbmUgbGlzdGVuaW5nIGIvYyByZXNvbHZlKClcblxuICAgICAgICAgICAgICByZXNvbHZlKCBtLmRhdGEuJCRyZXNvbHZlICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYoIGlzT2JqZWN0ICYmICgnJCRyZWplY3QnIGluIG0uZGF0YSkgKXtcbiAgICAgICAgICAgICAgd3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGNiKTsgLy8gZG9uZSBsaXN0ZW5pbmcgYi9jIHJlamVjdCgpXG5cbiAgICAgICAgICAgICAgcmVqZWN0KCBtLmRhdGEuJCRyZWplY3QgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlbGYudHJpZ2dlciggbmV3ICQkLkV2ZW50KG0sIHsgdHlwZTogJ21lc3NhZ2UnLCBtZXNzYWdlOiBtLmRhdGEgfSkgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBmYWxzZSk7XG5cbiAgICAgICAgICBpZiggIXRocmVhZFRlY2hBbHJlYWR5RXhpc3RzICl7XG4gICAgICAgICAgICB3dy5wb3N0TWVzc2FnZSgnJCRzdGFydCcpOyAvLyBzdGFydCB1cCB0aGUgd29ya2VyXG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiggdXNlTm9kZSApe1xuICAgICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBwcm9jZXNzXG4gICAgICAgICAgdmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG4gICAgICAgICAgdmFyIGNoaWxkX3Byb2Nlc3MgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJyk7XG4gICAgICAgICAgdmFyIGNoaWxkID0gX3AuY2hpbGQgPSBfcC5jaGlsZCB8fCBjaGlsZF9wcm9jZXNzLmZvcmsoIHBhdGguam9pbihfX2Rpcm5hbWUsICd0aHJlYWQtbm9kZS1mb3JrJykgKTtcblxuICAgICAgICAgIC8vIGNoaWxkIHByb2Nlc3MgbWVzc2FnZXMgPT4gZXZlbnRzXG4gICAgICAgICAgdmFyIGNiO1xuICAgICAgICAgIGNoaWxkLm9uKCdtZXNzYWdlJywgY2IgPSBmdW5jdGlvbiggbSApe1xuICAgICAgICAgICAgaWYoICQkLmlzLm9iamVjdChtKSAmJiAoJyQkcmVzb2x2ZScgaW4gbSkgKXtcbiAgICAgICAgICAgICAgY2hpbGQucmVtb3ZlTGlzdGVuZXIoJ21lc3NhZ2UnLCBjYik7IC8vIGRvbmUgbGlzdGVuaW5nIGIvYyByZXNvbHZlKClcblxuICAgICAgICAgICAgICByZXNvbHZlKCBtLiQkcmVzb2x2ZSApO1xuICAgICAgICAgICAgfSBlbHNlIGlmKCAkJC5pcy5vYmplY3QobSkgJiYgKCckJHJlamVjdCcgaW4gbSkgKXtcbiAgICAgICAgICAgICAgY2hpbGQucmVtb3ZlTGlzdGVuZXIoJ21lc3NhZ2UnLCBjYik7IC8vIGRvbmUgbGlzdGVuaW5nIGIvYyByZWplY3QoKVxuXG4gICAgICAgICAgICAgIHJlamVjdCggbS4kJHJlamVjdCApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoe30sIHsgdHlwZTogJ21lc3NhZ2UnLCBtZXNzYWdlOiBtIH0pICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBhc2sgdGhlIGNoaWxkIHByb2Nlc3MgdG8gZXZhbCB0aGUgd29ya2VyIGNvZGVcbiAgICAgICAgICBjaGlsZC5zZW5kKHtcbiAgICAgICAgICAgICQkZXZhbDogZm5TdHJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkJC5lcnJvcignVHJpZWQgdG8gY3JlYXRlIHRocmVhZCBidXQgbm8gdW5kZXJseWluZyB0ZWNoIGZvdW5kIScpO1xuICAgICAgICAgIC8vIFRPRE8gZmFsbGJhY2sgb24gbWFpbiBKUyB0aHJlYWQ/XG4gICAgICAgIH1cblxuICAgICAgfSkudGhlbihmdW5jdGlvbiggdiApe1xuICAgICAgICBfcC5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIF9wLnJhbiA9IHRydWU7XG5cbiAgICAgICAgc2VsZi50cmlnZ2VyKCdyYW4nKTtcblxuICAgICAgICByZXR1cm4gdjtcbiAgICAgIH0pO1xuXG4gICAgICBpZiggX3AucXVldWUgPT0gbnVsbCApe1xuICAgICAgICBfcC5xdWV1ZSA9IHJ1blA7IC8vIGkuZS4gZmlyc3Qgc3RlcCBvZiBpbmR1Y3RpdmUgcHJvbWlzZSBjaGFpbiAoZm9yIHF1ZXVlKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcnVuUDtcbiAgICB9LFxuXG4gICAgLy8gc2VuZCB0aGUgdGhyZWFkIGEgbWVzc2FnZVxuICAgIG1lc3NhZ2U6IGZ1bmN0aW9uKCBtICl7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgICBpZiggX3Aud2Vid29ya2VyICl7XG4gICAgICAgIF9wLndlYndvcmtlci5wb3N0TWVzc2FnZSggbSApO1xuICAgICAgfVxuXG4gICAgICBpZiggX3AuY2hpbGQgKXtcbiAgICAgICAgX3AuY2hpbGQuc2VuZCggbSApO1xuICAgICAgfSBcblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgICBpZiggX3Aud2Vid29ya2VyICl7XG4gICAgICAgIF9wLndlYndvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgIH1cblxuICAgICAgaWYoIF9wLmNoaWxkICl7XG4gICAgICAgIF9wLmNoaWxkLmtpbGwoKTtcbiAgICAgIH0gXG5cbiAgICAgIF9wLnN0b3BwZWQgPSB0cnVlO1xuXG4gICAgICByZXR1cm4gdGhpcy50cmlnZ2VyKCdzdG9wJyk7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIHN0b3BwZWQ6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5zdG9wcGVkO1xuICAgIH1cblxuICB9KTtcblxuICB2YXIgZm5BcyA9IGZ1bmN0aW9uKCBmbiwgbmFtZSApe1xuICAgIHZhciBmblN0ciA9IGZuLnRvU3RyaW5nKCk7XG4gICAgZm5TdHIgPSBmblN0ci5yZXBsYWNlKC9mdW5jdGlvbi4qXFwoLywgJ2Z1bmN0aW9uICcgKyBuYW1lICsgJygnKTtcblxuICAgIHJldHVybiBmblN0cjtcbiAgfTtcblxuICB2YXIgZGVmaW5lRm5hbCA9IGZ1bmN0aW9uKCBvcHRzICl7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gZm5hbEltcGwoIGZuLCBhcmcxICl7XG4gICAgICB2YXIgZm5TdHIgPSBmbkFzKCBmbiwgJ18kXyRfJyArIG9wdHMubmFtZSApO1xuXG4gICAgICB0aGlzLnJlcXVpcmUoIGZuU3RyICk7XG5cbiAgICAgIHJldHVybiB0aGlzLnJ1biggWyBcbiAgICAgICAgJ2Z1bmN0aW9uKCBkYXRhICl7JyxcbiAgICAgICAgJyAgdmFyIG9yaWdSZXNvbHZlID0gcmVzb2x2ZTsnLFxuICAgICAgICAnICB2YXIgcmVzID0gW107JyxcbiAgICAgICAgJyAgJyxcbiAgICAgICAgJyAgcmVzb2x2ZSA9IGZ1bmN0aW9uKCB2YWwgKXsnLFxuICAgICAgICAnICAgIHJlcy5wdXNoKCB2YWwgKTsnLFxuICAgICAgICAnICB9OycsXG4gICAgICAgICcgICcsXG4gICAgICAgICcgIHZhciByZXQgPSBkYXRhLicgKyBvcHRzLm5hbWUgKyAnKCBfJF8kXycgKyBvcHRzLm5hbWUgKyAoIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gJywgJyArIEpTT04uc3RyaW5naWZ5KGFyZzEpIDogJycgKSArICcgKTsnLFxuICAgICAgICAnICAnLFxuICAgICAgICAnICByZXNvbHZlID0gb3JpZ1Jlc29sdmU7JyxcbiAgICAgICAgJyAgcmVzb2x2ZSggcmVzLmxlbmd0aCA+IDAgPyByZXMgOiByZXQgKTsnLFxuICAgICAgICAnfSdcbiAgICAgIF0uam9pbignXFxuJykgKTtcbiAgICB9O1xuICB9O1xuXG4gICQkLmZuLnRocmVhZCh7XG4gICAgcmVkdWNlOiBkZWZpbmVGbmFsKHsgbmFtZTogJ3JlZHVjZScgfSksXG5cbiAgICByZWR1Y2VSaWdodDogZGVmaW5lRm5hbCh7IG5hbWU6ICdyZWR1Y2VSaWdodCcgfSksXG5cbiAgICBtYXA6IGRlZmluZUZuYWwoeyBuYW1lOiAnbWFwJyB9KVxuICB9KTtcblxuICAvLyBhbGlhc2VzXG4gIHZhciBmbiA9ICQkLnRoZGZuO1xuICBmbi5wcm9taXNlID0gZm4ucnVuO1xuICBmbi50ZXJtaW5hdGUgPSBmbi5oYWx0ID0gZm4uc3RvcDtcbiAgZm4uaW5jbHVkZSA9IGZuLnJlcXVpcmU7XG5cbiAgLy8gaGlnaGVyIGxldmVsIGFsaWFzIChpbiBjYXNlIHlvdSBsaWtlIHRoZSB3b3JrZXIgbWV0YXBob3IpXG4gICQkLndvcmtlciA9ICQkLldvcmtlciA9ICQkLlRocmVhZDtcblxuICAvLyBwdWxsIGluIGV2ZW50IGFwaXNcbiAgJCQuZm4udGhyZWFkKHtcbiAgICBvbjogJCQuZGVmaW5lLm9uKCksXG4gICAgb25lOiAkJC5kZWZpbmUub24oeyB1bmJpbmRTZWxmT25UcmlnZ2VyOiB0cnVlIH0pLFxuICAgIG9mZjogJCQuZGVmaW5lLm9mZigpLCBcbiAgICB0cmlnZ2VyOiAkJC5kZWZpbmUudHJpZ2dlcigpXG4gIH0pO1xuXG4gICQkLmRlZmluZS5ldmVudEFsaWFzZXNPbiggJCQudGhkZm4gKTtcbiAgXG59KSggY3l0b3NjYXBlLCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB3aW5kb3cgKTtcblxuOyhmdW5jdGlvbigkJCwgd2luZG93KXsgJ3VzZSBzdHJpY3QnO1xuXG4gICQkLkZhYnJpYyA9IGZ1bmN0aW9uKCBOICl7XG4gICAgaWYoICEodGhpcyBpbnN0YW5jZW9mICQkLkZhYnJpYykgKXtcbiAgICAgIHJldHVybiBuZXcgJCQuRmFicmljKCBOICk7XG4gICAgfVxuXG4gICAgdGhpcy5fcHJpdmF0ZSA9IHtcbiAgICAgIHBhc3M6IFtdXG4gICAgfTtcblxuICAgIHZhciBkZWZOID0gNDtcblxuICAgIGlmKCAkJC5pcy5udW1iZXIoTikgKXtcbiAgICAgIC8vIHRoZW4gdXNlIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHRocmVhZHNcbiAgICB9IGlmKCB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeSAhPSBudWxsICl7XG4gICAgICBOID0gbmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3k7XG4gICAgfSBlbHNlIGlmKCB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyApe1xuICAgICAgTiA9IHJlcXVpcmUoJ29zJykuY3B1cygpLmxlbmd0aDtcbiAgICB9IGVsc2UgeyAvLyBUT0RPIGNvdWxkIHVzZSBhbiBlc3RpbWF0aW9uIGhlcmUgYnV0IHdvdWxkIHRoZSBhZGRpdGlvbmFsIGV4cGVuc2UgYmUgd29ydGggaXQ/XG4gICAgICBOID0gZGVmTjtcbiAgICB9XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IE47IGkrKyApe1xuICAgICAgdGhpc1tpXSA9ICQkLlRocmVhZCgpO1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gTjtcbiAgfTtcblxuICAkJC5mYWJyaWMgPSAkJC5GYWJyaWM7XG4gICQkLmZhYmZuID0gJCQuRmFicmljLnByb3RvdHlwZTsgLy8gc2hvcnQgYWxpYXNcblxuICAkJC5mbi5mYWJyaWMgPSBmdW5jdGlvbiggZm5NYXAsIG9wdGlvbnMgKXtcbiAgICBmb3IoIHZhciBuYW1lIGluIGZuTWFwICl7XG4gICAgICB2YXIgZm4gPSBmbk1hcFtuYW1lXTtcbiAgICAgICQkLkZhYnJpYy5wcm90b3R5cGVbIG5hbWUgXSA9IGZuO1xuICAgIH1cbiAgfTtcblxuICAkJC5mbi5mYWJyaWMoe1xuXG4gICAgLy8gcmVxdWlyZSBmbiBpbiBhbGwgdGhyZWFkc1xuICAgIHJlcXVpcmU6IGZ1bmN0aW9uKCBmbiwgYXMgKXtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgdGhyZWFkID0gdGhpc1tpXTtcblxuICAgICAgICB0aHJlYWQucmVxdWlyZSggZm4sIGFzICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBnZXQgYSByYW5kb20gdGhyZWFkXG4gICAgcmFuZG9tOiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGkgPSBNYXRoLnJvdW5kKCAodGhpcy5sZW5ndGggLSAxKSAqIE1hdGgucmFuZG9tKCkgKTtcbiAgICAgIHZhciB0aHJlYWQgPSB0aGlzW2ldO1xuXG4gICAgICByZXR1cm4gdGhyZWFkO1xuICAgIH0sXG5cbiAgICAvLyBydW4gb24gcmFuZG9tIHRocmVhZFxuICAgIHJ1bjogZnVuY3Rpb24oIGZuICl7XG4gICAgICB2YXIgcGFzcyA9IHRoaXMuX3ByaXZhdGUucGFzcy5zaGlmdCgpO1xuXG4gICAgICByZXR1cm4gdGhpcy5yYW5kb20oKS5wYXNzKCBwYXNzICkucnVuKCBmbiApO1xuICAgIH0sXG5cbiAgICAvLyBzZW5kcyBhIHJhbmRvbSB0aHJlYWQgYSBtZXNzYWdlXG4gICAgbWVzc2FnZTogZnVuY3Rpb24oIG0gKXtcbiAgICAgIHJldHVybiB0aGlzLnJhbmRvbSgpLm1lc3NhZ2UoIG0gKTtcbiAgICB9LFxuXG4gICAgLy8gc2VuZCBhbGwgdGhyZWFkcyBhIG1lc3NhZ2VcbiAgICBicm9hZGNhc3Q6IGZ1bmN0aW9uKCBtICl7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIHRocmVhZCA9IHRoaXNbaV07XG5cbiAgICAgICAgdGhyZWFkLm1lc3NhZ2UoIG0gKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIC8vIHN0b3AgYWxsIHRocmVhZHNcbiAgICBzdG9wOiBmdW5jdGlvbigpe1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciB0aHJlYWQgPSB0aGlzW2ldO1xuXG4gICAgICAgIHRocmVhZC5zdG9wKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICAvLyBwYXNzIGRhdGEgdG8gYmUgdXNlZCB3aXRoIC5zcHJlYWQoKSBldGMuXG4gICAgcGFzczogZnVuY3Rpb24oIGRhdGEgKXtcbiAgICAgIHZhciBwYXNzID0gdGhpcy5fcHJpdmF0ZS5wYXNzO1xuXG4gICAgICBpZiggJCQuaXMuYXJyYXkoZGF0YSkgKXtcbiAgICAgICAgcGFzcy5wdXNoKCBkYXRhICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkJC51dGlsLmVycm9yKCdPbmx5IGFycmF5cyBvciBjb2xsZWN0aW9ucyBtYXkgYmUgdXNlZCB3aXRoIGZhYnJpYy5wYXNzKCknKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIHNwcmVhZFNpemU6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgc3Vic2l6ZSA9ICBNYXRoLmNlaWwoIHRoaXMuX3ByaXZhdGUucGFzc1swXS5sZW5ndGggLyB0aGlzLmxlbmd0aCApO1xuXG4gICAgICBzdWJzaXplID0gTWF0aC5tYXgoIDEsIHN1YnNpemUgKTsgLy8gZG9uJ3QgcGFzcyBsZXNzIHRoYW4gb25lIGVsZSB0byBlYWNoIHRocmVhZFxuXG4gICAgICByZXR1cm4gc3Vic2l6ZTtcbiAgICB9LFxuXG4gICAgLy8gc3BsaXQgdGhlIGRhdGEgaW50byBzbGljZXMgdG8gc3ByZWFkIHRoZSBkYXRhIGVxdWFsbHkgYW1vbmcgdGhyZWFkc1xuICAgIHNwcmVhZDogZnVuY3Rpb24oIGZuICl7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgX3AgPSBzZWxmLl9wcml2YXRlO1xuICAgICAgdmFyIHN1YnNpemUgPSBzZWxmLnNwcmVhZFNpemUoKTsgLy8gbnVtYmVyIG9mIHBhc3MgZWxlcyB0byBoYW5kbGUgaW4gZWFjaCB0aHJlYWRcbiAgICAgIHZhciBwYXNzID0gX3AucGFzcy5zaGlmdCgpLmNvbmNhdChbXSk7IC8vIGtlZXAgYSBjb3B5XG4gICAgICB2YXIgcnVuUHMgPSBbXTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciB0aHJlYWQgPSB0aGlzW2ldO1xuICAgICAgICB2YXIgc2xpY2UgPSBwYXNzLnNwbGljZSggMCwgc3Vic2l6ZSApO1xuXG4gICAgICAgIHZhciBydW5QID0gdGhyZWFkLnBhc3MoIHNsaWNlICkucnVuKCBmbiApO1xuXG4gICAgICAgIHJ1blBzLnB1c2goIHJ1blAgKTtcblxuICAgICAgICB2YXIgZG9uZUVhcmx5ID0gcGFzcy5sZW5ndGggPT09IDA7XG4gICAgICAgIGlmKCBkb25lRWFybHkgKXsgYnJlYWs7IH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuICQkLlByb21pc2UuYWxsKCBydW5QcyApLnRoZW4oZnVuY3Rpb24oIHRoZW5zICl7XG4gICAgICAgIHZhciBwb3N0cGFzcyA9IFtdO1xuICAgICAgICB2YXIgcCA9IDA7XG5cbiAgICAgICAgLy8gZmlsbCBwb3N0cGFzcyB3aXRoIHRoZSB0b3RhbCByZXN1bHQgam9pbmVkIGZyb20gYWxsIHRocmVhZHNcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGVucy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciB0aGVuID0gdGhlbnNbaV07IC8vIGFycmF5IHJlc3VsdCBmcm9tIHRocmVhZCBpXG5cbiAgICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IHRoZW4ubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICAgIHZhciB0ID0gdGhlbltqXTsgLy8gYXJyYXkgZWxlbWVudFxuXG4gICAgICAgICAgICBwb3N0cGFzc1sgcCsrIF0gPSB0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb3N0cGFzcztcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBwYXJhbGxlbCB2ZXJzaW9uIG9mIGFycmF5Lm1hcCgpXG4gICAgbWFwOiBmdW5jdGlvbiggZm4gKXtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgc2VsZi5yZXF1aXJlKCBmbiwgJ18kXyRfZmFibWFwJyApO1xuXG4gICAgICByZXR1cm4gc2VsZi5zcHJlYWQoZnVuY3Rpb24oIHNwbGl0ICl7XG4gICAgICAgIHZhciBtYXBwZWQgPSBbXTtcbiAgICAgICAgdmFyIG9yaWdSZXNvbHZlID0gcmVzb2x2ZTtcblxuICAgICAgICByZXNvbHZlID0gZnVuY3Rpb24oIHZhbCApe1xuICAgICAgICAgIG1hcHBlZC5wdXNoKCB2YWwgKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHNwbGl0Lmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIG9sZExlbiA9IG1hcHBlZC5sZW5ndGg7XG4gICAgICAgICAgdmFyIHJldCA9IF8kXyRfZmFibWFwKCBzcGxpdFtpXSApO1xuICAgICAgICAgIHZhciBub3RoaW5nSW5zZEJ5UmVzb2x2ZSA9IG9sZExlbiA9PT0gbWFwcGVkLmxlbmd0aDtcblxuICAgICAgICAgIGlmKCBub3RoaW5nSW5zZEJ5UmVzb2x2ZSApe1xuICAgICAgICAgICAgbWFwcGVkLnB1c2goIHJldCApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlc29sdmUgPSBvcmlnUmVzb2x2ZTtcblxuICAgICAgICByZXR1cm4gbWFwcGVkO1xuICAgICAgfSk7XG5cbiAgICB9LFxuXG4gICAgLy8gcGFyYWxsZWwgdmVyc2lvbiBvZiBhcnJheS5maWx0ZXIoKVxuICAgIGZpbHRlcjogZnVuY3Rpb24oIGZuICl7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgICAgdmFyIHBhc3MgPSBfcC5wYXNzWzBdO1xuXG4gICAgICByZXR1cm4gdGhpcy5tYXAoIGZuICkudGhlbihmdW5jdGlvbiggaW5jbHVkZSApe1xuICAgICAgICB2YXIgcmV0ID0gW107XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwYXNzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGRhdHVtID0gcGFzc1tpXTtcbiAgICAgICAgICB2YXIgaW5jRGF0dW0gPSBpbmNsdWRlW2ldO1xuXG4gICAgICAgICAgaWYoIGluY0RhdHVtICl7XG4gICAgICAgICAgICByZXQucHVzaCggZGF0dW0gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIHNvcnRzIHRoZSBwYXNzZWQgYXJyYXkgdXNpbmcgYSBkaXZpZGUgYW5kIGNvbnF1ZXIgc3RyYXRlZ3lcbiAgICBzb3J0OiBmdW5jdGlvbiggY21wICl7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgUCA9IHRoaXMuX3ByaXZhdGUucGFzc1swXS5sZW5ndGg7XG4gICAgICB2YXIgc3Vic2l6ZSA9IHRoaXMuc3ByZWFkU2l6ZSgpO1xuXG4gICAgICBjbXAgPSBjbXAgfHwgZnVuY3Rpb24oIGEsIGIgKXsgLy8gZGVmYXVsdCBjb21wYXJpc29uIGZ1bmN0aW9uXG4gICAgICAgIGlmKCBhIDwgYiApe1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIGlmKCBhID4gYiApe1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnJlcXVpcmUoIGNtcCwgJ18kXyRfY21wJyApO1xuXG4gICAgICByZXR1cm4gc2VsZi5zcHJlYWQoZnVuY3Rpb24oIHNwbGl0ICl7IC8vIHNvcnQgZWFjaCBzcGxpdCBub3JtYWxseVxuICAgICAgICB2YXIgc29ydGVkU3BsaXQgPSBzcGxpdC5zb3J0KCBfJF8kX2NtcCApO1xuICAgICAgICByZXNvbHZlKCBzb3J0ZWRTcGxpdCApO1xuXG4gICAgICB9KS50aGVuKGZ1bmN0aW9uKCBqb2luZWQgKXtcbiAgICAgICAgLy8gZG8gYWxsIHRoZSBtZXJnaW5nIGluIHRoZSBtYWluIHRocmVhZCB0byBtaW5pbWlzZSBkYXRhIHRyYW5zZmVyXG5cbiAgICAgICAgLy8gVE9ETyBjb3VsZCBkbyBtZXJnaW5nIGluIHNlcGFyYXRlIHRocmVhZHMgYnV0IHdvdWxkIGluY3VyIGFkZCdsIGNvc3Qgb2YgZGF0YSB0cmFuc2ZlclxuICAgICAgICAvLyBmb3IgZWFjaCBsZXZlbCBvZiB0aGUgbWVyZ2VcblxuICAgICAgICB2YXIgbWVyZ2UgPSBmdW5jdGlvbiggaSwgaiwgbWF4ICl7XG4gICAgICAgICAgLy8gZG9uJ3Qgb3ZlcmZsb3cgYXJyYXlcbiAgICAgICAgICBqID0gTWF0aC5taW4oIGosIFAgKTtcbiAgICAgICAgICBtYXggPSBNYXRoLm1pbiggbWF4LCBQICk7XG5cbiAgICAgICAgICAvLyBsZWZ0IGFuZCByaWdodCBzaWRlcyBvZiBtZXJnZVxuICAgICAgICAgIHZhciBsID0gaTtcbiAgICAgICAgICB2YXIgciA9IGo7XG5cbiAgICAgICAgICB2YXIgc29ydGVkID0gW107XG5cbiAgICAgICAgICBmb3IoIHZhciBrID0gbDsgayA8IG1heDsgaysrICl7XG5cbiAgICAgICAgICAgIHZhciBlbGVJID0gam9pbmVkW2ldO1xuICAgICAgICAgICAgdmFyIGVsZUogPSBqb2luZWRbal07XG5cbiAgICAgICAgICAgIGlmKCBpIDwgciAmJiAoIGogPj0gbWF4IHx8IGNtcChlbGVJLCBlbGVKKSA8PSAwICkgKXtcbiAgICAgICAgICAgICAgc29ydGVkLnB1c2goIGVsZUkgKTtcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc29ydGVkLnB1c2goIGVsZUogKTtcbiAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaW4gdGhlIGFycmF5IHByb3BlciwgcHV0IHRoZSBzb3J0ZWQgdmFsdWVzXG4gICAgICAgICAgZm9yKCB2YXIgayA9IDA7IGsgPCBzb3J0ZWQubGVuZ3RoOyBrKysgKXsgLy8ga3RoIHNvcnRlZCBpdGVtXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBsICsgaztcblxuICAgICAgICAgICAgam9pbmVkWyBpbmRleCBdID0gc29ydGVkW2tdO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmb3IoIHZhciBzcGxpdEwgPSBzdWJzaXplOyBzcGxpdEwgPCBQOyBzcGxpdEwgKj0gMiApeyAvLyBtZXJnZSB1bnRpbCBhcnJheSBpcyBcInNwbGl0XCIgYXMgMVxuXG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBQOyBpICs9IDIqc3BsaXRMICl7XG4gICAgICAgICAgICBtZXJnZSggaSwgaSArIHNwbGl0TCwgaSArIDIqc3BsaXRMICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gam9pbmVkO1xuICAgICAgfSk7XG4gICAgfVxuXG5cbiAgfSk7XG5cbiAgdmFyIGRlZmluZVJhbmRvbVBhc3NlciA9IGZ1bmN0aW9uKCBvcHRzICl7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oIGZuLCBhcmcxICl7XG4gICAgICB2YXIgcGFzcyA9IHRoaXMuX3ByaXZhdGUucGFzcy5zaGlmdCgpO1xuXG4gICAgICByZXR1cm4gdGhpcy5yYW5kb20oKS5wYXNzKCBwYXNzIClbIG9wdHMudGhyZWFkRm4gXSggZm4sIGFyZzEgKTtcbiAgICB9O1xuICB9O1xuXG4gICQkLmZuLmZhYnJpYyh7XG4gICAgcmFuZG9tTWFwOiBkZWZpbmVSYW5kb21QYXNzZXIoeyB0aHJlYWRGbjogJ21hcCcgfSksXG5cbiAgICByZWR1Y2U6IGRlZmluZVJhbmRvbVBhc3Nlcih7IHRocmVhZEZuOiAncmVkdWNlJyB9KSxcblxuICAgIHJlZHVjZVJpZ2h0OiBkZWZpbmVSYW5kb21QYXNzZXIoeyB0aHJlYWRGbjogJ3JlZHVjZVJpZ2h0JyB9KVxuICB9KTtcblxuICAvLyBhbGlhc2VzXG4gIHZhciBmbiA9ICQkLmZhYmZuO1xuICBmbi5wcm9taXNlID0gZm4ucnVuO1xuICBmbi50ZXJtaW5hdGUgPSBmbi5oYWx0ID0gZm4uc3RvcDtcbiAgZm4uaW5jbHVkZSA9IGZuLnJlcXVpcmU7XG5cbiAgLy8gcHVsbCBpbiBldmVudCBhcGlzXG4gICQkLmZuLmZhYnJpYyh7XG4gICAgb246ICQkLmRlZmluZS5vbigpLFxuICAgIG9uZTogJCQuZGVmaW5lLm9uKHsgdW5iaW5kU2VsZk9uVHJpZ2dlcjogdHJ1ZSB9KSxcbiAgICBvZmY6ICQkLmRlZmluZS5vZmYoKSxcbiAgICB0cmlnZ2VyOiAkJC5kZWZpbmUudHJpZ2dlcigpXG4gIH0pO1xuXG4gICQkLmRlZmluZS5ldmVudEFsaWFzZXNPbiggJCQuZmFiZm4gKTtcblxufSkoIGN5dG9zY2FwZSwgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogd2luZG93ICk7XG5cbjsoZnVuY3Rpb24oJCQsIHdpbmRvdyl7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZGVmYXVsdHMgPSB7XG4gIH07XG4gIFxuICB2YXIgb3JpZ0RlZmF1bHRzID0gJCQudXRpbC5jb3B5KCBkZWZhdWx0cyApO1xuXG4gICQkLmRlZmF1bHRzID0gZnVuY3Rpb24oIG9wdHMgKXtcbiAgICBkZWZhdWx0cyA9ICQkLnV0aWwuZXh0ZW5kKHt9LCBvcmlnRGVmYXVsdHMsIG9wdHMpO1xuICB9O1xuXG4gICQkLmZuLmNvcmUgPSBmdW5jdGlvbiggZm5NYXAsIG9wdGlvbnMgKXtcbiAgICBmb3IoIHZhciBuYW1lIGluIGZuTWFwICl7XG4gICAgICB2YXIgZm4gPSBmbk1hcFtuYW1lXTtcbiAgICAgICQkLkNvcmUucHJvdG90eXBlWyBuYW1lIF0gPSBmbjtcbiAgICB9XG4gIH07XG4gIFxuICAkJC5Db3JlID0gZnVuY3Rpb24oIG9wdHMgKXtcbiAgICBpZiggISh0aGlzIGluc3RhbmNlb2YgJCQuQ29yZSkgKXtcbiAgICAgIHJldHVybiBuZXcgJCQuQ29yZShvcHRzKTtcbiAgICB9XG4gICAgdmFyIGN5ID0gdGhpcztcblxuICAgIG9wdHMgPSAkJC51dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIG9wdHMpO1xuXG4gICAgdmFyIGNvbnRhaW5lciA9IG9wdHMuY29udGFpbmVyO1xuICAgIHZhciByZWcgPSBjb250YWluZXIgPyBjb250YWluZXIuX2N5cmVnIDogbnVsbDsgLy8gZS5nLiBhbHJlYWR5IHJlZ2lzdGVyZWQgc29tZSBpbmZvIChlLmcuIHJlYWRpZXMpIHZpYSBqcXVlcnlcbiAgICByZWcgPSByZWcgfHwge307XG5cbiAgICBpZiggcmVnICYmIHJlZy5jeSApeyBcbiAgICAgIGlmKCBjb250YWluZXIgKXtcbiAgICAgICAgd2hpbGUoIGNvbnRhaW5lci5maXJzdENoaWxkICl7IC8vIGNsZWFuIHRoZSBjb250YWluZXJcbiAgICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lci5maXJzdENoaWxkICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmVnLmN5Lm5vdGlmeSh7IHR5cGU6ICdkZXN0cm95JyB9KTsgLy8gZGVzdHJveSB0aGUgcmVuZGVyZXJcblxuICAgICAgcmVnID0ge307IC8vIG9sZCBpbnN0YW5jZSA9PiByZXBsYWNlIHJlZyBjb21wbGV0ZWx5XG4gICAgfVxuXG4gICAgdmFyIHJlYWRpZXMgPSByZWcucmVhZGllcyA9IHJlZy5yZWFkaWVzIHx8IFtdO1xuICAgIFxuICAgIGlmKCBjb250YWluZXIgKXsgY29udGFpbmVyLl9jeXJlZyA9IHJlZzsgfSAvLyBtYWtlIHN1cmUgY29udGFpbmVyIGFzc29jJ2QgcmVnIHBvaW50cyB0byB0aGlzIGN5XG4gICAgcmVnLmN5ID0gY3k7XG5cbiAgICB2YXIgaGVhZCA9IHdpbmRvdyAhPT0gdW5kZWZpbmVkICYmIGNvbnRhaW5lciAhPT0gdW5kZWZpbmVkICYmICFvcHRzLmhlYWRsZXNzO1xuICAgIHZhciBvcHRpb25zID0gb3B0cztcbiAgICBvcHRpb25zLmxheW91dCA9ICQkLnV0aWwuZXh0ZW5kKCB7IG5hbWU6IGhlYWQgPyAnZ3JpZCcgOiAnbnVsbCcgfSwgb3B0aW9ucy5sYXlvdXQgKTtcbiAgICBvcHRpb25zLnJlbmRlcmVyID0gJCQudXRpbC5leHRlbmQoIHsgbmFtZTogaGVhZCA/ICdjYW52YXMnIDogJ251bGwnIH0sIG9wdGlvbnMucmVuZGVyZXIgKTtcbiAgICBcbiAgICB2YXIgZGVmVmFsID0gZnVuY3Rpb24oIGRlZiwgdmFsLCBhbHRWYWwgKXtcbiAgICAgIGlmKCB2YWwgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfSBlbHNlIGlmKCBhbHRWYWwgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICByZXR1cm4gYWx0VmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZSA9IHtcbiAgICAgIGNvbnRhaW5lcjogb3B0aW9ucy5jb250YWluZXIsIC8vIGh0bWwgZG9tIGVsZSBjb250YWluZXJcbiAgICAgIHJlYWR5OiBmYWxzZSwgLy8gd2hldGhlciByZWFkeSBoYXMgYmVlbiB0cmlnZ2VyZWRcbiAgICAgIGluaXRyZW5kZXI6IGZhbHNlLCAvLyBoYXMgaW5pdHJlbmRlciBoYXMgYmVlbiB0cmlnZ2VyZWRcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnMsIC8vIGNhY2hlZCBvcHRpb25zXG4gICAgICBlbGVtZW50czogW10sIC8vIGFycmF5IG9mIGVsZW1lbnRzXG4gICAgICBpZDJpbmRleDoge30sIC8vIGVsZW1lbnQgaWQgPT4gaW5kZXggaW4gZWxlbWVudHMgYXJyYXlcbiAgICAgIGxpc3RlbmVyczogW10sIC8vIGxpc3Qgb2YgbGlzdGVuZXJzXG4gICAgICBvblJlbmRlcnM6IFtdLCAvLyByZW5kZXJpbmcgbGlzdGVuZXJzXG4gICAgICBhbmlFbGVzOiAkJC5Db2xsZWN0aW9uKHRoaXMpLCAvLyBlbGVtZW50cyBiZWluZyBhbmltYXRlZFxuICAgICAgc2NyYXRjaDoge30sIC8vIHNjcmF0Y2ggb2JqZWN0IGZvciBjb3JlXG4gICAgICBsYXlvdXQ6IG51bGwsXG4gICAgICByZW5kZXJlcjogbnVsbCxcbiAgICAgIG5vdGlmaWNhdGlvbnNFbmFibGVkOiB0cnVlLCAvLyB3aGV0aGVyIG5vdGlmaWNhdGlvbnMgYXJlIHNlbnQgdG8gdGhlIHJlbmRlcmVyXG4gICAgICBtaW5ab29tOiAxZS01MCxcbiAgICAgIG1heFpvb206IDFlNTAsXG4gICAgICB6b29taW5nRW5hYmxlZDogZGVmVmFsKHRydWUsIG9wdGlvbnMuem9vbWluZ0VuYWJsZWQpLFxuICAgICAgdXNlclpvb21pbmdFbmFibGVkOiBkZWZWYWwodHJ1ZSwgb3B0aW9ucy51c2VyWm9vbWluZ0VuYWJsZWQpLFxuICAgICAgcGFubmluZ0VuYWJsZWQ6IGRlZlZhbCh0cnVlLCBvcHRpb25zLnBhbm5pbmdFbmFibGVkKSxcbiAgICAgIHVzZXJQYW5uaW5nRW5hYmxlZDogZGVmVmFsKHRydWUsIG9wdGlvbnMudXNlclBhbm5pbmdFbmFibGVkKSxcbiAgICAgIGJveFNlbGVjdGlvbkVuYWJsZWQ6IGRlZlZhbChmYWxzZSwgb3B0aW9ucy5ib3hTZWxlY3Rpb25FbmFibGVkKSxcbiAgICAgIGF1dG9sb2NrOiBkZWZWYWwoZmFsc2UsIG9wdGlvbnMuYXV0b2xvY2ssIG9wdGlvbnMuYXV0b2xvY2tOb2RlcyksXG4gICAgICBhdXRvdW5ncmFiaWZ5OiBkZWZWYWwoZmFsc2UsIG9wdGlvbnMuYXV0b3VuZ3JhYmlmeSwgb3B0aW9ucy5hdXRvdW5ncmFiaWZ5Tm9kZXMpLFxuICAgICAgYXV0b3Vuc2VsZWN0aWZ5OiBkZWZWYWwoZmFsc2UsIG9wdGlvbnMuYXV0b3Vuc2VsZWN0aWZ5KSxcbiAgICAgIHN0eWxlRW5hYmxlZDogb3B0aW9ucy5zdHlsZUVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IGhlYWQgOiBvcHRpb25zLnN0eWxlRW5hYmxlZCxcbiAgICAgIHpvb206ICQkLmlzLm51bWJlcihvcHRpb25zLnpvb20pID8gb3B0aW9ucy56b29tIDogMSxcbiAgICAgIHBhbjoge1xuICAgICAgICB4OiAkJC5pcy5wbGFpbk9iamVjdChvcHRpb25zLnBhbikgJiYgJCQuaXMubnVtYmVyKG9wdGlvbnMucGFuLngpID8gb3B0aW9ucy5wYW4ueCA6IDAsXG4gICAgICAgIHk6ICQkLmlzLnBsYWluT2JqZWN0KG9wdGlvbnMucGFuKSAmJiAkJC5pcy5udW1iZXIob3B0aW9ucy5wYW4ueSkgPyBvcHRpb25zLnBhbi55IDogMFxuICAgICAgfSxcbiAgICAgIGFuaW1hdGlvbjogeyAvLyBvYmplY3QgZm9yIGN1cnJlbnRseS1ydW5uaW5nIGFuaW1hdGlvbnNcbiAgICAgICAgY3VycmVudDogW10sXG4gICAgICAgIHF1ZXVlOiBbXVxuICAgICAgfSxcbiAgICAgIGhhc0NvbXBvdW5kTm9kZXM6IGZhbHNlLFxuICAgICAgZGVmZXJyZWRFeGVjUXVldWU6IFtdXG4gICAgfTtcblxuICAgIC8vIHNldCBzZWxlY3Rpb24gdHlwZVxuICAgIHZhciBzZWxUeXBlID0gb3B0aW9ucy5zZWxlY3Rpb25UeXBlO1xuICAgIGlmKCBzZWxUeXBlID09PSB1bmRlZmluZWQgfHwgKHNlbFR5cGUgIT09ICdhZGRpdGl2ZScgJiYgc2VsVHlwZSAhPT0gJ3NpbmdsZScpICl7XG4gICAgICAvLyB0aGVuIHNldCBkZWZhdWx0XG5cbiAgICAgIF9wLnNlbGVjdGlvblR5cGUgPSAnc2luZ2xlJztcbiAgICB9IGVsc2Uge1xuICAgICAgX3Auc2VsZWN0aW9uVHlwZSA9IHNlbFR5cGU7XG4gICAgfVxuXG4gICAgLy8gaW5pdCB6b29tIGJvdW5kc1xuICAgIGlmKCAkJC5pcy5udW1iZXIob3B0aW9ucy5taW5ab29tKSAmJiAkJC5pcy5udW1iZXIob3B0aW9ucy5tYXhab29tKSAmJiBvcHRpb25zLm1pblpvb20gPCBvcHRpb25zLm1heFpvb20gKXtcbiAgICAgIF9wLm1pblpvb20gPSBvcHRpb25zLm1pblpvb207XG4gICAgICBfcC5tYXhab29tID0gb3B0aW9ucy5tYXhab29tO1xuICAgIH0gZWxzZSBpZiggJCQuaXMubnVtYmVyKG9wdGlvbnMubWluWm9vbSkgJiYgb3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgKXtcbiAgICAgIF9wLm1pblpvb20gPSBvcHRpb25zLm1pblpvb207XG4gICAgfSBlbHNlIGlmKCAkJC5pcy5udW1iZXIob3B0aW9ucy5tYXhab29tKSAmJiBvcHRpb25zLm1pblpvb20gPT09IHVuZGVmaW5lZCApe1xuICAgICAgX3AubWF4Wm9vbSA9IG9wdGlvbnMubWF4Wm9vbTtcbiAgICB9XG5cbiAgICB2YXIgbG9hZEV4dERhdGEgPSBmdW5jdGlvbiggbmV4dCApe1xuICAgICAgdmFyIGFueUlzUHJvbWlzZSA9IGZhbHNlO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGV4dERhdGEubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGRhdHVtID0gZXh0RGF0YVtpXTtcblxuICAgICAgICBpZiggJCQuaXMucHJvbWlzZShkYXR1bSkgKXtcbiAgICAgICAgICBhbnlJc1Byb21pc2UgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKCBhbnlJc1Byb21pc2UgKXtcbiAgICAgICAgcmV0dXJuICQkLlByb21pc2UuYWxsKCBleHREYXRhICkudGhlbiggbmV4dCApOyAvLyBsb2FkIGFsbCBkYXRhIGFzeW5jaHJvbm91c2x5LCB0aGVuIGV4ZWMgcmVzdCBvZiBpbml0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0KCBleHREYXRhICk7IC8vIGV4ZWMgc3luY2hyb25vdXNseSBmb3IgY29udmVuaWVuY2VcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGV4dERhdGEgPSBbIG9wdGlvbnMuc3R5bGUsIG9wdGlvbnMuZWxlbWVudHMgXTtcbiAgICBsb2FkRXh0RGF0YShmdW5jdGlvbiggdGhlbnMgKXtcbiAgICAgIHZhciBpbml0U3R5bGUgPSB0aGVuc1swXTtcbiAgICAgIHZhciBpbml0RWxlcyA9IHRoZW5zWzFdO1xuICAgXG4gICAgICAvLyBpbml0IHN0eWxlXG4gICAgICBpZiggX3Auc3R5bGVFbmFibGVkICl7XG4gICAgICAgIGN5LnNldFN0eWxlKCBpbml0U3R5bGUgKTtcbiAgICAgIH1cblxuICAgICAgLy8gY3JlYXRlIHRoZSByZW5kZXJlclxuICAgICAgY3kuaW5pdFJlbmRlcmVyKCAkJC51dGlsLmV4dGVuZCh7XG4gICAgICAgIGhpZGVFZGdlc09uVmlld3BvcnQ6IG9wdGlvbnMuaGlkZUVkZ2VzT25WaWV3cG9ydCxcbiAgICAgICAgaGlkZUxhYmVsc09uVmlld3BvcnQ6IG9wdGlvbnMuaGlkZUxhYmVsc09uVmlld3BvcnQsXG4gICAgICAgIHRleHR1cmVPblZpZXdwb3J0OiBvcHRpb25zLnRleHR1cmVPblZpZXdwb3J0LFxuICAgICAgICB3aGVlbFNlbnNpdGl2aXR5OiAkJC5pcy5udW1iZXIob3B0aW9ucy53aGVlbFNlbnNpdGl2aXR5KSAmJiBvcHRpb25zLndoZWVsU2Vuc2l0aXZpdHkgPiAwID8gb3B0aW9ucy53aGVlbFNlbnNpdGl2aXR5IDogMSxcbiAgICAgICAgbW90aW9uQmx1cjogb3B0aW9ucy5tb3Rpb25CbHVyID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0aW9ucy5tb3Rpb25CbHVyLCAvLyBvbiBieSBkZWZhdWx0XG4gICAgICAgIG1vdGlvbkJsdXJPcGFjaXR5OiBvcHRpb25zLm1vdGlvbkJsdXJPcGFjaXR5ID09PSB1bmRlZmluZWQgPyAwLjA1IDogb3B0aW9ucy5tb3Rpb25CbHVyT3BhY2l0eSxcbiAgICAgICAgcGl4ZWxSYXRpbzogJCQuaXMubnVtYmVyKG9wdGlvbnMucGl4ZWxSYXRpbykgJiYgb3B0aW9ucy5waXhlbFJhdGlvID4gMCA/IG9wdGlvbnMucGl4ZWxSYXRpbyA6IChvcHRpb25zLnBpeGVsUmF0aW8gPT09ICdhdXRvJyA/IHVuZGVmaW5lZCA6IDEpLFxuICAgICAgICBkZXNrdG9wVGFwVGhyZXNob2xkOiBvcHRpb25zLmRlc2t0b3BUYXBUaHJlc2hvbGQgPT09IHVuZGVmaW5lZCA/IDQgOiBvcHRpb25zLmRlc2t0b3BUYXBUaHJlc2hvbGQsXG4gICAgICAgIHRvdWNoVGFwVGhyZXNob2xkOiBvcHRpb25zLnRvdWNoVGFwVGhyZXNob2xkID09PSB1bmRlZmluZWQgPyA4IDogb3B0aW9ucy50b3VjaFRhcFRocmVzaG9sZFxuICAgICAgfSwgb3B0aW9ucy5yZW5kZXJlcikgKTtcblxuICAgICAgLy8gdHJpZ2dlciB0aGUgcGFzc2VkIGZ1bmN0aW9uIGZvciB0aGUgYGluaXRyZW5kZXJgIGV2ZW50XG4gICAgICBpZiggb3B0aW9ucy5pbml0cmVuZGVyICl7XG4gICAgICAgIGN5Lm9uKCdpbml0cmVuZGVyJywgb3B0aW9ucy5pbml0cmVuZGVyKTtcbiAgICAgICAgY3kub24oJ2luaXRyZW5kZXInLCBmdW5jdGlvbigpe1xuICAgICAgICAgIGN5Ll9wcml2YXRlLmluaXRyZW5kZXIgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gaW5pdGlhbCBsb2FkXG4gICAgICBjeS5sb2FkKGluaXRFbGVzLCBmdW5jdGlvbigpeyAvLyBvbnJlYWR5XG4gICAgICAgIGN5LnN0YXJ0QW5pbWF0aW9uTG9vcCgpO1xuICAgICAgICBjeS5fcHJpdmF0ZS5yZWFkeSA9IHRydWU7XG5cbiAgICAgICAgLy8gaWYgYSByZWFkeSBjYWxsYmFjayBpcyBzcGVjaWZpZWQgYXMgYW4gb3B0aW9uLCB0aGUgYmluZCBpdFxuICAgICAgICBpZiggJCQuaXMuZm4oIG9wdGlvbnMucmVhZHkgKSApe1xuICAgICAgICAgIGN5Lm9uKCdyZWFkeScsIG9wdGlvbnMucmVhZHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYmluZCBhbGwgdGhlIHJlYWR5IGhhbmRsZXJzIHJlZ2lzdGVyZWQgYmVmb3JlIGNyZWF0aW5nIHRoaXMgaW5zdGFuY2VcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCByZWFkaWVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGZuID0gcmVhZGllc1tpXTtcbiAgICAgICAgICBjeS5vbigncmVhZHknLCBmbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYoIHJlZyApeyByZWcucmVhZGllcyA9IFtdOyB9IC8vIGNsZWFyIGIvYyB3ZSd2ZSBib3VuZCB0aGVtIGFsbCBhbmQgZG9uJ3Qgd2FudCB0byBrZWVwIGl0IGFyb3VuZCBpbiBjYXNlIGEgbmV3IGNvcmUgdXNlcyB0aGUgc2FtZSBkaXYgZXRjXG4gICAgICAgIFxuICAgICAgICBjeS50cmlnZ2VyKCdyZWFkeScpO1xuICAgICAgfSwgb3B0aW9ucy5kb25lKTtcblxuICAgIH0pO1xuICB9O1xuXG4gICQkLmNvcmVmbiA9ICQkLkNvcmUucHJvdG90eXBlOyAvLyBzaG9ydCBhbGlhc1xuICBcblxuICAkJC5mbi5jb3JlKHtcbiAgICBpc1JlYWR5OiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUucmVhZHk7XG4gICAgfSxcblxuICAgIHJlYWR5OiBmdW5jdGlvbiggZm4gKXtcbiAgICAgIGlmKCB0aGlzLmlzUmVhZHkoKSApe1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ3JlYWR5JywgW10sIGZuKTsgLy8ganVzdCBjYWxscyBmbiBhcyB0aG91Z2ggdHJpZ2dlcmVkIHZpYSByZWFkeSBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vbigncmVhZHknLCBmbik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGluaXRyZW5kZXI6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5pbml0cmVuZGVyO1xuICAgIH0sXG5cbiAgICBkZXN0cm95OiBmdW5jdGlvbigpe1xuICAgICAgdGhpcy5ub3RpZnkoeyB0eXBlOiAnZGVzdHJveScgfSk7IC8vIGRlc3Ryb3kgdGhlIHJlbmRlcmVyXG5cbiAgICAgIHZhciBkb21FbGUgPSB0aGlzLmNvbnRhaW5lcigpO1xuICAgICAgdmFyIHBhckVsZSA9IGRvbUVsZS5wYXJlbnROb2RlO1xuICAgICAgaWYoIHBhckVsZSApe1xuICAgICAgICB0cnl7XG4gICAgICAgICAgcGFyRWxlLnJlbW92ZUNoaWxkKCBkb21FbGUgKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAvLyBpZTEwIGlzc3VlICMxMDE0XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGdldEVsZW1lbnRCeUlkOiBmdW5jdGlvbiggaWQgKXtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuX3ByaXZhdGUuaWQyaW5kZXhbIGlkIF07XG4gICAgICBpZiggaW5kZXggIT09IHVuZGVmaW5lZCApe1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5lbGVtZW50c1sgaW5kZXggXTtcbiAgICAgIH1cblxuICAgICAgLy8gd29yc3QgY2FzZSwgcmV0dXJuIGFuIGVtcHR5IGNvbGxlY3Rpb25cbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggdGhpcyApO1xuICAgIH0sXG5cbiAgICBzZWxlY3Rpb25UeXBlOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuc2VsZWN0aW9uVHlwZTtcbiAgICB9LFxuXG4gICAgaGFzQ29tcG91bmROb2RlczogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmhhc0NvbXBvdW5kTm9kZXM7XG4gICAgfSxcblxuICAgIHN0eWxlRW5hYmxlZDogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnN0eWxlRW5hYmxlZDtcbiAgICB9LFxuXG4gICAgYWRkVG9Qb29sOiBmdW5jdGlvbiggZWxlcyApe1xuICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5fcHJpdmF0ZS5lbGVtZW50cztcbiAgICAgIHZhciBpZDJpbmRleCA9IHRoaXMuX3ByaXZhdGUuaWQyaW5kZXg7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgICAgICB2YXIgaWQgPSBlbGUuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgICAgdmFyIGluZGV4ID0gaWQyaW5kZXhbIGlkIF07XG4gICAgICAgIHZhciBhbHJlYWR5SW5Qb29sID0gaW5kZXggIT09IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiggIWFscmVhZHlJblBvb2wgKXtcbiAgICAgICAgICBpbmRleCA9IGVsZW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKCBlbGUgKTtcbiAgICAgICAgICBpZDJpbmRleFsgaWQgXSA9IGluZGV4O1xuICAgICAgICAgIGVsZS5fcHJpdmF0ZS5pbmRleCA9IGluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICByZW1vdmVGcm9tUG9vbDogZnVuY3Rpb24oIGVsZXMgKXtcbiAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuX3ByaXZhdGUuZWxlbWVudHM7XG4gICAgICB2YXIgaWQyaW5kZXggPSB0aGlzLl9wcml2YXRlLmlkMmluZGV4O1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICAgICAgdmFyIGlkID0gZWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICAgIHZhciBpbmRleCA9IGlkMmluZGV4WyBpZCBdO1xuICAgICAgICB2YXIgaW5Qb29sID0gaW5kZXggIT09IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiggaW5Qb29sICl7XG4gICAgICAgICAgdGhpcy5fcHJpdmF0ZS5pZDJpbmRleFsgaWQgXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBlbGVtZW50cy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICAgICAgLy8gYWRqdXN0IHRoZSBpbmRleCBvZiBhbGwgZWxlbWVudHMgcGFzdCB0aGlzIGluZGV4XG4gICAgICAgICAgZm9yKCB2YXIgaiA9IGluZGV4OyBqIDwgZWxlbWVudHMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICAgIHZhciBqaWQgPSBlbGVtZW50c1tqXS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgICAgICAgaWQyaW5kZXhbIGppZCBdLS07XG4gICAgICAgICAgICBlbGVtZW50c1tqXS5fcHJpdmF0ZS5pbmRleC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBjb250YWluZXI6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5jb250YWluZXI7XG4gICAgfSxcblxuICAgIG9wdGlvbnM6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gJCQudXRpbC5jb3B5KCB0aGlzLl9wcml2YXRlLm9wdGlvbnMgKTtcbiAgICB9LFxuICAgIFxuICAgIGpzb246IGZ1bmN0aW9uKHBhcmFtcyl7XG4gICAgICB2YXIganNvbiA9IHt9O1xuICAgICAgdmFyIGN5ID0gdGhpcztcbiAgICAgIFxuICAgICAganNvbi5lbGVtZW50cyA9IHt9O1xuICAgICAgY3kuZWxlbWVudHMoKS5lYWNoKGZ1bmN0aW9uKGksIGVsZSl7XG4gICAgICAgIHZhciBncm91cCA9IGVsZS5ncm91cCgpO1xuICAgICAgICBcbiAgICAgICAgaWYoICFqc29uLmVsZW1lbnRzW2dyb3VwXSApe1xuICAgICAgICAgIGpzb24uZWxlbWVudHNbZ3JvdXBdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGpzb24uZWxlbWVudHNbZ3JvdXBdLnB1c2goIGVsZS5qc29uKCkgKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiggdGhpcy5fcHJpdmF0ZS5zdHlsZUVuYWJsZWQgKXtcbiAgICAgICAganNvbi5zdHlsZSA9IGN5LnN0eWxlKCkuanNvbigpO1xuICAgICAgfVxuXG4gICAgICBqc29uLnpvb21pbmdFbmFibGVkID0gY3kuX3ByaXZhdGUuem9vbWluZ0VuYWJsZWQ7XG4gICAgICBqc29uLnVzZXJab29taW5nRW5hYmxlZCA9IGN5Ll9wcml2YXRlLnVzZXJab29taW5nRW5hYmxlZDtcbiAgICAgIGpzb24uem9vbSA9IGN5Ll9wcml2YXRlLnpvb207XG4gICAgICBqc29uLm1pblpvb20gPSBjeS5fcHJpdmF0ZS5taW5ab29tO1xuICAgICAganNvbi5tYXhab29tID0gY3kuX3ByaXZhdGUubWF4Wm9vbTtcbiAgICAgIGpzb24ucGFubmluZ0VuYWJsZWQgPSBjeS5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZDtcbiAgICAgIGpzb24udXNlclBhbm5pbmdFbmFibGVkID0gY3kuX3ByaXZhdGUudXNlclBhbm5pbmdFbmFibGVkO1xuICAgICAganNvbi5wYW4gPSBjeS5fcHJpdmF0ZS5wYW47XG4gICAgICBqc29uLmJveFNlbGVjdGlvbkVuYWJsZWQgPSBjeS5fcHJpdmF0ZS5ib3hTZWxlY3Rpb25FbmFibGVkO1xuICAgICAganNvbi5sYXlvdXQgPSBjeS5fcHJpdmF0ZS5vcHRpb25zLmxheW91dDtcbiAgICAgIGpzb24ucmVuZGVyZXIgPSBjeS5fcHJpdmF0ZS5vcHRpb25zLnJlbmRlcmVyO1xuICAgICAganNvbi5oaWRlRWRnZXNPblZpZXdwb3J0ID0gY3kuX3ByaXZhdGUub3B0aW9ucy5oaWRlRWRnZXNPblZpZXdwb3J0O1xuICAgICAganNvbi5oaWRlTGFiZWxzT25WaWV3cG9ydCA9IGN5Ll9wcml2YXRlLm9wdGlvbnMuaGlkZUxhYmVsc09uVmlld3BvcnQ7XG4gICAgICBqc29uLnRleHR1cmVPblZpZXdwb3J0ID0gY3kuX3ByaXZhdGUub3B0aW9ucy50ZXh0dXJlT25WaWV3cG9ydDtcbiAgICAgIGpzb24ud2hlZWxTZW5zaXRpdml0eSA9IGN5Ll9wcml2YXRlLm9wdGlvbnMud2hlZWxTZW5zaXRpdml0eTtcbiAgICAgIGpzb24ubW90aW9uQmx1ciA9IGN5Ll9wcml2YXRlLm9wdGlvbnMubW90aW9uQmx1cjtcbiAgICAgIFxuICAgICAgcmV0dXJuIGpzb247XG4gICAgfSxcblxuICAgIC8vIGRlZmVyIGV4ZWN1dGlvbiB1bnRpbCBub3QgYnVzeSBhbmQgZ3VhcmFudGVlIHJlbGF0aXZlIGV4ZWN1dGlvbiBvcmRlciBvZiBkZWZlcnJlZCBmdW5jdGlvbnNcbiAgICBkZWZlcjogZnVuY3Rpb24oIGZuICl7XG4gICAgICB2YXIgY3kgPSB0aGlzO1xuICAgICAgdmFyIF9wID0gY3kuX3ByaXZhdGU7XG4gICAgICB2YXIgcSA9IF9wLmRlZmVycmVkRXhlY1F1ZXVlO1xuXG4gICAgICBxLnB1c2goIGZuICk7XG5cbiAgICAgIGlmKCAhX3AuZGVmZXJyZWRUaW1lb3V0ICl7XG4gICAgICAgIF9wLmRlZmVycmVkVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICB3aGlsZSggcS5sZW5ndGggPiAwICl7XG4gICAgICAgICAgICAoIHEuc2hpZnQoKSApKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3AuZGVmZXJyZWRUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICB9KTsgIFxuICBcbn0pKCBjeXRvc2NhcGUsIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHdpbmRvdyApO1xuXG4oZnVuY3Rpb24oJCQsIHdpbmRvdyl7ICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiByZWFkeShmKSB7XG4gICAgdmFyIGZuID0gKCBkb2N1bWVudCAmJiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2ludGVyYWN0aXZlJyB8fCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSApICA/IGYgOiByZWFkeTtcblxuICAgIHNldFRpbWVvdXQoZm4sIDksIGYpO1xuICB9XG5cbiAgJCQuZm4uY29yZSh7XG4gICAgYWRkOiBmdW5jdGlvbihvcHRzKXtcbiAgICAgIFxuICAgICAgdmFyIGVsZW1lbnRzO1xuICAgICAgdmFyIGN5ID0gdGhpcztcbiAgICAgIFxuICAgICAgLy8gYWRkIHRoZSBlbGVtZW50c1xuICAgICAgaWYoICQkLmlzLmVsZW1lbnRPckNvbGxlY3Rpb24ob3B0cykgKXtcbiAgICAgICAgdmFyIGVsZXMgPSBvcHRzO1xuXG4gICAgICAgIGlmKCBlbGVzLl9wcml2YXRlLmN5ID09PSBjeSApeyAvLyBzYW1lIGluc3RhbmNlID0+IGp1c3QgcmVzdG9yZVxuICAgICAgICAgIGVsZW1lbnRzID0gZWxlcy5yZXN0b3JlKCk7XG5cbiAgICAgICAgfSBlbHNlIHsgLy8gb3RoZXJ3aXNlLCBjb3B5IGZyb20ganNvblxuICAgICAgICAgIHZhciBqc29ucyA9IFtdO1xuXG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgICAgIGpzb25zLnB1c2goIGVsZS5qc29uKCkgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlbGVtZW50cyA9IG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwganNvbnMgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBzcGVjaWZ5IGFuIGFycmF5IG9mIG9wdGlvbnNcbiAgICAgIGVsc2UgaWYoICQkLmlzLmFycmF5KG9wdHMpICl7XG4gICAgICAgIHZhciBqc29ucyA9IG9wdHM7XG5cbiAgICAgICAgZWxlbWVudHMgPSBuZXcgJCQuQ29sbGVjdGlvbihjeSwganNvbnMpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBzcGVjaWZ5IHZpYSBvcHRzLm5vZGVzIGFuZCBvcHRzLmVkZ2VzXG4gICAgICBlbHNlIGlmKCAkJC5pcy5wbGFpbk9iamVjdChvcHRzKSAmJiAoJCQuaXMuYXJyYXkob3B0cy5ub2RlcykgfHwgJCQuaXMuYXJyYXkob3B0cy5lZGdlcykpICl7XG4gICAgICAgIHZhciBlbGVzQnlHcm91cCA9IG9wdHM7XG4gICAgICAgIHZhciBqc29ucyA9IFtdO1xuXG4gICAgICAgIHZhciBncnMgPSBbJ25vZGVzJywgJ2VkZ2VzJ107XG4gICAgICAgIGZvciggdmFyIGkgPSAwLCBpbCA9IGdycy5sZW5ndGg7IGkgPCBpbDsgaSsrICl7XG4gICAgICAgICAgdmFyIGdyb3VwID0gZ3JzW2ldO1xuICAgICAgICAgIHZhciBlbGVzQXJyYXkgPSBlbGVzQnlHcm91cFtncm91cF07XG5cbiAgICAgICAgICBpZiggJCQuaXMuYXJyYXkoZWxlc0FycmF5KSApe1xuXG4gICAgICAgICAgICBmb3IoIHZhciBqID0gMCwgamwgPSBlbGVzQXJyYXkubGVuZ3RoOyBqIDwgamw7IGorKyApe1xuICAgICAgICAgICAgICB2YXIganNvbiA9IGVsZXNBcnJheVtqXTtcbiAgICAgICAgICAgICAganNvbi5ncm91cCA9IGdyb3VwO1xuXG4gICAgICAgICAgICAgIGpzb25zLnB1c2goIGpzb24gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IFxuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudHMgPSBuZXcgJCQuQ29sbGVjdGlvbihjeSwganNvbnMpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBzcGVjaWZ5IG9wdGlvbnMgZm9yIG9uZSBlbGVtZW50XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGpzb24gPSBvcHRzO1xuICAgICAgICBlbGVtZW50cyA9IChuZXcgJCQuRWxlbWVudCggY3ksIGpzb24gKSkuY29sbGVjdGlvbigpO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfSxcbiAgICBcbiAgICByZW1vdmU6IGZ1bmN0aW9uKGNvbGxlY3Rpb24pe1xuICAgICAgaWYoICQkLmlzLmVsZW1lbnRPckNvbGxlY3Rpb24oY29sbGVjdGlvbikgKXtcbiAgICAgICAgY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gICAgICB9IGVsc2UgaWYoICQkLmlzLnN0cmluZyhjb2xsZWN0aW9uKSApe1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSBjb2xsZWN0aW9uO1xuICAgICAgICBjb2xsZWN0aW9uID0gdGhpcy4kKCBzZWxlY3RvciApO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5yZW1vdmUoKTtcbiAgICB9LFxuICAgIFxuICAgIGxvYWQ6IGZ1bmN0aW9uKGVsZW1lbnRzLCBvbmxvYWQsIG9uZG9uZSl7XG4gICAgICB2YXIgY3kgPSB0aGlzO1xuICAgICAgXG4gICAgICBjeS5ub3RpZmljYXRpb25zKGZhbHNlKTtcblxuICAgICAgLy8gcmVtb3ZlIG9sZCBlbGVtZW50c1xuICAgICAgdmFyIG9sZEVsZXMgPSBjeS5lbGVtZW50cygpO1xuICAgICAgaWYoIG9sZEVsZXMubGVuZ3RoID4gMCApe1xuICAgICAgICBvbGRFbGVzLnJlbW92ZSgpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiggZWxlbWVudHMgIT0gbnVsbCApe1xuICAgICAgICBpZiggJCQuaXMucGxhaW5PYmplY3QoZWxlbWVudHMpIHx8ICQkLmlzLmFycmF5KGVsZW1lbnRzKSApe1xuICAgICAgICAgIGN5LmFkZCggZWxlbWVudHMgKTtcbiAgICAgICAgfSBcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gY2FsbGJhY2soKXsgICAgICAgIFxuICAgICAgICBjeS5vbmUoJ2xheW91dHJlYWR5JywgZnVuY3Rpb24oZSl7XG4gICAgICAgICAgY3kubm90aWZpY2F0aW9ucyh0cnVlKTtcbiAgICAgICAgICBjeS50cmlnZ2VyKGUpOyAvLyB3ZSBtaXNzZWQgdGhpcyBldmVudCBieSB0dXJuaW5nIG5vdGlmaWNhdGlvbnMgb2ZmLCBzbyBwYXNzIGl0IG9uXG5cbiAgICAgICAgICBjeS5ub3RpZnkoe1xuICAgICAgICAgICAgdHlwZTogJ2xvYWQnLFxuICAgICAgICAgICAgY29sbGVjdGlvbjogY3kuZWxlbWVudHMoKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY3kub25lKCdsb2FkJywgb25sb2FkKTtcbiAgICAgICAgICBjeS50cmlnZ2VyKCdsb2FkJyk7XG4gICAgICAgIH0pLm9uZSgnbGF5b3V0c3RvcCcsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgY3kub25lKCdkb25lJywgb25kb25lKTtcbiAgICAgICAgICBjeS50cmlnZ2VyKCdkb25lJyk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgdmFyIGxheW91dE9wdHMgPSAkJC51dGlsLmV4dGVuZCh7fSwgY3kuX3ByaXZhdGUub3B0aW9ucy5sYXlvdXQpO1xuICAgICAgICBsYXlvdXRPcHRzLmVsZXMgPSBjeS4kKCk7XG5cbiAgICAgICAgY3kubGF5b3V0KCBsYXlvdXRPcHRzICk7XG5cbiAgICAgIH1cblxuICAgICAgaWYoIHdpbmRvdyApe1xuICAgICAgICByZWFkeSggY2FsbGJhY2sgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG4gIFxufSkoIGN5dG9zY2FwZSwgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogd2luZG93ICk7XG5cbjsoZnVuY3Rpb24oJCQsIHdpbmRvdyl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gICQkLmZuLmNvcmUoe1xuICAgIFxuICAgIC8vIHB1bGwgaW4gYW5pbWF0aW9uIGZ1bmN0aW9uc1xuICAgIGFuaW1hdGVkOiAkJC5kZWZpbmUuYW5pbWF0ZWQoKSxcbiAgICBjbGVhclF1ZXVlOiAkJC5kZWZpbmUuY2xlYXJRdWV1ZSgpLFxuICAgIGRlbGF5OiAkJC5kZWZpbmUuZGVsYXkoKSxcbiAgICBhbmltYXRlOiAkJC5kZWZpbmUuYW5pbWF0ZSgpLFxuICAgIHN0b3A6ICQkLmRlZmluZS5zdG9wKCksXG5cbiAgICBhZGRUb0FuaW1hdGlvblBvb2w6IGZ1bmN0aW9uKCBlbGVzICl7XG4gICAgICB2YXIgY3kgPSB0aGlzO1xuXG4gICAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybjsgfSAvLyBzYXZlIGN5Y2xlcyB3aGVuIG5vIHN0eWxlIHVzZWRcbiAgICAgIFxuICAgICAgY3kuX3ByaXZhdGUuYW5pRWxlcy5tZXJnZSggZWxlcyApO1xuICAgIH0sXG5cbiAgICBzdGFydEFuaW1hdGlvbkxvb3A6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgY3kgPSB0aGlzO1xuXG4gICAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybjsgfSAvLyBzYXZlIGN5Y2xlcyB3aGVuIG5vIHN0eWxlIHVzZWRcblxuICAgICAgLy8gZG9uJ3QgZXhlY3V0ZSB0aGUgYW5pbWF0aW9uIGxvb3AgaW4gaGVhZGxlc3MgZW52aXJvbm1lbnRzXG4gICAgICBpZiggIXdpbmRvdyApe1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIGdsb2JhbEFuaW1hdGlvblN0ZXAoKXtcbiAgICAgICAgJCQudXRpbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24obm93KXtcbiAgICAgICAgICBoYW5kbGVFbGVtZW50cyhub3cpO1xuICAgICAgICAgIGdsb2JhbEFuaW1hdGlvblN0ZXAoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGdsb2JhbEFuaW1hdGlvblN0ZXAoKTsgLy8gZmlyc3QgY2FsbFxuICAgICAgXG4gICAgICBmdW5jdGlvbiBoYW5kbGVFbGVtZW50cyhub3cpe1xuICAgICAgICBub3cgPSArbmV3IERhdGUoKTtcblxuICAgICAgICB2YXIgZWxlcyA9IGN5Ll9wcml2YXRlLmFuaUVsZXM7XG4gICAgICAgIHZhciBkb25lRWxlcyA9IFtdO1xuXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZUVsZW1lbnQoIGVsZSwgaXNDb3JlICl7XG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSBlbGUuX3ByaXZhdGUuYW5pbWF0aW9uLmN1cnJlbnQ7XG4gICAgICAgICAgdmFyIHF1ZXVlID0gZWxlLl9wcml2YXRlLmFuaW1hdGlvbi5xdWV1ZTtcbiAgICAgICAgICB2YXIgcmFuQW5pcyA9IGZhbHNlO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIGlmIG5vdGhpbmcgY3VycmVudGx5IGFuaW1hdGluZywgZ2V0IHNvbWV0aGluZyBmcm9tIHRoZSBxdWV1ZVxuICAgICAgICAgIGlmKCBjdXJyZW50Lmxlbmd0aCA9PT0gMCApe1xuICAgICAgICAgICAgdmFyIG5leHQgPSBxdWV1ZS5sZW5ndGggPiAwID8gcXVldWUuc2hpZnQoKSA6IG51bGw7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKCBuZXh0ICl7XG4gICAgICAgICAgICAgIG5leHQuY2FsbFRpbWUgPSBub3c7IC8vIHdhcyBxdWV1ZWQsIHNvIHVwZGF0ZSBjYWxsIHRpbWVcbiAgICAgICAgICAgICAgY3VycmVudC5wdXNoKCBuZXh0ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIHN0ZXAgYW5kIHJlbW92ZSBpZiBkb25lXG4gICAgICAgICAgdmFyIGNvbXBsZXRlcyA9IFtdO1xuICAgICAgICAgIGZvcih2YXIgaSA9IGN1cnJlbnQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pe1xuICAgICAgICAgICAgdmFyIGFuaSA9IGN1cnJlbnRbaV07XG5cbiAgICAgICAgICAgIC8vIHN0YXJ0IGlmIG5lZWQgYmVcbiAgICAgICAgICAgIGlmKCAhYW5pLnN0YXJ0ZWQgKXsgc3RhcnRBbmltYXRpb24oIGVsZSwgYW5pICk7IH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc3RlcCggZWxlLCBhbmksIG5vdywgaXNDb3JlICk7XG5cbiAgICAgICAgICAgIGlmKCBhbmkuZG9uZSApe1xuICAgICAgICAgICAgICBjb21wbGV0ZXMucHVzaCggYW5pICk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyByZW1vdmUgY3VycmVudFtpXVxuICAgICAgICAgICAgICBjdXJyZW50LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmFuQW5pcyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIGNhbGwgY29tcGxldGUgY2FsbGJhY2tzXG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjb21wbGV0ZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgIHZhciBhbmkgPSBjb21wbGV0ZXNbaV07XG4gICAgICAgICAgICB2YXIgY29tcGxldGUgPSBhbmkucGFyYW1zLmNvbXBsZXRlO1xuXG4gICAgICAgICAgICBpZiggJCQuaXMuZm4oY29tcGxldGUpICl7XG4gICAgICAgICAgICAgIGNvbXBsZXRlLmFwcGx5KCBlbGUsIFsgbm93IF0gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggIWlzQ29yZSAmJiBjdXJyZW50Lmxlbmd0aCA9PT0gMCAmJiBxdWV1ZS5sZW5ndGggPT09IDAgKXtcbiAgICAgICAgICAgIGRvbmVFbGVzLnB1c2goIGVsZSApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByYW5BbmlzO1xuICAgICAgICB9IC8vIGhhbmRsZUVsZW1lbnRzXG5cbiAgICAgICAgLy8gaGFuZGxlIGFsbCBlbGVzXG4gICAgICAgIGZvciggdmFyIGUgPSAwOyBlIDwgZWxlcy5sZW5ndGg7IGUrKyApe1xuICAgICAgICAgIHZhciBlbGUgPSBlbGVzW2VdO1xuICAgICAgICAgIFxuICAgICAgICAgIGhhbmRsZUVsZW1lbnQoIGVsZSApO1xuICAgICAgICB9IC8vIGVhY2ggZWxlbWVudFxuXG4gICAgICAgIHZhciByYW5Db3JlQW5pID0gaGFuZGxlRWxlbWVudCggY3ksIHRydWUgKTtcbiAgICAgICAgXG4gICAgICAgIC8vIG5vdGlmeSByZW5kZXJlclxuICAgICAgICBpZiggZWxlcy5sZW5ndGggPiAwIHx8IHJhbkNvcmVBbmkgKXtcbiAgICAgICAgICB2YXIgdG9Ob3RpZnk7XG5cbiAgICAgICAgICBpZiggZWxlcy5sZW5ndGggPiAwICl7XG4gICAgICAgICAgICB2YXIgdXBkYXRlZEVsZXMgPSBlbGVzLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG4gICAgICAgICAgICB0b05vdGlmeSA9IHVwZGF0ZWRFbGVzLmxlbmd0aCA+IDAgPyBlbGVzLmFkZCggdXBkYXRlZEVsZXMgKSA6IGVsZXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3kubm90aWZ5KHtcbiAgICAgICAgICAgIHR5cGU6ICdkcmF3JyxcbiAgICAgICAgICAgIGNvbGxlY3Rpb246IHRvTm90aWZ5XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgZWxlbWVudHMgZnJvbSBsaXN0IG9mIGN1cnJlbnRseSBhbmltYXRpbmcgaWYgaXRzIHF1ZXVlcyBhcmUgZW1wdHlcbiAgICAgICAgZWxlcy51bm1lcmdlKCBkb25lRWxlcyApO1xuXG4gICAgICB9IC8vIGhhbmRsZUVsZW1lbnRzXG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHN0YXJ0QW5pbWF0aW9uKCBzZWxmLCBhbmkgKXtcbiAgICAgICAgdmFyIGlzQ29yZSA9ICQkLmlzLmNvcmUoIHNlbGYgKTtcbiAgICAgICAgdmFyIGlzRWxlcyA9ICFpc0NvcmU7XG4gICAgICAgIHZhciBlbGUgPSBzZWxmO1xuICAgICAgICB2YXIgc3R5bGUgPSBjeS5fcHJpdmF0ZS5zdHlsZTtcblxuICAgICAgICBpZiggaXNFbGVzICl7XG4gICAgICAgICAgdmFyIHBvcyA9IGVsZS5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAgICAgICB2YXIgc3RhcnRQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIHg6IHBvcy54LFxuICAgICAgICAgICAgeTogcG9zLnlcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBzdGFydFN0eWxlID0gc3R5bGUuZ2V0VmFsdWVTdHlsZSggZWxlICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggaXNDb3JlICl7XG4gICAgICAgICAgdmFyIHBhbiA9IGN5Ll9wcml2YXRlLnBhbjtcbiAgICAgICAgICB2YXIgc3RhcnRQYW4gPSB7XG4gICAgICAgICAgICB4OiBwYW4ueCxcbiAgICAgICAgICAgIHk6IHBhbi55XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciBzdGFydFpvb20gPSBjeS5fcHJpdmF0ZS56b29tO1xuICAgICAgICB9XG5cbiAgICAgICAgYW5pLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICBhbmkuc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgYW5pLnN0YXJ0UG9zaXRpb24gPSBzdGFydFBvc2l0aW9uO1xuICAgICAgICBhbmkuc3RhcnRTdHlsZSA9IHN0YXJ0U3R5bGU7XG4gICAgICAgIGFuaS5zdGFydFBhbiA9IHN0YXJ0UGFuO1xuICAgICAgICBhbmkuc3RhcnRab29tID0gc3RhcnRab29tO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzdGVwKCBzZWxmLCBhbmltYXRpb24sIG5vdywgaXNDb3JlICl7XG4gICAgICAgIHZhciBzdHlsZSA9IGN5Ll9wcml2YXRlLnN0eWxlO1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IGFuaW1hdGlvbi5wcm9wZXJ0aWVzO1xuICAgICAgICB2YXIgcGFyYW1zID0gYW5pbWF0aW9uLnBhcmFtcztcbiAgICAgICAgdmFyIHN0YXJ0VGltZSA9IGFuaW1hdGlvbi5zdGFydFRpbWU7XG4gICAgICAgIHZhciBwZXJjZW50O1xuICAgICAgICB2YXIgaXNFbGVzID0gIWlzQ29yZTtcbiAgICAgICAgXG4gICAgICAgIGlmKCBhbmltYXRpb24uZHVyYXRpb24gPT09IDAgKXtcbiAgICAgICAgICBwZXJjZW50ID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZXJjZW50ID0gTWF0aC5taW4oMSwgKG5vdyAtIHN0YXJ0VGltZSkvYW5pbWF0aW9uLmR1cmF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBwZXJjZW50IDwgMCApe1xuICAgICAgICAgIHBlcmNlbnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYoIHBlcmNlbnQgPiAxICl7XG4gICAgICAgICAgcGVyY2VudCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKCBwcm9wZXJ0aWVzLmRlbGF5ID09IG51bGwgKXsgLy8gdGhlbiB1cGRhdGVcblxuICAgICAgICAgIHZhciBzdGFydFBvcyA9IGFuaW1hdGlvbi5zdGFydFBvc2l0aW9uO1xuICAgICAgICAgIHZhciBlbmRQb3MgPSBwcm9wZXJ0aWVzLnBvc2l0aW9uO1xuICAgICAgICAgIHZhciBwb3MgPSBzZWxmLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgICAgIGlmKCBlbmRQb3MgJiYgaXNFbGVzICl7XG4gICAgICAgICAgICBpZiggdmFsaWQoIHN0YXJ0UG9zLngsIGVuZFBvcy54ICkgKXtcbiAgICAgICAgICAgICAgcG9zLnggPSBlYXNlKCBzdGFydFBvcy54LCBlbmRQb3MueCwgcGVyY2VudCApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiggdmFsaWQoIHN0YXJ0UG9zLnksIGVuZFBvcy55ICkgKXtcbiAgICAgICAgICAgICAgcG9zLnkgPSBlYXNlKCBzdGFydFBvcy55LCBlbmRQb3MueSwgcGVyY2VudCApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzdGFydFBhbiA9IGFuaW1hdGlvbi5zdGFydFBhbjtcbiAgICAgICAgICB2YXIgZW5kUGFuID0gcHJvcGVydGllcy5wYW47XG4gICAgICAgICAgdmFyIHBhbiA9IHNlbGYuX3ByaXZhdGUucGFuO1xuICAgICAgICAgIHZhciBhbmltYXRpbmdQYW4gPSBlbmRQYW4gIT0gbnVsbCAmJiBpc0NvcmU7XG4gICAgICAgICAgaWYoIGFuaW1hdGluZ1BhbiApe1xuICAgICAgICAgICAgaWYoIHZhbGlkKCBzdGFydFBhbi54LCBlbmRQYW4ueCApICl7XG4gICAgICAgICAgICAgIHBhbi54ID0gZWFzZSggc3RhcnRQYW4ueCwgZW5kUGFuLngsIHBlcmNlbnQgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIHZhbGlkKCBzdGFydFBhbi55LCBlbmRQYW4ueSApICl7XG4gICAgICAgICAgICAgIHBhbi55ID0gZWFzZSggc3RhcnRQYW4ueSwgZW5kUGFuLnksIHBlcmNlbnQgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdwYW4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc3RhcnRab29tID0gYW5pbWF0aW9uLnN0YXJ0Wm9vbTtcbiAgICAgICAgICB2YXIgZW5kWm9vbSA9IHByb3BlcnRpZXMuem9vbTtcbiAgICAgICAgICB2YXIgYW5pbWF0aW5nWm9vbSA9IGVuZFpvb20gIT0gbnVsbCAmJiBpc0NvcmU7XG4gICAgICAgICAgaWYoIGFuaW1hdGluZ1pvb20gKXtcbiAgICAgICAgICAgIGlmKCB2YWxpZCggc3RhcnRab29tLCBlbmRab29tICkgKXtcbiAgICAgICAgICAgICAgc2VsZi5fcHJpdmF0ZS56b29tID0gZWFzZSggc3RhcnRab29tLCBlbmRab29tLCBwZXJjZW50ICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcignem9vbScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCBhbmltYXRpbmdQYW4gfHwgYW5pbWF0aW5nWm9vbSApe1xuICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCd2aWV3cG9ydCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwcm9wcyA9IHByb3BlcnRpZXMuc3R5bGUgfHwgcHJvcGVydGllcy5jc3M7XG4gICAgICAgICAgaWYoIHByb3BzICYmIGlzRWxlcyApe1xuXG4gICAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICAgIHZhciBuYW1lID0gcHJvcHNbaV0ubmFtZTtcbiAgICAgICAgICAgICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICAgICAgICAgICAgdmFyIGVuZCA9IHByb3A7XG5cbiAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gYW5pbWF0aW9uLnN0YXJ0U3R5bGVbIG5hbWUgXTtcbiAgICAgICAgICAgICAgdmFyIGVhc2VkVmFsID0gZWFzZSggc3RhcnQsIGVuZCwgcGVyY2VudCApO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgc3R5bGUub3ZlcnJpZGVCeXBhc3MoIHNlbGYsIG5hbWUsIGVhc2VkVmFsICk7XG4gICAgICAgICAgICB9IC8vIGZvciBwcm9wc1xuICAgICAgICAgICAgXG4gICAgICAgICAgfSAvLyBpZiBcblxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiggJCQuaXMuZm4ocGFyYW1zLnN0ZXApICl7XG4gICAgICAgICAgcGFyYW1zLnN0ZXAuYXBwbHkoIHNlbGYsIFsgbm93IF0gKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoIHBlcmNlbnQgPj0gMSApe1xuICAgICAgICAgIGFuaW1hdGlvbi5kb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHBlcmNlbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHZhbGlkKHN0YXJ0LCBlbmQpe1xuICAgICAgICBpZiggc3RhcnQgPT0gbnVsbCB8fCBlbmQgPT0gbnVsbCApe1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoICQkLmlzLm51bWJlcihzdGFydCkgJiYgJCQuaXMubnVtYmVyKGVuZCkgKXtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmKCAoc3RhcnQpICYmIChlbmQpICl7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gZWFzZShzdGFydFByb3AsIGVuZFByb3AsIHBlcmNlbnQpe1xuICAgICAgICBpZiggcGVyY2VudCA8IDAgKXtcbiAgICAgICAgICBwZXJjZW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmKCBwZXJjZW50ID4gMSApe1xuICAgICAgICAgIHBlcmNlbnQgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YXJ0LCBlbmQ7XG5cbiAgICAgICAgaWYoIHN0YXJ0UHJvcC5weFZhbHVlICE9IG51bGwgfHwgc3RhcnRQcm9wLnZhbHVlICE9IG51bGwgKXtcbiAgICAgICAgICBzdGFydCA9IHN0YXJ0UHJvcC5weFZhbHVlICE9IG51bGwgPyBzdGFydFByb3AucHhWYWx1ZSA6IHN0YXJ0UHJvcC52YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGFydCA9IHN0YXJ0UHJvcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBlbmRQcm9wLnB4VmFsdWUgIT0gbnVsbCB8fCBlbmRQcm9wLnZhbHVlICE9IG51bGwgKXtcbiAgICAgICAgICBlbmQgPSBlbmRQcm9wLnB4VmFsdWUgIT0gbnVsbCA/IGVuZFByb3AucHhWYWx1ZSA6IGVuZFByb3AudmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5kID0gZW5kUHJvcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCAkJC5pcy5udW1iZXIoc3RhcnQpICYmICQkLmlzLm51bWJlcihlbmQpICl7XG4gICAgICAgICAgcmV0dXJuIHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAqIHBlcmNlbnQ7XG5cbiAgICAgICAgfSBlbHNlIGlmKCAkJC5pcy5udW1iZXIoc3RhcnRbMF0pICYmICQkLmlzLm51bWJlcihlbmRbMF0pICl7IC8vIHRoZW4gYXNzdW1lIGEgY29sb3VyXG4gICAgICAgICAgdmFyIGMxID0gc3RhcnQ7XG4gICAgICAgICAgdmFyIGMyID0gZW5kO1xuXG4gICAgICAgICAgdmFyIGNoID0gZnVuY3Rpb24oY2gxLCBjaDIpe1xuICAgICAgICAgICAgdmFyIGRpZmYgPSBjaDIgLSBjaDE7XG4gICAgICAgICAgICB2YXIgbWluID0gY2gxO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoIHBlcmNlbnQgKiBkaWZmICsgbWluICk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBcbiAgICAgICAgICB2YXIgciA9IGNoKCBjMVswXSwgYzJbMF0gKTtcbiAgICAgICAgICB2YXIgZyA9IGNoKCBjMVsxXSwgYzJbMV0gKTtcbiAgICAgICAgICB2YXIgYiA9IGNoKCBjMVsyXSwgYzJbMl0gKTtcbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gW3IsIGcsIGJdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgXG4gICAgfVxuICAgIFxuICB9KTtcbiAgXG59KSggY3l0b3NjYXBlLCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB3aW5kb3cgKTtcblxuXG4gIFxuICAgIFxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gICQkLmZuLmNvcmUoe1xuICAgIGRhdGE6ICQkLmRlZmluZS5kYXRhKHtcbiAgICAgIGZpZWxkOiAnZGF0YScsXG4gICAgICBiaW5kaW5nRXZlbnQ6ICdkYXRhJyxcbiAgICAgIGFsbG93QmluZGluZzogdHJ1ZSxcbiAgICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICAgIHNldHRpbmdFdmVudDogJ2RhdGEnLFxuICAgICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IHRydWUsXG4gICAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgICBhbGxvd0dldHRpbmc6IHRydWVcbiAgICB9KSxcblxuICAgIHJlbW92ZURhdGE6ICQkLmRlZmluZS5yZW1vdmVEYXRhKHtcbiAgICAgIGZpZWxkOiAnZGF0YScsXG4gICAgICBldmVudDogJ2RhdGEnLFxuICAgICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgICAgdHJpZ2dlckV2ZW50OiB0cnVlXG4gICAgfSksXG5cbiAgICBzY3JhdGNoOiAkJC5kZWZpbmUuZGF0YSh7XG4gICAgICBmaWVsZDogJ3NjcmF0Y2gnLFxuICAgICAgYWxsb3dCaW5kaW5nOiBmYWxzZSxcbiAgICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiBmYWxzZSxcbiAgICAgIGFsbG93R2V0dGluZzogdHJ1ZVxuICAgIH0pLFxuXG4gICAgcmVtb3ZlU2NyYXRjaDogJCQuZGVmaW5lLnJlbW92ZURhdGEoe1xuICAgICAgZmllbGQ6ICdzY3JhdGNoJyxcbiAgICAgIHRyaWdnZXJFdmVudDogZmFsc2VcbiAgICB9KVxuICB9KTtcbiAgXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgJCQuZm4uY29yZSh7XG4gICAgb246ICQkLmRlZmluZS5vbigpLCAvLyAub24oIGV2ZW50cyBbLCBzZWxlY3Rvcl0gWywgZGF0YV0sIGhhbmRsZXIpXG4gICAgb25lOiAkJC5kZWZpbmUub24oeyB1bmJpbmRTZWxmT25UcmlnZ2VyOiB0cnVlIH0pLFxuICAgIG9uY2U6ICQkLmRlZmluZS5vbih7IHVuYmluZEFsbEJpbmRlcnNPblRyaWdnZXI6IHRydWUgfSksXG4gICAgb2ZmOiAkJC5kZWZpbmUub2ZmKCksIC8vIC5vZmYoIGV2ZW50cyBbLCBzZWxlY3Rvcl0gWywgaGFuZGxlcl0gKVxuICAgIHRyaWdnZXI6ICQkLmRlZmluZS50cmlnZ2VyKCkgLy8gLnRyaWdnZXIoIGV2ZW50cyBbLCBleHRyYVBhcmFtc10gKVxuICB9KTtcblxuICAkJC5kZWZpbmUuZXZlbnRBbGlhc2VzT24oICQkLmNvcmVmbiApO1xuXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICAkJC5mbi5jb3JlKHtcbiAgICBcbiAgICBwbmc6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLl9wcml2YXRlLnJlbmRlcmVyO1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgIHJldHVybiByZW5kZXJlci5wbmcoIG9wdGlvbnMgKTsgICAgICBcbiAgICB9LFxuICAgIFxuICAgIGpwZzogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICAgIHZhciByZW5kZXJlciA9IHRoaXMuX3ByaXZhdGUucmVuZGVyZXI7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIFxuICAgICAgb3B0aW9ucy5iZyA9IG9wdGlvbnMuYmcgfHwgJyNmZmYnO1xuXG4gICAgICByZXR1cm4gcmVuZGVyZXIuanBnKCBvcHRpb25zICk7ICAgICAgXG4gICAgfVxuICAgIFxuICB9KTtcbiAgXG4gICQkLmNvcmVmbi5qcGVnID0gJCQuY29yZWZuLmpwZztcbiAgXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICAkJC5mbi5jb3JlKHtcbiAgICBcbiAgICBsYXlvdXQ6IGZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgICAgIHZhciBsYXlvdXQ7XG5cbiAgICAgIC8vIGFsd2F5cyB1c2UgYSBuZXcgbGF5b3V0IHcvIGluaXQgb3B0czsgc2xpZ2h0bHkgZGlmZmVyZW50IGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICAvLyBidXQgZml4ZXMgbGF5b3V0IHJldXNlIGlzc3VlcyBsaWtlIGRhZ3JlICM4MTkgXG4gICAgICBpZiggcGFyYW1zID09IG51bGwgKXsgXG4gICAgICAgIHBhcmFtcyA9ICQkLnV0aWwuZXh0ZW5kKHt9LCB0aGlzLl9wcml2YXRlLm9wdGlvbnMubGF5b3V0KTtcbiAgICAgICAgcGFyYW1zLmVsZXMgPSB0aGlzLiQoKTtcbiAgICAgIH1cblxuICAgICAgbGF5b3V0ID0gdGhpcy5pbml0TGF5b3V0KCBwYXJhbXMgKTtcbiAgICAgIGxheW91dC5ydW4oKTtcblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIG1ha2VMYXlvdXQ6IGZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgICAgIHJldHVybiB0aGlzLmluaXRMYXlvdXQoIHBhcmFtcyApO1xuICAgIH0sXG4gICAgXG4gICAgaW5pdExheW91dDogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICAgIGlmKCBvcHRpb25zID09IG51bGwgKXtcbiAgICAgICAgJCQudXRpbC5lcnJvcignTGF5b3V0IG9wdGlvbnMgbXVzdCBiZSBzcGVjaWZpZWQgdG8gbWFrZSBhIGxheW91dCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmKCBvcHRpb25zLm5hbWUgPT0gbnVsbCApe1xuICAgICAgICAkJC51dGlsLmVycm9yKCdBIGBuYW1lYCBtdXN0IGJlIHNwZWNpZmllZCB0byBtYWtlIGEgbGF5b3V0Jyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWU7XG4gICAgICB2YXIgTGF5b3V0UHJvdG8gPSAkJC5leHRlbnNpb24oJ2xheW91dCcsIG5hbWUpO1xuICAgICAgXG4gICAgICBpZiggTGF5b3V0UHJvdG8gPT0gbnVsbCApe1xuICAgICAgICAkJC51dGlsLmVycm9yKCdDYW4gbm90IGFwcGx5IGxheW91dDogTm8gc3VjaCBsYXlvdXQgYCcgKyBuYW1lICsgJ2AgZm91bmQ7IGRpZCB5b3UgaW5jbHVkZSBpdHMgSlMgZmlsZT8nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBvcHRpb25zLmVsZXMgPSBvcHRpb25zLmVsZXMgIT0gbnVsbCA/IG9wdGlvbnMuZWxlcyA6IHRoaXMuJCgpO1xuXG4gICAgICBpZiggJCQuaXMuc3RyaW5nKCBvcHRpb25zLmVsZXMgKSApe1xuICAgICAgICBvcHRpb25zLmVsZXMgPSB0aGlzLiQoIG9wdGlvbnMuZWxlcyApO1xuICAgICAgfVxuICAgICAgXG4gICAgICB2YXIgbGF5b3V0ID0gbmV3IExheW91dFByb3RvKCAkJC51dGlsLmV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgICBjeTogdGhpc1xuICAgICAgfSkgKTtcblxuICAgICAgLy8gbWFrZSBzdXJlIGxheW91dCBoYXMgX3ByaXZhdGUgZm9yIHVzZSB3LyBzdGQgYXBpcyBsaWtlIC5vbigpXG4gICAgICBpZiggISQkLmlzLnBsYWluT2JqZWN0KGxheW91dC5fcHJpdmF0ZSkgKXtcbiAgICAgICAgbGF5b3V0Ll9wcml2YXRlID0ge307XG4gICAgICB9XG5cbiAgICAgIGxheW91dC5fcHJpdmF0ZS5jeSA9IHRoaXM7XG4gICAgICBsYXlvdXQuX3ByaXZhdGUubGlzdGVuZXJzID0gW107XG4gICAgICBcbiAgICAgIHJldHVybiBsYXlvdXQ7XG4gICAgfVxuICAgIFxuICB9KTtcblxuICAkJC5jb3JlZm4uY3JlYXRlTGF5b3V0ID0gJCQuY29yZWZuLm1ha2VMYXlvdXQ7XG4gIFxufSkoIGN5dG9zY2FwZSApO1xuKGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgJCQuZm4uY29yZSh7XG4gICAgbm90aWZ5OiBmdW5jdGlvbiggcGFyYW1zICl7XG4gICAgICBpZiggdGhpcy5fcHJpdmF0ZS5iYXRjaGluZ05vdGlmeSApe1xuICAgICAgICB2YXIgYkVsZXMgPSB0aGlzLl9wcml2YXRlLmJhdGNoTm90aWZ5RWxlcztcbiAgICAgICAgdmFyIGJUeXBlcyA9IHRoaXMuX3ByaXZhdGUuYmF0Y2hOb3RpZnlUeXBlcztcblxuICAgICAgICBpZiggcGFyYW1zLmNvbGxlY3Rpb24gKXsgZm9yKCB2YXIgaSA9IDA7IGkgPCBwYXJhbXMuY29sbGVjdGlvbi5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlbGUgPSBwYXJhbXMuY29sbGVjdGlvbltpXTtcblxuICAgICAgICAgIGlmKCAhYkVsZXMuaWRzWyBlbGUuX3ByaXZhdGUuaWQgXSApe1xuICAgICAgICAgICAgYkVsZXMucHVzaCggZWxlICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH1cblxuICAgICAgICBpZiggIWJUeXBlcy5pZHNbIHBhcmFtcy50eXBlIF0gKXtcbiAgICAgICAgICBiVHlwZXMucHVzaCggcGFyYW1zLnR5cGUgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjsgLy8gbm90aWZpY2F0aW9ucyBhcmUgZGlzYWJsZWQgZHVyaW5nIGJhdGNoaW5nXG4gICAgICB9XG5cbiAgICAgIGlmKCAhdGhpcy5fcHJpdmF0ZS5ub3RpZmljYXRpb25zRW5hYmxlZCApeyByZXR1cm47IH0gLy8gZXhpdCBvbiBkaXNhYmxlZFxuXG4gICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyKCk7XG4gICAgICBcbiAgICAgIHJlbmRlcmVyLm5vdGlmeShwYXJhbXMpO1xuICAgIH0sXG4gICAgXG4gICAgbm90aWZpY2F0aW9uczogZnVuY3Rpb24oIGJvb2wgKXtcbiAgICAgIHZhciBwID0gdGhpcy5fcHJpdmF0ZTtcbiAgICAgIFxuICAgICAgaWYoIGJvb2wgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICByZXR1cm4gcC5ub3RpZmljYXRpb25zRW5hYmxlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHAubm90aWZpY2F0aW9uc0VuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgbm9Ob3RpZmljYXRpb25zOiBmdW5jdGlvbiggY2FsbGJhY2sgKXtcbiAgICAgIHRoaXMubm90aWZpY2F0aW9ucyhmYWxzZSk7XG4gICAgICBjYWxsYmFjaygpO1xuICAgICAgdGhpcy5ub3RpZmljYXRpb25zKHRydWUpO1xuICAgIH0sXG5cbiAgICBzdGFydEJhdGNoOiBmdW5jdGlvbigpe1xuICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgICAgX3AuYmF0Y2hpbmdTdHlsZSA9IF9wLmJhdGNoaW5nTm90aWZ5ID0gdHJ1ZTtcbiAgICAgIF9wLmJhdGNoU3R5bGVFbGVzID0gW107XG4gICAgICBfcC5iYXRjaE5vdGlmeUVsZXMgPSBbXTtcbiAgICAgIF9wLmJhdGNoTm90aWZ5VHlwZXMgPSBbXTtcblxuICAgICAgX3AuYmF0Y2hTdHlsZUVsZXMuaWRzID0ge307XG4gICAgICBfcC5iYXRjaE5vdGlmeUVsZXMuaWRzID0ge307XG4gICAgICBfcC5iYXRjaE5vdGlmeVR5cGVzLmlkcyA9IHt9O1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZW5kQmF0Y2g6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgICAvLyB1cGRhdGUgc3R5bGUgZm9yIGRpcnR5IGVsZXNcbiAgICAgIF9wLmJhdGNoaW5nU3R5bGUgPSBmYWxzZTtcbiAgICAgIG5ldyAkJC5Db2xsZWN0aW9uKHRoaXMsIF9wLmJhdGNoU3R5bGVFbGVzKS51cGRhdGVTdHlsZSgpO1xuXG4gICAgICAvLyBub3RpZnkgdGhlIHJlbmRlcmVyIG9mIHF1ZXVlZCBlbGVzIGFuZCBldmVudCB0eXBlc1xuICAgICAgX3AuYmF0Y2hpbmdOb3RpZnkgPSBmYWxzZTtcbiAgICAgIHRoaXMubm90aWZ5KHtcbiAgICAgICAgdHlwZTogX3AuYmF0Y2hOb3RpZnlUeXBlcyxcbiAgICAgICAgY29sbGVjdGlvbjogX3AuYmF0Y2hOb3RpZnlFbGVzXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGJhdGNoOiBmdW5jdGlvbiggY2FsbGJhY2sgKXtcbiAgICAgIHRoaXMuc3RhcnRCYXRjaCgpO1xuICAgICAgY2FsbGJhY2soKTtcbiAgICAgIHRoaXMuZW5kQmF0Y2goKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgIGJhdGNoRGF0YTogZnVuY3Rpb24oIG1hcCApe1xuICAgICAgdmFyIGN5ID0gdGhpcztcblxuICAgICAgcmV0dXJuIHRoaXMuYmF0Y2goZnVuY3Rpb24oKXtcbiAgICAgICAgZm9yKCB2YXIgaWQgaW4gbWFwICl7XG4gICAgICAgICAgdmFyIGRhdGEgPSBtYXBbaWRdO1xuICAgICAgICAgIHZhciBlbGUgPSBjeS5nZXRFbGVtZW50QnlJZCggaWQgKTtcbiAgICAgICAgICBcbiAgICAgICAgICBlbGUuZGF0YSggZGF0YSApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gICQkLmZuLmNvcmUoe1xuICAgIFxuICAgIHJlbmRlclRvOiBmdW5jdGlvbiggY29udGV4dCwgem9vbSwgcGFuLCBweFJhdGlvICl7XG4gICAgICB2YXIgciA9IHRoaXMuX3ByaXZhdGUucmVuZGVyZXI7XG5cbiAgICAgIHIucmVuZGVyVG8oIGNvbnRleHQsIHpvb20sIHBhbiwgcHhSYXRpbyApO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlbmRlcmVyOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUucmVuZGVyZXI7XG4gICAgfSxcblxuICAgIGZvcmNlUmVuZGVyOiBmdW5jdGlvbigpe1xuICAgICAgdGhpcy5ub3RpZnkoe1xuICAgICAgICB0eXBlOiAnZHJhdydcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcmVzaXplOiBmdW5jdGlvbigpe1xuICAgICAgdGhpcy5ub3RpZnkoe1xuICAgICAgICB0eXBlOiAncmVzaXplJ1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMudHJpZ2dlcigncmVzaXplJyk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgXG4gICAgaW5pdFJlbmRlcmVyOiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgICAgdmFyIGN5ID0gdGhpcztcblxuICAgICAgdmFyIFJlbmRlcmVyUHJvdG8gPSAkJC5leHRlbnNpb24oJ3JlbmRlcmVyJywgb3B0aW9ucy5uYW1lKTtcbiAgICAgIGlmKCBSZW5kZXJlclByb3RvID09IG51bGwgKXtcbiAgICAgICAgJCQudXRpbC5lcnJvcignQ2FuIG5vdCBpbml0aWFsaXNlOiBObyBzdWNoIHJlbmRlcmVyIGAlc2AgZm91bmQ7IGRpZCB5b3UgaW5jbHVkZSBpdHMgSlMgZmlsZT8nLCBvcHRpb25zLm5hbWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRoaXMuX3ByaXZhdGUucmVuZGVyZXIgPSBuZXcgUmVuZGVyZXJQcm90byhcbiAgICAgICAgJCQudXRpbC5leHRlbmQoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICBjeTogY3ksXG4gICAgICAgICAgc3R5bGU6IGN5Ll9wcml2YXRlLnN0eWxlXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgIFxuICAgIH0sXG5cbiAgICB0cmlnZ2VyT25SZW5kZXI6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgY2JzID0gdGhpcy5fcHJpdmF0ZS5vblJlbmRlcnM7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY2JzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBjYiA9IGNic1tpXTtcblxuICAgICAgICBjYigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgb25SZW5kZXI6IGZ1bmN0aW9uKCBjYiApe1xuICAgICAgdGhpcy5fcHJpdmF0ZS5vblJlbmRlcnMucHVzaCggY2IgKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIG9mZlJlbmRlcjogZnVuY3Rpb24oIGZuICl7XG4gICAgICB2YXIgY2JzID0gdGhpcy5fcHJpdmF0ZS5vblJlbmRlcnM7XG5cbiAgICAgIGlmKCBmbiA9PSBudWxsICl7IC8vIHVuYmluZCBhbGxcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5vblJlbmRlcnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY2JzLmxlbmd0aDsgaSsrICl7IC8vIHVuYmluZCBzcGVjaWZpZWRcbiAgICAgICAgdmFyIGNiID0gY2JzW2ldO1xuXG4gICAgICAgIGlmKCBmbiA9PT0gY2IgKXtcbiAgICAgICAgICBjYnMuc3BsaWNlKCBpLCAxICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIFxuICB9KTsgIFxuICBcbn0pKCBjeXRvc2NhcGUgKTtcbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICAkJC5mbi5jb3JlKHtcblxuICAgIC8vIGdldCBhIGNvbGxlY3Rpb25cbiAgICAvLyAtIGVtcHR5IGNvbGxlY3Rpb24gb24gbm8gYXJnc1xuICAgIC8vIC0gY29sbGVjdGlvbiBvZiBlbGVtZW50cyBpbiB0aGUgZ3JhcGggb24gc2VsZWN0b3IgYXJnXG4gICAgLy8gLSBndWFyYW50ZWUgYSByZXR1cm5lZCBjb2xsZWN0aW9uIHdoZW4gZWxlbWVudHMgb3IgY29sbGVjdGlvbiBzcGVjaWZpZWRcbiAgICBjb2xsZWN0aW9uOiBmdW5jdGlvbiggZWxlcyApe1xuXG4gICAgICBpZiggJCQuaXMuc3RyaW5nKCBlbGVzICkgKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuJCggZWxlcyApO1xuXG4gICAgICB9IGVsc2UgaWYoICQkLmlzLmVsZW1lbnRPckNvbGxlY3Rpb24oIGVsZXMgKSApe1xuICAgICAgICByZXR1cm4gZWxlcy5jb2xsZWN0aW9uKCk7XG5cbiAgICAgIH0gZWxzZSBpZiggJCQuaXMuYXJyYXkoIGVsZXMgKSApe1xuICAgICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIHRoaXMsIGVsZXMgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCB0aGlzICk7XG4gICAgfSxcbiAgICBcbiAgICBub2RlczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLiQoZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNOb2RlKCk7XG4gICAgICB9KTtcblxuICAgICAgaWYoIHNlbGVjdG9yICl7XG4gICAgICAgIHJldHVybiBub2Rlcy5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgICB9IFxuXG4gICAgICByZXR1cm4gbm9kZXM7XG4gICAgfSxcbiAgICBcbiAgICBlZGdlczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLiQoZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNFZGdlKCk7XG4gICAgICB9KTtcblxuICAgICAgaWYoIHNlbGVjdG9yICl7XG4gICAgICAgIHJldHVybiBlZGdlcy5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlZGdlcztcbiAgICB9LFxuICAgICAgXG4gICAgLy8gc2VhcmNoIHRoZSBncmFwaCBsaWtlIGpRdWVyeVxuICAgICQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgdmFyIGVsZXMgPSBuZXcgJCQuQ29sbGVjdGlvbiggdGhpcywgdGhpcy5fcHJpdmF0ZS5lbGVtZW50cyApO1xuXG4gICAgICBpZiggc2VsZWN0b3IgKXtcbiAgICAgICAgcmV0dXJuIGVsZXMuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWxlcztcbiAgICB9XG4gICAgXG4gIH0pOyAgXG5cbiAgLy8gYWxpYXNlc1xuICAkJC5jb3JlZm4uZWxlbWVudHMgPSAkJC5jb3JlZm4uZmlsdGVyID0gJCQuY29yZWZuLiQ7ICBcbiAgXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICAkJC5mbi5jb3JlKHtcbiAgICBcbiAgICBzdHlsZTogZnVuY3Rpb24oIG5ld1N0eWxlICl7XG4gICAgICBpZiggbmV3U3R5bGUgKXtcbiAgICAgICAgdmFyIHMgPSB0aGlzLnNldFN0eWxlKCBuZXdTdHlsZSApO1xuXG4gICAgICAgIHMudXBkYXRlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnN0eWxlO1xuICAgIH0sXG5cbiAgICBzZXRTdHlsZTogZnVuY3Rpb24oIHN0eWxlICl7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgICBpZiggJCQuaXMuc3R5bGVzaGVldChzdHlsZSkgKXtcbiAgICAgICAgX3Auc3R5bGUgPSBzdHlsZS5nZW5lcmF0ZVN0eWxlKHRoaXMpO1xuICAgICAgXG4gICAgICB9IGVsc2UgaWYoICQkLmlzLmFycmF5KHN0eWxlKSApIHtcbiAgICAgICAgX3Auc3R5bGUgPSAkJC5zdHlsZS5mcm9tSnNvbih0aGlzLCBzdHlsZSk7XG4gICAgICBcbiAgICAgIH0gZWxzZSBpZiggJCQuaXMuc3RyaW5nKHN0eWxlKSApe1xuICAgICAgICBfcC5zdHlsZSA9ICQkLnN0eWxlLmZyb21TdHJpbmcodGhpcywgc3R5bGUpO1xuICAgICAgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfcC5zdHlsZSA9IG5ldyAkJC5TdHlsZSggdGhpcyApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3Auc3R5bGU7XG4gICAgfVxuICB9KTtcbiAgXG59KSggY3l0b3NjYXBlICk7XG5cblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gICQkLmZuLmNvcmUoe1xuXG4gICAgYXV0b2xvY2s6IGZ1bmN0aW9uKGJvb2wpe1xuICAgICAgaWYoIGJvb2wgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICB0aGlzLl9wcml2YXRlLmF1dG9sb2NrID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmF1dG9sb2NrO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgYXV0b3VuZ3JhYmlmeTogZnVuY3Rpb24oYm9vbCl7XG4gICAgICBpZiggYm9vbCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUuYXV0b3VuZ3JhYmlmeSA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5hdXRvdW5ncmFiaWZ5O1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgYXV0b3Vuc2VsZWN0aWZ5OiBmdW5jdGlvbihib29sKXtcbiAgICAgIGlmKCBib29sICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5hdXRvdW5zZWxlY3RpZnkgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuYXV0b3Vuc2VsZWN0aWZ5O1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgcGFubmluZ0VuYWJsZWQ6IGZ1bmN0aW9uKCBib29sICl7XG4gICAgICBpZiggYm9vbCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICB1c2VyUGFubmluZ0VuYWJsZWQ6IGZ1bmN0aW9uKCBib29sICl7XG4gICAgICBpZiggYm9vbCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUudXNlclBhbm5pbmdFbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnVzZXJQYW5uaW5nRW5hYmxlZDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcbiAgICBcbiAgICB6b29taW5nRW5hYmxlZDogZnVuY3Rpb24oIGJvb2wgKXtcbiAgICAgIGlmKCBib29sICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS56b29taW5nRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS56b29taW5nRW5hYmxlZDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIHVzZXJab29taW5nRW5hYmxlZDogZnVuY3Rpb24oIGJvb2wgKXtcbiAgICAgIGlmKCBib29sICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS51c2VyWm9vbWluZ0VuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUudXNlclpvb21pbmdFbmFibGVkO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgYm94U2VsZWN0aW9uRW5hYmxlZDogZnVuY3Rpb24oIGJvb2wgKXtcbiAgICAgIGlmKCBib29sICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5ib3hTZWxlY3Rpb25FbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmJveFNlbGVjdGlvbkVuYWJsZWQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG4gICAgXG4gICAgcGFuOiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB2YXIgcGFuID0gdGhpcy5fcHJpdmF0ZS5wYW47XG4gICAgICB2YXIgZGltLCB2YWwsIGRpbXMsIHgsIHk7XG5cbiAgICAgIHN3aXRjaCggYXJncy5sZW5ndGggKXtcbiAgICAgIGNhc2UgMDogLy8gLnBhbigpXG4gICAgICAgIHJldHVybiBwYW47XG5cbiAgICAgIGNhc2UgMTogXG5cbiAgICAgICAgaWYoICQkLmlzLnN0cmluZyggYXJnc1swXSApICl7IC8vIC5wYW4oJ3gnKVxuICAgICAgICAgIGRpbSA9IGFyZ3NbMF07XG4gICAgICAgICAgcmV0dXJuIHBhblsgZGltIF07XG5cbiAgICAgICAgfSBlbHNlIGlmKCAkJC5pcy5wbGFpbk9iamVjdCggYXJnc1swXSApICkgeyAvLyAucGFuKHsgeDogMCwgeTogMTAwIH0pXG4gICAgICAgICAgaWYoICF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkICl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaW1zID0gYXJnc1swXTtcbiAgICAgICAgICB4ID0gZGltcy54O1xuICAgICAgICAgIHkgPSBkaW1zLnk7XG5cbiAgICAgICAgICBpZiggJCQuaXMubnVtYmVyKHgpICl7XG4gICAgICAgICAgICBwYW4ueCA9IHg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoICQkLmlzLm51bWJlcih5KSApe1xuICAgICAgICAgICAgcGFuLnkgPSB5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMudHJpZ2dlcigncGFuIHZpZXdwb3J0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMjogLy8gLnBhbigneCcsIDEwMClcbiAgICAgICAgaWYoICF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkICl7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBkaW0gPSBhcmdzWzBdO1xuICAgICAgICB2YWwgPSBhcmdzWzFdO1xuXG4gICAgICAgIGlmKCAoZGltID09PSAneCcgfHwgZGltID09PSAneScpICYmICQkLmlzLm51bWJlcih2YWwpICl7XG4gICAgICAgICAgcGFuW2RpbV0gPSB2YWw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRyaWdnZXIoJ3BhbiB2aWV3cG9ydCcpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7IC8vIGludmFsaWRcbiAgICAgIH1cblxuICAgICAgdGhpcy5ub3RpZnkoeyAvLyBub3RpZnkgdGhlIHJlbmRlcmVyIHRoYXQgdGhlIHZpZXdwb3J0IGNoYW5nZWRcbiAgICAgICAgdHlwZTogJ3ZpZXdwb3J0J1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG4gICAgXG4gICAgcGFuQnk6IGZ1bmN0aW9uKHBhcmFtcyl7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHZhciBwYW4gPSB0aGlzLl9wcml2YXRlLnBhbjtcbiAgICAgIHZhciBkaW0sIHZhbCwgZGltcywgeCwgeTtcblxuICAgICAgaWYoICF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkICl7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2goIGFyZ3MubGVuZ3RoICl7XG4gICAgICBjYXNlIDE6IFxuXG4gICAgICAgIGlmKCAkJC5pcy5wbGFpbk9iamVjdCggYXJnc1swXSApICkgeyAvLyAucGFuQnkoeyB4OiAwLCB5OiAxMDAgfSlcbiAgICAgICAgICBkaW1zID0gYXJnc1swXTtcbiAgICAgICAgICB4ID0gZGltcy54O1xuICAgICAgICAgIHkgPSBkaW1zLnk7XG5cbiAgICAgICAgICBpZiggJCQuaXMubnVtYmVyKHgpICl7XG4gICAgICAgICAgICBwYW4ueCArPSB4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCAkJC5pcy5udW1iZXIoeSkgKXtcbiAgICAgICAgICAgIHBhbi55ICs9IHk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdwYW4gdmlld3BvcnQnKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAyOiAvLyAucGFuQnkoJ3gnLCAxMDApXG4gICAgICAgIGRpbSA9IGFyZ3NbMF07XG4gICAgICAgIHZhbCA9IGFyZ3NbMV07XG5cbiAgICAgICAgaWYoIChkaW0gPT09ICd4JyB8fCBkaW0gPT09ICd5JykgJiYgJCQuaXMubnVtYmVyKHZhbCkgKXtcbiAgICAgICAgICBwYW5bZGltXSArPSB2YWw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRyaWdnZXIoJ3BhbiB2aWV3cG9ydCcpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7IC8vIGludmFsaWRcbiAgICAgIH1cblxuICAgICAgdGhpcy5ub3RpZnkoeyAvLyBub3RpZnkgdGhlIHJlbmRlcmVyIHRoYXQgdGhlIHZpZXdwb3J0IGNoYW5nZWRcbiAgICAgICAgdHlwZTogJ3ZpZXdwb3J0J1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG4gICAgXG4gICAgZml0OiBmdW5jdGlvbiggZWxlbWVudHMsIHBhZGRpbmcgKXtcbiAgICAgIHZhciB2aWV3cG9ydFN0YXRlID0gdGhpcy5nZXRGaXRWaWV3cG9ydCggZWxlbWVudHMsIHBhZGRpbmcgKTtcblxuICAgICAgaWYoIHZpZXdwb3J0U3RhdGUgKXtcbiAgICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICAgICAgX3Auem9vbSA9IHZpZXdwb3J0U3RhdGUuem9vbTtcbiAgICAgICAgX3AucGFuID0gdmlld3BvcnRTdGF0ZS5wYW47XG5cbiAgICAgICAgdGhpcy50cmlnZ2VyKCdwYW4gem9vbSB2aWV3cG9ydCcpO1xuXG4gICAgICAgIHRoaXMubm90aWZ5KHsgLy8gbm90aWZ5IHRoZSByZW5kZXJlciB0aGF0IHRoZSB2aWV3cG9ydCBjaGFuZ2VkXG4gICAgICAgICAgdHlwZTogJ3ZpZXdwb3J0J1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIGdldEZpdFZpZXdwb3J0OiBmdW5jdGlvbiggZWxlbWVudHMsIHBhZGRpbmcgKXtcbiAgICAgIGlmKCAkJC5pcy5udW1iZXIoZWxlbWVudHMpICYmIHBhZGRpbmcgPT09IHVuZGVmaW5lZCApeyAvLyBlbGVtZW50cyBpcyBvcHRpb25hbFxuICAgICAgICBwYWRkaW5nID0gZWxlbWVudHM7XG4gICAgICAgIGVsZW1lbnRzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBpZiggIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQgfHwgIXRoaXMuX3ByaXZhdGUuem9vbWluZ0VuYWJsZWQgKXtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgYmI7XG5cbiAgICAgIGlmKCAkJC5pcy5zdHJpbmcoZWxlbWVudHMpICl7XG4gICAgICAgIHZhciBzZWwgPSBlbGVtZW50cztcbiAgICAgICAgZWxlbWVudHMgPSB0aGlzLiQoIHNlbCApO1xuXG4gICAgICB9IGVsc2UgaWYoICQkLmlzLmJvdW5kaW5nQm94KGVsZW1lbnRzKSApeyAvLyBhc3N1bWUgYmJcbiAgICAgICAgdmFyIGJiZSA9IGVsZW1lbnRzO1xuICAgICAgICBiYiA9IHtcbiAgICAgICAgICB4MTogYmJlLngxLFxuICAgICAgICAgIHkxOiBiYmUueTEsXG4gICAgICAgICAgeDI6IGJiZS54MixcbiAgICAgICAgICB5MjogYmJlLnkyXG4gICAgICAgIH07XG5cbiAgICAgICAgYmIudyA9IGJiLngyIC0gYmIueDE7XG4gICAgICAgIGJiLmggPSBiYi55MiAtIGJiLnkxO1xuXG4gICAgICB9IGVsc2UgaWYoICEkJC5pcy5lbGVtZW50T3JDb2xsZWN0aW9uKGVsZW1lbnRzKSApe1xuICAgICAgICBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHMoKTtcbiAgICAgIH1cblxuICAgICAgYmIgPSBiYiB8fCBlbGVtZW50cy5ib3VuZGluZ0JveCgpO1xuXG4gICAgICB2YXIgdyA9IHRoaXMud2lkdGgoKTtcbiAgICAgIHZhciBoID0gdGhpcy5oZWlnaHQoKTtcbiAgICAgIHZhciB6b29tO1xuICAgICAgcGFkZGluZyA9ICQkLmlzLm51bWJlcihwYWRkaW5nKSA/IHBhZGRpbmcgOiAwO1xuXG4gICAgICBpZiggIWlzTmFOKHcpICYmICFpc05hTihoKSAmJiB3ID4gMCAmJiBoID4gMCAmJiAhaXNOYU4oYmIudykgJiYgIWlzTmFOKGJiLmgpICYmICBiYi53ID4gMCAmJiBiYi5oID4gMCApe1xuICAgICAgICB6b29tID0gTWF0aC5taW4oICh3IC0gMipwYWRkaW5nKS9iYi53LCAoaCAtIDIqcGFkZGluZykvYmIuaCApO1xuXG4gICAgICAgIC8vIGNyb3Agem9vbVxuICAgICAgICB6b29tID0gem9vbSA+IHRoaXMuX3ByaXZhdGUubWF4Wm9vbSA/IHRoaXMuX3ByaXZhdGUubWF4Wm9vbSA6IHpvb207XG4gICAgICAgIHpvb20gPSB6b29tIDwgdGhpcy5fcHJpdmF0ZS5taW5ab29tID8gdGhpcy5fcHJpdmF0ZS5taW5ab29tIDogem9vbTtcblxuICAgICAgICB2YXIgcGFuID0geyAvLyBub3cgcGFuIHRvIG1pZGRsZVxuICAgICAgICAgIHg6ICh3IC0gem9vbSooIGJiLngxICsgYmIueDIgKSkvMixcbiAgICAgICAgICB5OiAoaCAtIHpvb20qKCBiYi55MSArIGJiLnkyICkpLzJcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHpvb206IHpvb20sIFxuICAgICAgICAgIHBhbjogcGFuXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9LFxuICAgIFxuICAgIG1pblpvb206IGZ1bmN0aW9uKCB6b29tICl7XG4gICAgICBpZiggem9vbSA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLm1pblpvb207XG4gICAgICB9IGVsc2UgaWYoICQkLmlzLm51bWJlcih6b29tKSApe1xuICAgICAgICB0aGlzLl9wcml2YXRlLm1pblpvb20gPSB6b29tO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgbWF4Wm9vbTogZnVuY3Rpb24oIHpvb20gKXtcbiAgICAgIGlmKCB6b29tID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUubWF4Wm9vbTtcbiAgICAgIH0gZWxzZSBpZiggJCQuaXMubnVtYmVyKHpvb20pICl7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUubWF4Wm9vbSA9IHpvb207XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB6b29tOiBmdW5jdGlvbiggcGFyYW1zICl7XG4gICAgICB2YXIgcG9zOyAvLyBpbiByZW5kZXJlZCBweFxuICAgICAgdmFyIHpvb207XG5cbiAgICAgIGlmKCBwYXJhbXMgPT09IHVuZGVmaW5lZCApeyAvLyB0aGVuIGdldCB0aGUgem9vbVxuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS56b29tO1xuXG4gICAgICB9IGVsc2UgaWYoICQkLmlzLm51bWJlcihwYXJhbXMpICl7IC8vIHRoZW4gc2V0IHRoZSB6b29tXG4gICAgICAgIHpvb20gPSBwYXJhbXM7XG5cbiAgICAgIH0gZWxzZSBpZiggJCQuaXMucGxhaW5PYmplY3QocGFyYW1zKSApeyAvLyB0aGVuIHpvb20gYWJvdXQgYSBwb2ludFxuICAgICAgICB6b29tID0gcGFyYW1zLmxldmVsO1xuXG4gICAgICAgIGlmKCBwYXJhbXMucG9zaXRpb24gKXtcbiAgICAgICAgICB2YXIgcCA9IHBhcmFtcy5wb3NpdGlvbjtcbiAgICAgICAgICB2YXIgcGFuID0gdGhpcy5fcHJpdmF0ZS5wYW47XG4gICAgICAgICAgdmFyIHogPSB0aGlzLl9wcml2YXRlLnpvb207XG5cbiAgICAgICAgICBwb3MgPSB7IC8vIGNvbnZlcnQgdG8gcmVuZGVyZWQgcHhcbiAgICAgICAgICAgIHg6IHAueCAqIHogKyBwYW4ueCxcbiAgICAgICAgICAgIHk6IHAueSAqIHogKyBwYW4ueVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiggcGFyYW1zLnJlbmRlcmVkUG9zaXRpb24gKXtcbiAgICAgICAgICBwb3MgPSBwYXJhbXMucmVuZGVyZWRQb3NpdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBwb3MgJiYgIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQgKXtcbiAgICAgICAgICByZXR1cm4gdGhpczsgLy8gcGFubmluZyBkaXNhYmxlZFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKCAhdGhpcy5fcHJpdmF0ZS56b29taW5nRW5hYmxlZCApe1xuICAgICAgICByZXR1cm4gdGhpczsgLy8gem9vbWluZyBkaXNhYmxlZFxuICAgICAgfVxuXG4gICAgICBpZiggISQkLmlzLm51bWJlcih6b29tKSB8fCAoIHBvcyAmJiAoISQkLmlzLm51bWJlcihwb3MueCkgfHwgISQkLmlzLm51bWJlcihwb3MueSkpICkgKXtcbiAgICAgICAgcmV0dXJuIHRoaXM7IC8vIGNhbid0IHpvb20gd2l0aCBpbnZhbGlkIHBhcmFtc1xuICAgICAgfVxuXG4gICAgICAvLyBjcm9wIHpvb21cbiAgICAgIHpvb20gPSB6b29tID4gdGhpcy5fcHJpdmF0ZS5tYXhab29tID8gdGhpcy5fcHJpdmF0ZS5tYXhab29tIDogem9vbTtcbiAgICAgIHpvb20gPSB6b29tIDwgdGhpcy5fcHJpdmF0ZS5taW5ab29tID8gdGhpcy5fcHJpdmF0ZS5taW5ab29tIDogem9vbTtcblxuICAgICAgaWYoIHBvcyApeyAvLyBzZXQgem9vbSBhYm91dCBwb3NpdGlvblxuICAgICAgICB2YXIgcGFuMSA9IHRoaXMuX3ByaXZhdGUucGFuO1xuICAgICAgICB2YXIgem9vbTEgPSB0aGlzLl9wcml2YXRlLnpvb207XG4gICAgICAgIHZhciB6b29tMiA9IHpvb207XG4gICAgICAgIFxuICAgICAgICB2YXIgcGFuMiA9IHtcbiAgICAgICAgICB4OiAtem9vbTIvem9vbTEgKiAocG9zLnggLSBwYW4xLngpICsgcG9zLngsXG4gICAgICAgICAgeTogLXpvb20yL3pvb20xICogKHBvcy55IC0gcGFuMS55KSArIHBvcy55XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fcHJpdmF0ZS56b29tID0gem9vbTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5wYW4gPSBwYW4yO1xuXG4gICAgICAgIHZhciBwb3NDaGFuZ2VkID0gcGFuMS54ICE9PSBwYW4yLnggfHwgcGFuMS55ICE9PSBwYW4yLnk7XG4gICAgICAgIHRoaXMudHJpZ2dlcignIHpvb20gJyArIChwb3NDaGFuZ2VkID8gJyBwYW4gJyA6ICcnKSArICcgdmlld3BvcnQgJyApO1xuICAgICAgXG4gICAgICB9IGVsc2UgeyAvLyBqdXN0IHNldCB0aGUgem9vbVxuICAgICAgICB0aGlzLl9wcml2YXRlLnpvb20gPSB6b29tO1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ3pvb20gdmlld3BvcnQnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ub3RpZnkoeyAvLyBub3RpZnkgdGhlIHJlbmRlcmVyIHRoYXQgdGhlIHZpZXdwb3J0IGNoYW5nZWRcbiAgICAgICAgdHlwZTogJ3ZpZXdwb3J0J1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICB2aWV3cG9ydDogZnVuY3Rpb24oIG9wdHMgKXsgXG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgICAgdmFyIHpvb21EZWZkID0gdHJ1ZTtcbiAgICAgIHZhciBwYW5EZWZkID0gdHJ1ZTtcbiAgICAgIHZhciBldmVudHMgPSBbXTsgLy8gdG8gdHJpZ2dlclxuICAgICAgdmFyIHpvb21GYWlsZWQgPSBmYWxzZTtcbiAgICAgIHZhciBwYW5GYWlsZWQgPSBmYWxzZTtcblxuICAgICAgaWYoICFvcHRzICl7IHJldHVybiB0aGlzOyB9XG4gICAgICBpZiggISQkLmlzLm51bWJlcihvcHRzLnpvb20pICl7IHpvb21EZWZkID0gZmFsc2U7IH1cbiAgICAgIGlmKCAhJCQuaXMucGxhaW5PYmplY3Qob3B0cy5wYW4pICl7IHBhbkRlZmQgPSBmYWxzZTsgfVxuICAgICAgaWYoICF6b29tRGVmZCAmJiAhcGFuRGVmZCApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgICBpZiggem9vbURlZmQgKXtcbiAgICAgICAgdmFyIHogPSBvcHRzLnpvb207XG5cbiAgICAgICAgaWYoIHogPCBfcC5taW5ab29tIHx8IHogPiBfcC5tYXhab29tIHx8ICFfcC56b29taW5nRW5hYmxlZCApe1xuICAgICAgICAgIHpvb21GYWlsZWQgPSB0cnVlO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3Auem9vbSA9IHo7XG5cbiAgICAgICAgICBldmVudHMucHVzaCgnem9vbScpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKCBwYW5EZWZkICYmICghem9vbUZhaWxlZCB8fCAhb3B0cy5jYW5jZWxPbkZhaWxlZFpvb20pICYmIF9wLnBhbm5pbmdFbmFibGVkICl7XG4gICAgICAgIHZhciBwID0gb3B0cy5wYW47XG5cbiAgICAgICAgaWYoICQkLmlzLm51bWJlcihwLngpICl7XG4gICAgICAgICAgX3AucGFuLnggPSBwLng7XG4gICAgICAgICAgcGFuRmFpbGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggJCQuaXMubnVtYmVyKHAueSkgKXtcbiAgICAgICAgICBfcC5wYW4ueSA9IHAueTtcbiAgICAgICAgICBwYW5GYWlsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCAhcGFuRmFpbGVkICl7XG4gICAgICAgICAgZXZlbnRzLnB1c2goJ3BhbicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKCBldmVudHMubGVuZ3RoID4gMCApe1xuICAgICAgICBldmVudHMucHVzaCgndmlld3BvcnQnKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCBldmVudHMuam9pbignICcpICk7XG5cbiAgICAgICAgdGhpcy5ub3RpZnkoe1xuICAgICAgICAgIHR5cGU6ICd2aWV3cG9ydCdcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG4gICAgXG4gICAgY2VudGVyOiBmdW5jdGlvbiggZWxlbWVudHMgKXtcbiAgICAgIHZhciBwYW4gPSB0aGlzLmdldENlbnRlclBhbiggZWxlbWVudHMgKTtcblxuICAgICAgaWYoIHBhbiApe1xuICAgICAgICB0aGlzLl9wcml2YXRlLnBhbiA9IHBhbjtcblxuICAgICAgICB0aGlzLnRyaWdnZXIoJ3BhbiB2aWV3cG9ydCcpO1xuXG4gICAgICAgIHRoaXMubm90aWZ5KHsgLy8gbm90aWZ5IHRoZSByZW5kZXJlciB0aGF0IHRoZSB2aWV3cG9ydCBjaGFuZ2VkXG4gICAgICAgICAgdHlwZTogJ3ZpZXdwb3J0J1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIGdldENlbnRlclBhbjogZnVuY3Rpb24oIGVsZW1lbnRzLCB6b29tICl7XG4gICAgICBpZiggIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQgKXtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiggJCQuaXMuc3RyaW5nKGVsZW1lbnRzKSApe1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSBlbGVtZW50cztcbiAgICAgICAgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzKCBzZWxlY3RvciApO1xuICAgICAgfSBlbHNlIGlmKCAhJCQuaXMuZWxlbWVudE9yQ29sbGVjdGlvbihlbGVtZW50cykgKXtcbiAgICAgICAgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBiYiA9IGVsZW1lbnRzLmJvdW5kaW5nQm94KCk7XG4gICAgICB2YXIgdyA9IHRoaXMud2lkdGgoKTtcbiAgICAgIHZhciBoID0gdGhpcy5oZWlnaHQoKTtcbiAgICAgIHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl9wcml2YXRlLnpvb20gOiB6b29tO1xuXG4gICAgICB2YXIgcGFuID0geyAvLyBtaWRkbGVcbiAgICAgICAgeDogKHcgLSB6b29tKiggYmIueDEgKyBiYi54MiApKS8yLFxuICAgICAgICB5OiAoaCAtIHpvb20qKCBiYi55MSArIGJiLnkyICkpLzJcbiAgICAgIH07XG4gICAgICBcbiAgICAgIHJldHVybiBwYW47XG4gICAgfSxcbiAgICBcbiAgICByZXNldDogZnVuY3Rpb24oKXtcbiAgICAgIGlmKCAhdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCB8fCAhdGhpcy5fcHJpdmF0ZS56b29taW5nRW5hYmxlZCApe1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdGhpcy52aWV3cG9ydCh7XG4gICAgICAgIHBhbjogeyB4OiAwLCB5OiAwIH0sXG4gICAgICAgIHpvb206IDFcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgd2lkdGg6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5fcHJpdmF0ZS5jb250YWluZXI7XG5cbiAgICAgIGlmKCBjb250YWluZXIgKXtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5jbGllbnRXaWR0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDE7IC8vIGZhbGxiYWNrIGlmIG5vIGNvbnRhaW5lciAobm90IDAgYi9jIGNhbiBiZSB1c2VkIGZvciBkaXZpZGluZyBldGMpXG4gICAgfSxcblxuICAgIGhlaWdodDogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLl9wcml2YXRlLmNvbnRhaW5lcjtcblxuICAgICAgaWYoIGNvbnRhaW5lciApe1xuICAgICAgICByZXR1cm4gY29udGFpbmVyLmNsaWVudEhlaWdodDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDE7IC8vIGZhbGxiYWNrIGlmIG5vIGNvbnRhaW5lciAobm90IDAgYi9jIGNhbiBiZSB1c2VkIGZvciBkaXZpZGluZyBldGMpXG4gICAgfSxcblxuICAgIGV4dGVudDogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBwYW4gPSB0aGlzLl9wcml2YXRlLnBhbjtcbiAgICAgIHZhciB6b29tID0gdGhpcy5fcHJpdmF0ZS56b29tO1xuICAgICAgdmFyIHJiID0gdGhpcy5yZW5kZXJlZEV4dGVudCgpO1xuXG4gICAgICB2YXIgYiA9IHtcbiAgICAgICAgeDE6ICggcmIueDEgLSBwYW4ueCApL3pvb20sXG4gICAgICAgIHgyOiAoIHJiLngyIC0gcGFuLnggKS96b29tLFxuICAgICAgICB5MTogKCByYi55MSAtIHBhbi55ICkvem9vbSxcbiAgICAgICAgeTI6ICggcmIueTIgLSBwYW4ueSApL3pvb20sXG4gICAgICB9O1xuXG4gICAgICBiLncgPSBiLngyIC0gYi54MTtcbiAgICAgIGIuaCA9IGIueTIgLSBiLnkxO1xuXG4gICAgICByZXR1cm4gYjtcbiAgICB9LFxuXG4gICAgcmVuZGVyZWRFeHRlbnQ6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoKCk7XG4gICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5oZWlnaHQoKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDE6IDAsXG4gICAgICAgIHkxOiAwLFxuICAgICAgICB4Mjogd2lkdGgsXG4gICAgICAgIHkyOiBoZWlnaHQsXG4gICAgICAgIHc6IHdpZHRoLFxuICAgICAgICBoOiBoZWlnaHRcbiAgICAgIH07XG4gICAgfVxuICB9KTtcblxuICAvLyBhbGlhc2VzXG4gICQkLmNvcmVmbi5jZW50cmUgPSAkJC5jb3JlZm4uY2VudGVyO1xuXG4gIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICQkLmNvcmVmbi5hdXRvbG9ja05vZGVzID0gJCQuY29yZWZuLmF1dG9sb2NrO1xuICAkJC5jb3JlZm4uYXV0b3VuZ3JhYmlmeU5vZGVzID0gJCQuY29yZWZuLmF1dG91bmdyYWJpZnk7XG5cbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gIC8vIFVzZSB0aGlzIGludGVyZmFjZSB0byBkZWZpbmUgZnVuY3Rpb25zIGZvciBjb2xsZWN0aW9ucy9lbGVtZW50cy5cbiAgLy8gVGhpcyBpbnRlcmZhY2UgaXMgZ29vZCwgYmVjYXVzZSBpdCBmb3JjZXMgeW91IHRvIHRoaW5rIGluIHRlcm1zXG4gIC8vIG9mIHRoZSBjb2xsZWN0aW9ucyBjYXNlIChtb3JlIHRoYW4gMSBlbGVtZW50KSwgc28gd2UgZG9uJ3QgbmVlZFxuICAvLyBub3RpZmljYXRpb24gYmxvY2tpbmcgbm9uc2Vuc2UgZXZlcnl3aGVyZS5cbiAgLy9cbiAgLy8gT3RoZXIgY29sbGVjdGlvbi0qLmpzIGZpbGVzIGRlcGVuZCBvbiB0aGlzIGJlaW5nIGRlZmluZWQgZmlyc3QuXG4gIC8vIEl0J3MgYSB0cmFkZSBvZmY6IEl0IHNpbXBsaWZpZXMgdGhlIGNvZGUgZm9yIENvbGxlY3Rpb24gYW5kIFxuICAvLyBFbGVtZW50IGludGVncmF0aW9uIHNvIG11Y2ggdGhhdCBpdCdzIHdvcnRoIGl0IHRvIGNyZWF0ZSB0aGVcbiAgLy8gSlMgZGVwZW5kZW5jeS5cbiAgLy9cbiAgLy8gSGF2aW5nIHRoaXMgaW50ZWdyYXRpb24gZ3VhcmFudGVlcyB0aGF0IHdlIGNhbiBjYWxsIGFueVxuICAvLyBjb2xsZWN0aW9uIGZ1bmN0aW9uIG9uIGFuIGVsZW1lbnQgYW5kIHZpY2UgdmVyc2EuXG5cbiAgLy8gZS5nLiAkJC5mbi5jb2xsZWN0aW9uKHsgc29tZUZ1bmM6IGZ1bmN0aW9uKCl7IC8qIC4uLiAqLyB9IH0pXG4gICQkLmZuLmNvbGxlY3Rpb24gPSAkJC5mbi5lbGVzID0gZnVuY3Rpb24oIGZuTWFwLCBvcHRpb25zICl7XG4gICAgZm9yKCB2YXIgbmFtZSBpbiBmbk1hcCApe1xuICAgICAgdmFyIGZuID0gZm5NYXBbbmFtZV07XG5cbiAgICAgICQkLkNvbGxlY3Rpb24ucHJvdG90eXBlWyBuYW1lIF0gPSBmbjtcbiAgICB9XG4gIH07XG4gIFxuICAvLyBmYWN0b3J5IGZvciBnZW5lcmF0aW5nIGVkZ2UgaWRzIHdoZW4gbm8gaWQgaXMgc3BlY2lmaWVkIGZvciBhIG5ldyBlbGVtZW50XG4gIHZhciBpZEZhY3RvcnkgPSB7XG4gICAgcHJlZml4OiB7XG4gICAgICBub2RlczogJ24nLFxuICAgICAgZWRnZXM6ICdlJ1xuICAgIH0sXG4gICAgaWQ6IHtcbiAgICAgIG5vZGVzOiAwLFxuICAgICAgZWRnZXM6IDBcbiAgICB9LFxuICAgIGdlbmVyYXRlOiBmdW5jdGlvbihjeSwgZWxlbWVudCwgdHJ5VGhpc0lkKXtcbiAgICAgIHZhciBqc29uID0gJCQuaXMuZWxlbWVudCggZWxlbWVudCApID8gZWxlbWVudC5fcHJpdmF0ZSA6IGVsZW1lbnQ7XG4gICAgICB2YXIgZ3JvdXAgPSBqc29uLmdyb3VwO1xuICAgICAgdmFyIGlkID0gdHJ5VGhpc0lkICE9IG51bGwgPyB0cnlUaGlzSWQgOiB0aGlzLnByZWZpeFtncm91cF0gKyB0aGlzLmlkW2dyb3VwXTtcbiAgICAgIFxuICAgICAgaWYoIGN5LmdldEVsZW1lbnRCeUlkKGlkKS5lbXB0eSgpICl7XG4gICAgICAgIHRoaXMuaWRbZ3JvdXBdKys7IC8vIHdlJ3ZlIHVzZWQgdGhlIGN1cnJlbnQgaWQsIHNvIG1vdmUgaXQgdXBcbiAgICAgIH0gZWxzZSB7IC8vIG90aGVyd2lzZSBrZWVwIHRyeWluZyBzdWNjZXNzaXZlIHVudXNlZCBpZHNcbiAgICAgICAgd2hpbGUoICFjeS5nZXRFbGVtZW50QnlJZChpZCkuZW1wdHkoKSApe1xuICAgICAgICAgIGlkID0gdGhpcy5wcmVmaXhbZ3JvdXBdICsgKCArK3RoaXMuaWRbZ3JvdXBdICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbiAgfTtcbiAgXG4gIC8vIEVsZW1lbnRcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICBcbiAgLy8gcmVwcmVzZW50cyBhIG5vZGUgb3IgYW4gZWRnZVxuICAkJC5FbGVtZW50ID0gZnVuY3Rpb24oY3ksIHBhcmFtcywgcmVzdG9yZSl7XG4gICAgaWYoICEodGhpcyBpbnN0YW5jZW9mICQkLkVsZW1lbnQpICl7XG4gICAgICByZXR1cm4gbmV3ICQkLkVsZW1lbnQoY3ksIHBhcmFtcywgcmVzdG9yZSk7XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJlc3RvcmUgPSAocmVzdG9yZSA9PT0gdW5kZWZpbmVkIHx8IHJlc3RvcmUgPyB0cnVlIDogZmFsc2UpO1xuICAgIFxuICAgIGlmKCBjeSA9PT0gdW5kZWZpbmVkIHx8IHBhcmFtcyA9PT0gdW5kZWZpbmVkIHx8ICEkJC5pcy5jb3JlKGN5KSApe1xuICAgICAgJCQudXRpbC5lcnJvcignQW4gZWxlbWVudCBtdXN0IGhhdmUgYSBjb3JlIHJlZmVyZW5jZSBhbmQgcGFyYW1ldGVycyBzZXQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gdmFsaWRhdGUgZ3JvdXBcbiAgICBpZiggcGFyYW1zLmdyb3VwICE9PSAnbm9kZXMnICYmIHBhcmFtcy5ncm91cCAhPT0gJ2VkZ2VzJyApe1xuICAgICAgJCQudXRpbC5lcnJvcignQW4gZWxlbWVudCBtdXN0IGJlIG9mIHR5cGUgYG5vZGVzYCBvciBgZWRnZXNgOyB5b3Ugc3BlY2lmaWVkIGAnICsgcGFyYW1zLmdyb3VwICsgJ2AnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gbWFrZSB0aGUgZWxlbWVudCBhcnJheS1saWtlLCBqdXN0IGxpa2UgYSBjb2xsZWN0aW9uXG4gICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIHRoaXNbMF0gPSB0aGlzO1xuICAgIFxuICAgIC8vIE5PVEU6IHdoZW4gc29tZXRoaW5nIGlzIGFkZGVkIGhlcmUsIGFkZCBhbHNvIHRvIGVsZS5qc29uKClcbiAgICB0aGlzLl9wcml2YXRlID0ge1xuICAgICAgY3k6IGN5LFxuICAgICAgc2luZ2xlOiB0cnVlLCAvLyBpbmRpY2F0ZXMgdGhpcyBpcyBhbiBlbGVtZW50XG4gICAgICBkYXRhOiBwYXJhbXMuZGF0YSB8fCB7fSwgLy8gZGF0YSBvYmplY3RcbiAgICAgIHBvc2l0aW9uOiBwYXJhbXMucG9zaXRpb24gfHwge30sIC8vICh4LCB5KSBwb3NpdGlvbiBwYWlyXG4gICAgICBhdXRvV2lkdGg6IHVuZGVmaW5lZCwgLy8gd2lkdGggYW5kIGhlaWdodCBvZiBub2RlcyBjYWxjdWxhdGVkIGJ5IHRoZSByZW5kZXJlciB3aGVuIHNldCB0byBzcGVjaWFsICdhdXRvJyB2YWx1ZVxuICAgICAgYXV0b0hlaWdodDogdW5kZWZpbmVkLCBcbiAgICAgIGxpc3RlbmVyczogW10sIC8vIGFycmF5IG9mIGJvdW5kIGxpc3RlbmVyc1xuICAgICAgZ3JvdXA6IHBhcmFtcy5ncm91cCwgLy8gc3RyaW5nOyAnbm9kZXMnIG9yICdlZGdlcydcbiAgICAgIHN0eWxlOiB7fSwgLy8gcHJvcGVydGllcyBhcyBzZXQgYnkgdGhlIHN0eWxlXG4gICAgICByc3R5bGU6IHt9LCAvLyBwcm9wZXJ0aWVzIGZvciBzdHlsZSBzZW50IGZyb20gdGhlIHJlbmRlcmVyIHRvIHRoZSBjb3JlXG4gICAgICBzdHlsZUN4dHM6IFtdLCAvLyBhcHBsaWVkIHN0eWxlIGNvbnRleHRzIGZyb20gdGhlIHN0eWxlclxuICAgICAgcmVtb3ZlZDogdHJ1ZSwgLy8gd2hldGhlciBpdCdzIGluc2lkZSB0aGUgdmlzOyB0cnVlIGlmIHJlbW92ZWQgKHNldCB0cnVlIGhlcmUgc2luY2Ugd2UgY2FsbCByZXN0b3JlKVxuICAgICAgc2VsZWN0ZWQ6IHBhcmFtcy5zZWxlY3RlZCA/IHRydWUgOiBmYWxzZSwgLy8gd2hldGhlciBpdCdzIHNlbGVjdGVkXG4gICAgICBzZWxlY3RhYmxlOiBwYXJhbXMuc2VsZWN0YWJsZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICggcGFyYW1zLnNlbGVjdGFibGUgPyB0cnVlIDogZmFsc2UgKSwgLy8gd2hldGhlciBpdCdzIHNlbGVjdGFibGVcbiAgICAgIGxvY2tlZDogcGFyYW1zLmxvY2tlZCA/IHRydWUgOiBmYWxzZSwgLy8gd2hldGhlciB0aGUgZWxlbWVudCBpcyBsb2NrZWQgKGNhbm5vdCBiZSBtb3ZlZClcbiAgICAgIGdyYWJiZWQ6IGZhbHNlLCAvLyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIGdyYWJiZWQgYnkgdGhlIG1vdXNlOyByZW5kZXJlciBzZXRzIHRoaXMgcHJpdmF0ZWx5XG4gICAgICBncmFiYmFibGU6IHBhcmFtcy5ncmFiYmFibGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiAoIHBhcmFtcy5ncmFiYmFibGUgPyB0cnVlIDogZmFsc2UgKSwgLy8gd2hldGhlciB0aGUgZWxlbWVudCBjYW4gYmUgZ3JhYmJlZFxuICAgICAgYWN0aXZlOiBmYWxzZSwgLy8gd2hldGhlciB0aGUgZWxlbWVudCBpcyBhY3RpdmUgZnJvbSB1c2VyIGludGVyYWN0aW9uXG4gICAgICBjbGFzc2VzOiB7fSwgLy8gbWFwICggY2xhc3NOYW1lID0+IHRydWUgKVxuICAgICAgYW5pbWF0aW9uOiB7IC8vIG9iamVjdCBmb3IgY3VycmVudGx5LXJ1bm5pbmcgYW5pbWF0aW9uc1xuICAgICAgICBjdXJyZW50OiBbXSxcbiAgICAgICAgcXVldWU6IFtdXG4gICAgICB9LFxuICAgICAgcnNjcmF0Y2g6IHt9LCAvLyBvYmplY3QgaW4gd2hpY2ggdGhlIHJlbmRlcmVyIGNhbiBzdG9yZSBpbmZvcm1hdGlvblxuICAgICAgc2NyYXRjaDogcGFyYW1zLnNjcmF0Y2ggfHwge30sIC8vIHNjcmF0Y2ggb2JqZWN0c1xuICAgICAgZWRnZXM6IFtdLCAvLyBhcnJheSBvZiBjb25uZWN0ZWQgZWRnZXNcbiAgICAgIGNoaWxkcmVuOiBbXSAvLyBhcnJheSBvZiBjaGlsZHJlblxuICAgIH07XG4gICAgXG4gICAgLy8gcmVuZGVyZWRQb3NpdGlvbiBvdmVycmlkZXMgaWYgc3BlY2lmaWVkXG4gICAgaWYoIHBhcmFtcy5yZW5kZXJlZFBvc2l0aW9uICl7XG4gICAgICB2YXIgcnBvcyA9IHBhcmFtcy5yZW5kZXJlZFBvc2l0aW9uO1xuICAgICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG5cbiAgICAgIHRoaXMuX3ByaXZhdGUucG9zaXRpb24gPSB7XG4gICAgICAgIHg6IChycG9zLnggLSBwYW4ueCkvem9vbSxcbiAgICAgICAgeTogKHJwb3MueSAtIHBhbi55KS96b29tXG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICBpZiggJCQuaXMuc3RyaW5nKHBhcmFtcy5jbGFzc2VzKSApe1xuICAgICAgdmFyIGNsYXNzZXMgPSBwYXJhbXMuY2xhc3Nlcy5zcGxpdCgvXFxzKy8pO1xuICAgICAgZm9yKCB2YXIgaSA9IDAsIGwgPSBjbGFzc2VzLmxlbmd0aDsgaSA8IGw7IGkrKyApe1xuICAgICAgICB2YXIgY2xzID0gY2xhc3Nlc1tpXTtcbiAgICAgICAgaWYoICFjbHMgfHwgY2xzID09PSAnJyApeyBjb250aW51ZTsgfVxuXG4gICAgICAgIHNlbGYuX3ByaXZhdGUuY2xhc3Nlc1tjbHNdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiggcGFyYW1zLmNzcyApe1xuICAgICAgY3kuc3R5bGUoKS5hcHBseUJ5cGFzcyggdGhpcywgcGFyYW1zLmNzcyApO1xuICAgIH1cbiAgICBcbiAgICBpZiggcmVzdG9yZSA9PT0gdW5kZWZpbmVkIHx8IHJlc3RvcmUgKXtcbiAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgIH1cbiAgICBcbiAgfTtcblxuICBcbiAgLy8gQ29sbGVjdGlvblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIFxuICAvLyByZXByZXNlbnRzIGEgc2V0IG9mIG5vZGVzLCBlZGdlcywgb3IgYm90aCB0b2dldGhlclxuICAkJC5Db2xsZWN0aW9uID0gZnVuY3Rpb24oY3ksIGVsZW1lbnRzLCBvcHRpb25zKXtcbiAgICBpZiggISh0aGlzIGluc3RhbmNlb2YgJCQuQ29sbGVjdGlvbikgKXtcbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbihjeSwgZWxlbWVudHMpO1xuICAgIH1cblxuICAgIGlmKCBjeSA9PT0gdW5kZWZpbmVkIHx8ICEkJC5pcy5jb3JlKGN5KSApe1xuICAgICAgJCQudXRpbC5lcnJvcignQSBjb2xsZWN0aW9uIG11c3QgaGF2ZSBhIHJlZmVyZW5jZSB0byB0aGUgY29yZScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICB2YXIgaWRzID0ge307XG4gICAgdmFyIGluZGV4ZXMgPSB7fTtcbiAgICB2YXIgY3JlYXRlZEVsZW1lbnRzID0gZmFsc2U7XG4gICAgXG4gICAgaWYoICFlbGVtZW50cyApe1xuICAgICAgZWxlbWVudHMgPSBbXTtcbiAgICB9IGVsc2UgaWYoIGVsZW1lbnRzLmxlbmd0aCA+IDAgJiYgJCQuaXMucGxhaW5PYmplY3QoIGVsZW1lbnRzWzBdICkgJiYgISQkLmlzLmVsZW1lbnQoIGVsZW1lbnRzWzBdICkgKXtcbiAgICAgIGNyZWF0ZWRFbGVtZW50cyA9IHRydWU7XG5cbiAgICAgIC8vIG1ha2UgZWxlbWVudHMgZnJvbSBqc29uIGFuZCByZXN0b3JlIGFsbCBhdCBvbmNlIGxhdGVyXG4gICAgICB2YXIgZWxlcyA9IFtdO1xuICAgICAgdmFyIGVsZXNJZHMgPSB7fTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDAsIGwgPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKXtcbiAgICAgICAgdmFyIGpzb24gPSBlbGVtZW50c1tpXTtcblxuICAgICAgICBpZigganNvbi5kYXRhID09IG51bGwgKXtcbiAgICAgICAgICBqc29uLmRhdGEgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIGRhdGEgPSBqc29uLmRhdGE7XG5cbiAgICAgICAgLy8gbWFrZSBzdXJlIG5ld2x5IGNyZWF0ZWQgZWxlbWVudHMgaGF2ZSB2YWxpZCBpZHNcbiAgICAgICAgaWYoIGRhdGEuaWQgPT0gbnVsbCApe1xuICAgICAgICAgIGRhdGEuaWQgPSBpZEZhY3RvcnkuZ2VuZXJhdGUoIGN5LCBqc29uICk7XG4gICAgICAgIH0gZWxzZSBpZiggY3kuZ2V0RWxlbWVudEJ5SWQoIGRhdGEuaWQgKS5sZW5ndGggIT09IDAgfHwgZWxlc0lkc1sgZGF0YS5pZCBdICl7XG4gICAgICAgICAgY29udGludWU7IC8vIGNhbid0IGNyZWF0ZSBlbGVtZW50IGlmIHByaW9yIGlkIGFscmVhZHkgZXhpc3RzXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWxlID0gbmV3ICQkLkVsZW1lbnQoIGN5LCBqc29uLCBmYWxzZSApO1xuICAgICAgICBlbGVzLnB1c2goIGVsZSApO1xuICAgICAgICBlbGVzSWRzWyBkYXRhLmlkIF0gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50cyA9IGVsZXM7XG4gICAgfVxuICAgIFxuICAgIHRoaXMubGVuZ3RoID0gMDtcblxuICAgIGZvciggdmFyIGkgPSAwLCBsID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICl7XG4gICAgICB2YXIgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgaWYoICFlbGVtZW50ICl7ICBjb250aW51ZTsgfVxuICAgICAgXG4gICAgICB2YXIgaWQgPSBlbGVtZW50Ll9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICBcbiAgICAgIGlmKCAhb3B0aW9ucyB8fCAob3B0aW9ucy51bmlxdWUgJiYgIWlkc1sgaWQgXSApICl7XG4gICAgICAgIGlkc1sgaWQgXSA9IGVsZW1lbnQ7XG4gICAgICAgIGluZGV4ZXNbIGlkIF0gPSB0aGlzLmxlbmd0aDtcblxuICAgICAgICB0aGlzWyB0aGlzLmxlbmd0aCBdID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgdGhpcy5fcHJpdmF0ZSA9IHtcbiAgICAgIGN5OiBjeSxcbiAgICAgIGlkczogaWRzLFxuICAgICAgaW5kZXhlczogaW5kZXhlc1xuICAgIH07XG5cbiAgICAvLyByZXN0b3JlIHRoZSBlbGVtZW50cyBpZiB3ZSBjcmVhdGVkIHRoZW0gZnJvbSBqc29uXG4gICAgaWYoIGNyZWF0ZWRFbGVtZW50cyApe1xuICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgfVxuICB9O1xuICBcbiAgXG4gIC8vIEZ1bmN0aW9uc1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIFxuICAvLyBrZWVwIHRoZSBwcm90b3R5cGVzIGluIHN5bmMgKGFuIGVsZW1lbnQgaGFzIHRoZSBzYW1lIGZ1bmN0aW9ucyBhcyBhIGNvbGxlY3Rpb24pXG4gIC8vIGFuZCB1c2UgJCQuZWxlZm4gYW5kICQkLmVsZXNmbiBhcyBzaG9ydGhhbmRzIHRvIHRoZSBwcm90b3R5cGVzXG4gICQkLmVsZWZuID0gJCQuZWxlc2ZuID0gJCQuRWxlbWVudC5wcm90b3R5cGUgPSAkJC5Db2xsZWN0aW9uLnByb3RvdHlwZTtcblxuICAkJC5lbGVzZm4uY3kgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmN5O1xuICB9O1xuICBcbiAgJCQuZWxlc2ZuLmVsZW1lbnQgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzWzBdO1xuICB9O1xuICBcbiAgJCQuZWxlc2ZuLmNvbGxlY3Rpb24gPSBmdW5jdGlvbigpe1xuICAgIGlmKCAkJC5pcy5jb2xsZWN0aW9uKHRoaXMpICl7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2UgeyAvLyBhbiBlbGVtZW50XG4gICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIHRoaXMuX3ByaXZhdGUuY3ksIFt0aGlzXSApO1xuICAgIH1cbiAgfTtcblxuICAkJC5lbGVzZm4udW5pcXVlID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIHRoaXMuX3ByaXZhdGUuY3ksIHRoaXMsIHsgdW5pcXVlOiB0cnVlIH0gKTtcbiAgfTtcblxuICAkJC5lbGVzZm4uZ2V0RWxlbWVudEJ5SWQgPSBmdW5jdGlvbiggaWQgKXtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgIHZhciBlbGUgPSB0aGlzLl9wcml2YXRlLmlkc1sgaWQgXTtcblxuICAgIHJldHVybiBlbGUgPyBlbGUgOiAkJC5Db2xsZWN0aW9uKGN5KTsgLy8gZ2V0IGVsZSBvciBlbXB0eSBjb2xsZWN0aW9uXG4gIH07XG5cbiAgJCQuZWxlc2ZuLmpzb24gPSBmdW5jdGlvbigpe1xuICAgIHZhciBlbGUgPSB0aGlzLmVsZW1lbnQoKTtcbiAgICBpZiggZWxlID09IG51bGwgKXsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuXG4gICAgdmFyIHAgPSBlbGUuX3ByaXZhdGU7XG4gICAgXG4gICAgdmFyIGpzb24gPSAkJC51dGlsLmNvcHkoe1xuICAgICAgZGF0YTogcC5kYXRhLFxuICAgICAgcG9zaXRpb246IHAucG9zaXRpb24sXG4gICAgICBncm91cDogcC5ncm91cCxcbiAgICAgIGJ5cGFzczogcC5ieXBhc3MsXG4gICAgICByZW1vdmVkOiBwLnJlbW92ZWQsXG4gICAgICBzZWxlY3RlZDogcC5zZWxlY3RlZCxcbiAgICAgIHNlbGVjdGFibGU6IHAuc2VsZWN0YWJsZSxcbiAgICAgIGxvY2tlZDogcC5sb2NrZWQsXG4gICAgICBncmFiYmVkOiBwLmdyYWJiZWQsXG4gICAgICBncmFiYmFibGU6IHAuZ3JhYmJhYmxlLFxuICAgICAgY2xhc3NlczogJydcbiAgICB9KTtcbiAgICBcbiAgICB2YXIgY2xhc3NlcyA9IFtdO1xuICAgIGZvciggdmFyIGNscyBpbiBwLmNsYXNzZXMgKXtcbiAgICAgIGlmKCBwLmNsYXNzZXNbY2xzXSApe1xuICAgICAgICBjbGFzc2VzLnB1c2goY2xzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjbGFzc2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgY2xzID0gY2xhc3Nlc1tpXTtcbiAgICAgIGpzb24uY2xhc3NlcyArPSBjbHMgKyAoIGkgPCBjbGFzc2VzLmxlbmd0aCAtIDEgPyAnICcgOiAnJyApO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4ganNvbjtcbiAgfTtcblxuICAkJC5lbGVzZm4uanNvbnMgPSBmdW5jdGlvbigpe1xuICAgIHZhciBqc29ucyA9IFtdO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIHZhciBqc29uID0gZWxlLmpzb24oKTtcblxuICAgICAganNvbnMucHVzaCgganNvbiApO1xuICAgIH1cblxuICAgIHJldHVybiBqc29ucztcbiAgfTtcblxuICAkJC5lbGVzZm4uY2xvbmUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICB2YXIgZWxlc0FyciA9IFtdO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIHZhciBqc29uID0gZWxlLmpzb24oKTtcbiAgICAgIHZhciBjbG9uZSA9IG5ldyAkJC5FbGVtZW50KGN5LCBqc29uLCBmYWxzZSk7IC8vIE5CIG5vIHJlc3RvcmVcblxuICAgICAgZWxlc0Fyci5wdXNoKCBjbG9uZSApO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIGVsZXNBcnIgKTtcbiAgfTtcbiAgJCQuZWxlc2ZuLmNvcHkgPSAkJC5lbGVzZm4uY2xvbmU7XG5cbiAgJCQuZWxlc2ZuLnJlc3RvcmUgPSBmdW5jdGlvbiggbm90aWZ5UmVuZGVyZXIgKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHJlc3RvcmVkID0gW107XG4gICAgdmFyIGN5ID0gc2VsZi5jeSgpO1xuICAgIFxuICAgIGlmKCBub3RpZnlSZW5kZXJlciA9PT0gdW5kZWZpbmVkICl7XG4gICAgICBub3RpZnlSZW5kZXJlciA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIGFycmF5cyBvZiBub2RlcyBhbmQgZWRnZXMsIHNpbmNlIHdlIG5lZWQgdG9cbiAgICAvLyByZXN0b3JlIHRoZSBub2RlcyBmaXJzdFxuICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgIHZhciBub2RlcyA9IFtdLCBlZGdlcyA9IFtdO1xuICAgIHZhciBudW1Ob2RlcyA9IDA7XG4gICAgdmFyIG51bUVkZ2VzID0gMDtcbiAgICBmb3IoIHZhciBpID0gMCwgbCA9IHNlbGYubGVuZ3RoOyBpIDwgbDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gc2VsZltpXTtcbiAgICAgIFxuICAgICAgLy8ga2VlcCBub2RlcyBmaXJzdCBpbiB0aGUgYXJyYXkgYW5kIGVkZ2VzIGFmdGVyXG4gICAgICBpZiggZWxlLmlzTm9kZSgpICl7IC8vIHB1dCB0byBmcm9udCBvZiBhcnJheSBpZiBub2RlXG4gICAgICAgIG5vZGVzLnB1c2goIGVsZSApO1xuICAgICAgICBudW1Ob2RlcysrO1xuICAgICAgfSBlbHNlIHsgLy8gcHV0IHRvIGVuZCBvZiBhcnJheSBpZiBlZGdlXG4gICAgICAgIGVkZ2VzLnB1c2goIGVsZSApO1xuICAgICAgICBudW1FZGdlcysrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGVsZW1lbnRzID0gbm9kZXMuY29uY2F0KCBlZGdlcyApO1xuXG4gICAgLy8gbm93LCByZXN0b3JlIGVhY2ggZWxlbWVudFxuICAgIGZvciggdmFyIGkgPSAwLCBsID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gZWxlbWVudHNbaV07XG5cbiAgICAgIGlmKCAhZWxlLnJlbW92ZWQoKSApe1xuICAgICAgICAvLyBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICB2YXIgX3ByaXZhdGUgPSBlbGUuX3ByaXZhdGU7XG4gICAgICB2YXIgZGF0YSA9IF9wcml2YXRlLmRhdGE7XG4gICAgICBcbiAgICAgIC8vIHNldCBpZCBhbmQgdmFsaWRhdGVcbiAgICAgIGlmKCBkYXRhLmlkID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgZGF0YS5pZCA9IGlkRmFjdG9yeS5nZW5lcmF0ZSggY3ksIGVsZSApO1xuICAgICAgfSBlbHNlIGlmKCAkJC5pcy5lbXB0eVN0cmluZyhkYXRhLmlkKSB8fCAhJCQuaXMuc3RyaW5nKGRhdGEuaWQpICl7XG4gICAgICAgICQkLnV0aWwuZXJyb3IoJ0NhbiBub3QgY3JlYXRlIGVsZW1lbnQgd2l0aCBpbnZhbGlkIHN0cmluZyBJRCBgJyArIGRhdGEuaWQgKyAnYCcpO1xuICAgICAgICBcbiAgICAgICAgLy8gY2FuJ3QgY3JlYXRlIGVsZW1lbnQgaWYgaXQgaGFzIGVtcHR5IHN0cmluZyBhcyBpZCBvciBub24tc3RyaW5nIGlkXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmKCBjeS5nZXRFbGVtZW50QnlJZCggZGF0YS5pZCApLmxlbmd0aCAhPT0gMCApe1xuICAgICAgICAkJC51dGlsLmVycm9yKCdDYW4gbm90IGNyZWF0ZSBzZWNvbmQgZWxlbWVudCB3aXRoIElEIGAnICsgZGF0YS5pZCArICdgJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBjYW4ndCBjcmVhdGUgZWxlbWVudCBpZiBvbmUgYWxyZWFkeSBoYXMgdGhhdCBpZFxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlkID0gZGF0YS5pZDsgLy8gaWQgaXMgZmluYWxpc2VkLCBub3cgbGV0J3Mga2VlcCBhIHJlZlxuICAgICAgXG4gICAgICBpZiggZWxlLmlzRWRnZSgpICl7IC8vIGV4dHJhIGNoZWNrcyBmb3IgZWRnZXNcbiAgICAgICAgXG4gICAgICAgIHZhciBlZGdlID0gZWxlO1xuICAgICAgICB2YXIgZmllbGRzID0gWydzb3VyY2UnLCAndGFyZ2V0J107XG4gICAgICAgIHZhciBmaWVsZHNMZW5ndGggPSBmaWVsZHMubGVuZ3RoO1xuICAgICAgICB2YXIgYmFkU291cmNlT3JUYXJnZXQgPSBmYWxzZTtcbiAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IGZpZWxkc0xlbmd0aDsgaisrKXtcbiAgICAgICAgICBcbiAgICAgICAgICB2YXIgZmllbGQgPSBmaWVsZHNbal07XG4gICAgICAgICAgdmFyIHZhbCA9IGRhdGFbZmllbGRdO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmKCB2YWwgPT0gbnVsbCB8fCB2YWwgPT09ICcnICl7XG4gICAgICAgICAgICAvLyBjYW4ndCBjcmVhdGUgaWYgc291cmNlIG9yIHRhcmdldCBpcyBub3QgZGVmaW5lZCBwcm9wZXJseVxuICAgICAgICAgICAgJCQudXRpbC5lcnJvcignQ2FuIG5vdCBjcmVhdGUgZWRnZSBgJyArIGlkICsgJ2Agd2l0aCB1bnNwZWNpZmllZCAnICsgZmllbGQpO1xuICAgICAgICAgICAgYmFkU291cmNlT3JUYXJnZXQgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiggY3kuZ2V0RWxlbWVudEJ5SWQodmFsKS5lbXB0eSgpICl7IFxuICAgICAgICAgICAgLy8gY2FuJ3QgY3JlYXRlIGVkZ2UgaWYgb25lIG9mIGl0cyBub2RlcyBkb2Vzbid0IGV4aXN0XG4gICAgICAgICAgICAkJC51dGlsLmVycm9yKCdDYW4gbm90IGNyZWF0ZSBlZGdlIGAnICsgaWQgKyAnYCB3aXRoIG5vbmV4aXN0YW50ICcgKyBmaWVsZCArICcgYCcgKyB2YWwgKyAnYCcpO1xuICAgICAgICAgICAgYmFkU291cmNlT3JUYXJnZXQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBiYWRTb3VyY2VPclRhcmdldCApeyBjb250aW51ZTsgfSAvLyBjYW4ndCBjcmVhdGUgdGhpc1xuICAgICAgICBcbiAgICAgICAgdmFyIHNyYyA9IGN5LmdldEVsZW1lbnRCeUlkKCBkYXRhLnNvdXJjZSApO1xuICAgICAgICB2YXIgdGd0ID0gY3kuZ2V0RWxlbWVudEJ5SWQoIGRhdGEudGFyZ2V0ICk7XG5cbiAgICAgICAgc3JjLl9wcml2YXRlLmVkZ2VzLnB1c2goIGVkZ2UgKTtcbiAgICAgICAgdGd0Ll9wcml2YXRlLmVkZ2VzLnB1c2goIGVkZ2UgKTtcblxuICAgICAgICBlZGdlLl9wcml2YXRlLnNvdXJjZSA9IHNyYztcbiAgICAgICAgZWRnZS5fcHJpdmF0ZS50YXJnZXQgPSB0Z3Q7XG5cbiAgICAgIH0gLy8gaWYgaXMgZWRnZVxuICAgICAgIFxuICAgICAgLy8gY3JlYXRlIG1vY2sgaWRzIG1hcCBmb3IgZWxlbWVudCBzbyBpdCBjYW4gYmUgdXNlZCBsaWtlIGNvbGxlY3Rpb25zXG4gICAgICBfcHJpdmF0ZS5pZHMgPSB7fTtcbiAgICAgIF9wcml2YXRlLmlkc1sgaWQgXSA9IGVsZTtcblxuICAgICAgX3ByaXZhdGUucmVtb3ZlZCA9IGZhbHNlO1xuICAgICAgY3kuYWRkVG9Qb29sKCBlbGUgKTtcbiAgICAgIFxuICAgICAgcmVzdG9yZWQucHVzaCggZWxlICk7XG4gICAgfSAvLyBmb3IgZWFjaCBlbGVtZW50XG5cbiAgICAvLyBkbyBjb21wb3VuZCBub2RlIHNhbml0eSBjaGVja3NcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKysgKXsgLy8gZWFjaCBub2RlIFxuICAgICAgdmFyIG5vZGUgPSBlbGVtZW50c1tpXTtcbiAgICAgIHZhciBkYXRhID0gbm9kZS5fcHJpdmF0ZS5kYXRhO1xuXG4gICAgICB2YXIgcGFyZW50SWQgPSBub2RlLl9wcml2YXRlLmRhdGEucGFyZW50O1xuICAgICAgdmFyIHNwZWNpZmllZFBhcmVudCA9IHBhcmVudElkICE9IG51bGw7XG5cbiAgICAgIGlmKCBzcGVjaWZpZWRQYXJlbnQgKXtcbiAgICAgICAgdmFyIHBhcmVudCA9IGN5LmdldEVsZW1lbnRCeUlkKCBwYXJlbnRJZCApO1xuXG4gICAgICAgIGlmKCBwYXJlbnQuZW1wdHkoKSApe1xuICAgICAgICAgIC8vIG5vbi1leGlzdGFudCBwYXJlbnQ7IGp1c3QgcmVtb3ZlIGl0XG4gICAgICAgICAgZGF0YS5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHNlbGZBc1BhcmVudCA9IGZhbHNlO1xuICAgICAgICAgIHZhciBhbmNlc3RvciA9IHBhcmVudDtcbiAgICAgICAgICB3aGlsZSggIWFuY2VzdG9yLmVtcHR5KCkgKXtcbiAgICAgICAgICAgIGlmKCBub2RlLnNhbWUoYW5jZXN0b3IpICl7XG4gICAgICAgICAgICAgIC8vIG1hcmsgc2VsZiBhcyBwYXJlbnQgYW5kIHJlbW92ZSBmcm9tIGRhdGFcbiAgICAgICAgICAgICAgc2VsZkFzUGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgZGF0YS5wYXJlbnQgPSB1bmRlZmluZWQ7IC8vIHJlbW92ZSBwYXJlbnQgcmVmZXJlbmNlXG5cbiAgICAgICAgICAgICAgLy8gZXhpdCBvciB3ZSBsb29wIGZvcmV2ZXJcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoICFzZWxmQXNQYXJlbnQgKXtcbiAgICAgICAgICAgIC8vIGNvbm5lY3Qgd2l0aCBjaGlsZHJlblxuICAgICAgICAgICAgcGFyZW50WzBdLl9wcml2YXRlLmNoaWxkcmVuLnB1c2goIG5vZGUgKTtcbiAgICAgICAgICAgIG5vZGUuX3ByaXZhdGUucGFyZW50ID0gcGFyZW50WzBdO1xuXG4gICAgICAgICAgICAvLyBsZXQgdGhlIGNvcmUga25vdyB3ZSBoYXZlIGEgY29tcG91bmQgZ3JhcGhcbiAgICAgICAgICAgIGN5Ll9wcml2YXRlLmhhc0NvbXBvdW5kTm9kZXMgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBlbHNlXG4gICAgICB9IC8vIGlmIHNwZWNpZmllZCBwYXJlbnRcbiAgICB9IC8vIGZvciBlYWNoIG5vZGVcbiAgICBcbiAgICByZXN0b3JlZCA9IG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgcmVzdG9yZWQgKTtcbiAgICBpZiggcmVzdG9yZWQubGVuZ3RoID4gMCApe1xuXG4gICAgICB2YXIgdG9VcGRhdGVTdHlsZSA9IHJlc3RvcmVkLmFkZCggcmVzdG9yZWQuY29ubmVjdGVkTm9kZXMoKSApLmFkZCggcmVzdG9yZWQucGFyZW50KCkgKTtcbiAgICAgIHRvVXBkYXRlU3R5bGUudXBkYXRlU3R5bGUoIG5vdGlmeVJlbmRlcmVyICk7XG5cbiAgICAgIGlmKCBub3RpZnlSZW5kZXJlciApe1xuICAgICAgICByZXN0b3JlZC5ydHJpZ2dlcignYWRkJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN0b3JlZC50cmlnZ2VyKCdhZGQnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHNlbGY7IC8vIGNoYWluYWJpbGl0eVxuICB9O1xuICBcbiAgJCQuZWxlc2ZuLnJlbW92ZWQgPSBmdW5jdGlvbigpe1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHJldHVybiBlbGUgJiYgZWxlLl9wcml2YXRlLnJlbW92ZWQ7XG4gIH07XG5cbiAgJCQuZWxlc2ZuLmluc2lkZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgcmV0dXJuIGVsZSAmJiAhZWxlLl9wcml2YXRlLnJlbW92ZWQ7XG4gIH07XG5cbiAgJCQuZWxlc2ZuLnJlbW92ZSA9IGZ1bmN0aW9uKCBub3RpZnlSZW5kZXJlciApe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcmVtb3ZlZCA9IFtdO1xuICAgIHZhciBlbGVzVG9SZW1vdmUgPSBbXTtcbiAgICB2YXIgZWxlc1RvUmVtb3ZlSWRzID0ge307XG4gICAgdmFyIGN5ID0gc2VsZi5fcHJpdmF0ZS5jeTtcbiAgICBcbiAgICBpZiggbm90aWZ5UmVuZGVyZXIgPT09IHVuZGVmaW5lZCApe1xuICAgICAgbm90aWZ5UmVuZGVyZXIgPSB0cnVlO1xuICAgIH1cbiAgICBcbiAgICAvLyBhZGQgY29ubmVjdGVkIGVkZ2VzXG4gICAgZnVuY3Rpb24gYWRkQ29ubmVjdGVkRWRnZXMobm9kZSl7XG4gICAgICB2YXIgZWRnZXMgPSBub2RlLl9wcml2YXRlLmVkZ2VzOyBcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgYWRkKCBlZGdlc1tpXSApO1xuICAgICAgfVxuICAgIH1cbiAgICBcblxuICAgIC8vIGFkZCBkZXNjZW5kYW50IG5vZGVzXG4gICAgZnVuY3Rpb24gYWRkQ2hpbGRyZW4obm9kZSl7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLl9wcml2YXRlLmNoaWxkcmVuO1xuICAgICAgXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIGFkZCggY2hpbGRyZW5baV0gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGQoIGVsZSApe1xuICAgICAgdmFyIGFscmVhZHlBZGRlZCA9ICBlbGVzVG9SZW1vdmVJZHNbIGVsZS5pZCgpIF07XG4gICAgICBpZiggYWxyZWFkeUFkZGVkICl7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZXNUb1JlbW92ZUlkc1sgZWxlLmlkKCkgXSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmKCBlbGUuaXNOb2RlKCkgKXtcbiAgICAgICAgZWxlc1RvUmVtb3ZlLnB1c2goIGVsZSApOyAvLyBub2RlcyBhcmUgcmVtb3ZlZCBsYXN0XG5cbiAgICAgICAgYWRkQ29ubmVjdGVkRWRnZXMoIGVsZSApO1xuICAgICAgICBhZGRDaGlsZHJlbiggZWxlICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVzVG9SZW1vdmUudW5zaGlmdCggZWxlICk7IC8vIGVkZ2VzIGFyZSByZW1vdmVkIGZpcnN0XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gbWFrZSB0aGUgbGlzdCBvZiBlbGVtZW50cyB0byByZW1vdmVcbiAgICAvLyAobWF5IGJlIHJlbW92aW5nIG1vcmUgdGhhbiBzcGVjaWZpZWQgZHVlIHRvIGNvbm5lY3RlZCBlZGdlcyBldGMpXG5cbiAgICBmb3IoIHZhciBpID0gMCwgbCA9IHNlbGYubGVuZ3RoOyBpIDwgbDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gc2VsZltpXTtcblxuICAgICAgYWRkKCBlbGUgKTtcbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gcmVtb3ZlRWRnZVJlZihub2RlLCBlZGdlKXtcbiAgICAgIHZhciBjb25uZWN0ZWRFZGdlcyA9IG5vZGUuX3ByaXZhdGUuZWRnZXM7XG4gICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGNvbm5lY3RlZEVkZ2VzLmxlbmd0aDsgaisrICl7XG4gICAgICAgIHZhciBjb25uZWN0ZWRFZGdlID0gY29ubmVjdGVkRWRnZXNbal07XG4gICAgICAgIFxuICAgICAgICBpZiggZWRnZSA9PT0gY29ubmVjdGVkRWRnZSApe1xuICAgICAgICAgIGNvbm5lY3RlZEVkZ2VzLnNwbGljZSggaiwgMSApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlQ2hpbGRSZWYocGFyZW50LCBlbGUpe1xuICAgICAgZWxlID0gZWxlWzBdO1xuICAgICAgcGFyZW50ID0gcGFyZW50WzBdO1xuICAgICAgdmFyIGNoaWxkcmVuID0gcGFyZW50Ll9wcml2YXRlLmNoaWxkcmVuO1xuXG4gICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGNoaWxkcmVuLmxlbmd0aDsgaisrICl7XG4gICAgICAgIGlmKCBjaGlsZHJlbltqXVswXSA9PT0gZWxlWzBdICl7XG4gICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGosIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzVG9SZW1vdmUubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSBlbGVzVG9SZW1vdmVbaV07XG5cbiAgICAgIC8vIG1hcmsgYXMgcmVtb3ZlZFxuICAgICAgZWxlLl9wcml2YXRlLnJlbW92ZWQgPSB0cnVlO1xuXG4gICAgICAvLyByZW1vdmUgZnJvbSBjb3JlIHBvb2xcbiAgICAgIGN5LnJlbW92ZUZyb21Qb29sKCBlbGUgKTtcblxuICAgICAgLy8gYWRkIHRvIGxpc3Qgb2YgcmVtb3ZlZCBlbGVtZW50c1xuICAgICAgcmVtb3ZlZC5wdXNoKCBlbGUgKTtcblxuICAgICAgaWYoIGVsZS5pc0VkZ2UoKSApeyAvLyByZW1vdmUgcmVmZXJlbmNlcyB0byB0aGlzIGVkZ2UgaW4gaXRzIGNvbm5lY3RlZCBub2Rlc1xuICAgICAgICB2YXIgc3JjID0gZWxlLnNvdXJjZSgpWzBdO1xuICAgICAgICB2YXIgdGd0ID0gZWxlLnRhcmdldCgpWzBdO1xuXG4gICAgICAgIHJlbW92ZUVkZ2VSZWYoIHNyYywgZWxlICk7XG4gICAgICAgIHJlbW92ZUVkZ2VSZWYoIHRndCwgZWxlICk7XG5cbiAgICAgIH0gZWxzZSB7IC8vIHJlbW92ZSByZWZlcmVuY2UgdG8gcGFyZW50IFxuICAgICAgICB2YXIgcGFyZW50ID0gZWxlLnBhcmVudCgpO1xuXG4gICAgICAgIGlmKCBwYXJlbnQubGVuZ3RoICE9PSAwICl7XG4gICAgICAgICAgcmVtb3ZlQ2hpbGRSZWYocGFyZW50LCBlbGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSBjb21wb3VuZCBncmFwaCBvciBub3RcbiAgICB2YXIgZWxlc1N0aWxsSW5zaWRlID0gY3kuX3ByaXZhdGUuZWxlbWVudHM7XG4gICAgY3kuX3ByaXZhdGUuaGFzQ29tcG91bmROb2RlcyA9IGZhbHNlO1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlc1N0aWxsSW5zaWRlLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gZWxlc1N0aWxsSW5zaWRlW2ldO1xuXG4gICAgICBpZiggZWxlLmlzUGFyZW50KCkgKXtcbiAgICAgICAgY3kuX3ByaXZhdGUuaGFzQ29tcG91bmROb2RlcyA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZW1vdmVkRWxlbWVudHMgPSBuZXcgJCQuQ29sbGVjdGlvbiggdGhpcy5jeSgpLCByZW1vdmVkICk7XG4gICAgaWYoIHJlbW92ZWRFbGVtZW50cy5zaXplKCkgPiAwICl7XG4gICAgICAvLyBtdXN0IG1hbnVhbGx5IG5vdGlmeSBzaW5jZSB0cmlnZ2VyIHdvbid0IGRvIHRoaXMgYXV0b21hdGljYWxseSBvbmNlIHJlbW92ZWRcbiAgICAgIFxuICAgICAgaWYoIG5vdGlmeVJlbmRlcmVyICl7XG4gICAgICAgIHRoaXMuY3koKS5ub3RpZnkoe1xuICAgICAgICAgIHR5cGU6ICdyZW1vdmUnLFxuICAgICAgICAgIGNvbGxlY3Rpb246IHJlbW92ZWRFbGVtZW50c1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmVtb3ZlZEVsZW1lbnRzLnRyaWdnZXIoJ3JlbW92ZScpO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGZvciBlbXB0eSByZW1haW5pbmcgcGFyZW50IG5vZGVzXG4gICAgdmFyIGNoZWNrZWRQYXJlbnRJZCA9IHt9O1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlc1RvUmVtb3ZlLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gZWxlc1RvUmVtb3ZlW2ldO1xuICAgICAgdmFyIGlzTm9kZSA9IGVsZS5fcHJpdmF0ZS5ncm91cCA9PT0gJ25vZGVzJztcbiAgICAgIHZhciBwYXJlbnRJZCA9IGVsZS5fcHJpdmF0ZS5kYXRhLnBhcmVudDtcblxuICAgICAgaWYoIGlzTm9kZSAmJiBwYXJlbnRJZCAhPT0gdW5kZWZpbmVkICYmICFjaGVja2VkUGFyZW50SWRbIHBhcmVudElkIF0gKXtcbiAgICAgICAgY2hlY2tlZFBhcmVudElkWyBwYXJlbnRJZCBdID0gdHJ1ZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IGN5LmdldEVsZW1lbnRCeUlkKCBwYXJlbnRJZCApO1xuXG4gICAgICAgIGlmKCBwYXJlbnQgJiYgcGFyZW50Lmxlbmd0aCAhPT0gMCAmJiAhcGFyZW50Ll9wcml2YXRlLnJlbW92ZWQgJiYgcGFyZW50LmNoaWxkcmVuKCkubGVuZ3RoID09PSAwICl7XG4gICAgICAgICAgcGFyZW50LnVwZGF0ZVN0eWxlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAkJC5lbGVzZm4ubW92ZSA9IGZ1bmN0aW9uKCBzdHJ1Y3QgKXtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgaWYoIHN0cnVjdC5zb3VyY2UgIT09IHVuZGVmaW5lZCB8fCBzdHJ1Y3QudGFyZ2V0ICE9PSB1bmRlZmluZWQgKXtcbiAgICAgIHZhciBzcmNJZCA9IHN0cnVjdC5zb3VyY2U7XG4gICAgICB2YXIgdGd0SWQgPSBzdHJ1Y3QudGFyZ2V0O1xuICAgICAgdmFyIHNyY0V4aXN0cyA9IGN5LmdldEVsZW1lbnRCeUlkKCBzcmNJZCApLmxlbmd0aCA+IDA7XG4gICAgICB2YXIgdGd0RXhpc3RzID0gY3kuZ2V0RWxlbWVudEJ5SWQoIHRndElkICkubGVuZ3RoID4gMDtcblxuICAgICAgaWYoIHNyY0V4aXN0cyB8fCB0Z3RFeGlzdHMgKXtcbiAgICAgICAgdmFyIGpzb25zID0gdGhpcy5qc29ucygpO1xuXG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBqc29ucy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBqc29uID0ganNvbnNbaV07XG5cbiAgICAgICAgICBpZigganNvbi5ncm91cCA9PT0gJ2VkZ2VzJyApe1xuICAgICAgICAgICAgaWYoIHNyY0V4aXN0cyApeyBqc29uLmRhdGEuc291cmNlID0gc3JjSWQ7IH1cbiAgICAgICAgICAgIGlmKCB0Z3RFeGlzdHMgKXsganNvbi5kYXRhLnRhcmdldCA9IHRndElkOyB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGN5LmFkZCgganNvbnMgKTtcbiAgICAgIH1cbiBcbiAgICB9IGVsc2UgaWYoIHN0cnVjdC5wYXJlbnQgIT09IHVuZGVmaW5lZCApeyAvLyBtb3ZlIG5vZGUgdG8gbmV3IHBhcmVudFxuICAgICAgdmFyIHBhcmVudElkID0gc3RydWN0LnBhcmVudDtcbiAgICAgIHZhciBwYXJlbnRFeGlzdHMgPSBwYXJlbnRJZCA9PT0gbnVsbCB8fCBjeS5nZXRFbGVtZW50QnlJZCggcGFyZW50SWQgKS5sZW5ndGggPiAwO1xuICAgIFxuICAgICAgaWYoIHBhcmVudEV4aXN0cyApe1xuICAgICAgICB2YXIganNvbnMgPSB0aGlzLmpzb25zKCk7XG4gICAgICAgIHZhciBkZXNjcyA9IHRoaXMuZGVzY2VuZGFudHMoKTtcbiAgICAgICAgdmFyIGRlc2NzRXRjID0gZGVzY3MubWVyZ2UoIGRlc2NzLmFkZCh0aGlzKS5jb25uZWN0ZWRFZGdlcygpICk7XG5cbiAgICAgICAgdGhpcy5yZW1vdmUoKTsgLy8gTkI6IGFsc28gcmVtb3ZlcyBkZXNjZW5kYW50cyBhbmQgdGhlaXIgY29ubmVjdGVkIGVkZ2VzXG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGpzb24gPSBqc29uc1tpXTtcblxuICAgICAgICAgIGlmKCBqc29uLmdyb3VwID09PSAnbm9kZXMnICl7XG4gICAgICAgICAgICBqc29uLmRhdGEucGFyZW50ID0gcGFyZW50SWQgPT09IG51bGwgPyB1bmRlZmluZWQgOiBwYXJlbnRJZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGN5LmFkZCgganNvbnMgKS5tZXJnZSggZGVzY3NFdGMucmVzdG9yZSgpICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGlmIG5vdGhpbmcgZG9uZVxuICB9O1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIHNlYXJjaCwgc3Bhbm5pbmcgdHJlZXMsIGV0Y1xuICAkJC5mbi5lbGVzKHtcblxuICAgIC8vIHN0ZCBmdW5jdGlvbmFsIGVsZSBmaXJzdCBjYWxsYmFjayBzdHlsZVxuICAgIHN0ZEJyZWFkdGhGaXJzdFNlYXJjaDogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICAgIG9wdGlvbnMgPSAkJC51dGlsLmV4dGVuZCgge30sIG9wdGlvbnMsIHtcbiAgICAgICAgc3RkOiB0cnVlXG4gICAgICB9ICk7XG5cbiAgICAgIHJldHVybiB0aGlzLmJyZWFkdGhGaXJzdFNlYXJjaCggb3B0aW9ucyApO1xuICAgIH0sXG5cbiAgICAvLyBkbyBhIGJyZWFkdGggZmlyc3Qgc2VhcmNoIGZyb20gdGhlIG5vZGVzIGluIHRoZSBjb2xsZWN0aW9uXG4gICAgLy8gZnJvbSBwc2V1ZG9jb2RlIG9uIHdpa2lwZWRpYVxuICAgIGJyZWFkdGhGaXJzdFNlYXJjaDogZnVuY3Rpb24oIHJvb3RzLCBmbiwgZGlyZWN0ZWQgKXtcbiAgICAgIHZhciBvcHRpb25zO1xuICAgICAgdmFyIHN0ZDtcbiAgICAgIHZhciB0aGlzQXJnO1xuICAgICAgaWYoICQkLmlzLnBsYWluT2JqZWN0KHJvb3RzKSAmJiAhJCQuaXMuZWxlbWVudE9yQ29sbGVjdGlvbihyb290cykgKXtcbiAgICAgICAgb3B0aW9ucyA9IHJvb3RzO1xuICAgICAgICByb290cyA9IG9wdGlvbnMucm9vdHM7XG4gICAgICAgIGZuID0gb3B0aW9ucy52aXNpdDtcbiAgICAgICAgZGlyZWN0ZWQgPSBvcHRpb25zLmRpcmVjdGVkO1xuICAgICAgICBzdGQgPSBvcHRpb25zLnN0ZDtcbiAgICAgICAgdGhpc0FyZyA9IG9wdGlvbnMudGhpc0FyZztcbiAgICAgIH1cblxuICAgICAgZGlyZWN0ZWQgPSBhcmd1bWVudHMubGVuZ3RoID09PSAyICYmICEkJC5pcy5mbihmbikgPyBmbiA6IGRpcmVjdGVkO1xuICAgICAgZm4gPSAkJC5pcy5mbihmbikgPyBmbiA6IGZ1bmN0aW9uKCl7fTtcbiAgICAgIFxuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICAgIHZhciB2ID0gJCQuaXMuc3RyaW5nKHJvb3RzKSA/IHRoaXMuZmlsdGVyKHJvb3RzKSA6IHJvb3RzO1xuICAgICAgdmFyIFEgPSBbXTtcbiAgICAgIHZhciBjb25uZWN0ZWROb2RlcyA9IFtdO1xuICAgICAgdmFyIGNvbm5lY3RlZEJ5ID0ge307XG4gICAgICB2YXIgaWQyZGVwdGggPSB7fTtcbiAgICAgIHZhciBWID0ge307XG4gICAgICB2YXIgaiA9IDA7XG4gICAgICB2YXIgZm91bmQ7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCk7XG5cbiAgICAgIC8vIGVucXVldWUgdlxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgaSsrICl7XG4gICAgICAgIGlmKCB2W2ldLmlzTm9kZSgpICl7XG4gICAgICAgICAgUS51bnNoaWZ0KCB2W2ldICk7XG4gICAgICAgICAgVlsgdltpXS5pZCgpIF0gPSB0cnVlOyBcblxuICAgICAgICAgIGNvbm5lY3RlZE5vZGVzLnB1c2goIHZbaV0gKTtcbiAgICAgICAgICBpZDJkZXB0aFsgdltpXS5pZCgpIF0gPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHdoaWxlKCBRLmxlbmd0aCAhPT0gMCApe1xuICAgICAgICB2YXIgdiA9IFEuc2hpZnQoKTtcbiAgICAgICAgdmFyIGRlcHRoID0gaWQyZGVwdGhbIHYuaWQoKSBdO1xuICAgICAgICB2YXIgcHJldkVkZ2UgPSBjb25uZWN0ZWRCeVsgdi5pZCgpIF07XG4gICAgICAgIHZhciBwcmV2Tm9kZSA9IHByZXZFZGdlID09IG51bGwgPyB1bmRlZmluZWQgOiBwcmV2RWRnZS5jb25uZWN0ZWROb2RlcygpLm5vdCggdiApWzBdO1xuICAgICAgICB2YXIgcmV0O1xuXG4gICAgICAgIGlmKCBzdGQgKXtcbiAgICAgICAgICByZXQgPSBmbi5jYWxsKHRoaXNBcmcsIHYsIHByZXZFZGdlLCBwcmV2Tm9kZSwgaisrLCBkZXB0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0ID0gZm4uY2FsbCh2LCBqKyssIGRlcHRoLCB2LCBwcmV2RWRnZSwgcHJldk5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIHJldCA9PT0gdHJ1ZSApe1xuICAgICAgICAgIGZvdW5kID0gdjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCByZXQgPT09IGZhbHNlICl7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdndFZGdlcyA9IHYuY29ubmVjdGVkRWRnZXMoZGlyZWN0ZWQgPyBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5kYXRhKCdzb3VyY2UnKSA9PT0gdi5pZCgpOyB9IDogdW5kZWZpbmVkKS5pbnRlcnNlY3QoIGVkZ2VzICk7XG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdndFZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlID0gdndFZGdlc1tpXTtcbiAgICAgICAgICB2YXIgdyA9IGUuY29ubmVjdGVkTm9kZXMoZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuaWQoKSAhPT0gdi5pZCgpOyB9KS5pbnRlcnNlY3QoIG5vZGVzICk7XG5cbiAgICAgICAgICBpZiggdy5sZW5ndGggIT09IDAgJiYgIVZbIHcuaWQoKSBdICl7XG4gICAgICAgICAgICB3ID0gd1swXTtcblxuICAgICAgICAgICAgUS5wdXNoKCB3ICk7XG4gICAgICAgICAgICBWWyB3LmlkKCkgXSA9IHRydWU7XG5cbiAgICAgICAgICAgIGlkMmRlcHRoWyB3LmlkKCkgXSA9IGlkMmRlcHRoWyB2LmlkKCkgXSArIDE7XG5cbiAgICAgICAgICAgIGNvbm5lY3RlZE5vZGVzLnB1c2goIHcgKTtcbiAgICAgICAgICAgIGNvbm5lY3RlZEJ5WyB3LmlkKCkgXSA9IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgfVxuXG4gICAgICB2YXIgY29ubmVjdGVkRWxlcyA9IFtdO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNvbm5lY3RlZE5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBub2RlID0gY29ubmVjdGVkTm9kZXNbaV07XG4gICAgICAgIHZhciBlZGdlID0gY29ubmVjdGVkQnlbIG5vZGUuaWQoKSBdO1xuXG4gICAgICAgIGlmKCBlZGdlICl7XG4gICAgICAgICAgY29ubmVjdGVkRWxlcy5wdXNoKCBlZGdlICk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25uZWN0ZWRFbGVzLnB1c2goIG5vZGUgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aDogbmV3ICQkLkNvbGxlY3Rpb24oIGN5LCBjb25uZWN0ZWRFbGVzLCB7IHVuaXF1ZTogdHJ1ZSB9ICksXG4gICAgICAgIGZvdW5kOiBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIGZvdW5kLCB7IHVuaXF1ZTogdHJ1ZSB9IClcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8vIHN0ZCBmdW5jdGlvbmFsIGVsZSBmaXJzdCBjYWxsYmFjayBzdHlsZVxuICAgIHN0ZERlcHRoRmlyc3RTZWFyY2g6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgICBvcHRpb25zID0gJCQudXRpbC5leHRlbmQoIHt9LCBvcHRpb25zLCB7XG4gICAgICAgIHN0ZDogdHJ1ZVxuICAgICAgfSApO1xuXG4gICAgICByZXR1cm4gdGhpcy5kZXB0aEZpcnN0U2VhcmNoKCBvcHRpb25zICk7XG4gICAgfSxcblxuICAgIC8vIGRvIGEgZGVwdGggZmlyc3Qgc2VhcmNoIG9uIHRoZSBub2RlcyBpbiB0aGUgY29sbGVjdGlvblxuICAgIC8vIGZyb20gcHNldWRvY29kZSBvbiB3aWtpcGVkaWEgKGl0ZXJhdGl2ZSBpbXBsKVxuICAgIGRlcHRoRmlyc3RTZWFyY2g6IGZ1bmN0aW9uKCByb290cywgZm4sIGRpcmVjdGVkICl7XG4gICAgICB2YXIgb3B0aW9ucztcbiAgICAgIHZhciBzdGQ7XG4gICAgICB2YXIgdGhpc0FyZztcbiAgICAgIGlmKCAkJC5pcy5wbGFpbk9iamVjdChyb290cykgJiYgISQkLmlzLmVsZW1lbnRPckNvbGxlY3Rpb24ocm9vdHMpICl7XG4gICAgICAgIG9wdGlvbnMgPSByb290cztcbiAgICAgICAgcm9vdHMgPSBvcHRpb25zLnJvb3RzO1xuICAgICAgICBmbiA9IG9wdGlvbnMudmlzaXQ7XG4gICAgICAgIGRpcmVjdGVkID0gb3B0aW9ucy5kaXJlY3RlZDtcbiAgICAgICAgc3RkID0gb3B0aW9ucy5zdGQ7XG4gICAgICAgIHRoaXNBcmcgPSBvcHRpb25zLnRoaXNBcmc7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGRpcmVjdGVkID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiAhJCQuaXMuZm4oZm4pID8gZm4gOiBkaXJlY3RlZDtcbiAgICAgIGZuID0gJCQuaXMuZm4oZm4pID8gZm4gOiBmdW5jdGlvbigpe307XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgICAgdmFyIHYgPSAkJC5pcy5zdHJpbmcocm9vdHMpID8gdGhpcy5maWx0ZXIocm9vdHMpIDogcm9vdHM7XG4gICAgICB2YXIgUyA9IFtdO1xuICAgICAgdmFyIGNvbm5lY3RlZE5vZGVzID0gW107XG4gICAgICB2YXIgY29ubmVjdGVkQnkgPSB7fTtcbiAgICAgIHZhciBpZDJkZXB0aCA9IHt9O1xuICAgICAgdmFyIGRpc2NvdmVyZWQgPSB7fTtcbiAgICAgIHZhciBqID0gMDtcbiAgICAgIHZhciBmb3VuZDtcbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuZWRnZXMoKTtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcblxuICAgICAgLy8gcHVzaCB2XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHYubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgaWYoIHZbaV0uaXNOb2RlKCkgKXtcbiAgICAgICAgICBTLnB1c2goIHZbaV0gKTtcblxuICAgICAgICAgIGNvbm5lY3RlZE5vZGVzLnB1c2goIHZbaV0gKTtcbiAgICAgICAgICBpZDJkZXB0aFsgdltpXS5pZCgpIF0gPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHdoaWxlKCBTLmxlbmd0aCAhPT0gMCApe1xuICAgICAgICB2YXIgdiA9IFMucG9wKCk7XG5cbiAgICAgICAgaWYoICFkaXNjb3ZlcmVkWyB2LmlkKCkgXSApe1xuICAgICAgICAgIGRpc2NvdmVyZWRbIHYuaWQoKSBdID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBkZXB0aCA9IGlkMmRlcHRoWyB2LmlkKCkgXTtcbiAgICAgICAgICB2YXIgcHJldkVkZ2UgPSBjb25uZWN0ZWRCeVsgdi5pZCgpIF07XG4gICAgICAgICAgdmFyIHByZXZOb2RlID0gcHJldkVkZ2UgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHByZXZFZGdlLmNvbm5lY3RlZE5vZGVzKCkubm90KCB2IClbMF07XG4gICAgICAgICAgdmFyIHJldDtcblxuICAgICAgICAgIGlmKCBzdGQgKXtcbiAgICAgICAgICAgIHJldCA9IGZuLmNhbGwodGhpc0FyZywgdiwgcHJldkVkZ2UsIHByZXZOb2RlLCBqKyssIGRlcHRoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0ID0gZm4uY2FsbCh2LCBqKyssIGRlcHRoLCB2LCBwcmV2RWRnZSwgcHJldk5vZGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCByZXQgPT09IHRydWUgKXtcbiAgICAgICAgICAgIGZvdW5kID0gdjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCByZXQgPT09IGZhbHNlICl7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdndFZGdlcyA9IHYuY29ubmVjdGVkRWRnZXMoZGlyZWN0ZWQgPyBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5kYXRhKCdzb3VyY2UnKSA9PT0gdi5pZCgpOyB9IDogdW5kZWZpbmVkKS5pbnRlcnNlY3QoIGVkZ2VzICk7XG4gICAgICAgICAgXG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB2d0VkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICB2YXIgZSA9IHZ3RWRnZXNbaV07XG4gICAgICAgICAgICB2YXIgdyA9IGUuY29ubmVjdGVkTm9kZXMoZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuaWQoKSAhPT0gdi5pZCgpOyB9KS5pbnRlcnNlY3QoIG5vZGVzICk7XG5cbiAgICAgICAgICAgIGlmKCB3Lmxlbmd0aCAhPT0gMCAmJiAhZGlzY292ZXJlZFsgdy5pZCgpIF0gKXtcbiAgICAgICAgICAgICAgdyA9IHdbMF07XG5cbiAgICAgICAgICAgICAgUy5wdXNoKCB3ICk7XG5cbiAgICAgICAgICAgICAgaWQyZGVwdGhbIHcuaWQoKSBdID0gaWQyZGVwdGhbIHYuaWQoKSBdICsgMTtcblxuICAgICAgICAgICAgICBjb25uZWN0ZWROb2Rlcy5wdXNoKCB3ICk7XG4gICAgICAgICAgICAgIGNvbm5lY3RlZEJ5WyB3LmlkKCkgXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjb25uZWN0ZWRFbGVzID0gW107XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY29ubmVjdGVkTm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIG5vZGUgPSBjb25uZWN0ZWROb2Rlc1tpXTtcbiAgICAgICAgdmFyIGVkZ2UgPSBjb25uZWN0ZWRCeVsgbm9kZS5pZCgpIF07XG5cbiAgICAgICAgaWYoIGVkZ2UgKXtcbiAgICAgICAgICBjb25uZWN0ZWRFbGVzLnB1c2goIGVkZ2UgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbm5lY3RlZEVsZXMucHVzaCggbm9kZSApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRoOiBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIGNvbm5lY3RlZEVsZXMsIHsgdW5pcXVlOiB0cnVlIH0gKSxcbiAgICAgICAgZm91bmQ6IG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgZm91bmQsIHsgdW5pcXVlOiB0cnVlIH0gKVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLy8ga3J1c2thbCdzIGFsZ29yaXRobSAoZmluZHMgbWluIHNwYW5uaW5nIHRyZWUsIGFzc3VtaW5nIHVuZGlyZWN0ZWQgZ3JhcGgpXG4gICAgLy8gaW1wbGVtZW50ZWQgZnJvbSBwc2V1ZG9jb2RlIGZyb20gd2lraXBlZGlhXG4gICAga3J1c2thbDogZnVuY3Rpb24oIHdlaWdodEZuICl7XG4gICAgICB3ZWlnaHRGbiA9ICQkLmlzLmZuKHdlaWdodEZuKSA/IHdlaWdodEZuIDogZnVuY3Rpb24oKXsgcmV0dXJuIDE7IH07IC8vIGlmIG5vdCBzcGVjaWZpZWQsIGFzc3VtZSBlYWNoIGVkZ2UgaGFzIGVxdWFsIHdlaWdodCAoMSlcblxuICAgICAgZnVuY3Rpb24gZmluZFNldChlbGUpe1xuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGZvcmVzdC5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlbGVzID0gZm9yZXN0W2ldO1xuXG4gICAgICAgICAgaWYoIGVsZXMuYW55U2FtZShlbGUpICl7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBlbGVzOiBlbGVzLFxuICAgICAgICAgICAgICBpbmRleDogaVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIEEgPSBuZXcgJCQuQ29sbGVjdGlvbih0aGlzLl9wcml2YXRlLmN5LCBbXSk7XG4gICAgICB2YXIgZm9yZXN0ID0gW107XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgZm9yZXN0LnB1c2goIG5vZGVzW2ldLmNvbGxlY3Rpb24oKSApO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCk7XG4gICAgICB2YXIgUyA9IGVkZ2VzLnRvQXJyYXkoKS5zb3J0KGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgICB2YXIgd2VpZ2h0QSA9IHdlaWdodEZuLmNhbGwoYSwgYSk7XG4gICAgICAgIHZhciB3ZWlnaHRCID0gd2VpZ2h0Rm4uY2FsbChiLCBiKTtcblxuICAgICAgICByZXR1cm4gd2VpZ2h0QSAtIHdlaWdodEI7XG4gICAgICB9KTtcblxuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IFMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZWRnZSA9IFNbaV07XG4gICAgICAgIHZhciB1ID0gZWRnZS5zb3VyY2UoKVswXTtcbiAgICAgICAgdmFyIHYgPSBlZGdlLnRhcmdldCgpWzBdO1xuICAgICAgICB2YXIgc2V0VSA9IGZpbmRTZXQodSk7XG4gICAgICAgIHZhciBzZXRWID0gZmluZFNldCh2KTtcblxuICAgICAgICBpZiggc2V0VS5pbmRleCAhPT0gc2V0Vi5pbmRleCApe1xuICAgICAgICAgIEEgPSBBLmFkZCggZWRnZSApO1xuXG4gICAgICAgICAgLy8gY29tYmluZSBmb3Jlc3RzIGZvciB1IGFuZCB2XG4gICAgICAgICAgZm9yZXN0WyBzZXRVLmluZGV4IF0gPSBzZXRVLmVsZXMuYWRkKCBzZXRWLmVsZXMgKTtcbiAgICAgICAgICBmb3Jlc3Quc3BsaWNlKCBzZXRWLmluZGV4LCAxICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGVzLmFkZCggQSApO1xuXG4gICAgfSxcblxuICAgIGRpamtzdHJhOiBmdW5jdGlvbiggcm9vdCwgd2VpZ2h0Rm4sIGRpcmVjdGVkICl7XG4gICAgICB2YXIgb3B0aW9ucztcbiAgICAgIGlmKCAkJC5pcy5wbGFpbk9iamVjdChyb290KSAmJiAhJCQuaXMuZWxlbWVudE9yQ29sbGVjdGlvbihyb290KSApe1xuICAgICAgICBvcHRpb25zID0gcm9vdDtcbiAgICAgICAgcm9vdCA9IG9wdGlvbnMucm9vdDtcbiAgICAgICAgd2VpZ2h0Rm4gPSBvcHRpb25zLndlaWdodDtcbiAgICAgICAgZGlyZWN0ZWQgPSBvcHRpb25zLmRpcmVjdGVkO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgICAgd2VpZ2h0Rm4gPSAkJC5pcy5mbih3ZWlnaHRGbikgPyB3ZWlnaHRGbiA6IGZ1bmN0aW9uKCl7IHJldHVybiAxOyB9OyAvLyBpZiBub3Qgc3BlY2lmaWVkLCBhc3N1bWUgZWFjaCBlZGdlIGhhcyBlcXVhbCB3ZWlnaHQgKDEpXG5cbiAgICAgIHZhciBzb3VyY2UgPSAkJC5pcy5zdHJpbmcocm9vdCkgPyB0aGlzLmZpbHRlcihyb290KVswXSA6IHJvb3RbMF07XG4gICAgICB2YXIgZGlzdCA9IHt9O1xuICAgICAgdmFyIHByZXYgPSB7fTtcbiAgICAgIHZhciBrbm93bkRpc3QgPSB7fTtcblxuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcygpLmZpbHRlcihmdW5jdGlvbigpeyByZXR1cm4gIXRoaXMuaXNMb29wKCk7IH0pO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgICAgdmFyIFEgPSBbXTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICBkaXN0WyBub2Rlc1tpXS5pZCgpIF0gPSBub2Rlc1tpXS5zYW1lKCBzb3VyY2UgKSA/IDAgOiBJbmZpbml0eTtcbiAgICAgICAgUS5wdXNoKCBub2Rlc1tpXSApO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWVGbiA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGRpc3RbIG5vZGUuaWQoKSBdO1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgUSA9IG5ldyAkJC5Db2xsZWN0aW9uKGN5LCBRKTtcbiAgICBcbiAgICAgIHZhciBoZWFwID0gJCQuTWluaGVhcChjeSwgUSwgdmFsdWVGbik7XG4gICAgXG4gICAgICB2YXIgZGlzdEJldHdlZW4gPSBmdW5jdGlvbih1LCB2KXtcbiAgICAgICAgdmFyIHV2cyA9ICggZGlyZWN0ZWQgPyB1LmVkZ2VzVG8odikgOiB1LmVkZ2VzV2l0aCh2KSApLmludGVyc2VjdChlZGdlcyk7XG4gICAgICAgIHZhciBzbWFsbGVzdERpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgICAgIHZhciBzbWFsbGVzdEVkZ2U7XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB1dnMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZWRnZSA9IHV2c1tpXTtcbiAgICAgICAgICB2YXIgd2VpZ2h0ID0gd2VpZ2h0Rm4uYXBwbHkoIGVkZ2UsIFtlZGdlXSApO1xuXG4gICAgICAgICAgaWYoIHdlaWdodCA8IHNtYWxsZXN0RGlzdGFuY2UgfHwgIXNtYWxsZXN0RWRnZSApe1xuICAgICAgICAgICAgc21hbGxlc3REaXN0YW5jZSA9IHdlaWdodDtcbiAgICAgICAgICAgIHNtYWxsZXN0RWRnZSA9IGVkZ2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBlZGdlOiBzbWFsbGVzdEVkZ2UsXG4gICAgICAgICAgZGlzdDogc21hbGxlc3REaXN0YW5jZVxuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgd2hpbGUoaGVhcC5zaXplKCkgPiAwKXtcbiAgICAgICAgdmFyIHNtYWxsZXN0RWwgPSBoZWFwLnBvcCgpLFxuICAgICAgICBzbWFsbGV0c0Rpc3QgPSBzbWFsbGVzdEVsLnZhbHVlLFxuICAgICAgICB1aWQgPSBzbWFsbGVzdEVsLmlkLFxuICAgICAgICB1ID0gY3kuZ2V0RWxlbWVudEJ5SWQodWlkKTtcbiAgICBcbiAgICAgICAga25vd25EaXN0W3VpZF0gPSBzbWFsbGV0c0Rpc3Q7XG4gICAgICBcbiAgICAgICAgaWYoIHNtYWxsZXRzRGlzdCA9PT0gTWF0aC5JbmZpbml0ZSApe1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5laWdoYm9ycyA9IHUubmVpZ2hib3Job29kKCkuaW50ZXJzZWN0KG5vZGVzKTtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBuZWlnaGJvcnMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgdiA9IG5laWdoYm9yc1tpXTtcbiAgICAgICAgICB2YXIgdmlkID0gdi5pZCgpO1xuICAgICAgICAgIHZhciB2RGlzdCA9IGRpc3RCZXR3ZWVuKHUsIHYpO1xuXG4gICAgICAgICAgdmFyIGFsdCA9IHNtYWxsZXRzRGlzdCArIHZEaXN0LmRpc3Q7XG5cbiAgICAgICAgICBpZiggYWx0IDwgaGVhcC5nZXRWYWx1ZUJ5SWQodmlkKSApe1xuICAgICAgICAgICAgaGVhcC5lZGl0KHZpZCwgYWx0KTtcbiAgICAgICAgICAgIHByZXZbIHZpZCBdID0ge1xuICAgICAgICAgICAgICBub2RlOiB1LFxuICAgICAgICAgICAgICBlZGdlOiB2RGlzdC5lZGdlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBmb3IgXG4gICAgICB9IC8vIHdoaWxlXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpc3RhbmNlVG86IGZ1bmN0aW9uKG5vZGUpe1xuICAgICAgICAgIHZhciB0YXJnZXQgPSAkJC5pcy5zdHJpbmcobm9kZSkgPyBub2Rlcy5maWx0ZXIobm9kZSlbMF0gOiBub2RlWzBdO1xuXG4gICAgICAgICAgcmV0dXJuIGtub3duRGlzdFsgdGFyZ2V0LmlkKCkgXTtcbiAgICAgICAgfSxcblxuICAgICAgICBwYXRoVG86IGZ1bmN0aW9uKG5vZGUpe1xuICAgICAgICAgIHZhciB0YXJnZXQgPSAkJC5pcy5zdHJpbmcobm9kZSkgPyBub2Rlcy5maWx0ZXIobm9kZSlbMF0gOiBub2RlWzBdO1xuICAgICAgICAgIHZhciBTID0gW107XG4gICAgICAgICAgdmFyIHUgPSB0YXJnZXQ7XG5cbiAgICAgICAgICBpZiggdGFyZ2V0Lmxlbmd0aCA+IDAgKXtcbiAgICAgICAgICAgIFMudW5zaGlmdCggdGFyZ2V0ICk7XG5cbiAgICAgICAgICAgIHdoaWxlKCBwcmV2WyB1LmlkKCkgXSApe1xuICAgICAgICAgICAgICB2YXIgcCA9IHByZXZbIHUuaWQoKSBdO1xuXG4gICAgICAgICAgICAgIFMudW5zaGlmdCggcC5lZGdlICk7XG4gICAgICAgICAgICAgIFMudW5zaGlmdCggcC5ub2RlICk7XG5cbiAgICAgICAgICAgICAgdSA9IHAubm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIGN5LCBTICk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSAgXG4gIH0pO1xuXG4gIC8vIG5pY2UsIHNob3J0IG1hdGhlbWF0aGljYWwgYWxpYXNcbiAgJCQuZWxlc2ZuLmJmcyA9ICQkLmVsZXNmbi5icmVhZHRoRmlyc3RTZWFyY2g7XG4gICQkLmVsZXNmbi5kZnMgPSAkJC5lbGVzZm4uZGVwdGhGaXJzdFNlYXJjaDtcbiAgJCQuZWxlc2ZuLnN0ZEJmcyA9ICQkLmVsZXNmbi5zdGRCcmVhZHRoRmlyc3RTZWFyY2g7XG4gICQkLmVsZXNmbi5zdGREZnMgPSAkJC5lbGVzZm4uc3RkRGVwdGhGaXJzdFNlYXJjaDtcbiAgXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpIHsgXG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBBZGRpdGlvbmFsIGdyYXBoIGFuYWx5c2lzIGFsZ29yaXRobXNcbiAgJCQuZm4uZWxlcyh7XG5cbiAgICAvLyBJbXBsZW1lbnRlZCBmcm9tIHBzZXVkb2NvZGUgZnJvbSB3aWtpcGVkaWFcblxuICAgIC8vIG9wdGlvbnMgPT4gb3B0aW9ucyBvYmplY3RcbiAgICAvLyAgIHJvb3QgLy8gc3RhcnRpbmcgbm9kZSAoZWl0aGVyIGVsZW1lbnQgb3Igc2VsZWN0b3Igc3RyaW5nKVxuICAgIC8vICAgd2VpZ2h0OiBmdW5jdGlvbiggZWRnZSApe30gLy8gc3BlY2lmaWVzIHdlaWdodCB0byB1c2UgZm9yIGBlZGdlYC9gdGhpc2AuIElmIG5vdCBwcmVzZW50LCBpdCB3aWxsIGJlIGFzdW1lZCBhIHdlaWdodCBvZiAxIGZvciBhbGwgZWRnZXNcbiAgICAvLyAgIGhldXJpc3RpYzogZnVuY3Rpb24oIG5vZGUgKXt9IC8vIHNwZWNpZmllcyBoZXVyaXN0aWMgdmFsdWUgZm9yIGBub2RlYC9gdGhpc2BcbiAgICAvLyAgIGRpcmVjdGVkIC8vIGRlZmF1bHQgZmFsc2VcbiAgICAvLyAgIGdvYWwgLy8gdGFyZ2V0IG5vZGUgKGVpdGhlciBlbGVtZW50IG9yIHNlbGVjdG9yIHN0cmluZykuIE1hbmRhdG9yeS5cblxuICAgIC8vIHJldE9iaiA9PiByZXR1cm5lZCBvYmplY3QgYnkgZnVuY3Rpb25cbiAgICAvLyAgIGZvdW5kIDogdHJ1ZS9mYWxzZSAvLyB3aGV0aGVyIGEgcGF0aCBmcm9tIHJvb3QgdG8gZ29hbCBoYXMgYmVlbiBmb3VuZFxuICAgIC8vICAgZGlzdGFuY2UgLy8gRGlzdGFuY2UgZm9yIHRoZSBzaG9ydGVzdCBwYXRoIGZyb20gcm9vdCB0byBnb2FsXG4gICAgLy8gICBwYXRoIC8vIEFycmF5IG9mIGlkcyBvZiBub2RlcyBpbiBzaG9ydGVzdCBwYXRoXG4gICAgYVN0YXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAvLyB2YXIgbG9nRGVidWcgPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vICAgaWYgKGRlYnVnKSB7XG4gICAgICAvLyAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgIC8vICAgfVxuICAgICAgLy8gfTtcblxuICAgICAgLy8gUmVjb25zdHJ1Y3RzIHRoZSBwYXRoIGZyb20gU3RhcnQgdG8gRW5kLCBhY3VtdWxhdGluZyB0aGUgcmVzdWx0IGluIHBhdGhBY3VtXG4gICAgICB2YXIgcmVjb25zdHJ1Y3RQYXRoID0gZnVuY3Rpb24oc3RhcnQsIGVuZCwgY2FtZUZyb21NYXAsIHBhdGhBY3VtKSB7XG4gICAgICAgIC8vIEJhc2UgY2FzZVxuICAgICAgICBpZiAoc3RhcnQgPT0gZW5kKSB7XG4gICAgICAgICAgcGF0aEFjdW0ucHVzaCggY3kuZ2V0RWxlbWVudEJ5SWQoZW5kKSApO1xuICAgICAgICAgIHJldHVybiBwYXRoQWN1bTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKGVuZCBpbiBjYW1lRnJvbU1hcCkge1xuICAgICAgICAgIC8vIFdlIGtub3cgd2hpY2ggbm9kZSBpcyBiZWZvcmUgdGhlIGxhc3Qgb25lXG4gICAgICAgICAgdmFyIHByZXZpb3VzID0gY2FtZUZyb21NYXBbZW5kXTtcbiAgICAgICAgICB2YXIgcHJldmlvdXNFZGdlID0gY2FtZUZyb21FZGdlW2VuZF07XG5cbiAgICAgICAgICBwYXRoQWN1bS5wdXNoKCBjeS5nZXRFbGVtZW50QnlJZChlbmQpICk7XG4gICAgICAgICAgcGF0aEFjdW0ucHVzaCggY3kuZ2V0RWxlbWVudEJ5SWQocHJldmlvdXNFZGdlKSApO1xuXG5cbiAgICAgICAgICByZXR1cm4gcmVjb25zdHJ1Y3RQYXRoKHN0YXJ0LCBcbiAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMsIFxuICAgICAgICAgICAgICAgICAgICAgICBjYW1lRnJvbU1hcCwgXG4gICAgICAgICAgICAgICAgICAgICAgIHBhdGhBY3VtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIHNob3VsZCBub3QgcmVhY2ggaGVyZSFcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDsgICAgICAgXG4gICAgICB9O1xuXG4gICAgICAvLyBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCBpbiBvcGVuU2V0IHdoaWNoIGhhcyBtaW5pbXVtIGZTY29yZVxuICAgICAgdmFyIGZpbmRNaW4gPSBmdW5jdGlvbihvcGVuU2V0LCBmU2NvcmUpIHtcbiAgICAgICAgaWYgKG9wZW5TZXQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgLy8gU2hvdWxkIG5ldmVyIGJlIHRoZSBjYXNlXG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWluUG9zID0gMDtcbiAgICAgICAgdmFyIHRlbXBTY29yZSA9IGZTY29yZVtvcGVuU2V0WzBdXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBvcGVuU2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHMgPSBmU2NvcmVbb3BlblNldFtpXV07XG4gICAgICAgICAgaWYgKHMgPCB0ZW1wU2NvcmUpIHtcbiAgICAgICAgICAgIHRlbXBTY29yZSA9IHM7XG4gICAgICAgICAgICBtaW5Qb3MgPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWluUG9zO1xuICAgICAgfTtcblxuICAgICAgLy8gUGFyc2Ugb3B0aW9uc1xuICAgICAgLy8gZGVidWcgLSBvcHRpb25hbFxuICAgICAgLy8gaWYgKG9wdGlvbnMuZGVidWcgIT0gbnVsbCkge1xuICAgICAgLy8gICB2YXIgZGVidWcgPSBvcHRpb25zLmRlYnVnO1xuICAgICAgLy8gfSBlbHNlIHtcbiAgICAgIC8vICAgdmFyIGRlYnVnID0gZmFsc2U7XG4gICAgICAvLyB9XG5cbiAgICAgIC8vIGxvZ0RlYnVnKFwiU3RhcnRpbmcgYVN0YXIuLi5cIik7IFxuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgICAgLy8gcm9vdCAtIG1hbmRhdG9yeSFcbiAgICAgIGlmIChvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5yb290ICE9IG51bGwpIHsgICAgICAgIFxuICAgICAgICB2YXIgc291cmNlID0gJCQuaXMuc3RyaW5nKG9wdGlvbnMucm9vdCkgPyBcbiAgICAgICAgICAvLyB1c2UgaXQgYXMgYSBzZWxlY3RvciwgZS5nLiBcIiNyb290SURcbiAgICAgICAgICB0aGlzLmZpbHRlcihvcHRpb25zLnJvb3QpWzBdIDogXG4gICAgICAgICAgb3B0aW9ucy5yb290WzBdO1xuICAgICAgICAvLyBsb2dEZWJ1ZyhcIlNvdXJjZSBub2RlOiAlc1wiLCBzb3VyY2UuaWQoKSk7IFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gZ29hbCAtIG1hbmRhdG9yeSFcbiAgICAgIGlmIChvcHRpb25zLmdvYWwgIT0gbnVsbCkgeyAgICAgICBcbiAgICAgICAgdmFyIHRhcmdldCA9ICQkLmlzLnN0cmluZyhvcHRpb25zLmdvYWwpID8gXG4gICAgICAgICAgLy8gdXNlIGl0IGFzIGEgc2VsZWN0b3IsIGUuZy4gXCIjZ29hbElEXG4gICAgICAgICAgdGhpcy5maWx0ZXIob3B0aW9ucy5nb2FsKVswXSA6IFxuICAgICAgICAgIG9wdGlvbnMuZ29hbFswXTtcbiAgICAgICAgLy8gbG9nRGVidWcoXCJUYXJnZXQgbm9kZTogJXNcIiwgdGFyZ2V0LmlkKCkpOyBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIEhldXJpc3RpYyBmdW5jdGlvbiAtIG9wdGlvbmFsXG4gICAgICBpZiAob3B0aW9ucy5oZXVyaXN0aWMgIT0gbnVsbCAmJiAkJC5pcy5mbihvcHRpb25zLmhldXJpc3RpYykpIHsgICAgICAgXG4gICAgICAgIHZhciBoZXVyaXN0aWMgPSBvcHRpb25zLmhldXJpc3RpYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBoZXVyaXN0aWMgPSBmdW5jdGlvbigpeyByZXR1cm4gMDsgfTsgLy8gdXNlIGNvbnN0YW50IGlmIHVuc3BlY2lmaWVkXG4gICAgICAgIC8vICQkLnV0aWwuZXJyb3IoXCJNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAoaGV1cmlzdGljKSEgQWJvcnRpbmcuXCIpO1xuICAgICAgICAvLyByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFdlaWdodCBmdW5jdGlvbiAtIG9wdGlvbmFsXG4gICAgICBpZiAob3B0aW9ucy53ZWlnaHQgIT0gbnVsbCAmJiAkJC5pcy5mbihvcHRpb25zLndlaWdodCkpIHsgICAgICAgXG4gICAgICAgIHZhciB3ZWlnaHRGbiA9IG9wdGlvbnMud2VpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgbm90IHNwZWNpZmllZCwgYXNzdW1lIGVhY2ggZWRnZSBoYXMgZXF1YWwgd2VpZ2h0ICgxKVxuICAgICAgICB2YXIgd2VpZ2h0Rm4gPSBmdW5jdGlvbihlKSB7cmV0dXJuIDE7fTtcbiAgICAgIH1cblxuICAgICAgLy8gZGlyZWN0ZWQgLSBvcHRpb25hbFxuICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0ZWQgIT0gbnVsbCkgeyAgICAgICBcbiAgICAgICAgdmFyIGRpcmVjdGVkID0gb3B0aW9ucy5kaXJlY3RlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkaXJlY3RlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2xvc2VkU2V0ID0gW107XG4gICAgICB2YXIgb3BlblNldCA9IFtzb3VyY2UuaWQoKV07XG4gICAgICB2YXIgY2FtZUZyb20gPSB7fTtcbiAgICAgIHZhciBjYW1lRnJvbUVkZ2UgPSB7fTtcbiAgICAgIHZhciBnU2NvcmUgPSB7fTtcbiAgICAgIHZhciBmU2NvcmUgPSB7fTtcblxuICAgICAgZ1Njb3JlW3NvdXJjZS5pZCgpXSA9IDA7XG4gICAgICBmU2NvcmVbc291cmNlLmlkKCldID0gaGV1cmlzdGljKHNvdXJjZSk7XG4gICAgICBcbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuZWRnZXMoKS5zdGRGaWx0ZXIoZnVuY3Rpb24oZSl7IHJldHVybiAhZS5pc0xvb3AoKTsgfSk7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG5cbiAgICAgIC8vIENvdW50ZXJcbiAgICAgIHZhciBzdGVwcyA9IDA7XG5cbiAgICAgIC8vIE1haW4gbG9vcCBcbiAgICAgIHdoaWxlIChvcGVuU2V0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIG1pblBvcyA9IGZpbmRNaW4ob3BlblNldCwgZlNjb3JlKTtcbiAgICAgICAgdmFyIGNNaW4gPSBjeS5nZXRFbGVtZW50QnlJZCggb3BlblNldFttaW5Qb3NdICk7XG4gICAgICAgIHN0ZXBzKys7XG5cbiAgICAgICAgLy8gbG9nRGVidWcoXCJcXG5TdGVwOiAlc1wiLCBzdGVwcyk7XG4gICAgICAgIC8vIGxvZ0RlYnVnKFwiUHJvY2Vzc2luZyBub2RlOiAlcywgZlNjb3JlID0gJXNcIiwgY01pbi5pZCgpLCBmU2NvcmVbY01pbi5pZCgpXSk7XG4gICAgICAgIFxuICAgICAgICAvLyBJZiB3ZSd2ZSBmb3VuZCBvdXIgZ29hbCwgdGhlbiB3ZSBhcmUgZG9uZVxuICAgICAgICBpZiAoY01pbi5pZCgpID09IHRhcmdldC5pZCgpKSB7XG4gICAgICAgICAgLy8gbG9nRGVidWcoXCJGb3VuZCBnb2FsIG5vZGUhXCIpO1xuICAgICAgICAgIHZhciByUGF0aCA9IHJlY29uc3RydWN0UGF0aChzb3VyY2UuaWQoKSwgdGFyZ2V0LmlkKCksIGNhbWVGcm9tLCBbXSk7XG4gICAgICAgICAgclBhdGgucmV2ZXJzZSgpO1xuICAgICAgICAgIC8vIGxvZ0RlYnVnKFwiUGF0aDogJXNcIiwgclBhdGgpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmb3VuZCA6IHRydWUsXG4gICAgICAgICAgICBkaXN0YW5jZSA6IGdTY29yZVtjTWluLmlkKCldLFxuICAgICAgICAgICAgcGF0aCA6IG5ldyAkJC5Db2xsZWN0aW9uKGN5LCByUGF0aCksXG4gICAgICAgICAgICBzdGVwcyA6IHN0ZXBzXG4gICAgICAgICAgfTsgICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEFkZCBjTWluIHRvIHByb2Nlc3NlZCBub2Rlc1xuICAgICAgICBjbG9zZWRTZXQucHVzaChjTWluLmlkKCkpO1xuICAgICAgICAvLyBSZW1vdmUgY01pbiBmcm9tIGJvdW5kYXJ5IG5vZGVzXG4gICAgICAgIG9wZW5TZXQuc3BsaWNlKG1pblBvcywgMSk7XG4gICAgICAgIC8vIGxvZ0RlYnVnKFwiQWRkZWQgbm9kZSB0byBjbG9zZWRTZXQsIHJlbW92ZWQgZnJvbSBvcGVuU2V0LlwiKTtcbiAgICAgICAgLy8gbG9nRGVidWcoXCJQcm9jZXNzaW5nIG5laWdoYm9ycy4uLlwiKTtcblxuICAgICAgICAvLyBVcGRhdGUgc2NvcmVzIGZvciBuZWlnaGJvcnMgb2YgY01pblxuICAgICAgICAvLyBUYWtlIGludG8gYWNjb3VudCBpZiBncmFwaCBpcyBkaXJlY3RlZCBvciBub3RcbiAgICAgICAgdmFyIHZ3RWRnZXMgPSBjTWluLmNvbm5lY3RlZEVkZ2VzKCk7XG4gICAgICAgIGlmKCBkaXJlY3RlZCApeyB2d0VkZ2VzID0gdndFZGdlcy5zdGRGaWx0ZXIoZnVuY3Rpb24oZWxlKXsgcmV0dXJuIGVsZS5kYXRhKCdzb3VyY2UnKSA9PT0gY01pbi5pZCgpOyB9KTsgfVxuICAgICAgICB2d0VkZ2VzID0gdndFZGdlcy5pbnRlcnNlY3QoZWRnZXMpOyAgXG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZ3RWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZSA9IHZ3RWRnZXNbaV07XG4gICAgICAgICAgdmFyIHcgPSBlLmNvbm5lY3RlZE5vZGVzKCkuc3RkRmlsdGVyKGZ1bmN0aW9uKG4peyByZXR1cm4gbi5pZCgpICE9PSBjTWluLmlkKCk7IH0pLmludGVyc2VjdChub2Rlcyk7XG5cbiAgICAgICAgICAvLyBsb2dEZWJ1ZyhcIiAgIHByb2Nlc3NpbmcgbmVpZ2hib3I6ICVzXCIsIHcuaWQoKSk7XG4gICAgICAgICAgLy8gaWYgbm9kZSBpcyBpbiBjbG9zZWRTZXQsIGlnbm9yZSBpdFxuICAgICAgICAgIGlmIChjbG9zZWRTZXQuaW5kZXhPZih3LmlkKCkpICE9IC0xKSB7XG4gICAgICAgICAgICAvLyBsb2dEZWJ1ZyhcIiAgIGFscmVhZHkgaW4gY2xvc2VkU2V0LCBpZ25vcmluZyBpdC5cIik7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gTmV3IHRlbnRhdGl2ZSBzY29yZSBmb3Igbm9kZSB3XG4gICAgICAgICAgdmFyIHRlbXBTY29yZSA9IGdTY29yZVtjTWluLmlkKCldICsgd2VpZ2h0Rm4uYXBwbHkoZSwgW2VdKTtcbiAgICAgICAgICAvLyBsb2dEZWJ1ZyhcIiAgIHRlbnRhdGl2ZSBnU2NvcmU6ICVkXCIsIHRlbXBTY29yZSk7XG5cbiAgICAgICAgICAvLyBVcGRhdGUgZ1Njb3JlIGZvciBub2RlIHcgaWY6XG4gICAgICAgICAgLy8gICB3IG5vdCBwcmVzZW50IGluIG9wZW5TZXRcbiAgICAgICAgICAvLyBPUlxuICAgICAgICAgIC8vICAgdGVudGF0aXZlIGdTY29yZSBpcyBsZXNzIHRoYW4gcHJldmlvdXMgdmFsdWVcblxuICAgICAgICAgIC8vIHcgbm90IGluIG9wZW5TZXRcbiAgICAgICAgICBpZiAob3BlblNldC5pbmRleE9mKHcuaWQoKSkgPT0gLTEpIHtcbiAgICAgICAgICAgIGdTY29yZVt3LmlkKCldID0gdGVtcFNjb3JlO1xuICAgICAgICAgICAgZlNjb3JlW3cuaWQoKV0gPSB0ZW1wU2NvcmUgKyBoZXVyaXN0aWModyk7XG4gICAgICAgICAgICBvcGVuU2V0LnB1c2gody5pZCgpKTsgLy8gQWRkIG5vZGUgdG8gb3BlblNldFxuICAgICAgICAgICAgY2FtZUZyb21bdy5pZCgpXSA9IGNNaW4uaWQoKTtcbiAgICAgICAgICAgIGNhbWVGcm9tRWRnZVt3LmlkKCldID0gZS5pZCgpO1xuICAgICAgICAgICAgLy8gbG9nRGVidWcoXCIgICBub3QgaW4gb3BlblNldCwgYWRkaW5nIGl0LiBcIik7XG4gICAgICAgICAgICAvLyBsb2dEZWJ1ZyhcIiAgIGZTY29yZSglcykgPSAlc1wiLCB3LmlkKCksIHRlbXBTY29yZSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gdyBhbHJlYWR5IGluIG9wZW5TZXQsIGJ1dCB3aXRoIGdyZWF0ZXIgZ1Njb3JlXG4gICAgICAgICAgaWYgKHRlbXBTY29yZSA8IGdTY29yZVt3LmlkKCldKSB7XG4gICAgICAgICAgICBnU2NvcmVbdy5pZCgpXSA9IHRlbXBTY29yZTtcbiAgICAgICAgICAgIGZTY29yZVt3LmlkKCldID0gdGVtcFNjb3JlICsgaGV1cmlzdGljKHcpO1xuICAgICAgICAgICAgY2FtZUZyb21bdy5pZCgpXSA9IGNNaW4uaWQoKTtcbiAgICAgICAgICAgIC8vIGxvZ0RlYnVnKFwiICAgYmV0dGVyIHNjb3JlLCByZXBsYWNpbmcgZ1Njb3JlLiBcIik7XG4gICAgICAgICAgICAvLyBsb2dEZWJ1ZyhcIiAgIGZTY29yZSglcykgPSAlc1wiLCB3LmlkKCksIHRlbXBTY29yZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gLy8gRW5kIG9mIG5laWdoYm9ycyB1cGRhdGVcblxuICAgICAgfSAvLyBFbmQgb2YgbWFpbiBsb29wXG5cbiAgICAgIC8vIElmIHdlJ3ZlIHJlYWNoZWQgaGVyZSwgdGhlbiB3ZSd2ZSBub3QgcmVhY2hlZCBvdXIgZ29hbFxuICAgICAgLy8gbG9nRGVidWcoXCJSZWFjaGVkIGVuZCBvZiBjb21wdXRhdGlvbiB3aXRob3V0IGZpbmRpbmcgb3VyIGdvYWxcIik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBmb3VuZCA6IGZhbHNlLFxuICAgICAgICBkaXN0YW5jZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgcGF0aCA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3RlcHMgOiBzdGVwc1xuICAgICAgfTtcbiAgICB9LCAvLyBhU3RhcigpXG5cblxuICAgIC8vIEltcGxlbWVudGVkIGZyb20gcHNldWRvY29kZSBmcm9tIHdpa2lwZWRpYVxuICAgIC8vIG9wdGlvbnMgPT4gb3B0aW9ucyBvYmplY3RcbiAgICAvLyAgIHdlaWdodDogZnVuY3Rpb24oIGVkZ2UgKXt9IC8vIHNwZWNpZmllcyB3ZWlnaHQgdG8gdXNlIGZvciBgZWRnZWAvYHRoaXNgLiBJZiBub3QgcHJlc2VudCwgaXQgd2lsbCBiZSBhc3VtZWQgYSB3ZWlnaHQgb2YgMSBmb3IgYWxsIGVkZ2VzXG4gICAgLy8gICBkaXJlY3RlZCAvLyBkZWZhdWx0IGZhbHNlXG4gICAgLy8gcmV0T2JqID0+IHJldHVybmVkIG9iamVjdCBieSBmdW5jdGlvblxuICAgIC8vICAgcGF0aFRvIDogZnVuY3Rpb24oZnJvbUlkLCB0b0lkKSAvLyBSZXR1cm5zIHRoZSBzaG9ydGVzdCBwYXRoIGZyb20gbm9kZSB3aXRoIElEIFwiZnJvbUlEXCIgdG8gbm9kZSB3aXRoIElEIFwidG9JZFwiLCBhcyBhbiBhcnJheSBvZiBub2RlIElEc1xuICAgIC8vICAgZGlzdGFuY2VUbzogZnVuY3Rpb24oZnJvbUlkLCB0b0lkKSAvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBvZiB0aGUgc2hvcnRlc3QgcGF0aCBmcm9tIG5vZGUgd2l0aCBJRCBcImZyb21JRFwiIHRvIG5vZGUgd2l0aCBJRCBcInRvSWRcIlxuICAgIGZsb3lkV2Fyc2hhbGw6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAvLyB2YXIgbG9nRGVidWcgPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vICAgaWYgKGRlYnVnKSB7XG4gICAgICAvLyAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgIC8vICAgfVxuICAgICAgLy8gfTtcblxuICAgICAgLy8gUGFyc2Ugb3B0aW9uc1xuICAgICAgLy8gZGVidWcgLSBvcHRpb25hbFxuICAgICAgLy8gaWYgKG9wdGlvbnMuZGVidWcgIT0gbnVsbCkge1xuICAgICAgLy8gICB2YXIgZGVidWcgPSBvcHRpb25zLmRlYnVnO1xuICAgICAgLy8gfSBlbHNlIHtcbiAgICAgIC8vICAgdmFyIGRlYnVnID0gZmFsc2U7XG4gICAgICAvLyB9XG4gICAgICAvLyBsb2dEZWJ1ZyhcIlN0YXJ0aW5nIGZsb3lkV2Fyc2hhbGwuLi5cIik7IFxuXG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgICAvLyBXZWlnaHQgZnVuY3Rpb24gLSBvcHRpb25hbFxuICAgICAgaWYgKG9wdGlvbnMud2VpZ2h0ICE9IG51bGwgJiYgJCQuaXMuZm4ob3B0aW9ucy53ZWlnaHQpKSB7ICAgICAgIFxuICAgICAgICB2YXIgd2VpZ2h0Rm4gPSBvcHRpb25zLndlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIG5vdCBzcGVjaWZpZWQsIGFzc3VtZSBlYWNoIGVkZ2UgaGFzIGVxdWFsIHdlaWdodCAoMSlcbiAgICAgICAgdmFyIHdlaWdodEZuID0gZnVuY3Rpb24oZSkge3JldHVybiAxO307XG4gICAgICB9XG5cbiAgICAgIC8vIGRpcmVjdGVkIC0gb3B0aW9uYWxcbiAgICAgIGlmIChvcHRpb25zLmRpcmVjdGVkICE9IG51bGwpIHsgICAgICAgXG4gICAgICAgIHZhciBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZGlyZWN0ZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcygpLnN0ZEZpbHRlcihmdW5jdGlvbihlKXsgcmV0dXJuICFlLmlzTG9vcCgpOyB9KTtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICAgIHZhciBudW1Ob2RlcyA9IG5vZGVzLmxlbmd0aDtcblxuICAgICAgLy8gbWFwcGluZzogbm9kZSBpZCAtPiBwb3NpdGlvbiBpbiBub2RlcyBhcnJheVxuICAgICAgdmFyIGlkMnBvc2l0aW9uID0ge307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgaWQycG9zaXRpb25bbm9kZXNbaV0uaWQoKV0gPSBpO1xuICAgICAgfSAgICAgXG5cbiAgICAgIC8vIEluaXRpYWxpemUgZGlzdGFuY2UgbWF0cml4XG4gICAgICB2YXIgZGlzdCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgIHZhciBuZXdSb3cgPSBuZXcgQXJyYXkobnVtTm9kZXMpO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKyspIHtcbiAgICAgICAgICBpZiAoaSA9PSBqKSB7XG4gICAgICAgICAgICBuZXdSb3dbal0gPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdSb3dbal0gPSBJbmZpbml0eTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGlzdC5wdXNoKG5ld1Jvdyk7XG4gICAgICB9ICAgICAgICAgICBcblxuICAgICAgLy8gSW5pdGlhbGl6ZSBtYXRyaXggdXNlZCBmb3IgcGF0aCByZWNvbnN0cnVjdGlvblxuICAgICAgLy8gSW5pdGlhbGl6ZSBkaXN0YW5jZSBtYXRyaXhcbiAgICAgIHZhciBuZXh0ID0gW107XG4gICAgICB2YXIgZWRnZU5leHQgPSBbXTtcblxuICAgICAgdmFyIGluaXRNYXRyaXggPSBmdW5jdGlvbihuZXh0KXtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5ld1JvdyA9IG5ldyBBcnJheShudW1Ob2Rlcyk7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1Ob2RlczsgaisrKSB7XG4gICAgICAgICAgICBuZXdSb3dbal0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHQucHVzaChuZXdSb3cpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpbml0TWF0cml4KG5leHQpO1xuICAgICAgaW5pdE1hdHJpeChlZGdlTmV4dCk7XG4gICAgICBcbiAgICAgIC8vIFByb2Nlc3MgZWRnZXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoIDsgaSsrKSB7ICAgICBcbiAgICAgICAgdmFyIHNvdXJjZUluZGV4ID0gaWQycG9zaXRpb25bZWRnZXNbaV0uc291cmNlKCkuaWQoKV07XG4gICAgICAgIHZhciB0YXJnZXRJbmRleCA9IGlkMnBvc2l0aW9uW2VkZ2VzW2ldLnRhcmdldCgpLmlkKCldOyAgICBcbiAgICAgICAgdmFyIHdlaWdodCA9IHdlaWdodEZuLmFwcGx5KGVkZ2VzW2ldLCBbZWRnZXNbaV1dKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIGFscmVhZHkgcHJvY2VzcyBhbm90aGVyIGVkZ2UgYmV0d2VlbiBzYW1lIDIgbm9kZXNcbiAgICAgICAgaWYgKGRpc3Rbc291cmNlSW5kZXhdW3RhcmdldEluZGV4XSA+IHdlaWdodCkge1xuICAgICAgICAgIGRpc3Rbc291cmNlSW5kZXhdW3RhcmdldEluZGV4XSA9IHdlaWdodDtcbiAgICAgICAgICBuZXh0W3NvdXJjZUluZGV4XVt0YXJnZXRJbmRleF0gPSB0YXJnZXRJbmRleDtcbiAgICAgICAgICBlZGdlTmV4dFtzb3VyY2VJbmRleF1bdGFyZ2V0SW5kZXhdID0gZWRnZXNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgdW5kaXJlY3RlZCBncmFwaCwgcHJvY2VzcyAncmV2ZXJzZWQnIGVkZ2VzXG4gICAgICBpZiAoIWRpcmVjdGVkKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoIDsgaSsrKSB7ICAgICBcbiAgICAgICAgICB2YXIgc291cmNlSW5kZXggPSBpZDJwb3NpdGlvbltlZGdlc1tpXS50YXJnZXQoKS5pZCgpXTsgICAgXG4gICAgICAgICAgdmFyIHRhcmdldEluZGV4ID0gaWQycG9zaXRpb25bZWRnZXNbaV0uc291cmNlKCkuaWQoKV07XG4gICAgICAgICAgdmFyIHdlaWdodCA9IHdlaWdodEZuLmFwcGx5KGVkZ2VzW2ldLCBbZWRnZXNbaV1dKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDaGVjayBpZiBhbHJlYWR5IHByb2Nlc3MgYW5vdGhlciBlZGdlIGJldHdlZW4gc2FtZSAyIG5vZGVzXG4gICAgICAgICAgaWYgKGRpc3Rbc291cmNlSW5kZXhdW3RhcmdldEluZGV4XSA+IHdlaWdodCkge1xuICAgICAgICAgICAgZGlzdFtzb3VyY2VJbmRleF1bdGFyZ2V0SW5kZXhdID0gd2VpZ2h0O1xuICAgICAgICAgICAgbmV4dFtzb3VyY2VJbmRleF1bdGFyZ2V0SW5kZXhdID0gdGFyZ2V0SW5kZXg7XG4gICAgICAgICAgICBlZGdlTmV4dFtzb3VyY2VJbmRleF1bdGFyZ2V0SW5kZXhdID0gZWRnZXNbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE1haW4gbG9vcFxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBudW1Ob2RlczsgaysrKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtTm9kZXM7IGorKykgeyAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGRpc3RbaV1ba10gKyBkaXN0W2tdW2pdIDwgZGlzdFtpXVtqXSkge1xuICAgICAgICAgICAgICBkaXN0W2ldW2pdID0gZGlzdFtpXVtrXSArIGRpc3Rba11bal07XG4gICAgICAgICAgICAgIG5leHRbaV1bal0gPSBuZXh0W2ldW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBCdWlsZCByZXN1bHQgb2JqZWN0ICAgICAgIFxuICAgICAgdmFyIHBvc2l0aW9uMmlkID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgcG9zaXRpb24yaWQucHVzaChub2Rlc1tpXS5pZCgpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlcyA9IHtcbiAgICAgICAgZGlzdGFuY2U6IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gICAgICAgICAgaWYgKCQkLmlzLnN0cmluZyhmcm9tKSkge1xuICAgICAgICAgICAgLy8gZnJvbSBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgICAgdmFyIGZyb21JZCA9IChjeS5maWx0ZXIoZnJvbSlbMF0pLmlkKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZyb20gaXMgYSBub2RlXG4gICAgICAgICAgICB2YXIgZnJvbUlkID0gZnJvbS5pZCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgkJC5pcy5zdHJpbmcodG8pKSB7XG4gICAgICAgICAgICAvLyB0byBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgICAgdmFyIHRvSWQgPSAoY3kuZmlsdGVyKHRvKVswXSkuaWQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdG8gaXMgYSBub2RlXG4gICAgICAgICAgICB2YXIgdG9JZCA9IHRvLmlkKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGRpc3RbaWQycG9zaXRpb25bZnJvbUlkXV1baWQycG9zaXRpb25bdG9JZF1dO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhdGg6IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gICAgICAgICAgdmFyIHJlY29uc3RydWN0UGF0aEF1eCA9IGZ1bmN0aW9uKGZyb20sIHRvLCBuZXh0LCBwb3NpdGlvbjJpZCwgZWRnZU5leHQpIHtcbiAgICAgICAgICAgIGlmIChmcm9tID09PSB0bykge1xuICAgICAgICAgICAgICByZXR1cm4gY3kuZ2V0RWxlbWVudEJ5SWQoIHBvc2l0aW9uMmlkW2Zyb21dICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dFtmcm9tXVt0b10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcGF0aCA9IFsgY3kuZ2V0RWxlbWVudEJ5SWQocG9zaXRpb24yaWRbZnJvbV0pIF07XG4gICAgICAgICAgICB2YXIgcHJldiA9IGZyb207XG4gICAgICAgICAgICB3aGlsZSAoZnJvbSAhPT0gdG8pIHtcbiAgICAgICAgICAgICAgcHJldiA9IGZyb207XG4gICAgICAgICAgICAgIGZyb20gPSBuZXh0W2Zyb21dW3RvXTtcblxuICAgICAgICAgICAgICB2YXIgZWRnZSA9IGVkZ2VOZXh0W3ByZXZdW2Zyb21dO1xuICAgICAgICAgICAgICBwYXRoLnB1c2goIGVkZ2UgKTtcblxuICAgICAgICAgICAgICBwYXRoLnB1c2goIGN5LmdldEVsZW1lbnRCeUlkKHBvc2l0aW9uMmlkW2Zyb21dKSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmICgkJC5pcy5zdHJpbmcoZnJvbSkpIHtcbiAgICAgICAgICAgIC8vIGZyb20gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICAgIHZhciBmcm9tSWQgPSAoY3kuZmlsdGVyKGZyb20pWzBdKS5pZCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBmcm9tIGlzIGEgbm9kZVxuICAgICAgICAgICAgdmFyIGZyb21JZCA9IGZyb20uaWQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoJCQuaXMuc3RyaW5nKHRvKSkge1xuICAgICAgICAgICAgLy8gdG8gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICAgIHZhciB0b0lkID0gKGN5LmZpbHRlcih0bylbMF0pLmlkKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRvIGlzIGEgbm9kZVxuICAgICAgICAgICAgdmFyIHRvSWQgPSB0by5pZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICB2YXIgcGF0aEFyciA9IHJlY29uc3RydWN0UGF0aEF1eChpZDJwb3NpdGlvbltmcm9tSWRdLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkMnBvc2l0aW9uW3RvSWRdLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjJpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VOZXh0KTtcblxuICAgICAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIHBhdGhBcnIgKTtcbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiByZXM7XG5cbiAgICB9LCAvLyBmbG95ZFdhcnNoYWxsXG5cblxuICAgIC8vIEltcGxlbWVudGVkIGZyb20gcHNldWRvY29kZSBmcm9tIHdpa2lwZWRpYVxuICAgIC8vIG9wdGlvbnMgPT4gb3B0aW9ucyBvYmplY3RcbiAgICAvLyAgIHJvb3Q6IHN0YXJ0aW5nIG5vZGUgKGVpdGhlciBlbGVtZW50IG9yIHNlbGVjdG9yIHN0cmluZylcbiAgICAvLyAgIHdlaWdodDogZnVuY3Rpb24oIGVkZ2UgKXt9IC8vIHNwZWNpZmllcyB3ZWlnaHQgdG8gdXNlIGZvciBgZWRnZWAvYHRoaXNgLiBJZiBub3QgcHJlc2VudCwgaXQgd2lsbCBiZSBhc3VtZWQgYSB3ZWlnaHQgb2YgMSBmb3IgYWxsIGVkZ2VzXG4gICAgLy8gICBkaXJlY3RlZCAvLyBkZWZhdWx0IGZhbHNlXG4gICAgLy8gcmV0T2JqID0+IHJldHVybmVkIG9iamVjdCBieSBmdW5jdGlvblxuICAgIC8vICAgcGF0aFRvIDogZnVuY3Rpb24odG9JZCkgLy8gUmV0dXJucyB0aGUgc2hvcnRlc3QgcGF0aCBmcm9tIHJvb3Qgbm9kZSB0byBub2RlIHdpdGggSUQgXCJ0b0lkXCIsIGFzIGFuIGFycmF5IG9mIG5vZGUgSURzXG4gICAgLy8gICBkaXN0YW5jZVRvOiBmdW5jdGlvbih0b0lkKSAvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBvZiB0aGUgc2hvcnRlc3QgcGF0aCBmcm9tIHJvb3Qgbm9kZSB0byBub2RlIHdpdGggSUQgXCJ0b0lkXCJcbiAgICAvLyAgIGhhc05lZ2F0aXZlV2VpZ2h0Q3ljbGU6IHRydWUvZmFsc2UgKGlmIHRydWUsIHBhdGhUbyBhbmQgZGlzdGFuY2VUbyB3aWxsIGJlIHVuZGVmaW5lZClcbiAgICBiZWxsbWFuRm9yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgIC8vIHZhciBsb2dEZWJ1ZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gICBpZiAoZGVidWcpIHtcbiAgICAgIC8vICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgICAgLy8gICB9XG4gICAgICAvLyB9O1xuXG4gICAgICAvLyBQYXJzZSBvcHRpb25zXG4gICAgICAvLyBkZWJ1ZyAtIG9wdGlvbmFsXG4gICAgICAvLyBpZiAob3B0aW9ucy5kZWJ1ZyAhPSBudWxsKSB7XG4gICAgICAvLyAgIHZhciBkZWJ1ZyA9IG9wdGlvbnMuZGVidWc7XG4gICAgICAvLyB9IGVsc2Uge1xuICAgICAgLy8gICB2YXIgZGVidWcgPSBmYWxzZTtcbiAgICAgIC8vIH1cbiAgICAgIC8vIGxvZ0RlYnVnKFwiU3RhcnRpbmcgYmVsbG1hbkZvcmQuLi5cIik7IFxuXG4gICAgICAvLyBXZWlnaHQgZnVuY3Rpb24gLSBvcHRpb25hbFxuICAgICAgaWYgKG9wdGlvbnMud2VpZ2h0ICE9IG51bGwgJiYgJCQuaXMuZm4ob3B0aW9ucy53ZWlnaHQpKSB7ICAgICAgIFxuICAgICAgICB2YXIgd2VpZ2h0Rm4gPSBvcHRpb25zLndlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIG5vdCBzcGVjaWZpZWQsIGFzc3VtZSBlYWNoIGVkZ2UgaGFzIGVxdWFsIHdlaWdodCAoMSlcbiAgICAgICAgdmFyIHdlaWdodEZuID0gZnVuY3Rpb24oZSkge3JldHVybiAxO307XG4gICAgICB9XG5cbiAgICAgIC8vIGRpcmVjdGVkIC0gb3B0aW9uYWxcbiAgICAgIGlmIChvcHRpb25zLmRpcmVjdGVkICE9IG51bGwpIHsgICAgICAgXG4gICAgICAgIHZhciBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZGlyZWN0ZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gcm9vdCAtIG1hbmRhdG9yeSFcbiAgICAgIGlmIChvcHRpb25zLnJvb3QgIT0gbnVsbCkgeyAgICAgICBcbiAgICAgICAgaWYgKCQkLmlzLnN0cmluZyhvcHRpb25zLnJvb3QpKSB7XG4gICAgICAgICAgLy8gdXNlIGl0IGFzIGEgc2VsZWN0b3IsIGUuZy4gXCIjcm9vdElEXG4gICAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZmlsdGVyKG9wdGlvbnMucm9vdClbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IG9wdGlvbnMucm9vdFswXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBsb2dEZWJ1ZyhcIlNvdXJjZSBub2RlOiAlc1wiLCBzb3VyY2UuaWQoKSk7IFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJCQudXRpbC5lcnJvcihcIm9wdGlvbnMucm9vdCByZXF1aXJlZFwiKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuZWRnZXMoKS5zdGRGaWx0ZXIoZnVuY3Rpb24oZSl7IHJldHVybiAhZS5pc0xvb3AoKTsgfSk7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgICB2YXIgbnVtTm9kZXMgPSBub2Rlcy5sZW5ndGg7XG5cbiAgICAgIC8vIG1hcHBpbmc6IG5vZGUgaWQgLT4gcG9zaXRpb24gaW4gbm9kZXMgYXJyYXlcbiAgICAgIHZhciBpZDJwb3NpdGlvbiA9IHt9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgIGlkMnBvc2l0aW9uW25vZGVzW2ldLmlkKCldID0gaTtcbiAgICAgIH0gICAgIFxuXG4gICAgICAvLyBJbml0aWFsaXphdGlvbnNcbiAgICAgIHZhciBjb3N0ID0gW107XG4gICAgICB2YXIgcHJlZGVjZXNzb3IgPSBbXTtcbiAgICAgIHZhciBwcmVkRWRnZSA9IFtdO1xuICAgICAgXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgaWYgKG5vZGVzW2ldLmlkKCkgPT09IHNvdXJjZS5pZCgpKSB7XG4gICAgICAgICAgY29zdFtpXSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29zdFtpXSA9IEluZmluaXR5O1xuICAgICAgICB9IFxuICAgICAgICBwcmVkZWNlc3NvcltpXSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRWRnZXMgcmVsYXhhdGlvbiAgICAgIFxuICAgICAgdmFyIGZsYWcgPSBmYWxzZTtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICBmbGFnID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGUgPSAwOyBlIDwgZWRnZXMubGVuZ3RoOyBlKyspIHtcbiAgICAgICAgICB2YXIgc291cmNlSW5kZXggPSBpZDJwb3NpdGlvbltlZGdlc1tlXS5zb3VyY2UoKS5pZCgpXTtcbiAgICAgICAgICB2YXIgdGFyZ2V0SW5kZXggPSBpZDJwb3NpdGlvbltlZGdlc1tlXS50YXJnZXQoKS5pZCgpXTsgICAgXG4gICAgICAgICAgdmFyIHdlaWdodCA9IHdlaWdodEZuLmFwcGx5KGVkZ2VzW2VdLCBbZWRnZXNbZV1dKTtcbiAgICAgICAgICBcbiAgICAgICAgICB2YXIgdGVtcCA9IGNvc3Rbc291cmNlSW5kZXhdICsgd2VpZ2h0O1xuICAgICAgICAgIGlmICh0ZW1wIDwgY29zdFt0YXJnZXRJbmRleF0pIHtcbiAgICAgICAgICAgIGNvc3RbdGFyZ2V0SW5kZXhdID0gdGVtcDtcbiAgICAgICAgICAgIHByZWRlY2Vzc29yW3RhcmdldEluZGV4XSA9IHNvdXJjZUluZGV4O1xuICAgICAgICAgICAgcHJlZEVkZ2VbdGFyZ2V0SW5kZXhdID0gZWRnZXNbZV07XG4gICAgICAgICAgICBmbGFnID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB1bmRpcmVjdGVkIGdyYXBoLCB3ZSBuZWVkIHRvIHRha2UgaW50byBhY2NvdW50IHRoZSAncmV2ZXJzZScgZWRnZVxuICAgICAgICAgIGlmICghZGlyZWN0ZWQpIHtcbiAgICAgICAgICAgIHZhciB0ZW1wID0gY29zdFt0YXJnZXRJbmRleF0gKyB3ZWlnaHQ7XG4gICAgICAgICAgICBpZiAodGVtcCA8IGNvc3Rbc291cmNlSW5kZXhdKSB7XG4gICAgICAgICAgICAgIGNvc3Rbc291cmNlSW5kZXhdID0gdGVtcDtcbiAgICAgICAgICAgICAgcHJlZGVjZXNzb3Jbc291cmNlSW5kZXhdID0gdGFyZ2V0SW5kZXg7XG4gICAgICAgICAgICAgIHByZWRFZGdlW3NvdXJjZUluZGV4XSA9IGVkZ2VzW2VdO1xuICAgICAgICAgICAgICBmbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWZsYWcpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSAgICAgIFxuICAgICAgICAgICAgXG4gICAgICBpZiAoZmxhZykge1xuICAgICAgICAvLyBDaGVjayBmb3IgbmVnYXRpdmUgd2VpZ2h0IGN5Y2xlc1xuICAgICAgICBmb3IgKHZhciBlID0gMDsgZSA8IGVkZ2VzLmxlbmd0aDsgZSsrKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZUluZGV4ID0gaWQycG9zaXRpb25bZWRnZXNbZV0uc291cmNlKCkuaWQoKV07XG4gICAgICAgICAgdmFyIHRhcmdldEluZGV4ID0gaWQycG9zaXRpb25bZWRnZXNbZV0udGFyZ2V0KCkuaWQoKV07ICAgIFxuICAgICAgICAgIHZhciB3ZWlnaHQgPSB3ZWlnaHRGbi5hcHBseShlZGdlc1tlXSwgW2VkZ2VzW2VdXSk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGNvc3Rbc291cmNlSW5kZXhdICsgd2VpZ2h0IDwgY29zdFt0YXJnZXRJbmRleF0pIHtcbiAgICAgICAgICAgICQkLnV0aWwuZXJyb3IoXCJFcnJvcjogZ3JhcGggY29udGFpbnMgYSBuZWdhdGl2ZSB3ZWlndGggY3ljbGUhXCIpOyBcbiAgICAgICAgICAgIHJldHVybiB7IHBhdGhUbzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICBkaXN0YW5jZVRvOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgIGhhc05lZ2F0aXZlV2VpZ2h0Q3ljbGU6IHRydWV9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSAgICAgXG4gICAgICB9XG5cbiAgICAgIC8vIEJ1aWxkIHJlc3VsdCBvYmplY3QgICAgICAgXG4gICAgICB2YXIgcG9zaXRpb24yaWQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICBwb3NpdGlvbjJpZC5wdXNoKG5vZGVzW2ldLmlkKCkpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBcbiAgICAgIHZhciByZXMgPSB7ICAgICAgIFxuICAgICAgICBkaXN0YW5jZVRvIDogZnVuY3Rpb24odG8pIHtcbiAgICAgICAgICBpZiAoJCQuaXMuc3RyaW5nKHRvKSkge1xuICAgICAgICAgICAgLy8gdG8gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICAgIHZhciB0b0lkID0gKGN5LmZpbHRlcih0bylbMF0pLmlkKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRvIGlzIGEgbm9kZVxuICAgICAgICAgICAgdmFyIHRvSWQgPSB0by5pZCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb3N0W2lkMnBvc2l0aW9uW3RvSWRdXTtcbiAgICAgICAgfSwgXG5cbiAgICAgICAgcGF0aFRvIDogZnVuY3Rpb24odG8pIHtcblxuICAgICAgICAgIHZhciByZWNvbnN0cnVjdFBhdGhBdXggPSBmdW5jdGlvbihwcmVkZWNlc3NvciwgZnJvbVBvcywgdG9Qb3MsIHBvc2l0aW9uMmlkLCBhY3VtUGF0aCwgcHJlZEVkZ2UpIHtcbiAgICAgICAgICAgIGZvcig7Oyl7XG4gICAgICAgICAgICAgIC8vIEFkZCB0b0lkIHRvIHBhdGhcbiAgICAgICAgICAgICAgYWN1bVBhdGgucHVzaCggY3kuZ2V0RWxlbWVudEJ5SWQocG9zaXRpb24yaWRbdG9Qb3NdKSApO1xuICAgICAgICAgICAgICBhY3VtUGF0aC5wdXNoKCBwcmVkRWRnZVt0b1Bvc10gKTtcblxuICAgICAgICAgICAgICBpZiAoZnJvbVBvcyA9PT0gdG9Qb3MpIHtcbiAgICAgICAgICAgICAgICAvLyByZWFjaGVkIHN0YXJ0aW5nIG5vZGVcbiAgICAgICAgICAgICAgICByZXR1cm4gYWN1bVBhdGg7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBJZiBubyBwYXRoIGV4aXN0cywgZGlzY2FydCBhY3VtdWxhdGVkIHBhdGggYW5kIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgdmFyIHByZWRQb3MgPSBwcmVkZWNlc3Nvclt0b1Bvc107XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJlZFBvcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0b1BvcyA9IHByZWRQb3M7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKCQkLmlzLnN0cmluZyh0bykpIHtcbiAgICAgICAgICAgIC8vIHRvIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgICB2YXIgdG9JZCA9IChjeS5maWx0ZXIodG8pWzBdKS5pZCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0byBpcyBhIG5vZGVcbiAgICAgICAgICAgIHZhciB0b0lkID0gdG8uaWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHBhdGggPSBbXTtcblxuICAgICAgICAgIC8vIFRoaXMgcmV0dXJucyBhIHJldmVyc2VkIHBhdGggXG4gICAgICAgICAgdmFyIHJlcyA9ICByZWNvbnN0cnVjdFBhdGhBdXgocHJlZGVjZXNzb3IsIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQycG9zaXRpb25bc291cmNlLmlkKCldLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQycG9zaXRpb25bdG9JZF0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24yaWQsIFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWRFZGdlKTtcblxuICAgICAgICAgIC8vIEdldCBpdCBpbiB0aGUgY29ycmVjdCBvcmRlciBhbmQgcmV0dXJuIGl0XG4gICAgICAgICAgaWYgKHJlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXMucmV2ZXJzZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbihjeSwgcmVzKTsgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICB9LCBcblxuICAgICAgICBoYXNOZWdhdGl2ZVdlaWdodEN5Y2xlOiBmYWxzZVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHJlcztcblxuICAgIH0sIC8vIGJlbGxtYW5Gb3JkXG5cblxuICAgIC8vIENvbXB1dGVzIHRoZSBtaW5pbXVtIGN1dCBvZiBhbiB1bmRpcmVjdGVkIGdyYXBoXG4gICAgLy8gUmV0dXJucyB0aGUgY29ycmVjdCBhbnN3ZXIgd2l0aCBoaWdoIHByb2JhYmlsaXR5XG4gICAgLy8gb3B0aW9ucyA9PiBvcHRpb25zIG9iamVjdFxuICAgIC8vIFxuICAgIC8vIHJldE9iaiA9PiByZXR1cm5lZCBvYmplY3QgYnkgZnVuY3Rpb25cbiAgICAvLyAgIGN1dCA6IGxpc3Qgb2YgSURzIG9mIGVkZ2VzIGluIHRoZSBjdXQsXG4gICAgLy8gICBwYXJ0aXRpb24xOiBsaXN0IG9mIElEcyBvZiBub2RlcyBpbiBvbmUgcGFydGl0aW9uXG4gICAgLy8gICBwYXJ0aXRpb24yOiBsaXN0IG9mIElEcyBvZiBub2RlcyBpbiB0aGUgb3RoZXIgcGFydGl0aW9uXG4gICAga2FyZ2VyU3RlaW46IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgXG4gICAgICAvLyB2YXIgbG9nRGVidWcgPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vICAgaWYgKGRlYnVnKSB7XG4gICAgICAvLyAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgIC8vICAgfVxuICAgICAgLy8gfTtcblxuICAgICAgLy8gRnVuY3Rpb24gd2hpY2ggY29sYXBzZXMgMiAobWV0YSkgbm9kZXMgaW50byBvbmVcbiAgICAgIC8vIFVwZGF0ZXMgdGhlIHJlbWFpbmluZyBlZGdlIGxpc3RzXG4gICAgICAvLyBSZWNlaXZlcyBhcyBhIHBhcmFtYXRlciB0aGUgZWRnZSB3aGljaCBjYXVzZXMgdGhlIGNvbGxhcHNlXG4gICAgICB2YXIgY29sYXBzZSA9IGZ1bmN0aW9uKGVkZ2VJbmRleCwgbm9kZU1hcCwgcmVtYWluaW5nRWRnZXMpIHtcbiAgICAgICAgdmFyIGVkZ2VJbmZvID0gcmVtYWluaW5nRWRnZXNbZWRnZUluZGV4XTtcbiAgICAgICAgdmFyIHNvdXJjZUluID0gZWRnZUluZm9bMV07XG4gICAgICAgIHZhciB0YXJnZXRJbiA9IGVkZ2VJbmZvWzJdO1xuICAgICAgICB2YXIgcGFydGl0aW9uMSA9IG5vZGVNYXBbc291cmNlSW5dO1xuICAgICAgICB2YXIgcGFydGl0aW9uMiA9IG5vZGVNYXBbdGFyZ2V0SW5dO1xuXG4gICAgICAgIC8vIERlbGV0ZSBhbGwgZWRnZXMgYmV0d2VlbiBwYXJ0aXRpb24xIGFuZCBwYXJ0aXRpb24yXG4gICAgICAgIHZhciBuZXdFZGdlcyA9IHJlbWFpbmluZ0VkZ2VzLmZpbHRlcihmdW5jdGlvbihlZGdlKSB7XG4gICAgICAgICAgaWYgKG5vZGVNYXBbZWRnZVsxXV0gPT09IHBhcnRpdGlvbjEgJiYgbm9kZU1hcFtlZGdlWzJdXSA9PT0gcGFydGl0aW9uMikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobm9kZU1hcFtlZGdlWzFdXSA9PT0gcGFydGl0aW9uMiAmJiBub2RlTWFwW2VkZ2VbMl1dID09PSBwYXJ0aXRpb24xKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIEFsbCBlZGdlcyBwb2ludGluZyB0byBwYXJ0aXRpb24yIHNob3VsZCBub3cgcG9pbnQgdG8gcGFydGl0aW9uMVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0VkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVkZ2UgPSBuZXdFZGdlc1tpXTtcbiAgICAgICAgICBpZiAoZWRnZVsxXSA9PT0gcGFydGl0aW9uMikgeyAvLyBDaGVjayBzb3VyY2VcbiAgICAgICAgICAgIG5ld0VkZ2VzW2ldID0gZWRnZS5zbGljZSgwKTtcbiAgICAgICAgICAgIG5ld0VkZ2VzW2ldWzFdID0gcGFydGl0aW9uMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVkZ2VbMl0gPT09IHBhcnRpdGlvbjIpIHsgLy8gQ2hlY2sgdGFyZ2V0XG4gICAgICAgICAgICBuZXdFZGdlc1tpXSA9IGVkZ2Uuc2xpY2UoMCk7XG4gICAgICAgICAgICBuZXdFZGdlc1tpXVsyXSA9IHBhcnRpdGlvbjE7XG4gICAgICAgICAgfVxuICAgICAgICB9IFxuICAgICAgICBcbiAgICAgICAgLy8gTW92ZSBhbGwgbm9kZXMgZnJvbSBwYXJ0aXRpb24yIHRvIHBhcnRpdGlvbjFcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlTWFwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKG5vZGVNYXBbaV0gPT09IHBhcnRpdGlvbjIpIHtcbiAgICAgICAgICAgIG5vZGVNYXBbaV0gPSBwYXJ0aXRpb24xO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIG5ld0VkZ2VzO1xuICAgICAgfTtcblxuXG4gICAgICAvLyBDb250cmFjdHMgYSBncmFwaCB1bnRpbCB3ZSByZWFjaCBhIGNlcnRhaW4gbnVtYmVyIG9mIG1ldGEgbm9kZXNcbiAgICAgIHZhciBjb250cmFjdFVudGlsID0gZnVuY3Rpb24obWV0YU5vZGVNYXAsIFxuICAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nRWRnZXMsXG4gICAgICAgICAgICAgICAgICAgICBzaXplLCBcbiAgICAgICAgICAgICAgICAgICAgIHNpemVMaW1pdCkge1xuICAgICAgICAvLyBTdG9wIGNvbmRpdGlvblxuICAgICAgICBpZiAoc2l6ZSA8PSBzaXplTGltaXQpIHtcbiAgICAgICAgICByZXR1cm4gcmVtYWluaW5nRWRnZXM7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENob29zZSBhbiBlZGdlIHJhbmRvbWx5XG4gICAgICAgIHZhciBlZGdlSW5kZXggPSBNYXRoLmZsb29yKChNYXRoLnJhbmRvbSgpICogcmVtYWluaW5nRWRnZXMubGVuZ3RoKSk7XG5cbiAgICAgICAgLy8gQ29sYXBzZSBncmFwaCBiYXNlZCBvbiBlZGdlXG4gICAgICAgIHZhciBuZXdFZGdlcyA9IGNvbGFwc2UoZWRnZUluZGV4LCBtZXRhTm9kZU1hcCwgcmVtYWluaW5nRWRnZXMpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGNvbnRyYWN0VW50aWwobWV0YU5vZGVNYXAsIFxuICAgICAgICAgICAgICAgICAgIG5ld0VkZ2VzLCBcbiAgICAgICAgICAgICAgICAgICBzaXplIC0gMSwgXG4gICAgICAgICAgICAgICAgICAgc2l6ZUxpbWl0KTsgICAgICAgIFxuICAgICAgfTtcblxuXG4gICAgICAvLyBQYXJzZSBvcHRpb25zXG4gICAgICAvLyBkZWJ1ZyAtIG9wdGlvbmFsXG4gICAgICAvLyBpZiAob3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMuZGVidWcgIT0gbnVsbCkge1xuICAgICAgLy8gICB2YXIgZGVidWcgPSBvcHRpb25zLmRlYnVnO1xuICAgICAgLy8gfSBlbHNlIHtcbiAgICAgIC8vICAgdmFyIGRlYnVnID0gZmFsc2U7XG4gICAgICAvLyB9XG4gICAgICAvLyBsb2dEZWJ1ZyhcIlN0YXJ0aW5nIGthcmdlclN0ZWluLi4uXCIpOyBcblxuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuZWRnZXMoKS5zdGRGaWx0ZXIoZnVuY3Rpb24oZSl7IHJldHVybiAhZS5pc0xvb3AoKTsgfSk7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgICB2YXIgbnVtTm9kZXMgPSBub2Rlcy5sZW5ndGg7XG4gICAgICB2YXIgbnVtRWRnZXMgPSBlZGdlcy5sZW5ndGg7XG4gICAgICB2YXIgbnVtSXRlciA9IE1hdGguY2VpbChNYXRoLnBvdyhNYXRoLmxvZyhudW1Ob2RlcykgLyBNYXRoLkxOMiwgMikpO1xuICAgICAgdmFyIHN0b3BTaXplID0gTWF0aC5mbG9vcihudW1Ob2RlcyAvIE1hdGguc3FydCgyKSk7XG5cbiAgICAgIGlmIChudW1Ob2RlcyA8IDIpIHtcbiAgICAgICAgJCQudXRpbC5lcnJvcihcIkF0IGxlYXN0IDIgbm9kZXMgYXJlIHJlcXVpcmVkIGZvciBLYXJnZXJTdGVpbmcgYWxnb3JpdGhtIVwiKTsgXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBudW1lcmljYWwgaWRlbnRpZmllcnMgZm9yIGVhY2ggbm9kZVxuICAgICAgLy8gbWFwcGluZzogbm9kZSBpZCAtPiBwb3NpdGlvbiBpbiBub2RlcyBhcnJheVxuICAgICAgLy8gZm9yIHJldmVyc2UgbWFwcGluZywgc2ltcGx5IHVzZSBub2RlcyBhcnJheVxuICAgICAgdmFyIGlkMnBvc2l0aW9uID0ge307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgaWQycG9zaXRpb25bbm9kZXNbaV0uaWQoKV0gPSBpO1xuICAgICAgfVxuXG4gICAgICAvLyBOb3cgc3RvcmUgZWRnZSBkZXN0aW5hdGlvbiBhcyBpbmRleGVzXG4gICAgICAvLyBGb3JtYXQgZm9yIGVhY2ggZWRnZSAoZWRnZSBpbmRleCwgc291cmNlIG5vZGUgaW5kZXgsIHRhcmdldCBub2RlIGluZGV4KVxuICAgICAgdmFyIGVkZ2VJbmRleGVzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUVkZ2VzOyBpKyspIHtcbiAgICAgICAgdmFyIGUgPSBlZGdlc1tpXTtcbiAgICAgICAgZWRnZUluZGV4ZXMucHVzaChbaSwgaWQycG9zaXRpb25bZS5zb3VyY2UoKS5pZCgpXSwgaWQycG9zaXRpb25bZS50YXJnZXQoKS5pZCgpXV0pO1xuICAgICAgfVxuXG4gICAgICAvLyBXZSB3aWxsIHN0b3JlIHRoZSBiZXN0IGN1dCBmb3VuZCBoZXJlXG4gICAgICB2YXIgbWluQ3V0U2l6ZSA9IEluZmluaXR5O1xuICAgICAgdmFyIG1pbkN1dDsgICAgIFxuXG4gICAgICAvLyBJbml0aWFsIG1ldGEgbm9kZSBwYXJ0aXRpb25cbiAgICAgIHZhciBvcmlnaW5hbE1ldGFOb2RlID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgb3JpZ2luYWxNZXRhTm9kZS5wdXNoKGkpO1xuICAgICAgfVxuXG4gICAgICAvLyBNYWluIGxvb3BcbiAgICAgIGZvciAodmFyIGl0ZXIgPSAwOyBpdGVyIDw9IG51bUl0ZXI7IGl0ZXIrKykge1xuICAgICAgICAvLyBDcmVhdGUgbmV3IG1ldGEgbm9kZSBwYXJ0aXRpb25cbiAgICAgICAgdmFyIG1ldGFOb2RlTWFwID0gb3JpZ2luYWxNZXRhTm9kZS5zbGljZSgwKTtcblxuICAgICAgICAvLyBDb250cmFjdCB1bnRpbCBzdG9wIHBvaW50IChzdG9wU2l6ZSBub2RlcylcbiAgICAgICAgdmFyIGVkZ2VzU3RhdGUgPSBjb250cmFjdFVudGlsKG1ldGFOb2RlTWFwLCBlZGdlSW5kZXhlcywgbnVtTm9kZXMsIHN0b3BTaXplKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBhIGNvcHkgb2YgdGhlIGNvbGFwc2VkIG5vZGVzIHN0YXRlXG4gICAgICAgIHZhciBtZXRhTm9kZU1hcDIgPSBtZXRhTm9kZU1hcC5zbGljZSgwKTtcblxuICAgICAgICAvLyBSdW4gMiBpdGVyYXRpb25zIHN0YXJ0aW5nIGluIHRoZSBzdG9wIHN0YXRlXG4gICAgICAgIHZhciByZXMxID0gY29udHJhY3RVbnRpbChtZXRhTm9kZU1hcCwgZWRnZXNTdGF0ZSwgc3RvcFNpemUsIDIpO1xuICAgICAgICB2YXIgcmVzMiA9IGNvbnRyYWN0VW50aWwobWV0YU5vZGVNYXAyLCBlZGdlc1N0YXRlLCBzdG9wU2l6ZSwgMik7XG5cbiAgICAgICAgLy8gSXMgYW55IG9mIHRoZSAyIHJlc3VsdHMgdGhlIGJlc3QgY3V0IHNvIGZhcj9cbiAgICAgICAgaWYgKHJlczEubGVuZ3RoIDw9IHJlczIubGVuZ3RoICYmIHJlczEubGVuZ3RoIDwgbWluQ3V0U2l6ZSkge1xuICAgICAgICAgIG1pbkN1dFNpemUgPSByZXMxLmxlbmd0aDtcbiAgICAgICAgICBtaW5DdXQgPSBbcmVzMSwgbWV0YU5vZGVNYXBdO1xuICAgICAgICB9IGVsc2UgaWYgKHJlczIubGVuZ3RoIDw9IHJlczEubGVuZ3RoICYmIHJlczIubGVuZ3RoIDwgbWluQ3V0U2l6ZSkge1xuICAgICAgICAgIG1pbkN1dFNpemUgPSByZXMyLmxlbmd0aDtcbiAgICAgICAgICBtaW5DdXQgPSBbcmVzMiwgbWV0YU5vZGVNYXAyXTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBlbmQgb2YgbWFpbiBsb29wXG5cbiAgICAgIFxuICAgICAgLy8gQ29uc3RydWN0IHJlc3VsdFxuICAgICAgdmFyIHJlc0VkZ2VzID0gKG1pbkN1dFswXSkubWFwKGZ1bmN0aW9uKGUpeyByZXR1cm4gZWRnZXNbZVswXV07IH0pO1xuICAgICAgdmFyIHBhcnRpdGlvbjEgPSBbXTtcbiAgICAgIHZhciBwYXJ0aXRpb24yID0gW107XG5cbiAgICAgIC8vIHRyYXZlcnNlIG1ldGFOb2RlTWFwIGZvciBiZXN0IGN1dFxuICAgICAgdmFyIHdpdG5lc3NOb2RlUGFydGl0aW9uID0gbWluQ3V0WzFdWzBdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW5DdXRbMV0ubGVuZ3RoOyBpKyspIHsgXG4gICAgICAgIHZhciBwYXJ0aXRpb25JZCA9IG1pbkN1dFsxXVtpXTsgXG4gICAgICAgIGlmIChwYXJ0aXRpb25JZCA9PT0gd2l0bmVzc05vZGVQYXJ0aXRpb24pIHtcbiAgICAgICAgICBwYXJ0aXRpb24xLnB1c2gobm9kZXNbaV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnRpdGlvbjIucHVzaChub2Rlc1tpXSk7XG4gICAgICAgIH0gICAgICAgXG4gICAgICB9XG4gICAgICBcbiAgICAgIHZhciByZXQgPSB7XG4gICAgICAgIGN1dDogbmV3ICQkLkNvbGxlY3Rpb24oY3ksIHJlc0VkZ2VzKSxcbiAgICAgICAgcGFydGl0aW9uMTogbmV3ICQkLkNvbGxlY3Rpb24oY3ksIHBhcnRpdGlvbjEpLFxuICAgICAgICBwYXJ0aXRpb24yOiBuZXcgJCQuQ29sbGVjdGlvbihjeSwgcGFydGl0aW9uMilcbiAgICAgIH07XG4gICAgICBcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuXG4gICAgLy8gXG4gICAgLy8gb3B0aW9ucyA9PiBvcHRpb25zIG9iamVjdFxuICAgIC8vICAgZGFtcGluZ0ZhY3Rvcjogb3B0aW9uYWxcbiAgICAvLyAgIHByZWNpc2lvbjogb3B0aW9uYWxcbiAgICAvLyAgIGl0ZXJhdGlvbnMgOiBvcHRpb25hbFxuICAgIC8vIHJldE9iaiA9PiByZXR1cm5lZCBvYmplY3QgYnkgZnVuY3Rpb25cbiAgICAvLyAgcmFuayA6IGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgcGFnZVJhbmsgb2YgYSBnaXZlbiBub2RlIChvYmplY3Qgb3Igc2VsZWN0b3Igc3RyaW5nKVxuICAgIHBhZ2VSYW5rOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIFxuICAgICAgdmFyIG5vcm1hbGl6ZVZlY3RvciA9IGZ1bmN0aW9uKHZlY3Rvcikge1xuICAgICAgICB2YXIgbGVuZ3RoID0gdmVjdG9yLmxlbmd0aDtcblxuICAgICAgICAvLyBGaXJzdCwgZ2V0IHN1bSBvZiBhbGwgZWxlbWVudHNcbiAgICAgICAgdmFyIHRvdGFsID0gMDsgXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0b3RhbCArPSB2ZWN0b3JbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3csIGRpdmlkZSBlYWNoIGJ5IHRoZSBzdW0gb2YgYWxsIGVsZW1lbnRzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2ZWN0b3JbaV0gPSB2ZWN0b3JbaV0gLyB0b3RhbDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gdmFyIGxvZ0RlYnVnID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyAgIGlmIChkZWJ1Zykge1xuICAgICAgLy8gICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgICAvLyAgIH1cbiAgICAgIC8vIH07XG4gICAgICBcbiAgICAgIC8vIFBhcnNlIG9wdGlvbnNcbiAgICAgIC8vIGRlYnVnIC0gb3B0aW9uYWxcbiAgICAgIC8vIGlmIChvcHRpb25zICE9IG51bGwgJiYgXG4gICAgICAvLyAgIG9wdGlvbnMuZGVidWcgIT0gbnVsbCkge1xuICAgICAgLy8gICB2YXIgZGVidWcgPSBvcHRpb25zLmRlYnVnO1xuICAgICAgLy8gfSBlbHNlIHtcbiAgICAgIC8vICAgdmFyIGRlYnVnID0gZmFsc2U7XG4gICAgICAvLyB9XG4gICAgICAvLyBsb2dEZWJ1ZyhcIlN0YXJ0aW5nIHBhZ2VSYW5rLi4uXCIpOyBcblxuICAgICAgLy8gZGFtcGluZ0ZhY3RvciAtIG9wdGlvbmFsXG4gICAgICBpZiAob3B0aW9ucyAhPSBudWxsICYmIFxuICAgICAgICBvcHRpb25zLmRhbXBpbmdmYWN0b3IgIT0gbnVsbCkge1xuICAgICAgICB2YXIgZGFtcGluZ0ZhY3RvciA9IG9wdGlvbnMuZGFtcGluZ0ZhY3RvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkYW1waW5nRmFjdG9yID0gMC44OyAvLyBEZWZhdWx0IGRhbXBpbmcgZmFjdG9yXG4gICAgICB9XG5cbiAgICAgIC8vIGRlc2lyZWQgcHJlY2lzaW9uIC0gb3B0aW9uYWxcbiAgICAgIGlmIChvcHRpb25zICE9IG51bGwgJiYgXG4gICAgICAgIG9wdGlvbnMucHJlY2lzaW9uICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGVwc2lsb24gPSBvcHRpb25zLnByZWNpc2lvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBlcHNpbG9uID0gMC4wMDAwMDE7IC8vIERlZmF1bHQgcHJlY2lzaW9uXG4gICAgICB9XG5cbiAgICAgIC8vIE1heCBudW1iZXIgb2YgaXRlcmF0aW9ucyAtIG9wdGlvbmFsXG4gICAgICBpZiAob3B0aW9ucyAhPSBudWxsICYmIFxuICAgICAgICBvcHRpb25zLml0ZXJhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbnVtSXRlciA9IG9wdGlvbnMuaXRlcmF0aW9ucztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBudW1JdGVyID0gMjAwOyAvLyBEZWZhdWx0IG51bWJlciBvZiBpdGVyYXRpb25zXG4gICAgICB9XG5cbiAgICAgIC8vIFdlaWdodCBmdW5jdGlvbiAtIG9wdGlvbmFsXG4gICAgICBpZiAob3B0aW9ucyAhPSBudWxsICYmIFxuICAgICAgICBvcHRpb25zLndlaWdodCAhPSBudWxsICYmIFxuICAgICAgICAkJC5pcy5mbihvcHRpb25zLndlaWdodCkpIHsgICAgICAgXG4gICAgICAgIHZhciB3ZWlnaHRGbiA9IG9wdGlvbnMud2VpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgbm90IHNwZWNpZmllZCwgYXNzdW1lIGVhY2ggZWRnZSBoYXMgZXF1YWwgd2VpZ2h0ICgxKVxuICAgICAgICB2YXIgd2VpZ2h0Rm4gPSBmdW5jdGlvbihlKSB7cmV0dXJuIDE7fTsgXG4gICAgICB9XG5cbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCkuc3RkRmlsdGVyKGZ1bmN0aW9uKGUpeyByZXR1cm4gIWUuaXNMb29wKCk7IH0pO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgICAgdmFyIG51bU5vZGVzID0gbm9kZXMubGVuZ3RoO1xuICAgICAgdmFyIG51bUVkZ2VzID0gZWRnZXMubGVuZ3RoO1xuXG4gICAgICAvLyBDcmVhdGUgbnVtZXJpY2FsIGlkZW50aWZpZXJzIGZvciBlYWNoIG5vZGVcbiAgICAgIC8vIG1hcHBpbmc6IG5vZGUgaWQgLT4gcG9zaXRpb24gaW4gbm9kZXMgYXJyYXlcbiAgICAgIC8vIGZvciByZXZlcnNlIG1hcHBpbmcsIHNpbXBseSB1c2Ugbm9kZXMgYXJyYXlcbiAgICAgIHZhciBpZDJwb3NpdGlvbiA9IHt9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgIGlkMnBvc2l0aW9uW25vZGVzW2ldLmlkKCldID0gaTtcbiAgICAgIH1cblxuICAgICAgLy8gQ29uc3RydWN0IHRyYW5zcG9zZWQgYWRqYWNlbmN5IG1hdHJpeFxuICAgICAgLy8gRmlyc3QgbGV0cyBoYXZlIGEgemVyb2VkIG1hdHJpeCBvZiB0aGUgcmlnaHQgc2l6ZVxuICAgICAgLy8gV2UnbGwgYWxzbyBrZWVwIHRyYWNrIG9mIHRoZSBzdW0gb2YgZWFjaCBjb2x1bW5cbiAgICAgIHZhciBtYXRyaXggPSBbXTtcbiAgICAgIHZhciBjb2x1bW5TdW0gPSBbXTtcbiAgICAgIHZhciBhZGRpdGlvbmFsUHJvYiA9ICgxIC0gZGFtcGluZ0ZhY3RvcikgLyBudW1Ob2RlcztcblxuICAgICAgLy8gQ3JlYXRlIG51bGwgbWF0cmljXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHsgXG4gICAgICAgIHZhciBuZXdSb3cgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1Ob2RlczsgaisrKSB7XG4gICAgICAgICAgbmV3Um93LnB1c2goMC4wKTtcbiAgICAgICAgfVxuICAgICAgICBtYXRyaXgucHVzaChuZXdSb3cpO1xuICAgICAgICBjb2x1bW5TdW0ucHVzaCgwLjApO1xuICAgICAgfVxuXG4gICAgICAvLyBOb3csIHByb2Nlc3MgZWRnZXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtRWRnZXM7IGkrKykge1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2ldO1xuICAgICAgICB2YXIgcyA9IGlkMnBvc2l0aW9uW2VkZ2Uuc291cmNlKCkuaWQoKV07XG4gICAgICAgIHZhciB0ID0gaWQycG9zaXRpb25bZWRnZS50YXJnZXQoKS5pZCgpXTtcbiAgICAgICAgdmFyIHcgPSB3ZWlnaHRGbi5hcHBseShlZGdlLCBbZWRnZV0pO1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIG1hdHJpeFxuICAgICAgICBtYXRyaXhbdF1bc10gKz0gdztcblxuICAgICAgICAvLyBVcGRhdGUgY29sdW1uIHN1bVxuICAgICAgICBjb2x1bW5TdW1bc10gKz0gdzsgXG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBhZGRpdGlvbmFsIHByb2JhYmlsaXR5IGJhc2VkIG9uIGRhbXBpbmcgZmFjdG9yXG4gICAgICAvLyBBbHNvLCB0YWtlIGludG8gYWNjb3VudCBjb2x1bW5zIHRoYXQgaGF2ZSBzdW0gPSAwXG4gICAgICB2YXIgcCA9IDEuMCAvIG51bU5vZGVzICsgYWRkaXRpb25hbFByb2I7IC8vIFNob3J0aGFuZFxuICAgICAgLy8gVHJhdmVyc2UgbWF0cml4LCBjb2x1bW4gYnkgY29sdW1uXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKyspIHsgXG4gICAgICAgIGlmIChjb2x1bW5TdW1bal0gPT09IDApIHtcbiAgICAgICAgICAvLyBObyAnbGlua3MnIG91dCBmcm9tIG5vZGUganRoLCBhc3N1bWUgZXF1YWwgcHJvYmFiaWxpdHkgZm9yIGVhY2ggcG9zc2libGUgbm9kZVxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICAgICAgbWF0cml4W2ldW2pdID0gcDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm9kZSBqdGggaGFzIG91dGdvaW5nIGxpbmssIGNvbXB1dGUgbm9ybWFsaXplZCBwcm9iYWJpbGl0aWVzXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgICAgICBtYXRyaXhbaV1bal0gPSBtYXRyaXhbaV1bal0gLyBjb2x1bW5TdW1bal0gKyBhZGRpdGlvbmFsUHJvYjtcbiAgICAgICAgICB9ICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ29tcHV0ZSBkb21pbmFudCBlaWdlbnZlY3RvciB1c2luZyBwb3dlciBtZXRob2RcbiAgICAgIHZhciBlaWdlbnZlY3RvciA9IFtdO1xuICAgICAgdmFyIG51bGxWZWN0b3IgPSBbXTtcbiAgICAgIHZhciBwcmV2aW91cztcblxuICAgICAgLy8gU3RhcnQgd2l0aCBhIHZlY3RvciBvZiBhbGwgMSdzXG4gICAgICAvLyBBbHNvLCBpbml0aWFsaXplIGEgbnVsbCB2ZWN0b3Igd2hpY2ggd2lsbCBiZSB1c2VkIGFzIHNob3J0aGFuZFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgIGVpZ2VudmVjdG9yLnB1c2goMS4wKTtcbiAgICAgICAgbnVsbFZlY3Rvci5wdXNoKDAuMCk7XG4gICAgICB9XG4gICAgICAgICAgICBcbiAgICAgIGZvciAodmFyIGl0ZXIgPSAwOyBpdGVyIDwgbnVtSXRlcjsgaXRlcisrKSB7XG4gICAgICAgIC8vIE5ldyBhcnJheSB3aXRoIGFsbCAwJ3NcbiAgICAgICAgdmFyIHRlbXAgPSBudWxsVmVjdG9yLnNsaWNlKDApO1xuICAgICAgICBcbiAgICAgICAgLy8gTXVsdGlwbHkgbWF0cml4IHdpdGggcHJldmlvdXMgcmVzdWx0XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtTm9kZXM7IGorKykgeyAgICAgICAgXG4gICAgICAgICAgICB0ZW1wW2ldICs9IG1hdHJpeFtpXVtqXSAqIGVpZ2VudmVjdG9yW2pdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG5vcm1hbGl6ZVZlY3Rvcih0ZW1wKTtcbiAgICAgICAgcHJldmlvdXMgPSBlaWdlbnZlY3RvcjtcbiAgICAgICAgZWlnZW52ZWN0b3IgPSB0ZW1wO1xuXG4gICAgICAgIHZhciBkaWZmID0gMDtcbiAgICAgICAgLy8gQ29tcHV0ZSBkaWZmZXJlbmNlIChzcXVhcmVkIG1vZHVsZSkgb2YgYm90aCB2ZWN0b3JzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICAgIGRpZmYgKz0gTWF0aC5wb3cocHJldmlvdXNbaV0gLSBlaWdlbnZlY3RvcltpXSwgMik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIElmIGRpZmZlcmVuY2UgaXMgbGVzcyB0aGFuIHRoZSBkZXNpcmVkIHRocmVzaG9sZCwgc3RvcCBpdGVyYXRpbmdcbiAgICAgICAgaWYgKGRpZmYgPCBlcHNpbG9uKSB7XG4gICAgICAgICAgLy8gbG9nRGVidWcoXCJTdG9wZWQgYXQgaXRlcmF0aW9uICVzXCIsIGl0ZXIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAgICAgICBcbiAgICAgIC8vIGxvZ0RlYnVnKFwiUmVzdWx0OlxcblwiICsgZWlnZW52ZWN0b3IpO1xuXG4gICAgICAvLyBDb25zdHJ1Y3QgcmVzdWx0XG4gICAgICB2YXIgcmVzID0ge1xuICAgICAgICByYW5rIDogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgIGlmICgkJC5pcy5zdHJpbmcobm9kZSkpIHtcbiAgICAgICAgICAgIC8vIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgICB2YXIgbm9kZUlkID0gKGN5LmZpbHRlcihub2RlKVswXSkuaWQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaXMgYSBub2RlIG9iamVjdFxuICAgICAgICAgICAgdmFyIG5vZGVJZCA9IG5vZGUuaWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGVpZ2VudmVjdG9yW2lkMnBvc2l0aW9uW25vZGVJZF1dO1xuICAgICAgICB9XG4gICAgICB9O1xuXG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSwgLy8gcGFnZVJhbmtcblxuXG4gICAgLy8gb3B0aW9ucyA9PiBvcHRpb25zIG9iamVjdFxuICAgIC8vICAgd2VpZ2h0OiBmdW5jdGlvbiggZWRnZSApe30gLy8gc3BlY2lmaWVzIHdlaWdodCB0byB1c2UgZm9yIGBlZGdlYC9gdGhpc2AuIElmIG5vdCBwcmVzZW50LCBpdCB3aWxsIGJlIGFzdW1lZCBhIHdlaWdodCBvZiAxIGZvciBhbGwgZWRnZXNcbiAgICAvLyAgIGRpcmVjdGVkIC8vIGRlZmF1bHQgZmFsc2VcbiAgICAvLyByZXRPYmogPT4gcmV0dXJuZWQgb2JqZWN0IGJ5IGZ1bmN0aW9uXG4gICAgLy8gaWYgZGlyZWN0ZWRcbiAgICAvLyAgIGluZGVncmVlIDogZnVuY3Rpb24obm9kZSkgLy8gUmV0dXJucyB0aGUgbm9ybWFsaXplZCBpbmRlZ3JlZSBvZiB0aGUgZ2l2ZW4gbm9kZVxuICAgIC8vICAgb3V0ZGVncmVlOiBmdW5jdGlvbihub2RlKSAvLyBSZXR1cm5zIHRoZSBub3JtYWxpemVkIG91dGRlZ3JlZSBvZiB0aGUgZ2l2ZW4gbm9kZVxuICAgIC8vIGlmIHVuZGlyZWN0ZWRcbiAgICAvLyAgIGRlZ3JlZSA6IGZ1bmN0aW9uKG5vZGUpIC8vIFJldHVybnMgdGhlIG5vcm1hbGl6ZWQgZGVncmVlIG9mIHRoZSBnaXZlbiBub2RlXG4gICAgZGVncmVlQ2VudHJhbGl0eU5vcm1hbGl6ZWQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgLy8gdmFyIGxvZ0RlYnVnID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gICBpZiAoZGVidWcpIHtcbiAgICAgIC8vICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgICAgLy8gICB9XG4gICAgICAvLyB9O1xuXG4gICAgICAvLyBQYXJzZSBvcHRpb25zXG4gICAgICAvLyBkZWJ1ZyAtIG9wdGlvbmFsXG4gICAgICAvLyBpZiAob3B0aW9ucy5kZWJ1ZyAhPSBudWxsKSB7XG4gICAgICAvLyAgIHZhciBkZWJ1ZyA9IG9wdGlvbnMuZGVidWc7XG4gICAgICAvLyB9IGVsc2Uge1xuICAgICAgLy8gICB2YXIgZGVidWcgPSBmYWxzZTtcbiAgICAgIC8vIH1cblxuICAgICAgLy8gZGlyZWN0ZWQgLSBvcHRpb25hbFxuICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0ZWQgIT0gbnVsbCkge1xuICAgICAgICB2YXIgZGlyZWN0ZWQgPSBvcHRpb25zLmRpcmVjdGVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGRpcmVjdGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIGxvZ0RlYnVnKFwiU3RhcnRpbmcgZGVncmVlIGNlbnRyYWxpdHkuLi5cIik7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgICB2YXIgbnVtTm9kZXMgPSBub2Rlcy5sZW5ndGg7XG5cbiAgICAgIGlmICghZGlyZWN0ZWQpIHtcbiAgICAgICAgdmFyIGRlZ3JlZXMgPSB7fTtcbiAgICAgICAgdmFyIG1heERlZ3JlZSA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAvLyBhZGQgY3VycmVudCBub2RlIHRvIHRoZSBjdXJyZW50IG9wdGlvbnMgb2JqZWN0IGFuZCBjYWxsIGRlZ3JlZUNlbnRyYWxpdHkgXG4gICAgICAgICAgdmFyIGN1cnJEZWdyZWUgPSB0aGlzLmRlZ3JlZUNlbnRyYWxpdHkoJCQudXRpbC5leHRlbmQoe30sIG9wdGlvbnMsIHtyb290OiBub2RlfSkpO1xuICAgICAgICAgIGlmIChtYXhEZWdyZWUgPCBjdXJyRGVncmVlLmRlZ3JlZSlcbiAgICAgICAgICAgIG1heERlZ3JlZSA9IGN1cnJEZWdyZWUuZGVncmVlO1xuXG4gICAgICAgICAgZGVncmVlc1tub2RlLmlkKCldID0gY3VyckRlZ3JlZS5kZWdyZWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRlZ3JlZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmICgkJC5pcy5zdHJpbmcobm9kZSkpIHtcbiAgICAgICAgICAgICAgLy8gZnJvbSBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgICAgICB2YXIgbm9kZSA9IChjeS5maWx0ZXIobm9kZSlbMF0pLmlkKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBmcm9tIGlzIGEgbm9kZVxuICAgICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGUuaWQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRlZ3JlZXNbbm9kZV0gLyBtYXhEZWdyZWU7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGluZGVncmVlcyA9IHt9O1xuICAgICAgICB2YXIgb3V0ZGVncmVlcyA9IHt9O1xuICAgICAgICB2YXIgbWF4SW5kZWdyZWUgPSAwO1xuICAgICAgICB2YXIgbWF4T3V0ZGVncmVlID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgIC8vIGFkZCBjdXJyZW50IG5vZGUgdG8gdGhlIGN1cnJlbnQgb3B0aW9ucyBvYmplY3QgYW5kIGNhbGwgZGVncmVlQ2VudHJhbGl0eSBcbiAgICAgICAgICB2YXIgY3VyckRlZ3JlZSA9IHRoaXMuZGVncmVlQ2VudHJhbGl0eSgkJC51dGlsLmV4dGVuZCh7fSwgb3B0aW9ucywge3Jvb3Q6IG5vZGV9KSk7XG5cbiAgICAgICAgICBpZiAobWF4SW5kZWdyZWUgPCBjdXJyRGVncmVlLmluZGVncmVlKVxuICAgICAgICAgICAgbWF4SW5kZWdyZWUgPSBjdXJyRGVncmVlLmluZGVncmVlO1xuXG4gICAgICAgICAgaWYgKG1heE91dGRlZ3JlZSA8IGN1cnJEZWdyZWUub3V0ZGVncmVlKVxuICAgICAgICAgICAgbWF4T3V0ZGVncmVlID0gY3VyckRlZ3JlZS5vdXRkZWdyZWU7XG5cbiAgICAgICAgICBpbmRlZ3JlZXNbbm9kZS5pZCgpXSA9IGN1cnJEZWdyZWUuaW5kZWdyZWU7XG4gICAgICAgICAgb3V0ZGVncmVlc1tub2RlLmlkKCldID0gY3VyckRlZ3JlZS5vdXRkZWdyZWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGluZGVncmVlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKCQkLmlzLnN0cmluZyhub2RlKSkge1xuICAgICAgICAgICAgICAvLyBmcm9tIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgICAgIHZhciBub2RlID0gKGN5LmZpbHRlcihub2RlKVswXSkuaWQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGZyb20gaXMgYSBub2RlXG4gICAgICAgICAgICAgIHZhciBub2RlID0gbm9kZS5pZCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaW5kZWdyZWVzW25vZGVdIC8gbWF4SW5kZWdyZWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvdXRkZWdyZWU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBpZiAoJCQuaXMuc3RyaW5nKG5vZGUpKSB7XG4gICAgICAgICAgICAgIC8vIGZyb20gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICAgICAgdmFyIG5vZGUgPSAoY3kuZmlsdGVyKG5vZGUpWzBdKS5pZCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gZnJvbSBpcyBhIG5vZGVcbiAgICAgICAgICAgICAgdmFyIG5vZGUgPSBub2RlLmlkKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvdXRkZWdyZWVzW25vZGVdIC8gbWF4T3V0ZGVncmVlO1xuICAgICAgICAgIH1cblxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgfSwgLy8gZGVncmVlQ2VudHJhbGl0eU5vcm1hbGl6ZWRcblxuICAgIC8vIEltcGxlbWVudGVkIGZyb20gdGhlIGFsZ29yaXRobSBpbiBPcHNhaGwncyBwYXBlciBcIk5vZGUgY2VudHJhbGl0eSBpbiB3ZWlnaHRlZCBuZXR3b3JrczogR2VuZXJhbGl6aW5nIGRlZ3JlZSBhbmQgc2hvcnRlc3QgcGF0aHNcIiBjaGVjayB0aGUgaGVhZGluZyAyIFwiRGVncmVlXCJcbiAgICAvLyBvcHRpb25zID0+IG9wdGlvbnMgb2JqZWN0XG4gICAgLy8gICBub2RlIDogZm9jYWwgbm9kZVxuICAgIC8vICAgd2VpZ2h0OiBmdW5jdGlvbiggZWRnZSApe30gLy8gc3BlY2lmaWVzIHdlaWdodCB0byB1c2UgZm9yIGBlZGdlYC9gdGhpc2AuIElmIG5vdCBwcmVzZW50LCBpdCB3aWxsIGJlIGFzdW1lZCBhIHdlaWdodCBvZiAxIGZvciBhbGwgZWRnZXNcbiAgICAvLyAgIGFscGhhIDogYWxwaGEgdmFsdWUgZm9yIHRoZSBhbGdvcml0aG0gKEJlbmNobWFyayB2YWx1ZXMgb2YgYWxwaGE6IDAgLT4gZGlzcmVnYXJkcyB0aGUgd2VpZ2h0cyBmb2N1c2VzIG9uIG51bWJlciBvZiBlZGdlc1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMSAtPiBkaXNyZWdhcmRzIHRoZSBudW1iZXIgb2YgZWRnZXMgZm9jdXNlcyBvbiB0b3RhbCBhbW91bnQgb2Ygd2VpZ2h0IFxuICAgIC8vICAgZGlyZWN0ZWQgLy8gZGVmYXVsdCBmYWxzZVxuICAgIC8vIHJldE9iaiA9PiByZXR1cm5lZCBvYmplY3QgYnkgZnVuY3Rpb25cbiAgICAvLyBpZiBkaXJlY3RlZFxuICAgIC8vICAgaW5kZWdyZWUgOiBpbmRlZ3JlZSBvZiB0aGUgZ2l2ZW4gbm9kZVxuICAgIC8vICAgb3V0ZGVncmVlOiBvdXRkZWdyZWUgb2YgdGhlIGdpdmVuIG5vZGVcbiAgICAvLyBpZiB1bmRpcmVjdGVkXG4gICAgLy8gICBkZWdyZWUgOiBkZWdyZWUgb2YgdGhlIGdpdmVuIG5vZGVcbiAgICBkZWdyZWVDZW50cmFsaXR5OiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgIHZhciBjYWxsaW5nRWxlcyA9IHRoaXM7XG5cbiAgICAgIC8vIHZhciBsb2dEZWJ1ZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vICAgaWYgKGRlYnVnKSB7XG4gICAgICAvLyAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgIC8vICAgfVxuICAgICAgLy8gfTtcblxuICAgICAgLy8gUGFyc2Ugb3B0aW9uc1xuICAgICAgLy8gZGVidWcgLSBvcHRpb25hbFxuICAgICAgLy8gaWYgKG9wdGlvbnMuZGVidWcgIT0gbnVsbCkge1xuICAgICAgLy8gICB2YXIgZGVidWcgPSBvcHRpb25zLmRlYnVnO1xuICAgICAgLy8gfSBlbHNlIHtcbiAgICAgIC8vICAgdmFyIGRlYnVnID0gZmFsc2U7XG4gICAgICAvLyB9XG5cbiAgICAgIC8vIGxvZ0RlYnVnKFwiU3RhcnRpbmcgZGVncmVlIGNlbnRyYWxpdHkuLi5cIik7XG5cbiAgICAgIC8vIHJvb3QgLSBtYW5kYXRvcnkhXG4gICAgICBpZiAob3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMucm9vdCAhPSBudWxsKSB7XG4gICAgICAgIHZhciByb290ID0gJCQuaXMuc3RyaW5nKG9wdGlvbnMucm9vdCkgPyB0aGlzLmZpbHRlcihvcHRpb25zLnJvb3QpWzBdIDogb3B0aW9ucy5yb290WzBdO1xuICAgICAgICAvLyBsb2dEZWJ1ZyhcIlNvdXJjZSBub2RlOiAlc1wiLCByb290LmlkKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLy8gd2VpZ2h0IC0gb3B0aW9uYWxcbiAgICAgIGlmIChvcHRpb25zLndlaWdodCAhPSBudWxsICYmICQkLmlzLmZuKG9wdGlvbnMud2VpZ2h0KSkge1xuICAgICAgICB2YXIgd2VpZ2h0Rm4gPSBvcHRpb25zLndlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIG5vdCBzcGVjaWZpZWQsIGFzc3VtZSBlYWNoIGVkZ2UgaGFzIGVxdWFsIHdlaWdodCAoMSlcbiAgICAgICAgdmFyIHdlaWdodEZuID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gZGlyZWN0ZWQgLSBvcHRpb25hbFxuICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0ZWQgIT0gbnVsbCkge1xuICAgICAgICB2YXIgZGlyZWN0ZWQgPSBvcHRpb25zLmRpcmVjdGVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGRpcmVjdGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIGFscGhhIC0gb3B0aW9uYWxcbiAgICAgIGlmIChvcHRpb25zLmFscGhhICE9IG51bGwgJiYgJCQuaXMubnVtYmVyKG9wdGlvbnMuYWxwaGEpKSB7XG4gICAgICAgIHZhciBhbHBoYSA9IG9wdGlvbnMuYWxwaGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbHBoYSA9IDA7XG4gICAgICB9XG5cblxuICAgICAgaWYgKCFkaXJlY3RlZCkge1xuICAgICAgICB2YXIgY29ubkVkZ2VzID0gcm9vdC5jb25uZWN0ZWRFZGdlcygpLmludGVyc2VjdGlvbiggY2FsbGluZ0VsZXMgKTtcbiAgICAgICAgdmFyIGsgPSBjb25uRWRnZXMubGVuZ3RoO1xuICAgICAgICB2YXIgcyA9IDA7XG5cbiAgICAgICAgLy8gTm93LCBzdW0gZWRnZSB3ZWlnaHRzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29ubkVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVkZ2UgPSBjb25uRWRnZXNbaV07XG4gICAgICAgICAgcyArPSB3ZWlnaHRGbi5hcHBseShlZGdlLCBbZWRnZV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkZWdyZWU6IE1hdGgucG93KGssIDEgLSBhbHBoYSkgKiBNYXRoLnBvdyhzLCBhbHBoYSlcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpbmNvbWluZyA9IHJvb3QuY29ubmVjdGVkRWRnZXMoJ2VkZ2VbdGFyZ2V0ID0gXCInICsgcm9vdC5pZCgpICsgJ1wiXScpLmludGVyc2VjdGlvbiggY2FsbGluZ0VsZXMgKTtcbiAgICAgICAgdmFyIG91dGdvaW5nID0gcm9vdC5jb25uZWN0ZWRFZGdlcygnZWRnZVtzb3VyY2UgPSBcIicgKyByb290LmlkKCkgKyAnXCJdJykuaW50ZXJzZWN0aW9uKCBjYWxsaW5nRWxlcyApO1xuICAgICAgICB2YXIga19pbiA9IGluY29taW5nLmxlbmd0aDtcbiAgICAgICAgdmFyIGtfb3V0ID0gb3V0Z29pbmcubGVuZ3RoO1xuICAgICAgICB2YXIgc19pbiA9IDA7XG4gICAgICAgIHZhciBzX291dCA9IDA7XG5cbiAgICAgICAgLy8gTm93LCBzdW0gaW5jb21pbmcgZWRnZSB3ZWlnaHRzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5jb21pbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWRnZSA9IGluY29taW5nW2ldO1xuICAgICAgICAgIHNfaW4gKz0gd2VpZ2h0Rm4uYXBwbHkoZWRnZSwgW2VkZ2VdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdywgc3VtIG91dGdvaW5nIGVkZ2Ugd2VpZ2h0c1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dGdvaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVkZ2UgPSBvdXRnb2luZ1tpXTtcbiAgICAgICAgICBzX291dCArPSB3ZWlnaHRGbi5hcHBseShlZGdlLCBbZWRnZV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpbmRlZ3JlZTogTWF0aC5wb3coa19pbiwgMSAtIGFscGhhKSAqIE1hdGgucG93KHNfaW4sIGFscGhhKSxcbiAgICAgICAgICBvdXRkZWdyZWU6IE1hdGgucG93KGtfb3V0LCAxIC0gYWxwaGEpICogTWF0aC5wb3coc19vdXQsIGFscGhhKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIC8vIGRlZ3JlZUNlbnRyYWxpdHlcblxuICAgIC8vIG9wdGlvbnMgPT4gb3B0aW9ucyBvYmplY3RcbiAgICAvLyAgIHdlaWdodDogZnVuY3Rpb24oIGVkZ2UgKXt9IC8vIHNwZWNpZmllcyB3ZWlnaHQgdG8gdXNlIGZvciBgZWRnZWAvYHRoaXNgLiBJZiBub3QgcHJlc2VudCwgaXQgd2lsbCBiZSBhc3VtZWQgYSB3ZWlnaHQgb2YgMSBmb3IgYWxsIGVkZ2VzXG4gICAgLy8gICBkaXJlY3RlZCAvLyBkZWZhdWx0IGZhbHNlXG4gICAgLy8gICBoYXJtb25pYyAvLyB1c2UgaGFybW9uaWMgbWVhbiBpbnN0ZWFkIG9mIGFyaXRobWV0aWMgbWVhblxuICAgIC8vIHJldE9iaiA9PiByZXR1cm5lZCBvYmplY3QgYnkgZnVuY3Rpb25cbiAgICAvLyAgIGNsb3NlbmVzcyA6IGZ1bmN0aW9uKG5vZGUpIC8vIFJldHVybnMgdGhlIG5vcm1hbGl6ZWQgY2xvc2VuZXNzIG9mIHRoZSBnaXZlbiBub2RlXG4gICAgY2xvc2VuZXNzQ2VudHJhbGl0eU5vcm1hbGl6ZWQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgLy8gdmFyIGxvZ0RlYnVnID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gICBpZiAoZGVidWcpIHtcbiAgICAgIC8vICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgICAgLy8gICB9XG4gICAgICAvLyB9O1xuXG4gICAgICAvLyBQYXJzZSBvcHRpb25zXG4gICAgICAvLyBkZWJ1ZyAtIG9wdGlvbmFsXG4gICAgICAvLyBpZiAob3B0aW9ucy5kZWJ1ZyAhPSBudWxsKSB7XG4gICAgICAvLyAgIHZhciBkZWJ1ZyA9IG9wdGlvbnMuZGVidWc7XG4gICAgICAvLyB9IGVsc2Uge1xuICAgICAgLy8gICB2YXIgZGVidWcgPSBmYWxzZTtcbiAgICAgIC8vIH1cblxuICAgICAgLy8gbG9nRGVidWcoXCJTdGFydGluZyBjbG9zZW5lc3MgY2VudHJhbGl0eS4uLlwiKTtcblxuICAgICAgdmFyIGhhcm1vbmljID0gb3B0aW9ucy5oYXJtb25pYztcbiAgICAgIGlmKCBoYXJtb25pYyA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgIGhhcm1vbmljID0gdHJ1ZTtcbiAgICAgIH1cbiBcbiAgICAgIHZhciBjbG9zZW5lc3NlcyA9IHt9O1xuICAgICAgdmFyIG1heENsb3NlbmVzcyA9IDA7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgICB2YXIgZncgPSB0aGlzLmZsb3lkV2Fyc2hhbGwoeyB3ZWlnaHQ6IG9wdGlvbnMud2VpZ2h0LCBkaXJlY3RlZDogb3B0aW9ucy5kaXJlY3RlZCB9KTtcblxuICAgICAgLy8gQ29tcHV0ZSBjbG9zZW5lc3MgZm9yIGV2ZXJ5IG5vZGUgYW5kIGZpbmQgdGhlIG1heGltdW0gY2xvc2VuZXNzXG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgY3VyckNsb3NlbmVzcyA9IDA7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAoaSAhPSBqKSB7XG4gICAgICAgICAgICB2YXIgZCA9IGZ3LmRpc3RhbmNlKG5vZGVzW2ldLCBub2Rlc1tqXSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKCBoYXJtb25pYyApe1xuICAgICAgICAgICAgICBjdXJyQ2xvc2VuZXNzICs9IDEgLyBkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY3VyckNsb3NlbmVzcyArPSBkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoICFoYXJtb25pYyApe1xuICAgICAgICAgIGN1cnJDbG9zZW5lc3MgPSAxIC8gY3VyckNsb3NlbmVzcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXhDbG9zZW5lc3MgPCBjdXJyQ2xvc2VuZXNzKXtcbiAgICAgICAgICBtYXhDbG9zZW5lc3MgPSBjdXJyQ2xvc2VuZXNzO1xuICAgICAgICB9XG5cbiAgICAgICAgY2xvc2VuZXNzZXNbbm9kZXNbaV0uaWQoKV0gPSBjdXJyQ2xvc2VuZXNzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjbG9zZW5lc3M6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgaWYgKCQkLmlzLnN0cmluZyhub2RlKSkge1xuICAgICAgICAgICAgLy8gZnJvbSBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgICAgdmFyIG5vZGUgPSAoY3kuZmlsdGVyKG5vZGUpWzBdKS5pZCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBmcm9tIGlzIGEgbm9kZVxuICAgICAgICAgICAgdmFyIG5vZGUgPSBub2RlLmlkKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNsb3NlbmVzc2VzW25vZGVdIC8gbWF4Q2xvc2VuZXNzO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgLy8gSW1wbGVtZW50ZWQgZnJvbSBwc2V1ZG9jb2RlIGZyb20gd2lraXBlZGlhXG4gICAgLy8gb3B0aW9ucyA9PiBvcHRpb25zIG9iamVjdFxuICAgIC8vICAgcm9vdCA6IGZvY2FsIG5vZGVcbiAgICAvLyAgIHdlaWdodDogZnVuY3Rpb24oIGVkZ2UgKXt9IC8vIHNwZWNpZmllcyB3ZWlnaHQgdG8gdXNlIGZvciBgZWRnZWAvYHRoaXNgLiBJZiBub3QgcHJlc2VudCwgaXQgd2lsbCBiZSBhc3VtZWQgYSB3ZWlnaHQgb2YgMSBmb3IgYWxsIGVkZ2VzXG4gICAgLy8gICBkaXJlY3RlZCAvLyBkZWZhdWx0IGZhbHNlXG4gICAgLy8gY2xvc2VuZXNzID0+IHJldHVybmVkIHZhbHVlIGJ5IHRoZSBmdW5jdGlvbi4gQ2xvc2VuZXNzIHZhbHVlIG9mIHRoZSBnaXZlbiBub2RlLlxuICAgIGNsb3NlbmVzc0NlbnRyYWxpdHk6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgLy8gdmFyIGxvZ0RlYnVnID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gICBpZiAoZGVidWcpIHtcbiAgICAgIC8vICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgICAgLy8gICB9XG4gICAgICAvLyB9O1xuXG4gICAgICAvLyBQYXJzZSBvcHRpb25zXG4gICAgICAvLyBkZWJ1ZyAtIG9wdGlvbmFsXG4gICAgICAvLyBpZiAob3B0aW9ucy5kZWJ1ZyAhPSBudWxsKSB7XG4gICAgICAvLyAgIHZhciBkZWJ1ZyA9IG9wdGlvbnMuZGVidWc7XG4gICAgICAvLyB9IGVsc2Uge1xuICAgICAgLy8gICB2YXIgZGVidWcgPSBmYWxzZTtcbiAgICAgIC8vIH1cblxuICAgICAgLy8gbG9nRGVidWcoXCJTdGFydGluZyBjbG9zZW5lc3MgY2VudHJhbGl0eS4uLlwiKTtcblxuICAgICAgLy8gcm9vdCAtIG1hbmRhdG9yeSFcbiAgICAgIGlmIChvcHRpb25zLnJvb3QgIT0gbnVsbCkge1xuICAgICAgICBpZiAoJCQuaXMuc3RyaW5nKG9wdGlvbnMucm9vdCkpIHtcbiAgICAgICAgICAvLyB1c2UgaXQgYXMgYSBzZWxlY3RvciwgZS5nLiBcIiNyb290SURcbiAgICAgICAgICB2YXIgcm9vdCA9IHRoaXMuZmlsdGVyKG9wdGlvbnMucm9vdClbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJvb3QgPSBvcHRpb25zLnJvb3RbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG9nRGVidWcoXCJTb3VyY2Ugbm9kZTogJXNcIiwgcm9vdC5pZCgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICQkLnV0aWwuZXJyb3IoXCJvcHRpb25zLnJvb3QgcmVxdWlyZWRcIik7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIHdlaWdodCAtIG9wdGlvbmFsXG4gICAgICBpZiAob3B0aW9ucy53ZWlnaHQgIT0gbnVsbCAmJiAkJC5pcy5mbihvcHRpb25zLndlaWdodCkpIHtcbiAgICAgICAgdmFyIHdlaWdodCA9IG9wdGlvbnMud2VpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHdlaWdodCA9IGZ1bmN0aW9uKCl7cmV0dXJuIDE7fTtcbiAgICAgIH1cblxuICAgICAgLy8gZGlyZWN0ZWQgLSBvcHRpb25hbFxuICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0ZWQgIT0gbnVsbCAmJiAkJC5pcy5ib29sKG9wdGlvbnMuZGlyZWN0ZWQpKSB7XG4gICAgICAgIHZhciBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZGlyZWN0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIGhhcm1vbmljID0gb3B0aW9ucy5oYXJtb25pYztcbiAgICAgIGlmKCBoYXJtb25pYyA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgIGhhcm1vbmljID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gd2UgbmVlZCBkaXN0YW5jZSBmcm9tIHRoaXMgbm9kZSB0byBldmVyeSBvdGhlciBub2RlXG4gICAgICB2YXIgZGlqa3N0cmEgPSB0aGlzLmRpamtzdHJhKHtcbiAgICAgICAgcm9vdDogcm9vdCxcbiAgICAgICAgd2VpZ2h0OiB3ZWlnaHQsXG4gICAgICAgIGRpcmVjdGVkOiBkaXJlY3RlZFxuICAgICAgfSk7XG4gICAgICB2YXIgdG90YWxEaXN0YW5jZSA9IDA7XG5cbiAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICBpZiAobm9kZXNbaV0uaWQoKSAhPSByb290LmlkKCkpe1xuICAgICAgICAgIHZhciBkID0gZGlqa3N0cmEuZGlzdGFuY2VUbyhub2Rlc1tpXSk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYoIGhhcm1vbmljICl7XG4gICAgICAgICAgICB0b3RhbERpc3RhbmNlICs9IDEgLyBkOyBcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG90YWxEaXN0YW5jZSArPSBkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFybW9uaWMgPyB0b3RhbERpc3RhbmNlIDogMSAvIHRvdGFsRGlzdGFuY2U7XG4gICAgfSwgLy8gY2xvc2VuZXNzQ2VudHJhbGl0eVxuXG4gICAgLy8gSW1wbGVtZW50ZWQgZnJvbSB0aGUgYWxnb3JpdGhtIGluIHRoZSBwYXBlciBcIk9uIFZhcmlhbnRzIG9mIFNob3J0ZXN0LVBhdGggQmV0d2Vlbm5lc3MgQ2VudHJhbGl0eSBhbmQgdGhlaXIgR2VuZXJpYyBDb21wdXRhdGlvblwiIGJ5IFVscmlrIEJyYW5kZXNcbiAgICAvLyBvcHRpb25zID0+IG9wdGlvbnMgb2JqZWN0XG4gICAgLy8gICB3ZWlnaHQ6IGZ1bmN0aW9uKCBlZGdlICl7fSAvLyBzcGVjaWZpZXMgd2VpZ2h0IHRvIHVzZSBmb3IgYGVkZ2VgL2B0aGlzYC4gSWYgbm90IHByZXNlbnQsIGl0IHdpbGwgYmUgYXN1bWVkIGEgd2VpZ2h0IG9mIDEgZm9yIGFsbCBlZGdlc1xuICAgIC8vICAgZGlyZWN0ZWQgLy8gZGVmYXVsdCBmYWxzZVxuICAgIC8vIHJldE9iaiA9PiByZXR1cm5lZCBvYmplY3QgYnkgZnVuY3Rpb25cbiAgICAvLyAgIGJldHdlZW5uZXNzIDogZnVuY3Rpb24obm9kZSkgLy8gUmV0dXJucyB0aGUgYmV0d2Vlbm5lc3MgY2VudHJhbGl0eSBvZiB0aGUgZ2l2ZW4gbm9kZVxuICAgIC8vICAgYmV0d2Vlbm5lc3NOb3JtYWxpemVkIDogZnVuY3Rpb24obm9kZSkgLy8gUmV0dXJucyB0aGUgbm9ybWFsaXplZCBiZXR3ZWVubmVzcyBjZW50cmFsaXR5IG9mIHRoZSBnaXZlbiBub2RlXG4gICAgYmV0d2Vlbm5lc3NDZW50cmFsaXR5OiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgIC8vIHZhciBsb2dEZWJ1ZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vICAgaWYgKGRlYnVnKSB7XG4gICAgICAvLyAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgIC8vICAgfVxuICAgICAgLy8gfTtcblxuICAgICAgLy8gUGFyc2Ugb3B0aW9uc1xuICAgICAgLy8gZGVidWcgLSBvcHRpb25hbFxuICAgICAgLy8gaWYgKG9wdGlvbnMuZGVidWcgIT0gbnVsbCkge1xuICAgICAgLy8gICB2YXIgZGVidWcgPSBvcHRpb25zLmRlYnVnO1xuICAgICAgLy8gfSBlbHNlIHtcbiAgICAgIC8vICAgdmFyIGRlYnVnID0gZmFsc2U7XG4gICAgICAvLyB9XG5cbiAgICAgIC8vIGxvZ0RlYnVnKFwiU3RhcnRpbmcgYmV0d2Vlbm5lc3MgY2VudHJhbGl0eS4uLlwiKTtcblxuICAgICAgLy8gV2VpZ2h0IC0gb3B0aW9uYWxcbiAgICAgIGlmIChvcHRpb25zLndlaWdodCAhPSBudWxsICYmICQkLmlzLmZuKG9wdGlvbnMud2VpZ2h0KSkge1xuICAgICAgICB2YXIgd2VpZ2h0Rm4gPSBvcHRpb25zLndlaWdodDtcbiAgICAgICAgdmFyIHdlaWdodGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB3ZWlnaHRlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBEaXJlY3RlZCAtIGRlZmF1bHQgZmFsc2VcbiAgICAgIGlmIChvcHRpb25zLmRpcmVjdGVkICE9IG51bGwgJiYgJCQuaXMuYm9vbChvcHRpb25zLmRpcmVjdGVkKSkge1xuICAgICAgICB2YXIgZGlyZWN0ZWQgPSBvcHRpb25zLmRpcmVjdGVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGRpcmVjdGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmlvcml0eUluc2VydCA9IGZ1bmN0aW9uIChxdWV1ZSwgZWxlKSB7XG4gICAgICAgIHF1ZXVlLnVuc2hpZnQoZWxlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGRbcXVldWVbaV1dIDwgZFtxdWV1ZVtpICsgMV1dICYmIGkgPCBxdWV1ZS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICB2YXIgdG1wID0gcXVldWVbaV07XG4gICAgICAgICAgcXVldWVbaV0gPSBxdWV1ZVtpICsgMV07XG4gICAgICAgICAgcXVldWVbaSArIDFdID0gdG1wO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgICAvLyBzdGFydGluZ1xuICAgICAgdmFyIFYgPSB0aGlzLm5vZGVzKCk7XG4gICAgICB2YXIgQSA9IHt9O1xuICAgICAgdmFyIEMgPSB7fTtcblxuICAgICAgLy8gQSBjb250YWlucyB0aGUgbmVpZ2hib3Job29kcyBvZiBldmVyeSBub2RlXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGRpcmVjdGVkKSB7XG4gICAgICAgICAgQVtWW2ldLmlkKCldID0gVltpXS5vdXRnb2VycyhcIm5vZGVcIik7IC8vIGdldCBvdXRnb2VycyBvZiBldmVyeSBub2RlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgQVtWW2ldLmlkKCldID0gVltpXS5vcGVuTmVpZ2hib3Job29kKFwibm9kZVwiKTsgLy8gZ2V0IG5laWdoYm9ycyBvZiBldmVyeSBub2RlICAgICAgICAgIFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEMgY29udGFpbnMgdGhlIGJldHdlZW5uZXNzIHZhbHVlc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBWLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIENbVltpXS5pZCgpXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgVi5sZW5ndGg7IHMrKykge1xuICAgICAgICB2YXIgUyA9IFtdOyAvLyBzdGFja1xuICAgICAgICB2YXIgUCA9IHt9O1xuICAgICAgICB2YXIgZyA9IHt9O1xuICAgICAgICB2YXIgZCA9IHt9O1xuICAgICAgICB2YXIgUSA9IFtdOyAvLyBxdWV1ZVxuXG4gICAgICAgIC8vIGluaXQgZGljdGlvbmFyaWVzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgVi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIFBbVltpXS5pZCgpXSA9IFtdO1xuICAgICAgICAgIGdbVltpXS5pZCgpXSA9IDA7XG4gICAgICAgICAgZFtWW2ldLmlkKCldID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICB9XG5cbiAgICAgICAgZ1tWW3NdLmlkKCldID0gMTsgLy8gc2lnbWFcbiAgICAgICAgZFtWW3NdLmlkKCldID0gMDsgLy8gZGlzdGFuY2UgdG8gc1xuXG4gICAgICAgIFEudW5zaGlmdChWW3NdLmlkKCkpO1xuXG4gICAgICAgIHdoaWxlIChRLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgdiA9IFEucG9wKCk7XG4gICAgICAgICAgUy5wdXNoKHYpO1xuICAgICAgICAgIGlmICh3ZWlnaHRlZCkge1xuICAgICAgICAgICAgQVt2XS5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7XG4gICAgICAgICAgICAgIGlmIChjeS4kKCcjJyArIHYpLmVkZ2VzVG8odykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBlZGdlID0gY3kuJCgnIycgKyB2KS5lZGdlc1RvKHcpWzBdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBlZGdlID0gdy5lZGdlc1RvKCcjJyArIHYpWzBdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICB2YXIgZWRnZVdlaWdodCA9IHdlaWdodEZuLmFwcGx5KGVkZ2UsIFtlZGdlXSk7XG5cbiAgICAgICAgICAgICAgaWYgKGRbdy5pZCgpXSA+IGRbdl0gKyBlZGdlV2VpZ2h0KSB7XG4gICAgICAgICAgICAgICAgZFt3LmlkKCldID0gZFt2XSArIGVkZ2VXZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKFEuaW5kZXhPZih3LmlkKCkpIDwgMCkgeyAvL2lmIHcgaXMgbm90IGluIFFcbiAgICAgICAgICAgICAgICAgIHByaW9yaXR5SW5zZXJ0KFEsIHcuaWQoKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gdXBkYXRlIHBvc2l0aW9uIGlmIHcgaXMgaW4gUVxuICAgICAgICAgICAgICAgICAgUS5zcGxpY2UoUS5pbmRleE9mKHcuaWQoKSksIDEpO1xuICAgICAgICAgICAgICAgICAgcHJpb3JpdHlJbnNlcnQoUSwgdy5pZCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ1t3LmlkKCldID0gMDtcbiAgICAgICAgICAgICAgICBQW3cuaWQoKV0gPSBbXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZFt3LmlkKCldID09IGRbdl0gKyBlZGdlV2VpZ2h0KSB7XG4gICAgICAgICAgICAgICAgZ1t3LmlkKCldID0gZ1t3LmlkKCldICsgZ1t2XTtcbiAgICAgICAgICAgICAgICBQW3cuaWQoKV0ucHVzaCh2KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEFbdl0uZm9yRWFjaChmdW5jdGlvbiAodykge1xuICAgICAgICAgICAgICBpZiAoZFt3LmlkKCldID09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkge1xuICAgICAgICAgICAgICAgIFEudW5zaGlmdCh3LmlkKCkpO1xuICAgICAgICAgICAgICAgIGRbdy5pZCgpXSA9IGRbdl0gKyAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChkW3cuaWQoKV0gPT0gZFt2XSArIDEpIHtcbiAgICAgICAgICAgICAgICBnW3cuaWQoKV0gPSBnW3cuaWQoKV0gKyBnW3ZdO1xuICAgICAgICAgICAgICAgIFBbdy5pZCgpXS5wdXNoKHYpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZSA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBlW1ZbaV0uaWQoKV0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKFMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciB3ID0gUy5wb3AoKTtcbiAgICAgICAgICBQW3ddLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIGVbdl0gPSBlW3ZdICsgKGdbdl0gLyBnW3ddKSAqICgxICsgZVt3XSk7XG4gICAgICAgICAgICBpZiAodyAhPSBWW3NdLmlkKCkpXG4gICAgICAgICAgICAgIENbd10gPSBDW3ddICsgZVt3XTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbWF4ID0gMDtcbiAgICAgIGZvciAodmFyIGtleSBpbiBDKSB7XG4gICAgICAgIGlmIChtYXggPCBDW2tleV0pXG4gICAgICAgICAgbWF4ID0gQ1trZXldO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmV0ID0ge1xuICAgICAgICBiZXR3ZWVubmVzczogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICBpZiAoJCQuaXMuc3RyaW5nKG5vZGUpKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IChjeS5maWx0ZXIobm9kZSlbMF0pLmlkKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gbm9kZS5pZCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBDW25vZGVdO1xuICAgICAgICB9LFxuXG4gICAgICAgIGJldHdlZW5uZXNzTm9ybWFsaXplZDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICBpZiAoJCQuaXMuc3RyaW5nKG5vZGUpKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IChjeS5maWx0ZXIobm9kZSlbMF0pLmlkKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gbm9kZS5pZCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBDW25vZGVdIC8gbWF4O1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBhbGlhc1xuICAgICAgcmV0LmJldHdlZW5uZXNzTm9ybWFsaXNlZCA9IHJldC5iZXR3ZWVubmVzc05vcm1hbGl6ZWQ7XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSAvLyBiZXR3ZWVubmVzc0NlbnRyYWxpdHlcbiAgfSk7IC8vICQkLmZuLmVsZXNcblxuICAvLyBuaWNlLCBzaG9ydCBtYXRoZW1hdGhpY2FsIGFsaWFzXG4gICQkLmVsZXNmbi5kYyA9ICQkLmVsZXNmbi5kZWdyZWVDZW50cmFsaXR5O1xuICAkJC5lbGVzZm4uZGNuID0gJCQuZWxlc2ZuLmRlZ3JlZUNlbnRyYWxpdHlOb3JtYWxpc2VkID0gJCQuZWxlc2ZuLmRlZ3JlZUNlbnRyYWxpdHlOb3JtYWxpemVkO1xuICAkJC5lbGVzZm4uY2MgPSAkJC5lbGVzZm4uY2xvc2VuZXNzQ2VudHJhbGl0eTtcbiAgJCQuZWxlc2ZuLmNjbiA9ICQkLmVsZXNmbi5jbG9zZW5lc3NDZW50cmFsaXR5Tm9ybWFsaXNlZCA9ICQkLmVsZXNmbi5jbG9zZW5lc3NDZW50cmFsaXR5Tm9ybWFsaXplZDtcbiAgJCQuZWxlc2ZuLmJjID0gJCQuZWxlc2ZuLmJldHdlZW5uZXNzQ2VudHJhbGl0eTtcbn0pIChjeXRvc2NhcGUpO1xuXG47KGZ1bmN0aW9uKCAkJCApeyAndXNlIHN0cmljdCc7XG5cbiAgJCQuZm4uZWxlcyh7XG4gICAgYW5pbWF0ZWQ6ICQkLmRlZmluZS5hbmltYXRlZCgpLFxuICAgIGNsZWFyUXVldWU6ICQkLmRlZmluZS5jbGVhclF1ZXVlKCksXG4gICAgZGVsYXk6ICQkLmRlZmluZS5kZWxheSgpLFxuICAgIGFuaW1hdGU6ICQkLmRlZmluZS5hbmltYXRlKCksXG4gICAgc3RvcDogJCQuZGVmaW5lLnN0b3AoKVxuICB9KTtcbiAgXG59KSggY3l0b3NjYXBlICk7ICBcblxuOyhmdW5jdGlvbiggJCQgKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgJCQuZm4uZWxlcyh7XG4gICAgYWRkQ2xhc3M6IGZ1bmN0aW9uKGNsYXNzZXMpe1xuICAgICAgY2xhc3NlcyA9IGNsYXNzZXMuc3BsaXQoL1xccysvKTtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBjaGFuZ2VkID0gW107XG4gICAgICBcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY2xhc3Nlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgY2xzID0gY2xhc3Nlc1tpXTtcbiAgICAgICAgaWYoICQkLmlzLmVtcHR5U3RyaW5nKGNscykgKXsgY29udGludWU7IH1cbiAgICAgICAgXG4gICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgc2VsZi5sZW5ndGg7IGorKyApe1xuICAgICAgICAgIHZhciBlbGUgPSBzZWxmW2pdO1xuICAgICAgICAgIHZhciBoYXNDbGFzcyA9IGVsZS5fcHJpdmF0ZS5jbGFzc2VzW2Nsc107XG4gICAgICAgICAgZWxlLl9wcml2YXRlLmNsYXNzZXNbY2xzXSA9IHRydWU7XG5cbiAgICAgICAgICBpZiggIWhhc0NsYXNzICl7IC8vIGlmIGRpZG4ndCBhbHJlYWR5IGhhdmUsIGFkZCB0byBsaXN0IG9mIGNoYW5nZWRcbiAgICAgICAgICAgIGNoYW5nZWQucHVzaCggZWxlICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIHRyaWdnZXIgdXBkYXRlIHN0eWxlIG9uIHRob3NlIGVsZXMgdGhhdCBoYWQgY2xhc3MgY2hhbmdlc1xuICAgICAgaWYoIGNoYW5nZWQubGVuZ3RoID4gMCApe1xuICAgICAgICBuZXcgJCQuQ29sbGVjdGlvbih0aGlzLl9wcml2YXRlLmN5LCBjaGFuZ2VkKVxuICAgICAgICAgIC51cGRhdGVTdHlsZSgpXG4gICAgICAgICAgLnRyaWdnZXIoJ2NsYXNzJylcbiAgICAgICAgO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgaGFzQ2xhc3M6IGZ1bmN0aW9uKGNsYXNzTmFtZSl7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICAgIHJldHVybiAoIGVsZSAhPSBudWxsICYmIGVsZS5fcHJpdmF0ZS5jbGFzc2VzW2NsYXNzTmFtZV0gKSA/IHRydWUgOiBmYWxzZTtcbiAgICB9LFxuXG4gICAgdG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKGNsYXNzZXNTdHIsIHRvZ2dsZSl7XG4gICAgICB2YXIgY2xhc3NlcyA9IGNsYXNzZXNTdHIuc3BsaXQoL1xccysvKTtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBjaGFuZ2VkID0gW107IC8vIGVsZXMgd2hvIGhhZCBjbGFzc2VzIGNoYW5nZWRcbiAgICAgIFxuICAgICAgZm9yKCB2YXIgaSA9IDAsIGlsID0gc2VsZi5sZW5ndGg7IGkgPCBpbDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSBzZWxmW2ldO1xuXG4gICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgY2xhc3Nlcy5sZW5ndGg7IGorKyApe1xuICAgICAgICAgIHZhciBjbHMgPSBjbGFzc2VzW2pdO1xuXG4gICAgICAgICAgaWYoICQkLmlzLmVtcHR5U3RyaW5nKGNscykgKXsgY29udGludWU7IH1cbiAgICAgICAgICBcbiAgICAgICAgICB2YXIgaGFzQ2xhc3MgPSBlbGUuX3ByaXZhdGUuY2xhc3Nlc1tjbHNdO1xuICAgICAgICAgIHZhciBzaG91bGRBZGQgPSB0b2dnbGUgfHwgKHRvZ2dsZSA9PT0gdW5kZWZpbmVkICYmICFoYXNDbGFzcyk7XG5cbiAgICAgICAgICBpZiggc2hvdWxkQWRkICl7XG4gICAgICAgICAgICBlbGUuX3ByaXZhdGUuY2xhc3Nlc1tjbHNdID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYoICFoYXNDbGFzcyApeyBjaGFuZ2VkLnB1c2goZWxlKTsgfVxuICAgICAgICAgIH0gZWxzZSB7IC8vIHRoZW4gcmVtb3ZlXG4gICAgICAgICAgICBlbGUuX3ByaXZhdGUuY2xhc3Nlc1tjbHNdID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmKCBoYXNDbGFzcyApeyBjaGFuZ2VkLnB1c2goZWxlKTsgfVxuICAgICAgICAgIH1cblxuICAgICAgICB9IC8vIGZvciBqIGNsYXNzZXNcbiAgICAgIH0gLy8gZm9yIGkgZWxlc1xuICAgICAgXG4gICAgICAvLyB0cmlnZ2VyIHVwZGF0ZSBzdHlsZSBvbiB0aG9zZSBlbGVzIHRoYXQgaGFkIGNsYXNzIGNoYW5nZXNcbiAgICAgIGlmKCBjaGFuZ2VkLmxlbmd0aCA+IDAgKXtcbiAgICAgICAgbmV3ICQkLkNvbGxlY3Rpb24odGhpcy5fcHJpdmF0ZS5jeSwgY2hhbmdlZClcbiAgICAgICAgICAudXBkYXRlU3R5bGUoKVxuICAgICAgICAgIC50cmlnZ2VyKCdjbGFzcycpXG4gICAgICAgIDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIHJlbW92ZUNsYXNzOiBmdW5jdGlvbihjbGFzc2VzKXtcbiAgICAgIGNsYXNzZXMgPSBjbGFzc2VzLnNwbGl0KC9cXHMrLyk7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgY2hhbmdlZCA9IFtdO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IHNlbGZbaV07XG5cbiAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBjbGFzc2VzLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgdmFyIGNscyA9IGNsYXNzZXNbal07XG4gICAgICAgICAgaWYoICFjbHMgfHwgY2xzID09PSAnJyApeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgdmFyIGhhc0NsYXNzID0gZWxlLl9wcml2YXRlLmNsYXNzZXNbY2xzXTtcbiAgICAgICAgICBlbGUuX3ByaXZhdGUuY2xhc3Nlc1tjbHNdID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgaWYoIGhhc0NsYXNzICl7IC8vIHRoZW4gd2UgY2hhbmdlZCBpdHMgc2V0IG9mIGNsYXNzZXNcbiAgICAgICAgICAgIGNoYW5nZWQucHVzaCggZWxlICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIHRyaWdnZXIgdXBkYXRlIHN0eWxlIG9uIHRob3NlIGVsZXMgdGhhdCBoYWQgY2xhc3MgY2hhbmdlc1xuICAgICAgaWYoIGNoYW5nZWQubGVuZ3RoID4gMCApe1xuICAgICAgICBuZXcgJCQuQ29sbGVjdGlvbihzZWxmLl9wcml2YXRlLmN5LCBjaGFuZ2VkKS51cGRhdGVTdHlsZSgpO1xuICAgICAgfVxuXG4gICAgICBzZWxmLnRyaWdnZXIoJ2NsYXNzJyk7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgZmxhc2hDbGFzczogZnVuY3Rpb24oY2xhc3NlcywgZHVyYXRpb24pe1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICBpZiggZHVyYXRpb24gPT0gbnVsbCApe1xuICAgICAgICBkdXJhdGlvbiA9IDI1MDtcbiAgICAgIH0gZWxzZSBpZiggZHVyYXRpb24gPT09IDAgKXtcbiAgICAgICAgcmV0dXJuIHNlbGY7IC8vIG5vdGhpbmcgdG8gZG8gcmVhbGx5XG4gICAgICB9XG5cbiAgICAgIHNlbGYuYWRkQ2xhc3MoIGNsYXNzZXMgKTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgc2VsZi5yZW1vdmVDbGFzcyggY2xhc3NlcyApO1xuICAgICAgfSwgZHVyYXRpb24pO1xuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIH0pO1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICAkJC5mbi5lbGVzKHtcbiAgICBhbGxBcmU6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKHNlbGVjdG9yKS5sZW5ndGggPT09IHRoaXMubGVuZ3RoO1xuICAgIH0sXG5cbiAgICBpczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoc2VsZWN0b3IpLmxlbmd0aCA+IDA7XG4gICAgfSxcblxuICAgIHNvbWU6IGZ1bmN0aW9uKCBmbiwgdGhpc0FyZyApe1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciByZXQgPSAhdGhpc0FyZyA/IGZuKCB0aGlzW2ldLCBpLCB0aGlzICkgOiBmbi5hcHBseSggdGhpc0FyZywgWyB0aGlzW2ldLCBpLCB0aGlzIF0gKTtcblxuICAgICAgICBpZiggcmV0ICl7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBldmVyeTogZnVuY3Rpb24oIGZuLCB0aGlzQXJnICl7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIHJldCA9ICF0aGlzQXJnID8gZm4oIHRoaXNbaV0sIGksIHRoaXMgKSA6IGZuLmFwcGx5KCB0aGlzQXJnLCBbIHRoaXNbaV0sIGksIHRoaXMgXSApO1xuXG4gICAgICAgIGlmKCAhcmV0ICl7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICBzYW1lOiBmdW5jdGlvbiggY29sbGVjdGlvbiApe1xuICAgICAgY29sbGVjdGlvbiA9IHRoaXMuY3koKS5jb2xsZWN0aW9uKCBjb2xsZWN0aW9uICk7XG5cbiAgICAgIC8vIGNoZWFwIGV4dHJhIGNoZWNrXG4gICAgICBpZiggdGhpcy5sZW5ndGggIT09IGNvbGxlY3Rpb24ubGVuZ3RoICl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuaW50ZXJzZWN0KCBjb2xsZWN0aW9uICkubGVuZ3RoID09PSB0aGlzLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgYW55U2FtZTogZnVuY3Rpb24oIGNvbGxlY3Rpb24gKXtcbiAgICAgIGNvbGxlY3Rpb24gPSB0aGlzLmN5KCkuY29sbGVjdGlvbiggY29sbGVjdGlvbiApO1xuXG4gICAgICByZXR1cm4gdGhpcy5pbnRlcnNlY3QoIGNvbGxlY3Rpb24gKS5sZW5ndGggPiAwO1xuICAgIH0sXG5cbiAgICBhbGxBcmVOZWlnaGJvcnM6IGZ1bmN0aW9uKCBjb2xsZWN0aW9uICl7XG4gICAgICBjb2xsZWN0aW9uID0gdGhpcy5jeSgpLmNvbGxlY3Rpb24oIGNvbGxlY3Rpb24gKTtcblxuICAgICAgcmV0dXJuIHRoaXMubmVpZ2hib3Job29kKCkuaW50ZXJzZWN0KCBjb2xsZWN0aW9uICkubGVuZ3RoID09PSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICB9XG4gIH0pO1xuXG4gICQkLmVsZXNmbi5hbGxBcmVOZWlnaGJvdXJzID0gJCQuZWxlc2ZuLmFsbEFyZU5laWdoYm9ycztcbiAgXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgLy8gQ29tcG91bmQgZnVuY3Rpb25zXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICQkLmZuLmVsZXMoe1xuICAgIHBhcmVudDogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICB2YXIgcGFyZW50cyA9IFtdO1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgICB2YXIgcGFyZW50ID0gY3kuZ2V0RWxlbWVudEJ5SWQoIGVsZS5fcHJpdmF0ZS5kYXRhLnBhcmVudCApO1xuXG4gICAgICAgIGlmKCBwYXJlbnQuc2l6ZSgpID4gMCApe1xuICAgICAgICAgIHBhcmVudHMucHVzaCggcGFyZW50ICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgcGFyZW50cywgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9LFxuXG4gICAgcGFyZW50czogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICB2YXIgcGFyZW50cyA9IFtdO1xuXG4gICAgICB2YXIgZWxlcyA9IHRoaXMucGFyZW50KCk7XG4gICAgICB3aGlsZSggZWxlcy5ub25lbXB0eSgpICl7XG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICAgIHBhcmVudHMucHVzaCggZWxlICk7XG4gICAgICAgIH1cblxuICAgICAgICBlbGVzID0gZWxlcy5wYXJlbnQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCB0aGlzLmN5KCksIHBhcmVudHMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfSxcblxuICAgIGNvbW1vbkFuY2VzdG9yczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICB2YXIgYW5jZXN0b3JzO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICAgIHZhciBwYXJlbnRzID0gZWxlLnBhcmVudHMoKTtcbiAgICAgICAgXG4gICAgICAgIGFuY2VzdG9ycyA9IGFuY2VzdG9ycyB8fCBwYXJlbnRzO1xuXG4gICAgICAgIGFuY2VzdG9ycyA9IGFuY2VzdG9ycy5pbnRlcnNlY3QoIHBhcmVudHMgKTsgLy8gY3VycmVudCBsaXN0IG11c3QgYmUgY29tbW9uIHdpdGggY3VycmVudCBlbGUgcGFyZW50cyBzZXRcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFuY2VzdG9ycy5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfSxcblxuICAgIG9ycGhhbnM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgcmV0dXJuIHRoaXMuc3RkRmlsdGVyKGZ1bmN0aW9uKCBlbGUgKXtcbiAgICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKSAmJiBlbGUucGFyZW50KCkuZW1wdHkoKTtcbiAgICAgIH0pLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9LFxuXG4gICAgbm9ub3JwaGFuczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICByZXR1cm4gdGhpcy5zdGRGaWx0ZXIoZnVuY3Rpb24oIGVsZSApe1xuICAgICAgICByZXR1cm4gZWxlLmlzTm9kZSgpICYmIGVsZS5wYXJlbnQoKS5ub25lbXB0eSgpO1xuICAgICAgfSkuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgIH0sXG5cbiAgICBjaGlsZHJlbjogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmNvbmNhdCggZWxlLl9wcml2YXRlLmNoaWxkcmVuICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggdGhpcy5jeSgpLCBjaGlsZHJlbiwgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9LFxuXG4gICAgc2libGluZ3M6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50KCkuY2hpbGRyZW4oKS5ub3QoIHRoaXMgKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfSxcblxuICAgIGlzUGFyZW50OiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5jaGlsZHJlbi5sZW5ndGggIT09IDA7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGlzQ2hpbGQ6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYoIGVsZSApe1xuICAgICAgICByZXR1cm4gZWxlLl9wcml2YXRlLmRhdGEucGFyZW50ICE9PSB1bmRlZmluZWQgJiYgZWxlLnBhcmVudCgpLmxlbmd0aCAhPT0gMDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZGVzY2VuZGFudHM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgdmFyIGVsZW1lbnRzID0gW107XG5cbiAgICAgIGZ1bmN0aW9uIGFkZCggZWxlcyApe1xuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgICAgICAgIGVsZW1lbnRzLnB1c2goIGVsZSApO1xuXG4gICAgICAgICAgaWYoIGVsZS5jaGlsZHJlbigpLm5vbmVtcHR5KCkgKXtcbiAgICAgICAgICAgIGFkZCggZWxlLmNoaWxkcmVuKCkgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYWRkKCB0aGlzLmNoaWxkcmVuKCkgKTtcblxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCB0aGlzLmN5KCksIGVsZW1lbnRzLCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gYWxpYXNlc1xuICAkJC5lbGVzZm4uYW5jZXN0b3JzID0gJCQuZWxlc2ZuLnBhcmVudHM7XG4gIFxufSkoIGN5dG9zY2FwZSApO1xuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgYm9yZGVyV2lkdGhNdWx0aXBsaWVyID0gMiAqIDAuNTtcbiAgdmFyIGJvcmRlcldpZHRoQWRqdXN0bWVudCA9IDA7XG5cbiAgJCQuZm4uZWxlcyh7XG5cbiAgICBkYXRhOiAkJC5kZWZpbmUuZGF0YSh7XG4gICAgICBmaWVsZDogJ2RhdGEnLFxuICAgICAgYmluZGluZ0V2ZW50OiAnZGF0YScsXG4gICAgICBhbGxvd0JpbmRpbmc6IHRydWUsXG4gICAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgICBzZXR0aW5nRXZlbnQ6ICdkYXRhJyxcbiAgICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiB0cnVlLFxuICAgICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgICAgYWxsb3dHZXR0aW5nOiB0cnVlLFxuICAgICAgaW1tdXRhYmxlS2V5czoge1xuICAgICAgICAnaWQnOiB0cnVlLFxuICAgICAgICAnc291cmNlJzogdHJ1ZSxcbiAgICAgICAgJ3RhcmdldCc6IHRydWUsXG4gICAgICAgICdwYXJlbnQnOiB0cnVlXG4gICAgICB9LFxuICAgICAgdXBkYXRlU3R5bGU6IHRydWVcbiAgICB9KSxcblxuICAgIHJlbW92ZURhdGE6ICQkLmRlZmluZS5yZW1vdmVEYXRhKHtcbiAgICAgIGZpZWxkOiAnZGF0YScsXG4gICAgICBldmVudDogJ2RhdGEnLFxuICAgICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgICAgdHJpZ2dlckV2ZW50OiB0cnVlLFxuICAgICAgaW1tdXRhYmxlS2V5czoge1xuICAgICAgICAnaWQnOiB0cnVlLFxuICAgICAgICAnc291cmNlJzogdHJ1ZSxcbiAgICAgICAgJ3RhcmdldCc6IHRydWUsXG4gICAgICAgICdwYXJlbnQnOiB0cnVlXG4gICAgICB9LFxuICAgICAgdXBkYXRlU3R5bGU6IHRydWVcbiAgICB9KSxcblxuICAgIHNjcmF0Y2g6ICQkLmRlZmluZS5kYXRhKHtcbiAgICAgIGZpZWxkOiAnc2NyYXRjaCcsXG4gICAgICBiaW5kaW5nRXZlbnQ6ICdzY3JhdGNoJyxcbiAgICAgIGFsbG93QmluZGluZzogdHJ1ZSxcbiAgICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICAgIHNldHRpbmdFdmVudDogJ3NjcmF0Y2gnLFxuICAgICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IHRydWUsXG4gICAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgICBhbGxvd0dldHRpbmc6IHRydWUsXG4gICAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICAgIH0pLFxuXG4gICAgcmVtb3ZlU2NyYXRjaDogJCQuZGVmaW5lLnJlbW92ZURhdGEoe1xuICAgICAgZmllbGQ6ICdzY3JhdGNoJyxcbiAgICAgIGV2ZW50OiAnc2NyYXRjaCcsXG4gICAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgICB0cmlnZ2VyRXZlbnQ6IHRydWUsXG4gICAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICAgIH0pLFxuXG4gICAgcnNjcmF0Y2g6ICQkLmRlZmluZS5kYXRhKHtcbiAgICAgIGZpZWxkOiAncnNjcmF0Y2gnLFxuICAgICAgYWxsb3dCaW5kaW5nOiBmYWxzZSxcbiAgICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiBmYWxzZSxcbiAgICAgIGFsbG93R2V0dGluZzogdHJ1ZVxuICAgIH0pLFxuXG4gICAgcmVtb3ZlUnNjcmF0Y2g6ICQkLmRlZmluZS5yZW1vdmVEYXRhKHtcbiAgICAgIGZpZWxkOiAncnNjcmF0Y2gnLFxuICAgICAgdHJpZ2dlckV2ZW50OiBmYWxzZVxuICAgIH0pLFxuXG4gICAgaWQ6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYoIGVsZSApe1xuICAgICAgICByZXR1cm4gZWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHBvc2l0aW9uOiAkJC5kZWZpbmUuZGF0YSh7XG4gICAgICBmaWVsZDogJ3Bvc2l0aW9uJyxcbiAgICAgIGJpbmRpbmdFdmVudDogJ3Bvc2l0aW9uJyxcbiAgICAgIGFsbG93QmluZGluZzogdHJ1ZSxcbiAgICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICAgIHNldHRpbmdFdmVudDogJ3Bvc2l0aW9uJyxcbiAgICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiB0cnVlLFxuICAgICAgdHJpZ2dlckZuTmFtZTogJ3J0cmlnZ2VyJyxcbiAgICAgIGFsbG93R2V0dGluZzogdHJ1ZSxcbiAgICAgIHZhbGlkS2V5czogWyd4JywgJ3knXSxcbiAgICAgIG9uU2V0OiBmdW5jdGlvbiggZWxlcyApe1xuICAgICAgICB2YXIgdXBkYXRlZEVsZXMgPSBlbGVzLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG4gICAgICAgIHVwZGF0ZWRFbGVzLnJ0cmlnZ2VyKCdwb3NpdGlvbicpO1xuICAgICAgfSxcbiAgICAgIGNhblNldDogZnVuY3Rpb24oIGVsZSApe1xuICAgICAgICByZXR1cm4gIWVsZS5sb2NrZWQoKTtcbiAgICAgIH1cbiAgICB9KSxcblxuICAgIC8vIHBvc2l0aW9uIGJ1dCBubyBub3RpZmljYXRpb24gdG8gcmVuZGVyZXJcbiAgICBzaWxlbnRQb3NpdGlvbjogJCQuZGVmaW5lLmRhdGEoe1xuICAgICAgZmllbGQ6ICdwb3NpdGlvbicsXG4gICAgICBiaW5kaW5nRXZlbnQ6ICdwb3NpdGlvbicsXG4gICAgICBhbGxvd0JpbmRpbmc6IGZhbHNlLFxuICAgICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgICAgc2V0dGluZ0V2ZW50OiAncG9zaXRpb24nLFxuICAgICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IGZhbHNlLFxuICAgICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgICAgYWxsb3dHZXR0aW5nOiB0cnVlLFxuICAgICAgdmFsaWRLZXlzOiBbJ3gnLCAneSddLFxuICAgICAgb25TZXQ6IGZ1bmN0aW9uKCBlbGVzICl7XG4gICAgICAgIGVsZXMudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgICAgIH0sXG4gICAgICBjYW5TZXQ6IGZ1bmN0aW9uKCBlbGUgKXtcbiAgICAgICAgcmV0dXJuICFlbGUubG9ja2VkKCk7XG4gICAgICB9XG4gICAgfSksXG5cbiAgICBwb3NpdGlvbnM6IGZ1bmN0aW9uKCBwb3MsIHNpbGVudCApe1xuICAgICAgaWYoICQkLmlzLnBsYWluT2JqZWN0KHBvcykgKXtcbiAgICAgICAgdGhpcy5wb3NpdGlvbihwb3MpO1xuXG4gICAgICB9IGVsc2UgaWYoICQkLmlzLmZuKHBvcykgKXtcbiAgICAgICAgdmFyIGZuID0gcG9zO1xuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuXG4gICAgICAgICAgdmFyIHBvcyA9IGZuLmFwcGx5KGVsZSwgW2ksIGVsZV0pO1xuXG4gICAgICAgICAgaWYoIHBvcyAmJiAhZWxlLmxvY2tlZCgpICl7XG4gICAgICAgICAgICB2YXIgZWxlUG9zID0gZWxlLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgICAgICAgZWxlUG9zLnggPSBwb3MueDtcbiAgICAgICAgICAgIGVsZVBvcy55ID0gcG9zLnk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHVwZGF0ZWRFbGVzID0gdGhpcy51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuICAgICAgICB2YXIgdG9UcmlnZ2VyID0gdXBkYXRlZEVsZXMubGVuZ3RoID4gMCA/IHRoaXMuYWRkKCB1cGRhdGVkRWxlcyApIDogdGhpcztcblxuICAgICAgICBpZiggc2lsZW50ICl7XG4gICAgICAgICAgdG9UcmlnZ2VyLnRyaWdnZXIoJ3Bvc2l0aW9uJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9UcmlnZ2VyLnJ0cmlnZ2VyKCdwb3NpdGlvbicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICBzaWxlbnRQb3NpdGlvbnM6IGZ1bmN0aW9uKCBwb3MgKXtcbiAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9ucyggcG9zLCB0cnVlICk7XG4gICAgfSxcblxuICAgIHVwZGF0ZUNvbXBvdW5kQm91bmRzOiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpIHx8ICFjeS5oYXNDb21wb3VuZE5vZGVzKCkgKXsgcmV0dXJuIGN5LmNvbGxlY3Rpb24oKTsgfSAvLyBzYXZlIGN5Y2xlcyBmb3Igbm9uIGNvbXBvdW5kIGdyYXBocyBvciB3aGVuIHN0eWxlIGRpc2FibGVkXG5cbiAgICAgIHZhciB1cGRhdGVkID0gW107XG5cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZSggcGFyZW50ICl7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHBhcmVudC5jaGlsZHJlbigpO1xuICAgICAgICB2YXIgc3R5bGUgPSBwYXJlbnQuX3ByaXZhdGUuc3R5bGU7XG4gICAgICAgIHZhciBpbmNsdWRlTGFiZWxzID0gc3R5bGVbJ2NvbXBvdW5kLXNpemluZy13cnQtbGFiZWxzJ10udmFsdWUgPT09ICdpbmNsdWRlJztcbiAgICAgICAgdmFyIGJiID0gY2hpbGRyZW4uYm91bmRpbmdCb3goeyBpbmNsdWRlTGFiZWxzOiBpbmNsdWRlTGFiZWxzLCBpbmNsdWRlRWRnZXM6IHRydWUgfSk7XG4gICAgICAgIHZhciBwYWRkaW5nID0ge1xuICAgICAgICAgIHRvcDogc3R5bGVbJ3BhZGRpbmctdG9wJ10ucHhWYWx1ZSxcbiAgICAgICAgICBib3R0b206IHN0eWxlWydwYWRkaW5nLWJvdHRvbSddLnB4VmFsdWUsXG4gICAgICAgICAgbGVmdDogc3R5bGVbJ3BhZGRpbmctbGVmdCddLnB4VmFsdWUsXG4gICAgICAgICAgcmlnaHQ6IHN0eWxlWydwYWRkaW5nLXJpZ2h0J10ucHhWYWx1ZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgcG9zID0gcGFyZW50Ll9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgICB2YXIgZGlkVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgaWYoIHN0eWxlWyd3aWR0aCddLnZhbHVlID09PSAnYXV0bycgKXtcbiAgICAgICAgICBwYXJlbnQuX3ByaXZhdGUuYXV0b1dpZHRoID0gYmIudyArIHBhZGRpbmcubGVmdCArIHBhZGRpbmcucmlnaHQ7XG4gICAgICAgICAgcG9zLnggPSAoYmIueDEgKyBiYi54MiAtIHBhZGRpbmcubGVmdCArIHBhZGRpbmcucmlnaHQpLzI7XG4gICAgICAgICAgZGlkVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBzdHlsZVsnaGVpZ2h0J10udmFsdWUgPT09ICdhdXRvJyApe1xuICAgICAgICAgIHBhcmVudC5fcHJpdmF0ZS5hdXRvSGVpZ2h0ID0gYmIuaCArIHBhZGRpbmcudG9wICsgcGFkZGluZy5ib3R0b207XG4gICAgICAgICAgcG9zLnkgPSAoYmIueTEgKyBiYi55MiAtIHBhZGRpbmcudG9wICsgcGFkZGluZy5ib3R0b20pLzI7XG4gICAgICAgICAgZGlkVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBkaWRVcGRhdGUgKXtcbiAgICAgICAgICB1cGRhdGVkLnB1c2goIHBhcmVudCApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGdvIHVwLCBsZXZlbCBieSBsZXZlbFxuICAgICAgdmFyIGVsZXMgPSB0aGlzLnBhcmVudCgpO1xuICAgICAgd2hpbGUoIGVsZXMubm9uZW1wdHkoKSApe1xuXG4gICAgICAgIC8vIHVwZGF0ZSBlYWNoIHBhcmVudCBub2RlIGluIHRoaXMgbGV2ZWxcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICAgICAgICB1cGRhdGUoIGVsZSApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbmV4dCBsZXZlbFxuICAgICAgICBlbGVzID0gZWxlcy5wYXJlbnQoKTtcbiAgICAgIH1cblxuICAgICAgLy8gcmV0dXJuIGNoYW5nZWRcbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIHVwZGF0ZWQgKTtcbiAgICB9LFxuXG4gICAgLy8gZ2V0L3NldCB0aGUgcmVuZGVyZWQgKGkuZS4gb24gc2NyZWVuKSBwb3NpdG9uIG9mIHRoZSBlbGVtZW50XG4gICAgcmVuZGVyZWRQb3NpdGlvbjogZnVuY3Rpb24oIGRpbSwgdmFsICl7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgICAgdmFyIHJwb3MgPSAkJC5pcy5wbGFpbk9iamVjdCggZGltICkgPyBkaW0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgc2V0dGluZyA9IHJwb3MgIT09IHVuZGVmaW5lZCB8fCAoIHZhbCAhPT0gdW5kZWZpbmVkICYmICQkLmlzLnN0cmluZyhkaW0pICk7XG5cbiAgICAgIGlmKCBlbGUgJiYgZWxlLmlzTm9kZSgpICl7IC8vIG11c3QgaGF2ZSBhbiBlbGVtZW50IGFuZCBtdXN0IGJlIGEgbm9kZSB0byByZXR1cm4gcG9zaXRpb25cbiAgICAgICAgaWYoIHNldHRpbmcgKXtcbiAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuXG4gICAgICAgICAgICBpZiggdmFsICE9PSB1bmRlZmluZWQgKXsgLy8gc2V0IG9uZSBkaW1lbnNpb25cbiAgICAgICAgICAgICAgZWxlLl9wcml2YXRlLnBvc2l0aW9uW2RpbV0gPSAoIHZhbCAtIHBhbltkaW1dICkvem9vbTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiggcnBvcyAhPT0gdW5kZWZpbmVkICl7IC8vIHNldCB3aG9sZSBwb3NpdGlvblxuICAgICAgICAgICAgICBlbGUuX3ByaXZhdGUucG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeDogKCBycG9zLnggLSBwYW4ueCApIC96b29tLFxuICAgICAgICAgICAgICAgIHk6ICggcnBvcy55IC0gcGFuLnkgKSAvem9vbVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMucnRyaWdnZXIoJ3Bvc2l0aW9uJyk7XG4gICAgICAgIH0gZWxzZSB7IC8vIGdldHRpbmdcbiAgICAgICAgICB2YXIgcG9zID0gZWxlLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgICAgIHJwb3MgPSB7XG4gICAgICAgICAgICB4OiBwb3MueCAqIHpvb20gKyBwYW4ueCxcbiAgICAgICAgICAgIHk6IHBvcy55ICogem9vbSArIHBhbi55XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmKCBkaW0gPT09IHVuZGVmaW5lZCApeyAvLyB0aGVuIHJldHVybiB0aGUgd2hvbGUgcmVuZGVyZWQgcG9zaXRpb25cbiAgICAgICAgICAgIHJldHVybiBycG9zO1xuICAgICAgICAgIH0gZWxzZSB7IC8vIHRoZW4gcmV0dXJuIHRoZSBzcGVjaWZpZWQgZGltZW5zaW9uXG4gICAgICAgICAgICByZXR1cm4gcnBvc1sgZGltIF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYoICFzZXR0aW5nICl7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIGZvciBlbXB0eSBjb2xsZWN0aW9uIGNhc2VcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIC8vIGdldC9zZXQgdGhlIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBwYXJlbnRcbiAgICByZWxhdGl2ZVBvc2l0aW9uOiBmdW5jdGlvbiggZGltLCB2YWwgKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgICAgdmFyIHBwb3MgPSAkJC5pcy5wbGFpbk9iamVjdCggZGltICkgPyBkaW0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgc2V0dGluZyA9IHBwb3MgIT09IHVuZGVmaW5lZCB8fCAoIHZhbCAhPT0gdW5kZWZpbmVkICYmICQkLmlzLnN0cmluZyhkaW0pICk7XG4gICAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcblxuICAgICAgaWYoIGVsZSAmJiBlbGUuaXNOb2RlKCkgKXsgLy8gbXVzdCBoYXZlIGFuIGVsZW1lbnQgYW5kIG11c3QgYmUgYSBub2RlIHRvIHJldHVybiBwb3NpdGlvblxuICAgICAgICBpZiggc2V0dGluZyApe1xuICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gaGFzQ29tcG91bmROb2RlcyA/IGVsZS5wYXJlbnQoKSA6IG51bGw7XG4gICAgICAgICAgICB2YXIgaGFzUGFyZW50ID0gcGFyZW50ICYmIHBhcmVudC5sZW5ndGggPiAwO1xuICAgICAgICAgICAgdmFyIHJlbGF0aXZlVG9QYXJlbnQgPSBoYXNQYXJlbnQ7XG5cbiAgICAgICAgICAgIGlmKCBoYXNQYXJlbnQgKXtcbiAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50WzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb3JpZ2luID0gcmVsYXRpdmVUb1BhcmVudCA/IHBhcmVudC5fcHJpdmF0ZS5wb3NpdGlvbiA6IHsgeDogMCwgeTogMCB9O1xuXG4gICAgICAgICAgICBpZiggdmFsICE9PSB1bmRlZmluZWQgKXsgLy8gc2V0IG9uZSBkaW1lbnNpb25cbiAgICAgICAgICAgICAgZWxlLl9wcml2YXRlLnBvc2l0aW9uW2RpbV0gPSB2YWwgKyBvcmlnaW5bZGltXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiggcHBvcyAhPT0gdW5kZWZpbmVkICl7IC8vIHNldCB3aG9sZSBwb3NpdGlvblxuICAgICAgICAgICAgICBlbGUuX3ByaXZhdGUucG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeDogcHBvcy54ICsgb3JpZ2luLngsXG4gICAgICAgICAgICAgICAgeTogcHBvcy55ICsgb3JpZ2luLnksXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5ydHJpZ2dlcigncG9zaXRpb24nKTtcblxuICAgICAgICB9IGVsc2UgeyAvLyBnZXR0aW5nXG4gICAgICAgICAgdmFyIHBvcyA9IGVsZS5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAgICAgICB2YXIgcGFyZW50ID0gaGFzQ29tcG91bmROb2RlcyA/IGVsZS5wYXJlbnQoKSA6IG51bGw7XG4gICAgICAgICAgdmFyIGhhc1BhcmVudCA9IHBhcmVudCAmJiBwYXJlbnQubGVuZ3RoID4gMDtcbiAgICAgICAgICB2YXIgcmVsYXRpdmVUb1BhcmVudCA9IGhhc1BhcmVudDtcblxuICAgICAgICAgIGlmKCBoYXNQYXJlbnQgKXtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudFswXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgb3JpZ2luID0gcmVsYXRpdmVUb1BhcmVudCA/IHBhcmVudC5fcHJpdmF0ZS5wb3NpdGlvbiA6IHsgeDogMCwgeTogMCB9O1xuXG4gICAgICAgICAgcHBvcyA9IHtcbiAgICAgICAgICAgIHg6IHBvcy54IC0gb3JpZ2luLngsXG4gICAgICAgICAgICB5OiBwb3MueSAtIG9yaWdpbi55XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmKCBkaW0gPT09IHVuZGVmaW5lZCApeyAvLyB0aGVuIHJldHVybiB0aGUgd2hvbGUgcmVuZGVyZWQgcG9zaXRpb25cbiAgICAgICAgICAgIHJldHVybiBwcG9zO1xuICAgICAgICAgIH0gZWxzZSB7IC8vIHRoZW4gcmV0dXJuIHRoZSBzcGVjaWZpZWQgZGltZW5zaW9uXG4gICAgICAgICAgICByZXR1cm4gcHBvc1sgZGltIF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYoICFzZXR0aW5nICl7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIGZvciBlbXB0eSBjb2xsZWN0aW9uIGNhc2VcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIC8vIGNvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGdldCBhIG51bWVyaWNhbCB2YWx1ZSBmb3IgdGhlIHdpZHRoIG9mIHRoZSBub2RlL2VkZ2VcbiAgICB3aWR0aDogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgICAgdmFyIGN5ID0gZWxlLl9wcml2YXRlLmN5O1xuICAgICAgdmFyIHN0eWxlRW5hYmxlZCA9IGN5Ll9wcml2YXRlLnN0eWxlRW5hYmxlZDtcblxuICAgICAgaWYoIGVsZSApe1xuICAgICAgICBpZiggc3R5bGVFbmFibGVkICl7XG4gICAgICAgICAgdmFyIHcgPSBlbGUuX3ByaXZhdGUuc3R5bGUud2lkdGg7XG4gICAgICAgICAgcmV0dXJuIHcuc3RyVmFsdWUgPT09ICdhdXRvJyA/IGVsZS5fcHJpdmF0ZS5hdXRvV2lkdGggOiB3LnB4VmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgb3V0ZXJXaWR0aDogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgICAgdmFyIGN5ID0gZWxlLl9wcml2YXRlLmN5O1xuICAgICAgdmFyIHN0eWxlRW5hYmxlZCA9IGN5Ll9wcml2YXRlLnN0eWxlRW5hYmxlZDtcblxuICAgICAgaWYoIGVsZSApe1xuICAgICAgICBpZiggc3R5bGVFbmFibGVkICl7XG4gICAgICAgICAgdmFyIHN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuICAgICAgICAgIHZhciB3aWR0aCA9IHN0eWxlLndpZHRoLnN0clZhbHVlID09PSAnYXV0bycgPyBlbGUuX3ByaXZhdGUuYXV0b1dpZHRoIDogc3R5bGUud2lkdGgucHhWYWx1ZTtcbiAgICAgICAgICB2YXIgYm9yZGVyID0gc3R5bGVbJ2JvcmRlci13aWR0aCddID8gc3R5bGVbJ2JvcmRlci13aWR0aCddLnB4VmFsdWUgKiBib3JkZXJXaWR0aE11bHRpcGxpZXIgKyBib3JkZXJXaWR0aEFkanVzdG1lbnQgOiAwO1xuXG4gICAgICAgICAgcmV0dXJuIHdpZHRoICsgYm9yZGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHJlbmRlcmVkV2lkdGg6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYoIGVsZSApe1xuICAgICAgICB2YXIgd2lkdGggPSBlbGUud2lkdGgoKTtcbiAgICAgICAgcmV0dXJuIHdpZHRoICogdGhpcy5jeSgpLnpvb20oKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVuZGVyZWRPdXRlcldpZHRoOiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgdmFyIG93aWR0aCA9IGVsZS5vdXRlcldpZHRoKCk7XG4gICAgICAgIHJldHVybiBvd2lkdGggKiB0aGlzLmN5KCkuem9vbSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBjb252ZW5pZW5jZSBmdW5jdGlvbiB0byBnZXQgYSBudW1lcmljYWwgdmFsdWUgZm9yIHRoZSBoZWlnaHQgb2YgdGhlIG5vZGVcbiAgICBoZWlnaHQ6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICAgIHZhciBjeSA9IGVsZS5fcHJpdmF0ZS5jeTtcbiAgICAgIHZhciBzdHlsZUVuYWJsZWQgPSBjeS5fcHJpdmF0ZS5zdHlsZUVuYWJsZWQ7XG5cbiAgICAgIGlmKCBlbGUgJiYgZWxlLl9wcml2YXRlLmdyb3VwID09PSAnbm9kZXMnICl7XG4gICAgICAgIGlmKCBzdHlsZUVuYWJsZWQgKXtcbiAgICAgICAgICB2YXIgaCA9IGVsZS5fcHJpdmF0ZS5zdHlsZS5oZWlnaHQ7XG4gICAgICAgICAgcmV0dXJuIGguc3RyVmFsdWUgPT09ICdhdXRvJyA/IGVsZS5fcHJpdmF0ZS5hdXRvSGVpZ2h0IDogaC5weFZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIG91dGVySGVpZ2h0OiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgICB2YXIgY3kgPSBlbGUuX3ByaXZhdGUuY3k7XG4gICAgICB2YXIgc3R5bGVFbmFibGVkID0gY3kuX3ByaXZhdGUuc3R5bGVFbmFibGVkO1xuXG4gICAgICBpZiggZWxlICYmIGVsZS5fcHJpdmF0ZS5ncm91cCA9PT0gJ25vZGVzJyApe1xuICAgICAgICBpZiggc3R5bGVFbmFibGVkICl7XG4gICAgICAgICAgdmFyIHN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuICAgICAgICAgIHZhciBoZWlnaHQgPSBzdHlsZS5oZWlnaHQuc3RyVmFsdWUgPT09ICdhdXRvJyA/IGVsZS5fcHJpdmF0ZS5hdXRvSGVpZ2h0IDogc3R5bGUuaGVpZ2h0LnB4VmFsdWU7XG4gICAgICAgICAgdmFyIGJvcmRlciA9IHN0eWxlWydib3JkZXItd2lkdGgnXSA/IHN0eWxlWydib3JkZXItd2lkdGgnXS5weFZhbHVlICogYm9yZGVyV2lkdGhNdWx0aXBsaWVyICsgYm9yZGVyV2lkdGhBZGp1c3RtZW50IDogMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoZWlnaHQgKyBib3JkZXI7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHJlbmRlcmVkSGVpZ2h0OiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmKCBlbGUgJiYgZWxlLl9wcml2YXRlLmdyb3VwID09PSAnbm9kZXMnICl7XG4gICAgICAgIHZhciBoZWlnaHQgPSBlbGUuaGVpZ2h0KCk7XG4gICAgICAgIHJldHVybiBoZWlnaHQgKiB0aGlzLmN5KCkuem9vbSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICByZW5kZXJlZE91dGVySGVpZ2h0OiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmKCBlbGUgJiYgZWxlLl9wcml2YXRlLmdyb3VwID09PSAnbm9kZXMnICl7XG4gICAgICAgIHZhciBvaGVpZ2h0ID0gZWxlLm91dGVySGVpZ2h0KCk7XG4gICAgICAgIHJldHVybiBvaGVpZ2h0ICogdGhpcy5jeSgpLnpvb20oKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVuZGVyZWRCb3VuZGluZ0JveDogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICAgIHZhciBiYiA9IHRoaXMuYm91bmRpbmdCb3goIG9wdGlvbnMgKTtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuXG4gICAgICB2YXIgeDEgPSBiYi54MSAqIHpvb20gKyBwYW4ueDtcbiAgICAgIHZhciB4MiA9IGJiLngyICogem9vbSArIHBhbi54O1xuICAgICAgdmFyIHkxID0gYmIueTEgKiB6b29tICsgcGFuLnk7XG4gICAgICB2YXIgeTIgPSBiYi55MiAqIHpvb20gKyBwYW4ueTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDE6IHgxLFxuICAgICAgICB4MjogeDIsXG4gICAgICAgIHkxOiB5MSxcbiAgICAgICAgeTI6IHkyLFxuICAgICAgICB3OiB4MiAtIHgxLFxuICAgICAgICBoOiB5MiAtIHkxXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvLyBnZXQgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgZWxlbWVudHMgKGluIHJhdyBtb2RlbCBwb3NpdGlvbilcbiAgICBib3VuZGluZ0JveDogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICAgIHZhciBlbGVzID0gdGhpcztcbiAgICAgIHZhciBjeSA9IGVsZXMuX3ByaXZhdGUuY3k7XG4gICAgICB2YXIgY3lfcCA9IGN5Ll9wcml2YXRlO1xuICAgICAgdmFyIHN0eWxlRW5hYmxlZCA9IGN5X3Auc3R5bGVFbmFibGVkO1xuXG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgdmFyIGluY2x1ZGVOb2RlcyA9IG9wdGlvbnMuaW5jbHVkZU5vZGVzID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0aW9ucy5pbmNsdWRlTm9kZXM7XG4gICAgICB2YXIgaW5jbHVkZUVkZ2VzID0gb3B0aW9ucy5pbmNsdWRlRWRnZXMgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRpb25zLmluY2x1ZGVFZGdlcztcbiAgICAgIHZhciBpbmNsdWRlTGFiZWxzID0gb3B0aW9ucy5pbmNsdWRlTGFiZWxzID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0aW9ucy5pbmNsdWRlTGFiZWxzO1xuXG4gICAgICAvLyByZWNhbGN1bGF0ZSBwcm9qZWN0aW9ucyBldGNcbiAgICAgIGlmKCBzdHlsZUVuYWJsZWQgKXtcbiAgICAgICAgY3lfcC5yZW5kZXJlci5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUoIHRoaXMgKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHgxID0gSW5maW5pdHk7XG4gICAgICB2YXIgeDIgPSAtSW5maW5pdHk7XG4gICAgICB2YXIgeTEgPSBJbmZpbml0eTtcbiAgICAgIHZhciB5MiA9IC1JbmZpbml0eTtcblxuICAgICAgLy8gZmluZCBib3VuZHMgb2YgZWxlbWVudHNcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgICB2YXIgc3R5bGUgPSBfcC5zdHlsZTtcbiAgICAgICAgdmFyIGRpc3BsYXkgPSBzdHlsZUVuYWJsZWQgPyBfcC5zdHlsZVsnZGlzcGxheSddLnZhbHVlIDogJ2VsZW1lbnQnO1xuICAgICAgICB2YXIgaXNOb2RlID0gX3AuZ3JvdXAgPT09ICdub2Rlcyc7XG4gICAgICAgIHZhciBleDEsIGV4MiwgZXkxLCBleTIsIHgsIHk7XG4gICAgICAgIHZhciBpbmNsdWRlZEVsZSA9IGZhbHNlO1xuXG4gICAgICAgIGlmKCBkaXNwbGF5ID09PSAnbm9uZScgKXsgY29udGludWU7IH0gLy8gdGhlbiBlbGUgZG9lc24ndCB0YWtlIHVwIHNwYWNlXG5cbiAgICAgICAgaWYoIGlzTm9kZSAmJiBpbmNsdWRlTm9kZXMgKXtcbiAgICAgICAgICBpbmNsdWRlZEVsZSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgcG9zID0gX3AucG9zaXRpb247XG4gICAgICAgICAgeCA9IHBvcy54O1xuICAgICAgICAgIHkgPSBwb3MueTtcbiAgICAgICAgICB2YXIgdyA9IGVsZS5vdXRlcldpZHRoKCk7XG4gICAgICAgICAgdmFyIGhhbGZXID0gdy8yO1xuICAgICAgICAgIHZhciBoID0gZWxlLm91dGVySGVpZ2h0KCk7XG4gICAgICAgICAgdmFyIGhhbGZIID0gaC8yO1xuXG4gICAgICAgICAgLy8gaGFuZGxlIG5vZGUgZGltZW5zaW9uc1xuICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgICAgIGV4MSA9IHggLSBoYWxmVztcbiAgICAgICAgICBleDIgPSB4ICsgaGFsZlc7XG4gICAgICAgICAgZXkxID0geSAtIGhhbGZIO1xuICAgICAgICAgIGV5MiA9IHkgKyBoYWxmSDtcblxuICAgICAgICAgIHgxID0gZXgxIDwgeDEgPyBleDEgOiB4MTtcbiAgICAgICAgICB4MiA9IGV4MiA+IHgyID8gZXgyIDogeDI7XG4gICAgICAgICAgeTEgPSBleTEgPCB5MSA/IGV5MSA6IHkxO1xuICAgICAgICAgIHkyID0gZXkyID4geTIgPyBleTIgOiB5MjtcblxuICAgICAgICB9IGVsc2UgaWYoIGVsZS5pc0VkZ2UoKSAmJiBpbmNsdWRlRWRnZXMgKXtcbiAgICAgICAgICBpbmNsdWRlZEVsZSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgbjEgPSBfcC5zb3VyY2U7XG4gICAgICAgICAgdmFyIG4xX3AgPSBuMS5fcHJpdmF0ZTtcbiAgICAgICAgICB2YXIgbjFwb3MgPSBuMV9wLnBvc2l0aW9uO1xuICAgICAgICAgIFxuICAgICAgICAgIHZhciBuMiA9IF9wLnRhcmdldDtcbiAgICAgICAgICB2YXIgbjJfcCA9IG4yLl9wcml2YXRlO1xuICAgICAgICAgIHZhciBuMnBvcyA9IG4yX3AucG9zaXRpb247XG4gICAgICAgICAgXG5cbiAgICAgICAgICAvLyBoYW5kbGUgZWRnZSBkaW1lbnNpb25zIChyb3VnaCBib3ggZXN0aW1hdGUpXG4gICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgICAgdmFyIHJzdHlsZSA9IF9wLnJzdHlsZSB8fCB7fTtcblxuICAgICAgICAgIGV4MSA9IG4xcG9zLng7XG4gICAgICAgICAgZXgyID0gbjJwb3MueDtcbiAgICAgICAgICBleTEgPSBuMXBvcy55O1xuICAgICAgICAgIGV5MiA9IG4ycG9zLnk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYoIGV4MSA+IGV4MiApe1xuICAgICAgICAgICAgdmFyIHRlbXAgPSBleDE7XG4gICAgICAgICAgICBleDEgPSBleDI7XG4gICAgICAgICAgICBleDIgPSB0ZW1wO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCBleTEgPiBleTIgKXtcbiAgICAgICAgICAgIHZhciB0ZW1wID0gZXkxO1xuICAgICAgICAgICAgZXkxID0gZXkyO1xuICAgICAgICAgICAgZXkyID0gdGVtcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB4MSA9IGV4MSA8IHgxID8gZXgxIDogeDE7XG4gICAgICAgICAgeDIgPSBleDIgPiB4MiA/IGV4MiA6IHgyO1xuICAgICAgICAgIHkxID0gZXkxIDwgeTEgPyBleTEgOiB5MTtcbiAgICAgICAgICB5MiA9IGV5MiA+IHkyID8gZXkyIDogeTI7XG5cbiAgICAgICAgICAvLyBoYW5kbGUgcG9pbnRzIGFsb25nIGVkZ2UgKHNhbml0eSBjaGVjaylcbiAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgICAgIGlmKCBzdHlsZUVuYWJsZWQgKXtcbiAgICAgICAgICAgIHZhciBicHRzID0gcnN0eWxlLmJlemllclB0cyB8fCBbXTtcblxuICAgICAgICAgICAgdmFyIHcgPSBzdHlsZVsnd2lkdGgnXS5weFZhbHVlO1xuICAgICAgICAgICAgdmFyIHdIYWxmID0gdy8yO1xuXG4gICAgICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGJwdHMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICAgICAgdmFyIGJwdCA9IGJwdHNbal07XG5cbiAgICAgICAgICAgICAgZXgxID0gYnB0LnggLSB3SGFsZjtcbiAgICAgICAgICAgICAgZXgyID0gYnB0LnggKyB3SGFsZjtcbiAgICAgICAgICAgICAgZXkxID0gYnB0LnkgLSB3SGFsZjtcbiAgICAgICAgICAgICAgZXkyID0gYnB0LnkgKyB3SGFsZjtcblxuICAgICAgICAgICAgICB4MSA9IGV4MSA8IHgxID8gZXgxIDogeDE7XG4gICAgICAgICAgICAgIHgyID0gZXgyID4geDIgPyBleDIgOiB4MjtcbiAgICAgICAgICAgICAgeTEgPSBleTEgPCB5MSA/IGV5MSA6IHkxO1xuICAgICAgICAgICAgICB5MiA9IGV5MiA+IHkyID8gZXkyIDogeTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIHByZWNpc2UgaGF5c3RhY2tzIChzYW5pdHkgY2hlY2spXG4gICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgICBcbiAgICAgICAgICBpZiggc3R5bGVFbmFibGVkICYmIHN0eWxlWydjdXJ2ZS1zdHlsZSddLnN0clZhbHVlID09PSAnaGF5c3RhY2snICl7XG4gICAgICAgICAgICB2YXIgaHB0cyA9IF9wLnJzY3JhdGNoLmhheXN0YWNrUHRzO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBleDEgPSBocHRzWzBdO1xuICAgICAgICAgICAgZXkxID0gaHB0c1sxXTtcbiAgICAgICAgICAgIGV4MiA9IGhwdHNbMl07XG4gICAgICAgICAgICBleTIgPSBocHRzWzNdO1xuXG4gICAgICAgICAgICBpZiggZXgxID4gZXgyICl7XG4gICAgICAgICAgICAgIHZhciB0ZW1wID0gZXgxO1xuICAgICAgICAgICAgICBleDEgPSBleDI7XG4gICAgICAgICAgICAgIGV4MiA9IHRlbXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCBleTEgPiBleTIgKXtcbiAgICAgICAgICAgICAgdmFyIHRlbXAgPSBleTE7XG4gICAgICAgICAgICAgIGV5MSA9IGV5MjtcbiAgICAgICAgICAgICAgZXkyID0gdGVtcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeDEgPSBleDEgPCB4MSA/IGV4MSA6IHgxO1xuICAgICAgICAgICAgeDIgPSBleDIgPiB4MiA/IGV4MiA6IHgyO1xuICAgICAgICAgICAgeTEgPSBleTEgPCB5MSA/IGV5MSA6IHkxO1xuICAgICAgICAgICAgeTIgPSBleTIgPiB5MiA/IGV5MiA6IHkyOyAgXG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gLy8gZWRnZXNcbiAgICAgICAgICAgIFxuXG4gICAgICAgIC8vIGhhbmRsZSBsYWJlbCBkaW1lbnNpb25zXG4gICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgICAgaWYoIHN0eWxlRW5hYmxlZCApe1xuXG4gICAgICAgICAgdmFyIHN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuICAgICAgICAgIHZhciByc3R5bGUgPSBlbGUuX3ByaXZhdGUucnN0eWxlO1xuICAgICAgICAgIHZhciBsYWJlbCA9IHN0eWxlWydjb250ZW50J10uc3RyVmFsdWU7XG4gICAgICAgICAgdmFyIGZvbnRTaXplID0gc3R5bGVbJ2ZvbnQtc2l6ZSddO1xuICAgICAgICAgIHZhciBoYWxpZ24gPSBzdHlsZVsndGV4dC1oYWxpZ24nXTtcbiAgICAgICAgICB2YXIgdmFsaWduID0gc3R5bGVbJ3RleHQtdmFsaWduJ107XG4gICAgICAgICAgdmFyIGxhYmVsV2lkdGggPSByc3R5bGUubGFiZWxXaWR0aDtcbiAgICAgICAgICB2YXIgbGFiZWxIZWlnaHQgPSByc3R5bGUubGFiZWxIZWlnaHQ7XG4gICAgICAgICAgdmFyIGxhYmVsWCA9IHJzdHlsZS5sYWJlbFg7XG4gICAgICAgICAgdmFyIGxhYmVsWSA9IHJzdHlsZS5sYWJlbFk7XG5cbiAgICAgICAgICBpZiggaW5jbHVkZWRFbGUgJiYgaW5jbHVkZUxhYmVscyAmJiBsYWJlbCAmJiBmb250U2l6ZSAmJiBsYWJlbEhlaWdodCAhPSBudWxsICYmIGxhYmVsV2lkdGggIT0gbnVsbCAmJiBsYWJlbFggIT0gbnVsbCAmJiBsYWJlbFkgIT0gbnVsbCAmJiBoYWxpZ24gJiYgdmFsaWduICl7XG4gICAgICAgICAgICB2YXIgbGggPSBsYWJlbEhlaWdodDtcbiAgICAgICAgICAgIHZhciBsdyA9IGxhYmVsV2lkdGg7XG4gICAgICAgICAgICB2YXIgbHgxLCBseDIsIGx5MSwgbHkyO1xuXG4gICAgICAgICAgICBpZiggZWxlLmlzRWRnZSgpICl7XG4gICAgICAgICAgICAgIGx4MSA9IGxhYmVsWCAtIGx3LzI7XG4gICAgICAgICAgICAgIGx4MiA9IGxhYmVsWCArIGx3LzI7XG4gICAgICAgICAgICAgIGx5MSA9IGxhYmVsWSAtIGxoLzI7XG4gICAgICAgICAgICAgIGx5MiA9IGxhYmVsWSArIGxoLzI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzd2l0Y2goIGhhbGlnbi52YWx1ZSApe1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgICAgbHgxID0gbGFiZWxYIC0gbHc7XG4gICAgICAgICAgICAgICAgICBseDIgPSBsYWJlbFg7XG4gICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICAgICAgICBseDEgPSBsYWJlbFggLSBsdy8yO1xuICAgICAgICAgICAgICAgICAgbHgyID0gbGFiZWxYICsgbHcvMjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgICAgbHgxID0gbGFiZWxYO1xuICAgICAgICAgICAgICAgICAgbHgyID0gbGFiZWxYICsgbHc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHN3aXRjaCggdmFsaWduLnZhbHVlICl7XG4gICAgICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgICAgICAgIGx5MSA9IGxhYmVsWSAtIGxoO1xuICAgICAgICAgICAgICAgICAgbHkyID0gbGFiZWxZO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgICAgICAgbHkxID0gbGFiZWxZIC0gbGgvMjtcbiAgICAgICAgICAgICAgICAgIGx5MiA9IGxhYmVsWSArIGxoLzI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgICBseTEgPSBsYWJlbFk7XG4gICAgICAgICAgICAgICAgICBseTIgPSBsYWJlbFkgKyBsaDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHgxID0gbHgxIDwgeDEgPyBseDEgOiB4MTtcbiAgICAgICAgICAgIHgyID0gbHgyID4geDIgPyBseDIgOiB4MjtcbiAgICAgICAgICAgIHkxID0gbHkxIDwgeTEgPyBseTEgOiB5MTtcbiAgICAgICAgICAgIHkyID0gbHkyID4geTIgPyBseTIgOiB5MjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gc3R5bGUgZW5hYmxlZFxuICAgICAgfSAvLyBmb3JcblxuICAgICAgdmFyIG5vbmluZiA9IGZ1bmN0aW9uKHgpe1xuICAgICAgICBpZiggeCA9PT0gSW5maW5pdHkgfHwgeCA9PT0gLUluZmluaXR5ICl7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB4O1xuICAgICAgfTtcblxuICAgICAgeDEgPSBub25pbmYoeDEpO1xuICAgICAgeDIgPSBub25pbmYoeDIpO1xuICAgICAgeTEgPSBub25pbmYoeTEpO1xuICAgICAgeTIgPSBub25pbmYoeTIpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogeDEsXG4gICAgICAgIHgyOiB4MixcbiAgICAgICAgeTE6IHkxLFxuICAgICAgICB5MjogeTIsXG4gICAgICAgIHc6IHgyIC0geDEsXG4gICAgICAgIGg6IHkyIC0geTFcbiAgICAgIH07XG4gICAgfVxuICB9KTtcblxuICAvLyBhbGlhc2VzXG4gIHZhciBmbiA9ICQkLmVsZXNmbjtcbiAgZm4uYXR0ciA9IGZuLmRhdGE7XG4gIGZuLnJlbW92ZUF0dHIgPSBmbi5yZW1vdmVEYXRhO1xuICBmbi5tb2RlbFBvc2l0aW9uID0gZm4ucG9pbnQgPSBmbi5wb3NpdGlvbjtcbiAgZm4ubW9kZWxQb3NpdGlvbnMgPSBmbi5wb2ludHMgPSBmbi5wb3NpdGlvbnM7XG4gIGZuLnJlbmRlcmVkUG9pbnQgPSBmbi5yZW5kZXJlZFBvc2l0aW9uO1xuICBmbi5yZWxhdGl2ZVBvaW50ID0gZm4ucmVsYXRpdmVQb3NpdGlvbjtcbiAgZm4uYm91bmRpbmdib3ggPSBmbi5ib3VuZGluZ0JveDtcbiAgZm4ucmVuZGVyZWRCb3VuZGluZ2JveCA9IGZuLnJlbmRlcmVkQm91bmRpbmdCb3g7XG5cbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbiggJCQgKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgLy8gUmVndWxhciBkZWdyZWUgZnVuY3Rpb25zICh3b3JrcyBvbiBzaW5nbGUgZWxlbWVudClcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICBcbiAgZnVuY3Rpb24gZGVmaW5lRGVncmVlRnVuY3Rpb24oY2FsbGJhY2spe1xuICAgIHJldHVybiBmdW5jdGlvbiggaW5jbHVkZUxvb3BzICl7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIGlmKCBpbmNsdWRlTG9vcHMgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICBpbmNsdWRlTG9vcHMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiggc2VsZi5sZW5ndGggPT09IDAgKXsgcmV0dXJuOyB9XG5cbiAgICAgIGlmKCBzZWxmLmlzTm9kZSgpICYmICFzZWxmLnJlbW92ZWQoKSApe1xuICAgICAgICB2YXIgZGVncmVlID0gMDtcbiAgICAgICAgdmFyIG5vZGUgPSBzZWxmWzBdO1xuICAgICAgICB2YXIgY29ubmVjdGVkRWRnZXMgPSBub2RlLl9wcml2YXRlLmVkZ2VzO1xuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY29ubmVjdGVkRWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZWRnZSA9IGNvbm5lY3RlZEVkZ2VzW2ldO1xuXG4gICAgICAgICAgaWYoICFpbmNsdWRlTG9vcHMgJiYgZWRnZS5pc0xvb3AoKSApe1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVncmVlICs9IGNhbGxiYWNrKCBub2RlLCBlZGdlICk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBkZWdyZWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBcbiAgJCQuZm4uZWxlcyh7XG4gICAgZGVncmVlOiBkZWZpbmVEZWdyZWVGdW5jdGlvbihmdW5jdGlvbihub2RlLCBlZGdlKXtcbiAgICAgIGlmKCBlZGdlLnNvdXJjZSgpLnNhbWUoIGVkZ2UudGFyZ2V0KCkgKSApe1xuICAgICAgICByZXR1cm4gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgIH0pLFxuXG4gICAgaW5kZWdyZWU6IGRlZmluZURlZ3JlZUZ1bmN0aW9uKGZ1bmN0aW9uKG5vZGUsIGVkZ2Upe1xuICAgICAgaWYoIGVkZ2UudGFyZ2V0KCkuc2FtZShub2RlKSApe1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH0pLFxuXG4gICAgb3V0ZGVncmVlOiBkZWZpbmVEZWdyZWVGdW5jdGlvbihmdW5jdGlvbihub2RlLCBlZGdlKXtcbiAgICAgIGlmKCBlZGdlLnNvdXJjZSgpLnNhbWUobm9kZSkgKXtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9KVxuICB9KTtcbiAgXG4gIFxuICAvLyBDb2xsZWN0aW9uIGRlZ3JlZSBzdGF0c1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIFxuICBmdW5jdGlvbiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbihkZWdyZWVGbiwgY2FsbGJhY2spe1xuICAgIHJldHVybiBmdW5jdGlvbiggaW5jbHVkZUxvb3BzICl7XG4gICAgICB2YXIgcmV0O1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSBub2Rlc1tpXTtcbiAgICAgICAgdmFyIGRlZ3JlZSA9IGVsZVtkZWdyZWVGbl0oIGluY2x1ZGVMb29wcyApO1xuICAgICAgICBpZiggZGVncmVlICE9PSB1bmRlZmluZWQgJiYgKHJldCA9PT0gdW5kZWZpbmVkIHx8IGNhbGxiYWNrKGRlZ3JlZSwgcmV0KSkgKXtcbiAgICAgICAgICByZXQgPSBkZWdyZWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICB9XG4gIFxuICAkJC5mbi5lbGVzKHtcbiAgICBtaW5EZWdyZWU6IGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKCdkZWdyZWUnLCBmdW5jdGlvbihkZWdyZWUsIG1pbil7XG4gICAgICByZXR1cm4gZGVncmVlIDwgbWluO1xuICAgIH0pLFxuXG4gICAgbWF4RGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignZGVncmVlJywgZnVuY3Rpb24oZGVncmVlLCBtYXgpe1xuICAgICAgcmV0dXJuIGRlZ3JlZSA+IG1heDtcbiAgICB9KSxcblxuICAgIG1pbkluZGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignaW5kZWdyZWUnLCBmdW5jdGlvbihkZWdyZWUsIG1pbil7XG4gICAgICByZXR1cm4gZGVncmVlIDwgbWluO1xuICAgIH0pLFxuXG4gICAgbWF4SW5kZWdyZWU6IGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKCdpbmRlZ3JlZScsIGZ1bmN0aW9uKGRlZ3JlZSwgbWF4KXtcbiAgICAgIHJldHVybiBkZWdyZWUgPiBtYXg7XG4gICAgfSksXG5cbiAgICBtaW5PdXRkZWdyZWU6IGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKCdvdXRkZWdyZWUnLCBmdW5jdGlvbihkZWdyZWUsIG1pbil7XG4gICAgICByZXR1cm4gZGVncmVlIDwgbWluO1xuICAgIH0pLFxuXG4gICAgbWF4T3V0ZGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignb3V0ZGVncmVlJywgZnVuY3Rpb24oZGVncmVlLCBtYXgpe1xuICAgICAgcmV0dXJuIGRlZ3JlZSA+IG1heDtcbiAgICB9KVxuICB9KTtcbiAgXG4gICQkLmZuLmVsZXMoe1xuICAgIHRvdGFsRGVncmVlOiBmdW5jdGlvbiggaW5jbHVkZUxvb3BzICl7XG4gICAgICB2YXIgdG90YWwgPSAwO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHRvdGFsICs9IG5vZGVzW2ldLmRlZ3JlZSggaW5jbHVkZUxvb3BzICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0b3RhbDtcbiAgICB9XG4gIH0pO1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuICBcbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICAvLyBGdW5jdGlvbnMgZm9yIGJpbmRpbmcgJiB0cmlnZ2VyaW5nIGV2ZW50c1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIFxuICAkJC5mbi5lbGVzKHtcbiAgICBvbjogJCQuZGVmaW5lLm9uKCksIC8vIC5vbiggZXZlbnRzIFssIHNlbGVjdG9yXSBbLCBkYXRhXSwgaGFuZGxlcilcbiAgICBvbmU6ICQkLmRlZmluZS5vbih7IHVuYmluZFNlbGZPblRyaWdnZXI6IHRydWUgfSksXG4gICAgb25jZTogJCQuZGVmaW5lLm9uKHsgdW5iaW5kQWxsQmluZGVyc09uVHJpZ2dlcjogdHJ1ZSB9KSxcbiAgICBvZmY6ICQkLmRlZmluZS5vZmYoKSwgLy8gLm9mZiggZXZlbnRzIFssIHNlbGVjdG9yXSBbLCBoYW5kbGVyXSApXG4gICAgdHJpZ2dlcjogJCQuZGVmaW5lLnRyaWdnZXIoKSwgLy8gLnRyaWdnZXIoIGV2ZW50cyBbLCBleHRyYVBhcmFtc10gKVxuXG4gICAgcnRyaWdnZXI6IGZ1bmN0aW9uKGV2ZW50LCBleHRyYVBhcmFtcyl7IC8vIGZvciBpbnRlcm5hbCB1c2Ugb25seVxuICAgICAgaWYoIHRoaXMubGVuZ3RoID09PSAwICl7IHJldHVybjsgfSAvLyBlbXB0eSBjb2xsZWN0aW9ucyBkb24ndCBuZWVkIHRvIG5vdGlmeSBhbnl0aGluZ1xuXG4gICAgICAvLyBub3RpZnkgcmVuZGVyZXJcbiAgICAgIHRoaXMuY3koKS5ub3RpZnkoe1xuICAgICAgICB0eXBlOiBldmVudCxcbiAgICAgICAgY29sbGVjdGlvbjogdGhpc1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHRoaXMudHJpZ2dlcihldmVudCwgZXh0cmFQYXJhbXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9KTtcblxuICAvLyBhbGlhc2VzOlxuICAkJC5kZWZpbmUuZXZlbnRBbGlhc2VzT24oICQkLmVsZXNmbiApO1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICAkJC5mbi5lbGVzKHtcbiAgICBub2RlczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24oaSwgZWxlbWVudCl7XG4gICAgICAgIHJldHVybiBlbGVtZW50LmlzTm9kZSgpO1xuICAgICAgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9LFxuXG4gICAgZWRnZXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKGksIGVsZW1lbnQpe1xuICAgICAgICByZXR1cm4gZWxlbWVudC5pc0VkZ2UoKTtcbiAgICAgIH0pLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfSxcblxuICAgIGZpbHRlcjogZnVuY3Rpb24oIGZpbHRlciApe1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICAgIFxuICAgICAgaWYoICQkLmlzLmZuKGZpbHRlcikgKXtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gW107XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG5cbiAgICAgICAgICBpZiggZmlsdGVyLmFwcGx5KGVsZSwgW2ksIGVsZV0pICl7XG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oY3ksIGVsZW1lbnRzKTtcbiAgICAgIFxuICAgICAgfSBlbHNlIGlmKCAkJC5pcy5zdHJpbmcoZmlsdGVyKSB8fCAkJC5pcy5lbGVtZW50T3JDb2xsZWN0aW9uKGZpbHRlcikgKXtcbiAgICAgICAgcmV0dXJuIG5ldyAkJC5TZWxlY3RvcihmaWx0ZXIpLmZpbHRlcih0aGlzKTtcbiAgICAgIFxuICAgICAgfSBlbHNlIGlmKCBmaWx0ZXIgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCBjeSApOyAvLyBpZiBub3QgaGFuZGxlZCBieSBhYm92ZSwgZ2l2ZSAnZW0gYW4gZW1wdHkgY29sbGVjdGlvblxuICAgIH0sXG5cbiAgICBub3Q6IGZ1bmN0aW9uKCB0b1JlbW92ZSApe1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgICAgaWYoICF0b1JlbW92ZSApe1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICBcbiAgICAgICAgaWYoICQkLmlzLnN0cmluZyggdG9SZW1vdmUgKSApe1xuICAgICAgICAgIHRvUmVtb3ZlID0gdGhpcy5maWx0ZXIoIHRvUmVtb3ZlICk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgICAgICBcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzW2ldO1xuXG4gICAgICAgICAgdmFyIHJlbW92ZSA9IHRvUmVtb3ZlLl9wcml2YXRlLmlkc1sgZWxlbWVudC5pZCgpIF07XG4gICAgICAgICAgaWYoICFyZW1vdmUgKXtcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goIGVsZW1lbnQgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIGVsZW1lbnRzICk7XG4gICAgICB9XG4gICAgICBcbiAgICB9LFxuXG4gICAgYWJzb2x1dGVDb21wbGVtZW50OiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgICAgcmV0dXJuIGN5LmVsZW1lbnRzKCkubm90KCB0aGlzICk7XG4gICAgfSxcblxuICAgIGludGVyc2VjdDogZnVuY3Rpb24oIG90aGVyICl7XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgICAgXG4gICAgICAvLyBpZiBhIHNlbGVjdG9yIGlzIHNwZWNpZmllZCwgdGhlbiBmaWx0ZXIgYnkgaXQgaW5zdGVhZFxuICAgICAgaWYoICQkLmlzLnN0cmluZyhvdGhlcikgKXtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gb3RoZXI7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgICB2YXIgY29sMSA9IHRoaXM7XG4gICAgICB2YXIgY29sMiA9IG90aGVyO1xuICAgICAgdmFyIGNvbDFTbWFsbGVyID0gdGhpcy5sZW5ndGggPCBvdGhlci5sZW5ndGg7XG4gICAgICAvLyB2YXIgaWRzMSA9IGNvbDFTbWFsbGVyID8gY29sMS5fcHJpdmF0ZS5pZHMgOiBjb2wyLl9wcml2YXRlLmlkcztcbiAgICAgIHZhciBpZHMyID0gY29sMVNtYWxsZXIgPyBjb2wyLl9wcml2YXRlLmlkcyA6IGNvbDEuX3ByaXZhdGUuaWRzO1xuICAgICAgdmFyIGNvbCA9IGNvbDFTbWFsbGVyID8gY29sMSA6IGNvbDI7XG4gICAgICBcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY29sLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBpZCA9IGNvbFtpXS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgICB2YXIgZWxlID0gaWRzMlsgaWQgXTtcblxuICAgICAgICBpZiggZWxlICl7XG4gICAgICAgICAgZWxlbWVudHMucHVzaCggZWxlICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgZWxlbWVudHMgKTtcbiAgICB9LFxuXG4gICAgeG9yOiBmdW5jdGlvbiggb3RoZXIgKXtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICAgIGlmKCAkJC5pcy5zdHJpbmcob3RoZXIpICl7XG4gICAgICAgIG90aGVyID0gY3kuJCggb3RoZXIgKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgICB2YXIgY29sMSA9IHRoaXM7XG4gICAgICB2YXIgY29sMiA9IG90aGVyO1xuICAgICAgXG4gICAgICB2YXIgYWRkID0gZnVuY3Rpb24oIGNvbCwgb3RoZXIgKXtcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNvbC5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlbGUgPSBjb2xbaV07XG4gICAgICAgICAgdmFyIGlkID0gZWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICAgICAgdmFyIGluT3RoZXIgPSBvdGhlci5fcHJpdmF0ZS5pZHNbIGlkIF07XG4gICAgICAgICAgXG4gICAgICAgICAgaWYoICFpbk90aGVyICl7XG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKCBlbGUgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgfTtcblxuICAgICAgYWRkKCBjb2wxLCBjb2wyICk7XG4gICAgICBhZGQoIGNvbDIsIGNvbDEgKTtcblxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgZWxlbWVudHMgKTtcbiAgICB9LCAgXG5cbiAgICBkaWZmOiBmdW5jdGlvbiggb3RoZXIgKXtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICAgIGlmKCAkJC5pcy5zdHJpbmcob3RoZXIpICl7XG4gICAgICAgIG90aGVyID0gY3kuJCggb3RoZXIgKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlZnQgPSBbXTtcbiAgICAgIHZhciByaWdodCA9IFtdO1xuICAgICAgdmFyIGJvdGggPSBbXTtcbiAgICAgIHZhciBjb2wxID0gdGhpcztcbiAgICAgIHZhciBjb2wyID0gb3RoZXI7XG5cbiAgICAgIHZhciBhZGQgPSBmdW5jdGlvbiggY29sLCBvdGhlciwgcmV0RWxlcyApe1xuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY29sLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IGNvbFtpXTtcbiAgICAgICAgICB2YXIgaWQgPSBlbGUuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgICAgICB2YXIgaW5PdGhlciA9IG90aGVyLl9wcml2YXRlLmlkc1sgaWQgXTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiggaW5PdGhlciApe1xuICAgICAgICAgICAgYm90aC5wdXNoKCBlbGUgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0RWxlcy5wdXNoKCBlbGUgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgfTtcblxuICAgICAgYWRkKCBjb2wxLCBjb2wyLCBsZWZ0ICk7XG4gICAgICBhZGQoIGNvbDIsIGNvbDEsIHJpZ2h0ICk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgbGVmdCwgeyB1bmlxdWU6IHRydWUgfSApLFxuICAgICAgICByaWdodDogbmV3ICQkLkNvbGxlY3Rpb24oIGN5LCByaWdodCwgeyB1bmlxdWU6IHRydWUgfSApLFxuICAgICAgICBib3RoOiBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIGJvdGgsIHsgdW5pcXVlOiB0cnVlIH0gKVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgYWRkOiBmdW5jdGlvbiggdG9BZGQgKXtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7ICAgIFxuICAgICAgXG4gICAgICBpZiggIXRvQWRkICl7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiggJCQuaXMuc3RyaW5nKHRvQWRkKSApe1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSB0b0FkZDtcbiAgICAgICAgdG9BZGQgPSBjeS5lbGVtZW50cyhzZWxlY3Rvcik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgZWxlbWVudHMucHVzaCggdGhpc1tpXSApO1xuICAgICAgfVxuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRvQWRkLmxlbmd0aDsgaSsrICl7XG5cbiAgICAgICAgdmFyIGFkZCA9ICF0aGlzLl9wcml2YXRlLmlkc1sgdG9BZGRbaV0uaWQoKSBdO1xuICAgICAgICBpZiggYWRkICl7XG4gICAgICAgICAgZWxlbWVudHMucHVzaCggdG9BZGRbaV0gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oY3ksIGVsZW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLy8gaW4gcGxhY2UgbWVyZ2Ugb24gY2FsbGluZyBjb2xsZWN0aW9uXG4gICAgbWVyZ2U6IGZ1bmN0aW9uKCB0b0FkZCApe1xuICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICAgIHZhciBjeSA9IF9wLmN5OyAgICBcbiAgICAgIFxuICAgICAgaWYoICF0b0FkZCApe1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYoICQkLmlzLnN0cmluZyh0b0FkZCkgKXtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gdG9BZGQ7XG4gICAgICAgIHRvQWRkID0gY3kuZWxlbWVudHMoc2VsZWN0b3IpO1xuICAgICAgfVxuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRvQWRkLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciB0b0FkZEVsZSA9IHRvQWRkW2ldO1xuICAgICAgICB2YXIgaWQgPSB0b0FkZEVsZS5pZCgpO1xuICAgICAgICB2YXIgYWRkID0gIV9wLmlkc1sgaWQgXTtcblxuICAgICAgICBpZiggYWRkICl7XG4gICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5sZW5ndGgrKztcblxuICAgICAgICAgIHRoaXNbIGluZGV4IF0gPSB0b0FkZEVsZTtcbiAgICAgICAgICBfcC5pZHNbIGlkIF0gPSB0b0FkZEVsZTtcbiAgICAgICAgICBfcC5pbmRleGVzWyBpZCBdID0gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIC8vIHJlbW92ZSBzaW5nbGUgZWxlIGluIHBsYWNlIGluIGNhbGxpbmcgY29sbGVjdGlvblxuICAgIHVubWVyZ2VPbmU6IGZ1bmN0aW9uKCBlbGUgKXtcbiAgICAgIGVsZSA9IGVsZVswXTtcblxuICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuICAgICAgdmFyIGkgPSBfcC5pbmRleGVzWyBpZCBdO1xuXG4gICAgICBpZiggaSA9PSBudWxsICl7XG4gICAgICAgIHJldHVybiB0aGlzOyAvLyBubyBuZWVkIHRvIHJlbW92ZVxuICAgICAgfVxuXG4gICAgICAvLyByZW1vdmUgZWxlXG4gICAgICB0aGlzW2ldID0gdW5kZWZpbmVkO1xuICAgICAgX3AuaWRzWyBpZCBdID0gdW5kZWZpbmVkO1xuICAgICAgX3AuaW5kZXhlc1sgaWQgXSA9IHVuZGVmaW5lZDtcblxuICAgICAgdmFyIHVubWVyZ2VkTGFzdEVsZSA9IGkgPT09IHRoaXMubGVuZ3RoIC0gMTtcblxuICAgICAgLy8gcmVwbGFjZSBlbXB0eSBzcG90IHdpdGggbGFzdCBlbGUgaW4gY29sbGVjdGlvblxuICAgICAgaWYoIHRoaXMubGVuZ3RoID4gMSAmJiAhdW5tZXJnZWRMYXN0RWxlICl7XG4gICAgICAgIHZhciBsYXN0RWxlSSA9IHRoaXMubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIGxhc3RFbGUgPSB0aGlzWyBsYXN0RWxlSSBdO1xuXG4gICAgICAgIHRoaXNbIGxhc3RFbGVJIF0gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXNbaV0gPSBsYXN0RWxlO1xuICAgICAgICBfcC5pbmRleGVzWyBsYXN0RWxlLmlkKCkgXSA9IGk7XG4gICAgICB9XG5cbiAgICAgIC8vIHRoZSBjb2xsZWN0aW9uIGlzIG5vdyAxIGVsZSBzbWFsbGVyXG4gICAgICB0aGlzLmxlbmd0aC0tO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gcmVtb3ZlIGVsZXMgaW4gcGxhY2Ugb24gY2FsbGluZyBjb2xsZWN0aW9uXG4gICAgdW5tZXJnZTogZnVuY3Rpb24oIHRvUmVtb3ZlICl7XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5OyAgICBcbiAgICAgIFxuICAgICAgaWYoICF0b1JlbW92ZSApe1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgaWYoICQkLmlzLnN0cmluZyh0b1JlbW92ZSkgKXtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gdG9SZW1vdmU7XG4gICAgICAgIHRvUmVtb3ZlID0gY3kuZWxlbWVudHMoc2VsZWN0b3IpO1xuICAgICAgfVxuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRvUmVtb3ZlLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHRoaXMudW5tZXJnZU9uZSggdG9SZW1vdmVbaV0gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIG1hcDogZnVuY3Rpb24oIG1hcEZuLCB0aGlzQXJnICl7XG4gICAgICB2YXIgYXJyID0gW107XG4gICAgICB2YXIgZWxlcyA9IHRoaXM7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgdmFyIHJldCA9IHRoaXNBcmcgPyBtYXBGbi5hcHBseSggdGhpc0FyZywgW2VsZSwgaSwgZWxlc10gKSA6IG1hcEZuKCBlbGUsIGksIGVsZXMgKTtcblxuICAgICAgICBhcnIucHVzaCggcmV0ICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcblxuICAgIHN0ZEZpbHRlcjogZnVuY3Rpb24oIGZuLCB0aGlzQXJnICl7XG4gICAgICB2YXIgZmlsdGVyRWxlcyA9IFtdO1xuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICB2YXIgaW5jbHVkZSA9IHRoaXNBcmcgPyBmbi5hcHBseSggdGhpc0FyZywgW2VsZSwgaSwgZWxlc10gKSA6IGZuKCBlbGUsIGksIGVsZXMgKTtcblxuICAgICAgICBpZiggaW5jbHVkZSApe1xuICAgICAgICAgIGZpbHRlckVsZXMucHVzaCggZWxlICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgZmlsdGVyRWxlcyApO1xuICAgIH0sXG5cbiAgICBtYXg6IGZ1bmN0aW9uKCB2YWxGbiwgdGhpc0FyZyApe1xuICAgICAgdmFyIG1heCA9IC1JbmZpbml0eTtcbiAgICAgIHZhciBtYXhFbGU7XG4gICAgICB2YXIgZWxlcyA9IHRoaXM7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXNBcmcgPyB2YWxGbi5hcHBseSggdGhpc0FyZywgWyBlbGUsIGksIGVsZXMgXSApIDogdmFsRm4oIGVsZSwgaSwgZWxlcyApO1xuXG4gICAgICAgIGlmKCB2YWwgPiBtYXggKXtcbiAgICAgICAgICBtYXggPSB2YWw7XG4gICAgICAgICAgbWF4RWxlID0gZWxlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBtYXgsXG4gICAgICAgIGVsZTogbWF4RWxlXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICBtaW46IGZ1bmN0aW9uKCB2YWxGbiwgdGhpc0FyZyApe1xuICAgICAgdmFyIG1pbiA9IEluZmluaXR5O1xuICAgICAgdmFyIG1pbkVsZTtcbiAgICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICB2YXIgdmFsID0gdGhpc0FyZyA/IHZhbEZuLmFwcGx5KCB0aGlzQXJnLCBbIGVsZSwgaSwgZWxlcyBdICkgOiB2YWxGbiggZWxlLCBpLCBlbGVzICk7XG5cbiAgICAgICAgaWYoIHZhbCA8IG1pbiApe1xuICAgICAgICAgIG1pbiA9IHZhbDtcbiAgICAgICAgICBtaW5FbGUgPSBlbGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IG1pbixcbiAgICAgICAgZWxlOiBtaW5FbGVcbiAgICAgIH07XG4gICAgfVxuICB9KTtcblxuICAvLyBhbGlhc2VzXG4gIHZhciBmbiA9ICQkLmVsZXNmbjtcbiAgZm5bJ3UnXSA9IGZuWyd8J10gPSBmblsnKyddID0gZm4udW5pb24gPSBmbi5vciA9IGZuLmFkZDtcbiAgZm5bJ1xcXFwnXSA9IGZuWychJ10gPSBmblsnLSddID0gZm4uZGlmZmVyZW5jZSA9IGZuLnJlbGF0aXZlQ29tcGxlbWVudCA9IGZuLm5vdDtcbiAgZm5bJ24nXSA9IGZuWycmJ10gPSBmblsnLiddID0gZm4uYW5kID0gZm4uaW50ZXJzZWN0aW9uID0gZm4uaW50ZXJzZWN0O1xuICBmblsnXiddID0gZm5bJygrKSddID0gZm5bJygtKSddID0gZm4uc3ltbWV0cmljRGlmZmVyZW5jZSA9IGZuLnN5bWRpZmYgPSBmbi54b3I7XG4gIGZuLmZuRmlsdGVyID0gZm4uZmlsdGVyRm4gPSBmbi5zdGRGaWx0ZXI7XG4gIGZuLmNvbXBsZW1lbnQgPSBmbi5hYnNjb21wID0gZm4uYWJzb2x1dGVDb21wbGVtZW50O1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgJCQuZm4uZWxlcyh7XG4gICAgaXNOb2RlOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMuZ3JvdXAoKSA9PT0gJ25vZGVzJztcbiAgICB9LFxuXG4gICAgaXNFZGdlOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMuZ3JvdXAoKSA9PT0gJ2VkZ2VzJztcbiAgICB9LFxuXG4gICAgaXNMb29wOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMuaXNFZGdlKCkgJiYgdGhpcy5zb3VyY2UoKS5pZCgpID09PSB0aGlzLnRhcmdldCgpLmlkKCk7XG4gICAgfSxcblxuICAgIGlzU2ltcGxlOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMuaXNFZGdlKCkgJiYgdGhpcy5zb3VyY2UoKS5pZCgpICE9PSB0aGlzLnRhcmdldCgpLmlkKCk7XG4gICAgfSxcblxuICAgIGdyb3VwOiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5ncm91cDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIFxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgLy8gRnVuY3Rpb25zIGZvciBpdGVyYXRpbmcgb3ZlciBjb2xsZWN0aW9uc1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIFxuICAkJC5mbi5lbGVzKHtcbiAgICBlYWNoOiBmdW5jdGlvbihmbil7XG4gICAgICBpZiggJCQuaXMuZm4oZm4pICl7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgICAgICB2YXIgcmV0ID0gZm4uYXBwbHkoIGVsZSwgWyBpLCBlbGUgXSApO1xuXG4gICAgICAgICAgaWYoIHJldCA9PT0gZmFsc2UgKXsgYnJlYWs7IH0gLy8gZXhpdCBlYWNoIGVhcmx5IG9uIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZm9yRWFjaDogZnVuY3Rpb24oZm4sIHRoaXNBcmcpe1xuICAgICAgaWYoICQkLmlzLmZuKGZuKSApe1xuXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgICAgICB2YXIgcmV0ID0gdGhpc0FyZyA/IGZuLmFwcGx5KCB0aGlzQXJnLCBbIGVsZSwgaSwgdGhpcyBdICkgOiBmbiggZWxlLCBpLCB0aGlzICk7XG5cbiAgICAgICAgICBpZiggcmV0ID09PSBmYWxzZSApeyBicmVhazsgfSAvLyBleGl0IGVhY2ggZWFybHkgb24gcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHRvQXJyYXk6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICAgIFxuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspe1xuICAgICAgICBhcnJheS5wdXNoKCB0aGlzW2ldICk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9LFxuXG4gICAgc2xpY2U6IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpe1xuICAgICAgdmFyIGFycmF5ID0gW107XG4gICAgICB2YXIgdGhpc1NpemUgPSB0aGlzLmxlbmd0aDtcbiAgICAgIFxuICAgICAgaWYoIGVuZCA9PSBudWxsICl7XG4gICAgICAgIGVuZCA9IHRoaXNTaXplO1xuICAgICAgfVxuXG4gICAgICBpZiggc3RhcnQgPT0gbnVsbCApe1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmKCBzdGFydCA8IDAgKXtcbiAgICAgICAgc3RhcnQgPSB0aGlzU2l6ZSArIHN0YXJ0O1xuICAgICAgfVxuXG4gICAgICBpZiggZW5kIDwgMCApe1xuICAgICAgICBlbmQgPSB0aGlzU2l6ZSArIGVuZDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZm9yKHZhciBpID0gc3RhcnQ7IGkgPj0gMCAmJiBpIDwgZW5kICYmIGkgPCB0aGlzU2l6ZTsgaSsrKXtcbiAgICAgICAgYXJyYXkucHVzaCggdGhpc1tpXSApO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24odGhpcy5jeSgpLCBhcnJheSk7XG4gICAgfSxcblxuICAgIHNpemU6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gICAgfSxcblxuICAgIGVxOiBmdW5jdGlvbihpKXtcbiAgICAgIHJldHVybiB0aGlzW2ldIHx8IG5ldyAkJC5Db2xsZWN0aW9uKCB0aGlzLmN5KCkgKTtcbiAgICB9LFxuXG4gICAgZmlyc3Q6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpc1swXSB8fCBuZXcgJCQuQ29sbGVjdGlvbiggdGhpcy5jeSgpICk7XG4gICAgfSxcblxuICAgIGxhc3Q6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpc1sgdGhpcy5sZW5ndGggLSAxIF0gfHwgbmV3ICQkLkNvbGxlY3Rpb24oIHRoaXMuY3koKSApO1xuICAgIH0sXG5cbiAgICBlbXB0eTogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA9PT0gMDtcbiAgICB9LFxuXG4gICAgbm9uZW1wdHk6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gIXRoaXMuZW1wdHkoKTtcbiAgICB9LFxuXG4gICAgc29ydDogZnVuY3Rpb24oIHNvcnRGbiApe1xuICAgICAgaWYoICEkJC5pcy5mbiggc29ydEZuICkgKXtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTsgICAgICBcbiAgICAgIHZhciBzb3J0ZWQgPSB0aGlzLnRvQXJyYXkoKS5zb3J0KCBzb3J0Rm4gKTtcblxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKGN5LCBzb3J0ZWQpO1xuICAgIH0sXG5cbiAgICBzb3J0QnlaSW5kZXg6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5zb3J0KCAkJC5Db2xsZWN0aW9uLnpJbmRleFNvcnQgKTtcbiAgICB9LFxuXG4gICAgekRlcHRoOiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgICBpZiggIWVsZSApeyByZXR1cm4gdW5kZWZpbmVkOyB9XG5cbiAgICAgIC8vIHZhciBjeSA9IGVsZS5jeSgpO1xuICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgdmFyIGdyb3VwID0gX3AuZ3JvdXA7XG5cbiAgICAgIGlmKCBncm91cCA9PT0gJ25vZGVzJyApe1xuICAgICAgICB2YXIgZGVwdGggPSBfcC5kYXRhLnBhcmVudCA/IGVsZS5wYXJlbnRzKCkuc2l6ZSgpIDogMDtcbiAgICAgICAgXG4gICAgICAgIGlmKCAhZWxlLmlzUGFyZW50KCkgKXtcbiAgICAgICAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTsgLy8gY2hpbGRsZXNzIG5vZGVzIGFsd2F5cyBvbiB0b3BcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGRlcHRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNyYyA9IF9wLnNvdXJjZTtcbiAgICAgICAgdmFyIHRndCA9IF9wLnRhcmdldDtcbiAgICAgICAgdmFyIHNyY0RlcHRoID0gc3JjLnpEZXB0aCgpO1xuICAgICAgICB2YXIgdGd0RGVwdGggPSB0Z3QuekRlcHRoKCk7XG5cbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KCBzcmNEZXB0aCwgdGd0RGVwdGgsIDAgKTsgLy8gZGVwdGggb2YgZGVlcGVzdCBwYXJlbnRcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gICQkLkNvbGxlY3Rpb24uekluZGV4U29ydCA9IGZ1bmN0aW9uKGEsIGIpe1xuICAgIHZhciBjeSA9IGEuY3koKTtcbiAgICB2YXIgYV9wID0gYS5fcHJpdmF0ZTtcbiAgICB2YXIgYl9wID0gYi5fcHJpdmF0ZTtcbiAgICB2YXIgekRpZmYgPSBhX3Auc3R5bGVbJ3otaW5kZXgnXS52YWx1ZSAtIGJfcC5zdHlsZVsnei1pbmRleCddLnZhbHVlO1xuICAgIHZhciBkZXB0aEEgPSAwO1xuICAgIHZhciBkZXB0aEIgPSAwO1xuICAgIHZhciBoYXNDb21wb3VuZE5vZGVzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICAgIHZhciBhSXNOb2RlID0gYV9wLmdyb3VwID09PSAnbm9kZXMnO1xuICAgIHZhciBhSXNFZGdlID0gYV9wLmdyb3VwID09PSAnZWRnZXMnO1xuICAgIHZhciBiSXNOb2RlID0gYl9wLmdyb3VwID09PSAnbm9kZXMnO1xuICAgIHZhciBiSXNFZGdlID0gYl9wLmdyb3VwID09PSAnZWRnZXMnO1xuXG4gICAgLy8gbm8gbmVlZCB0byBjYWxjdWxhdGUgZWxlbWVudCBkZXB0aCBpZiB0aGVyZSBpcyBubyBjb21wb3VuZCBub2RlXG4gICAgaWYoIGhhc0NvbXBvdW5kTm9kZXMgKXtcbiAgICAgIGRlcHRoQSA9IGEuekRlcHRoKCk7XG4gICAgICBkZXB0aEIgPSBiLnpEZXB0aCgpO1xuICAgIH1cblxuICAgIHZhciBkZXB0aERpZmYgPSBkZXB0aEEgLSBkZXB0aEI7XG4gICAgdmFyIHNhbWVEZXB0aCA9IGRlcHRoRGlmZiA9PT0gMDtcblxuICAgIGlmKCBzYW1lRGVwdGggKXtcbiAgICAgIFxuICAgICAgaWYoIGFJc05vZGUgJiYgYklzRWRnZSApeyAgICAgIFxuICAgICAgICByZXR1cm4gMTsgLy8gJ2EnIGlzIGEgbm9kZSwgaXQgc2hvdWxkIGJlIGRyYXduIGxhdGVyICAgICAgIFxuICAgICAgXG4gICAgICB9IGVsc2UgaWYoIGFJc0VkZ2UgJiYgYklzTm9kZSApe1xuICAgICAgICByZXR1cm4gLTE7IC8vICdhJyBpcyBhbiBlZGdlLCBpdCBzaG91bGQgYmUgZHJhd24gZmlyc3RcblxuICAgICAgfSBlbHNlIHsgLy8gYm90aCBub2RlcyBvciBib3RoIGVkZ2VzICAgICAgICBcbiAgICAgICAgaWYoIHpEaWZmID09PSAwICl7IC8vIHNhbWUgei1pbmRleCA9PiBjb21wYXJlIGluZGljZXMgaW4gdGhlIGNvcmUgKG9yZGVyIGFkZGVkIHRvIGdyYXBoIHcvIGxhc3Qgb24gdG9wKVxuICAgICAgICAgIHJldHVybiBhX3AuaW5kZXggLSBiX3AuaW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHpEaWZmO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgXG4gICAgLy8gZWxlbWVudHMgb24gZGlmZmVyZW50IGxldmVsXG4gICAgfSBlbHNlIHsgICAgICBcbiAgICAgIHJldHVybiBkZXB0aERpZmY7IC8vIGRlZXBlciBlbGVtZW50IHNob3VsZCBiZSBkcmF3biBsYXRlclxuICAgIH1cblxuICB9O1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gIC8vIEZ1bmN0aW9ucyBmb3IgbGF5b3V0cyBvbiBub2Rlc1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIFxuICAkJC5mbi5lbGVzKHtcblxuICAgIC8vIHVzaW5nIHN0YW5kYXJkIGxheW91dCBvcHRpb25zLCBhcHBseSBwb3NpdGlvbiBmdW5jdGlvbiAody8gb3Igdy9vIGFuaW1hdGlvbilcbiAgICBsYXlvdXRQb3NpdGlvbnM6IGZ1bmN0aW9uKCBsYXlvdXQsIG9wdGlvbnMsIGZuICl7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICAgIGxheW91dC50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHN0YXJ0JywgbGF5b3V0OiBsYXlvdXQgfSk7XG5cbiAgICAgIGlmKCBvcHRpb25zLmFuaW1hdGUgKXtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgdmFyIGxhc3ROb2RlID0gaSA9PT0gbm9kZXMubGVuZ3RoIC0gMTtcblxuICAgICAgICAgIHZhciBuZXdQb3MgPSBmbi5jYWxsKCBub2RlLCBpLCBub2RlICk7XG4gICAgICAgICAgdmFyIHBvcyA9IG5vZGUucG9zaXRpb24oKTtcblxuICAgICAgICAgIGlmKCAhJCQuaXMubnVtYmVyKHBvcy54KSB8fCAhJCQuaXMubnVtYmVyKHBvcy55KSApe1xuICAgICAgICAgICAgbm9kZS5zaWxlbnRQb3NpdGlvbih7IHg6IDAsIHk6IDAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbm9kZS5hbmltYXRlKHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBuZXdQb3NcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbixcbiAgICAgICAgICAgIHN0ZXA6ICFsYXN0Tm9kZSA/IHVuZGVmaW5lZCA6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIGlmKCBvcHRpb25zLmZpdCApe1xuICAgICAgICAgICAgICAgIGN5LmZpdCggb3B0aW9ucy5lbGVzLCBvcHRpb25zLnBhZGRpbmcgKTtcbiAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb21wbGV0ZTogIWxhc3ROb2RlID8gdW5kZWZpbmVkIDogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgaWYoIG9wdGlvbnMuem9vbSAhPSBudWxsICl7XG4gICAgICAgICAgICAgICAgY3kuem9vbSggb3B0aW9ucy56b29tICk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiggb3B0aW9ucy5wYW4gKXtcbiAgICAgICAgICAgICAgICBjeS5wYW4oIG9wdGlvbnMucGFuICk7XG4gICAgICAgICAgICAgIH0gXG5cbiAgICAgICAgICAgICAgaWYoIG9wdGlvbnMuZml0ICl7XG4gICAgICAgICAgICAgICAgY3kuZml0KCBvcHRpb25zLmVsZXMsIG9wdGlvbnMucGFkZGluZyApO1xuICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0c3RvcCcsIG9wdGlvbnMuc3RvcCk7XG4gICAgICAgICAgICAgIGxheW91dC50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHN0b3AnLCBsYXlvdXQ6IGxheW91dCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxheW91dC5vbmUoJ2xheW91dHJlYWR5Jywgb3B0aW9ucy5yZWFkeSk7XG4gICAgICAgIGxheW91dC50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHJlYWR5JywgbGF5b3V0OiBsYXlvdXQgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2Rlcy5wb3NpdGlvbnMoIGZuICk7XG5cbiAgICAgICAgaWYoIG9wdGlvbnMuZml0ICl7XG4gICAgICAgICAgY3kuZml0KCBvcHRpb25zLmVsZXMsIG9wdGlvbnMucGFkZGluZyApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIG9wdGlvbnMuem9vbSAhPSBudWxsICl7XG4gICAgICAgICAgY3kuem9vbSggb3B0aW9ucy56b29tICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggb3B0aW9ucy5wYW4gKXtcbiAgICAgICAgICBjeS5wYW4oIG9wdGlvbnMucGFuICk7XG4gICAgICAgIH0gXG5cbiAgICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0cmVhZHknLCBvcHRpb25zLnJlYWR5KTtcbiAgICAgICAgbGF5b3V0LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0cmVhZHknLCBsYXlvdXQ6IGxheW91dCB9KTtcbiAgICAgICAgXG4gICAgICAgIGxheW91dC5vbmUoJ2xheW91dHN0b3AnLCBvcHRpb25zLnN0b3ApO1xuICAgICAgICBsYXlvdXQudHJpZ2dlcih7IHR5cGU6ICdsYXlvdXRzdG9wJywgbGF5b3V0OiBsYXlvdXQgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICBsYXlvdXQ6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICAgIGN5LmxheW91dCggJCQudXRpbC5leHRlbmQoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgZWxlczogdGhpc1xuICAgICAgfSkgKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIG1ha2VMYXlvdXQ6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICAgIHJldHVybiBjeS5tYWtlTGF5b3V0KCAkJC51dGlsLmV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgICBlbGVzOiB0aGlzXG4gICAgICB9KSApO1xuICAgIH1cblxuICB9KTtcblxuICAvLyBhbGlhc2VzOlxuICAkJC5lbGVzZm4uY3JlYXRlTGF5b3V0ID0gJCQuZWxlc2ZuLm1ha2VMYXlvdXQ7XG4gIFxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gICQkLmZuLmVsZXMoe1xuXG4gICAgLy8gZnVsbHkgdXBkYXRlcyAocmVjYWxjdWxhdGVzKSB0aGUgc3R5bGUgZm9yIHRoZSBlbGVtZW50c1xuICAgIHVwZGF0ZVN0eWxlOiBmdW5jdGlvbiggbm90aWZ5UmVuZGVyZXIgKXtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIHRoaXM7IH1cblxuICAgICAgaWYoIGN5Ll9wcml2YXRlLmJhdGNoaW5nU3R5bGUgKXtcbiAgICAgICAgdmFyIGJFbGVzID0gY3kuX3ByaXZhdGUuYmF0Y2hTdHlsZUVsZXM7XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG5cbiAgICAgICAgICBpZiggIWJFbGVzLmlkc1sgZWxlLl9wcml2YXRlLmlkIF0gKXtcbiAgICAgICAgICAgIGJFbGVzLnB1c2goIGVsZSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZyBhbmQgZXhpdCBlYXJseSB3aGVuIGJhdGNoaW5nXG4gICAgICB9XG5cbiAgICAgIHZhciBzdHlsZSA9IGN5LnN0eWxlKCk7XG4gICAgICBub3RpZnlSZW5kZXJlciA9IG5vdGlmeVJlbmRlcmVyIHx8IG5vdGlmeVJlbmRlcmVyID09PSB1bmRlZmluZWQgPyB0cnVlIDogZmFsc2U7XG5cbiAgICAgIHN0eWxlLmFwcGx5KCB0aGlzICk7XG5cbiAgICAgIHZhciB1cGRhdGVkQ29tcG91bmRzID0gdGhpcy51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuICAgICAgdmFyIHRvTm90aWZ5ID0gdXBkYXRlZENvbXBvdW5kcy5sZW5ndGggPiAwID8gdGhpcy5hZGQoIHVwZGF0ZWRDb21wb3VuZHMgKSA6IHRoaXM7XG5cbiAgICAgIGlmKCBub3RpZnlSZW5kZXJlciApe1xuICAgICAgICB0b05vdGlmeS5ydHJpZ2dlcignc3R5bGUnKTsgLy8gbGV0IHJlbmRlcmVyIGtub3cgd2UgY2hhbmdlZCBzdHlsZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9Ob3RpZnkudHJpZ2dlcignc3R5bGUnKTsgLy8ganVzdCBmaXJlIHRoZSBldmVudFxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIC8vIGp1c3QgdXBkYXRlIHRoZSBtYXBwZXJzIGluIHRoZSBlbGVtZW50cycgc3R5bGVzOyBjaGVhcGVyIHRoYW4gZWxlcy51cGRhdGVTdHlsZSgpXG4gICAgdXBkYXRlTWFwcGVyczogZnVuY3Rpb24oIG5vdGlmeVJlbmRlcmVyICl7XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgICAgdmFyIHN0eWxlID0gY3kuc3R5bGUoKTtcbiAgICAgIG5vdGlmeVJlbmRlcmVyID0gbm90aWZ5UmVuZGVyZXIgfHwgbm90aWZ5UmVuZGVyZXIgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBmYWxzZTtcblxuICAgICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgICBzdHlsZS51cGRhdGVNYXBwZXJzKCB0aGlzICk7XG5cbiAgICAgIHZhciB1cGRhdGVkQ29tcG91bmRzID0gdGhpcy51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuICAgICAgdmFyIHRvTm90aWZ5ID0gdXBkYXRlZENvbXBvdW5kcy5sZW5ndGggPiAwID8gdGhpcy5hZGQoIHVwZGF0ZWRDb21wb3VuZHMgKSA6IHRoaXM7XG5cbiAgICAgIGlmKCBub3RpZnlSZW5kZXJlciApe1xuICAgICAgICB0b05vdGlmeS5ydHJpZ2dlcignc3R5bGUnKTsgLy8gbGV0IHJlbmRlcmVyIGtub3cgd2UgY2hhbmdlZCBzdHlsZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9Ob3RpZnkudHJpZ2dlcignc3R5bGUnKTsgLy8ganVzdCBmaXJlIHRoZSBldmVudFxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIC8vIGdldCB0aGUgc3BlY2lmaWVkIGNzcyBwcm9wZXJ0eSBhcyBhIHJlbmRlcmVkIHZhbHVlIChpLmUuIG9uLXNjcmVlbiB2YWx1ZSlcbiAgICAvLyBvciBnZXQgdGhlIHdob2xlIHJlbmRlcmVkIHN0eWxlIGlmIG5vIHByb3BlcnR5IHNwZWNpZmllZCAoTkIgZG9lc24ndCBhbGxvdyBzZXR0aW5nKVxuICAgIHJlbmRlcmVkQ3NzOiBmdW5jdGlvbiggcHJvcGVydHkgKXtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIHRoaXM7IH1cblxuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgdmFyIHJlbnN0eWxlID0gZWxlLmN5KCkuc3R5bGUoKS5nZXRSZW5kZXJlZFN0eWxlKCBlbGUgKTtcblxuICAgICAgICBpZiggcHJvcGVydHkgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgIHJldHVybiByZW5zdHlsZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcmVuc3R5bGVbIHByb3BlcnR5IF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gcmVhZCB0aGUgY2FsY3VsYXRlZCBjc3Mgc3R5bGUgb2YgdGhlIGVsZW1lbnQgb3Igb3ZlcnJpZGUgdGhlIHN0eWxlICh2aWEgYSBieXBhc3MpXG4gICAgY3NzOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKXtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgIFxuICAgICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgICB2YXIgdXBkYXRlVHJhbnNpdGlvbnMgPSBmYWxzZTtcbiAgICAgIHZhciBzdHlsZSA9IGN5LnN0eWxlKCk7XG5cbiAgICAgIGlmKCAkJC5pcy5wbGFpbk9iamVjdChuYW1lKSApeyAvLyB0aGVuIGV4dGVuZCB0aGUgYnlwYXNzXG4gICAgICAgIHZhciBwcm9wcyA9IG5hbWU7XG4gICAgICAgIHN0eWxlLmFwcGx5QnlwYXNzKCB0aGlzLCBwcm9wcywgdXBkYXRlVHJhbnNpdGlvbnMgKTtcblxuICAgICAgICB2YXIgdXBkYXRlZENvbXBvdW5kcyA9IHRoaXMudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgICAgICAgdmFyIHRvTm90aWZ5ID0gdXBkYXRlZENvbXBvdW5kcy5sZW5ndGggPiAwID8gdGhpcy5hZGQoIHVwZGF0ZWRDb21wb3VuZHMgKSA6IHRoaXM7XG4gICAgICAgIHRvTm90aWZ5LnJ0cmlnZ2VyKCdzdHlsZScpOyAvLyBsZXQgdGhlIHJlbmRlcmVyIGtub3cgd2UndmUgdXBkYXRlZCBzdHlsZVxuXG4gICAgICB9IGVsc2UgaWYoICQkLmlzLnN0cmluZyhuYW1lKSApe1xuICBcbiAgICAgICAgaWYoIHZhbHVlID09PSB1bmRlZmluZWQgKXsgLy8gdGhlbiBnZXQgdGhlIHByb3BlcnR5IGZyb20gdGhlIHN0eWxlXG4gICAgICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgICAgICBpZiggZWxlICl7XG4gICAgICAgICAgICByZXR1cm4gZWxlLl9wcml2YXRlLnN0eWxlWyBuYW1lIF0uc3RyVmFsdWU7XG4gICAgICAgICAgfSBlbHNlIHsgLy8gZW1wdHkgY29sbGVjdGlvbiA9PiBjYW4ndCBnZXQgYW55IHZhbHVlXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7IC8vIHRoZW4gc2V0IHRoZSBieXBhc3Mgd2l0aCB0aGUgcHJvcGVydHkgdmFsdWVcbiAgICAgICAgICBzdHlsZS5hcHBseUJ5cGFzcyggdGhpcywgbmFtZSwgdmFsdWUsIHVwZGF0ZVRyYW5zaXRpb25zICk7XG5cbiAgICAgICAgICB2YXIgdXBkYXRlZENvbXBvdW5kcyA9IHRoaXMudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgICAgICAgICB2YXIgdG9Ob3RpZnkgPSB1cGRhdGVkQ29tcG91bmRzLmxlbmd0aCA+IDAgPyB0aGlzLmFkZCggdXBkYXRlZENvbXBvdW5kcyApIDogdGhpcztcbiAgICAgICAgICB0b05vdGlmeS5ydHJpZ2dlcignc3R5bGUnKTsgLy8gbGV0IHRoZSByZW5kZXJlciBrbm93IHdlJ3ZlIHVwZGF0ZWQgc3R5bGVcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2UgaWYoIG5hbWUgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgICBpZiggZWxlICl7XG4gICAgICAgICAgcmV0dXJuIHN0eWxlLmdldFJhd1N0eWxlKCBlbGUgKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gZW1wdHkgY29sbGVjdGlvbiA9PiBjYW4ndCBnZXQgYW55IHZhbHVlXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICByZW1vdmVDc3M6IGZ1bmN0aW9uKCBuYW1lcyApe1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgICAgXG4gICAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiB0aGlzOyB9XG5cbiAgICAgIHZhciB1cGRhdGVUcmFuc2l0aW9ucyA9IGZhbHNlO1xuICAgICAgdmFyIHN0eWxlID0gY3kuc3R5bGUoKTtcbiAgICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgICAgaWYoIG5hbWVzID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICAgICAgICBzdHlsZS5yZW1vdmVBbGxCeXBhc3NlcyggZWxlLCB1cGRhdGVUcmFuc2l0aW9ucyApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuYW1lcyA9IG5hbWVzLnNwbGl0KC9cXHMrLyk7XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICAgICAgICBzdHlsZS5yZW1vdmVCeXBhc3NlcyggZWxlLCBuYW1lcywgdXBkYXRlVHJhbnNpdGlvbnMgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdXBkYXRlZENvbXBvdW5kcyA9IHRoaXMudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgICAgIHZhciB0b05vdGlmeSA9IHVwZGF0ZWRDb21wb3VuZHMubGVuZ3RoID4gMCA/IHRoaXMuYWRkKCB1cGRhdGVkQ29tcG91bmRzICkgOiB0aGlzO1xuICAgICAgdG9Ob3RpZnkucnRyaWdnZXIoJ3N0eWxlJyk7IC8vIGxldCB0aGUgcmVuZGVyZXIga25vdyB3ZSd2ZSB1cGRhdGVkIHN0eWxlXG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICBzaG93OiBmdW5jdGlvbigpe1xuICAgICAgdGhpcy5jc3MoJ2Rpc3BsYXknLCAnZWxlbWVudCcpO1xuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIGhpZGU6IGZ1bmN0aW9uKCl7XG4gICAgICB0aGlzLmNzcygnZGlzcGxheScsICdub25lJyk7XG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgdmlzaWJsZTogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIHRydWU7IH1cblxuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcblxuICAgICAgaWYoIGVsZSApe1xuICAgICAgICB2YXIgc3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG5cbiAgICAgICAgaWYoXG4gICAgICAgICAgc3R5bGVbJ3Zpc2liaWxpdHknXS52YWx1ZSAhPT0gJ3Zpc2libGUnXG4gICAgICAgICAgfHwgc3R5bGVbJ2Rpc3BsYXknXS52YWx1ZSAhPT0gJ2VsZW1lbnQnXG4gICAgICAgICl7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiggZWxlLl9wcml2YXRlLmdyb3VwID09PSAnbm9kZXMnICl7XG4gICAgICAgICAgaWYoICFoYXNDb21wb3VuZE5vZGVzICl7IHJldHVybiB0cnVlOyB9XG5cbiAgICAgICAgICB2YXIgcGFyZW50cyA9IGVsZS5fcHJpdmF0ZS5kYXRhLnBhcmVudCA/IGVsZS5wYXJlbnRzKCkgOiBudWxsO1xuXG4gICAgICAgICAgaWYoIHBhcmVudHMgKXtcbiAgICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gcGFyZW50c1tpXTtcbiAgICAgICAgICAgICAgdmFyIHBTdHlsZSA9IHBhcmVudC5fcHJpdmF0ZS5zdHlsZTtcbiAgICAgICAgICAgICAgdmFyIHBWaXMgPSBwU3R5bGVbJ3Zpc2liaWxpdHknXS52YWx1ZTtcbiAgICAgICAgICAgICAgdmFyIHBEaXMgPSBwU3R5bGVbJ2Rpc3BsYXknXS52YWx1ZTtcblxuICAgICAgICAgICAgICBpZiggcFZpcyAhPT0gJ3Zpc2libGUnIHx8IHBEaXMgIT09ICdlbGVtZW50JyApe1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzcmMgPSBlbGUuX3ByaXZhdGUuc291cmNlO1xuICAgICAgICAgIHZhciB0Z3QgPSBlbGUuX3ByaXZhdGUudGFyZ2V0O1xuXG4gICAgICAgICAgcmV0dXJuIHNyYy52aXNpYmxlKCkgJiYgdGd0LnZpc2libGUoKTtcbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgfSxcblxuICAgIGhpZGRlbjogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICBpZiggZWxlICl7XG4gICAgICAgIHJldHVybiAhZWxlLnZpc2libGUoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZWZmZWN0aXZlT3BhY2l0eTogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIDE7IH1cblxuICAgICAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYoIGVsZSApe1xuICAgICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICAgIHZhciBwYXJlbnRPcGFjaXR5ID0gX3Auc3R5bGUub3BhY2l0eS52YWx1ZTtcblxuICAgICAgICBpZiggIWhhc0NvbXBvdW5kTm9kZXMgKXsgcmV0dXJuIHBhcmVudE9wYWNpdHk7IH1cblxuICAgICAgICB2YXIgcGFyZW50cyA9ICFfcC5kYXRhLnBhcmVudCA/IG51bGwgOiBlbGUucGFyZW50cygpO1xuICAgICAgICBcbiAgICAgICAgaWYoIHBhcmVudHMgKXtcbiAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRzW2ldO1xuICAgICAgICAgICAgdmFyIG9wYWNpdHkgPSBwYXJlbnQuX3ByaXZhdGUuc3R5bGUub3BhY2l0eS52YWx1ZTtcblxuICAgICAgICAgICAgcGFyZW50T3BhY2l0eSA9IG9wYWNpdHkgKiBwYXJlbnRPcGFjaXR5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJlbnRPcGFjaXR5O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB0cmFuc3BhcmVudDogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgICAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBlbGUuY3koKS5oYXNDb21wb3VuZE5vZGVzKCk7XG5cbiAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgaWYoICFoYXNDb21wb3VuZE5vZGVzICl7XG4gICAgICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5zdHlsZS5vcGFjaXR5LnZhbHVlID09PSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBlbGUuZWZmZWN0aXZlT3BhY2l0eSgpID09PSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGlzRnVsbEF1dG9QYXJlbnQ6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYoIGVsZSApe1xuICAgICAgICB2YXIgYXV0b1cgPSBlbGUuX3ByaXZhdGUuc3R5bGVbJ3dpZHRoJ10udmFsdWUgPT09ICdhdXRvJztcbiAgICAgICAgdmFyIGF1dG9IID0gZWxlLl9wcml2YXRlLnN0eWxlWydoZWlnaHQnXS52YWx1ZSA9PT0gJ2F1dG8nO1xuXG4gICAgICAgIHJldHVybiBlbGUuaXNQYXJlbnQoKSAmJiBhdXRvVyAmJiBhdXRvSDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYmFja2dyb3VuZGluZzogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICByZXR1cm4gZWxlLl9wcml2YXRlLmJhY2tncm91bmRpbmcgPyB0cnVlIDogZmFsc2U7XG4gICAgfVxuXG4gIH0pO1xuXG5cbiAgJCQuZWxlc2ZuLmJ5cGFzcyA9ICQkLmVsZXNmbi5zdHlsZSA9ICQkLmVsZXNmbi5jc3M7XG4gICQkLmVsZXNmbi5yZW5kZXJlZFN0eWxlID0gJCQuZWxlc2ZuLnJlbmRlcmVkQ3NzO1xuICAkJC5lbGVzZm4ucmVtb3ZlQnlwYXNzID0gJCQuZWxlc2ZuLnJlbW92ZVN0eWxlID0gJCQuZWxlc2ZuLnJlbW92ZUNzcztcbiAgXG59KSggY3l0b3NjYXBlICk7XG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgLy8gQ29sbGVjdGlvbiBmdW5jdGlvbnMgdGhhdCB0b2dnbGUgYSBib29sZWFuIHZhbHVlXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgXG4gIFxuICBmdW5jdGlvbiBkZWZpbmVTd2l0Y2hGdW5jdGlvbihwYXJhbXMpe1xuICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB2YXIgY2hhbmdlZEVsZXMgPSBbXTtcbiAgICAgIFxuICAgICAgLy8gZS5nLiBjeS5ub2RlcygpLnNlbGVjdCggZGF0YSwgaGFuZGxlciApXG4gICAgICBpZiggYXJncy5sZW5ndGggPT09IDIgKXtcbiAgICAgICAgdmFyIGRhdGEgPSBhcmdzWzBdO1xuICAgICAgICB2YXIgaGFuZGxlciA9IGFyZ3NbMV07XG4gICAgICAgIHRoaXMuYmluZCggcGFyYW1zLmV2ZW50LCBkYXRhLCBoYW5kbGVyICk7XG4gICAgICB9IFxuICAgICAgXG4gICAgICAvLyBlLmcuIGN5Lm5vZGVzKCkuc2VsZWN0KCBoYW5kbGVyIClcbiAgICAgIGVsc2UgaWYoIGFyZ3MubGVuZ3RoID09PSAxICl7XG4gICAgICAgIHZhciBoYW5kbGVyID0gYXJnc1swXTtcbiAgICAgICAgdGhpcy5iaW5kKCBwYXJhbXMuZXZlbnQsIGhhbmRsZXIgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gZS5nLiBjeS5ub2RlcygpLnNlbGVjdCgpXG4gICAgICBlbHNlIGlmKCBhcmdzLmxlbmd0aCA9PT0gMCApe1xuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgICAgICB2YXIgYWJsZSA9ICFwYXJhbXMuYWJsZUZpZWxkIHx8IGVsZS5fcHJpdmF0ZVtwYXJhbXMuYWJsZUZpZWxkXTtcbiAgICAgICAgICB2YXIgY2hhbmdlZCA9IGVsZS5fcHJpdmF0ZVtwYXJhbXMuZmllbGRdICE9IHBhcmFtcy52YWx1ZTtcblxuICAgICAgICAgIGlmKCBwYXJhbXMub3ZlcnJpZGVBYmxlICl7XG4gICAgICAgICAgICB2YXIgb3ZlcnJpZGVBYmxlID0gcGFyYW1zLm92ZXJyaWRlQWJsZShlbGUpO1xuXG4gICAgICAgICAgICBpZiggb3ZlcnJpZGVBYmxlICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICAgICAgYWJsZSA9IG92ZXJyaWRlQWJsZTtcblxuICAgICAgICAgICAgICBpZiggIW92ZXJyaWRlQWJsZSApeyByZXR1cm4gdGhpczsgfSAvLyB0byBzYXZlIGN5Y2xlcyBhc3N1bWUgbm90IGFibGUgZm9yIGFsbCBvbiBvdmVycmlkZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCBhYmxlICl7XG4gICAgICAgICAgICBlbGUuX3ByaXZhdGVbcGFyYW1zLmZpZWxkXSA9IHBhcmFtcy52YWx1ZTtcblxuICAgICAgICAgICAgaWYoIGNoYW5nZWQgKXtcbiAgICAgICAgICAgICAgY2hhbmdlZEVsZXMucHVzaCggZWxlICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoYW5nZWRDb2xsID0gJCQuQ29sbGVjdGlvbiggdGhpcy5jeSgpLCBjaGFuZ2VkRWxlcyApO1xuICAgICAgICBjaGFuZ2VkQ29sbC51cGRhdGVTdHlsZSgpOyAvLyBjaGFuZ2Ugb2Ygc3RhdGUgPT4gcG9zc2libGUgY2hhbmdlIG9mIHN0eWxlXG4gICAgICAgIGNoYW5nZWRDb2xsLnRyaWdnZXIoIHBhcmFtcy5ldmVudCApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICB9XG4gIFxuICBmdW5jdGlvbiBkZWZpbmVTd2l0Y2hTZXQoIHBhcmFtcyApe1xuICAgICQkLmVsZXNmblsgcGFyYW1zLmZpZWxkIF0gPSBmdW5jdGlvbigpe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgaWYoIHBhcmFtcy5vdmVycmlkZUZpZWxkICl7XG4gICAgICAgICAgdmFyIHZhbCA9IHBhcmFtcy5vdmVycmlkZUZpZWxkKGVsZSk7XG5cbiAgICAgICAgICBpZiggdmFsICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZVsgcGFyYW1zLmZpZWxkIF07XG4gICAgICB9XG4gICAgfTtcbiAgICBcbiAgICAkJC5lbGVzZm5bIHBhcmFtcy5vbiBdID0gZGVmaW5lU3dpdGNoRnVuY3Rpb24oe1xuICAgICAgZXZlbnQ6IHBhcmFtcy5vbixcbiAgICAgIGZpZWxkOiBwYXJhbXMuZmllbGQsXG4gICAgICBhYmxlRmllbGQ6IHBhcmFtcy5hYmxlRmllbGQsXG4gICAgICBvdmVycmlkZUFibGU6IHBhcmFtcy5vdmVycmlkZUFibGUsXG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgJCQuZWxlc2ZuWyBwYXJhbXMub2ZmIF0gPSBkZWZpbmVTd2l0Y2hGdW5jdGlvbih7XG4gICAgICBldmVudDogcGFyYW1zLm9mZixcbiAgICAgIGZpZWxkOiBwYXJhbXMuZmllbGQsXG4gICAgICBhYmxlRmllbGQ6IHBhcmFtcy5hYmxlRmllbGQsXG4gICAgICBvdmVycmlkZUFibGU6IHBhcmFtcy5vdmVycmlkZUFibGUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTtcbiAgfVxuICBcbiAgZGVmaW5lU3dpdGNoU2V0KHtcbiAgICBmaWVsZDogJ2xvY2tlZCcsXG4gICAgb3ZlcnJpZGVGaWVsZDogZnVuY3Rpb24oZWxlKXtcbiAgICAgIHJldHVybiBlbGUuY3koKS5hdXRvbG9jaygpID8gdHJ1ZSA6IHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIG9uOiAnbG9jaycsXG4gICAgb2ZmOiAndW5sb2NrJ1xuICB9KTtcbiAgXG4gIGRlZmluZVN3aXRjaFNldCh7XG4gICAgZmllbGQ6ICdncmFiYmFibGUnLFxuICAgIG92ZXJyaWRlRmllbGQ6IGZ1bmN0aW9uKGVsZSl7XG4gICAgICByZXR1cm4gZWxlLmN5KCkuYXV0b3VuZ3JhYmlmeSgpID8gZmFsc2UgOiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBvbjogJ2dyYWJpZnknLFxuICAgIG9mZjogJ3VuZ3JhYmlmeSdcbiAgfSk7XG4gIFxuICBkZWZpbmVTd2l0Y2hTZXQoe1xuICAgIGZpZWxkOiAnc2VsZWN0ZWQnLFxuICAgIGFibGVGaWVsZDogJ3NlbGVjdGFibGUnLFxuICAgIG92ZXJyaWRlQWJsZTogZnVuY3Rpb24oZWxlKXtcbiAgICAgIHJldHVybiBlbGUuY3koKS5hdXRvdW5zZWxlY3RpZnkoKSA/IGZhbHNlIDogdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgb246ICdzZWxlY3QnLFxuICAgIG9mZjogJ3Vuc2VsZWN0J1xuICB9KTtcbiAgXG4gIGRlZmluZVN3aXRjaFNldCh7XG4gICAgZmllbGQ6ICdzZWxlY3RhYmxlJyxcbiAgICBvdmVycmlkZUZpZWxkOiBmdW5jdGlvbihlbGUpe1xuICAgICAgcmV0dXJuIGVsZS5jeSgpLmF1dG91bnNlbGVjdGlmeSgpID8gZmFsc2UgOiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBvbjogJ3NlbGVjdGlmeScsXG4gICAgb2ZmOiAndW5zZWxlY3RpZnknXG4gIH0pO1xuXG4gICQkLmVsZXNmbi5kZXNlbGVjdCA9ICQkLmVsZXNmbi51bnNlbGVjdDtcbiAgXG4gICQkLmVsZXNmbi5ncmFiYmVkID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICBpZiggZWxlICl7XG4gICAgICByZXR1cm4gZWxlLl9wcml2YXRlLmdyYWJiZWQ7XG4gICAgfVxuICB9O1xuXG4gIGRlZmluZVN3aXRjaFNldCh7XG4gICAgZmllbGQ6ICdhY3RpdmUnLFxuICAgIG9uOiAnYWN0aXZhdGUnLFxuICAgIG9mZjogJ3VuYWN0aXZhdGUnXG4gIH0pO1xuXG4gICQkLmVsZXNmbi5pbmFjdGl2ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgaWYoIGVsZSApe1xuICAgICAgcmV0dXJuICFlbGUuX3ByaXZhdGUuYWN0aXZlO1xuICAgIH1cbiAgfTtcbiAgXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgLy8gREFHIGZ1bmN0aW9uc1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICQkLmZuLmVsZXMoe1xuICAgIC8vIGdldCB0aGUgcm9vdCBub2RlcyBpbiB0aGUgREFHXG4gICAgcm9vdHM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgICAgdmFyIHJvb3RzID0gW107XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgaWYoICFlbGUuaXNOb2RlKCkgKXtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoYXNFZGdlc1BvaW50aW5nSW4gPSBlbGUuY29ubmVjdGVkRWRnZXMoZnVuY3Rpb24oKXtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhKCd0YXJnZXQnKSA9PT0gZWxlLmlkKCkgJiYgdGhpcy5kYXRhKCdzb3VyY2UnKSAhPT0gZWxlLmlkKCk7XG4gICAgICAgIH0pLmxlbmd0aCA+IDA7XG5cbiAgICAgICAgaWYoICFoYXNFZGdlc1BvaW50aW5nSW4gKXtcbiAgICAgICAgICByb290cy5wdXNoKCBlbGUgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIHRoaXMuX3ByaXZhdGUuY3ksIHJvb3RzLCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgIH0sXG5cbiAgICAvLyBnZXQgdGhlIGxlYWYgbm9kZXMgaW4gdGhlIERBR1xuICAgIGxlYXZlczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgICB2YXIgbGVhdmVzID0gW107XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgaWYoICFlbGUuaXNOb2RlKCkgKXtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoYXNFZGdlc1BvaW50aW5nT3V0ID0gZWxlLmNvbm5lY3RlZEVkZ2VzKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YSgnc291cmNlJykgPT09IGVsZS5pZCgpICYmIHRoaXMuZGF0YSgndGFyZ2V0JykgIT09IGVsZS5pZCgpO1xuICAgICAgICB9KS5sZW5ndGggPiAwO1xuXG4gICAgICAgIGlmKCAhaGFzRWRnZXNQb2ludGluZ091dCApe1xuICAgICAgICAgIGxlYXZlcy5wdXNoKCBlbGUgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIHRoaXMuX3ByaXZhdGUuY3ksIGxlYXZlcywgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9LFxuXG4gICAgLy8gbm9ybWFsbHkgY2FsbGVkIGNoaWxkcmVuIGluIGdyYXBoIHRoZW9yeVxuICAgIC8vIHRoZXNlIG5vZGVzID1lZGdlcz0+IG91dGdvaW5nIG5vZGVzXG4gICAgb3V0Z29lcnM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgICAgdmFyIG9FbGVzID0gW107XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgdmFyIGVsZUlkID0gZWxlLmlkKCk7XG5cbiAgICAgICAgaWYoICFlbGUuaXNOb2RlKCkgKXsgY29udGludWU7IH1cblxuICAgICAgICB2YXIgZWRnZXMgPSBlbGUuX3ByaXZhdGUuZWRnZXM7XG4gICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgZWRnZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2pdO1xuICAgICAgICAgIHZhciBzcmNJZCA9IGVkZ2UuX3ByaXZhdGUuZGF0YS5zb3VyY2U7XG4gICAgICAgICAgdmFyIHRndElkID0gZWRnZS5fcHJpdmF0ZS5kYXRhLnRhcmdldDtcblxuICAgICAgICAgIGlmKCBzcmNJZCA9PT0gZWxlSWQgJiYgdGd0SWQgIT09IGVsZUlkICl7XG4gICAgICAgICAgICBvRWxlcy5wdXNoKCBlZGdlICk7XG4gICAgICAgICAgICBvRWxlcy5wdXNoKCBlZGdlLnRhcmdldCgpWzBdICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggdGhpcy5fcHJpdmF0ZS5jeSwgb0VsZXMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfSxcblxuICAgIC8vIGFrYSBEQUcgZGVzY2VuZGFudHNcbiAgICBzdWNjZXNzb3JzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICAgIHZhciBlbGVzID0gdGhpcztcbiAgICAgIHZhciBzRWxlcyA9IFtdO1xuICAgICAgdmFyIHNFbGVzSWRzID0ge307XG5cbiAgICAgIGZvcig7Oyl7XG4gICAgICAgIHZhciBvdXRnb2VycyA9IGVsZXMub3V0Z29lcnMoKTtcblxuICAgICAgICBpZiggb3V0Z29lcnMubGVuZ3RoID09PSAwICl7IGJyZWFrOyB9IC8vIGRvbmUgaWYgbm8gb3V0Z29lcnMgbGVmdFxuXG4gICAgICAgIHZhciBuZXdPdXRnb2VycyA9IGZhbHNlO1xuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG91dGdvZXJzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIG91dGdvZXIgPSBvdXRnb2Vyc1tpXTtcbiAgICAgICAgICB2YXIgb3V0Z29lcklkID0gb3V0Z29lci5pZCgpO1xuXG4gICAgICAgICAgaWYoICFzRWxlc0lkc1sgb3V0Z29lcklkIF0gKXtcbiAgICAgICAgICAgIHNFbGVzSWRzWyBvdXRnb2VySWQgXSA9IHRydWU7XG4gICAgICAgICAgICBzRWxlcy5wdXNoKCBvdXRnb2VyICk7XG4gICAgICAgICAgICBuZXdPdXRnb2VycyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoICFuZXdPdXRnb2VycyApeyBicmVhazsgfSAvLyBkb25lIGlmIHRvdWNoZWQgYWxsIG91dGdvZXJzIGFscmVhZHlcblxuICAgICAgICBlbGVzID0gb3V0Z29lcnM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggdGhpcy5fcHJpdmF0ZS5jeSwgc0VsZXMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfSxcblxuICAgIC8vIG5vcm1hbGx5IGNhbGxlZCBwYXJlbnRzIGluIGdyYXBoIHRoZW9yeVxuICAgIC8vIHRoZXNlIG5vZGVzIDw9ZWRnZXM9IGluY29taW5nIG5vZGVzXG4gICAgaW5jb21lcnM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgICAgdmFyIG9FbGVzID0gW107XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgdmFyIGVsZUlkID0gZWxlLmlkKCk7XG5cbiAgICAgICAgaWYoICFlbGUuaXNOb2RlKCkgKXsgY29udGludWU7IH1cblxuICAgICAgICB2YXIgZWRnZXMgPSBlbGUuX3ByaXZhdGUuZWRnZXM7XG4gICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgZWRnZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2pdO1xuICAgICAgICAgIHZhciBzcmNJZCA9IGVkZ2UuX3ByaXZhdGUuZGF0YS5zb3VyY2U7XG4gICAgICAgICAgdmFyIHRndElkID0gZWRnZS5fcHJpdmF0ZS5kYXRhLnRhcmdldDtcblxuICAgICAgICAgIGlmKCB0Z3RJZCA9PT0gZWxlSWQgJiYgc3JjSWQgIT09IGVsZUlkICl7XG4gICAgICAgICAgICBvRWxlcy5wdXNoKCBlZGdlICk7XG4gICAgICAgICAgICBvRWxlcy5wdXNoKCBlZGdlLnNvdXJjZSgpWzBdICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggdGhpcy5fcHJpdmF0ZS5jeSwgb0VsZXMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfSxcblxuICAgIC8vIGFrYSBEQUcgYW5jZXN0b3JzXG4gICAgcHJlZGVjZXNzb3JzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICAgIHZhciBlbGVzID0gdGhpcztcbiAgICAgIHZhciBwRWxlcyA9IFtdO1xuICAgICAgdmFyIHBFbGVzSWRzID0ge307XG5cbiAgICAgIGZvcig7Oyl7XG4gICAgICAgIHZhciBpbmNvbWVycyA9IGVsZXMuaW5jb21lcnMoKTtcblxuICAgICAgICBpZiggaW5jb21lcnMubGVuZ3RoID09PSAwICl7IGJyZWFrOyB9IC8vIGRvbmUgaWYgbm8gaW5jb21lcnMgbGVmdFxuXG4gICAgICAgIHZhciBuZXdJbmNvbWVycyA9IGZhbHNlO1xuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGluY29tZXJzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGluY29tZXIgPSBpbmNvbWVyc1tpXTtcbiAgICAgICAgICB2YXIgaW5jb21lcklkID0gaW5jb21lci5pZCgpO1xuXG4gICAgICAgICAgaWYoICFwRWxlc0lkc1sgaW5jb21lcklkIF0gKXtcbiAgICAgICAgICAgIHBFbGVzSWRzWyBpbmNvbWVySWQgXSA9IHRydWU7XG4gICAgICAgICAgICBwRWxlcy5wdXNoKCBpbmNvbWVyICk7XG4gICAgICAgICAgICBuZXdJbmNvbWVycyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoICFuZXdJbmNvbWVycyApeyBicmVhazsgfSAvLyBkb25lIGlmIHRvdWNoZWQgYWxsIGluY29tZXJzIGFscmVhZHlcblxuICAgICAgICBlbGVzID0gaW5jb21lcnM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggdGhpcy5fcHJpdmF0ZS5jeSwgcEVsZXMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfVxuICB9KTtcblxuXG4gIC8vIE5laWdoYm91cmhvb2QgZnVuY3Rpb25zXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgJCQuZm4uZWxlcyh7XG4gICAgbmVpZ2hib3Job29kOiBmdW5jdGlvbihzZWxlY3Rvcil7XG4gICAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXsgLy8gZm9yIGFsbCBub2Rlc1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICB2YXIgY29ubmVjdGVkRWRnZXMgPSBub2RlLmNvbm5lY3RlZEVkZ2VzKCk7XG5cbiAgICAgICAgLy8gZm9yIGVhY2ggY29ubmVjdGVkIGVkZ2UsIGFkZCB0aGUgZWRnZSBhbmQgdGhlIG90aGVyIG5vZGVcbiAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBjb25uZWN0ZWRFZGdlcy5sZW5ndGg7IGorKyApe1xuICAgICAgICAgIHZhciBlZGdlID0gY29ubmVjdGVkRWRnZXNbal07XG4gICAgICAgICAgdmFyIG90aGVyTm9kZSA9IGVkZ2UuY29ubmVjdGVkTm9kZXMoKS5ub3Qobm9kZSk7XG5cbiAgICAgICAgICAvLyBuZWVkIGNoZWNrIGluIGNhc2Ugb2YgbG9vcFxuICAgICAgICAgIGlmKCBvdGhlck5vZGUubGVuZ3RoID4gMCApe1xuICAgICAgICAgICAgZWxlbWVudHMucHVzaCggb3RoZXJOb2RlWzBdICk7IC8vIGFkZCBub2RlIDEgaG9wIGF3YXlcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gYWRkIGNvbm5lY3RlZCBlZGdlXG4gICAgICAgICAgZWxlbWVudHMucHVzaCggZWRnZVswXSApO1xuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuICggbmV3ICQkLkNvbGxlY3Rpb24oIGN5LCBlbGVtZW50cywgeyB1bmlxdWU6IHRydWUgfSApICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgIH0sXG5cbiAgICBjbG9zZWROZWlnaGJvcmhvb2Q6IGZ1bmN0aW9uKHNlbGVjdG9yKXtcbiAgICAgIHJldHVybiB0aGlzLm5laWdoYm9yaG9vZCgpLmFkZCggdGhpcyApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9LFxuXG4gICAgb3Blbk5laWdoYm9yaG9vZDogZnVuY3Rpb24oc2VsZWN0b3Ipe1xuICAgICAgcmV0dXJuIHRoaXMubmVpZ2hib3Job29kKCBzZWxlY3RvciApO1xuICAgIH1cbiAgfSk7ICBcblxuICAvLyBhbGlhc2VzXG4gICQkLmVsZXNmbi5uZWlnaGJvdXJob29kID0gJCQuZWxlc2ZuLm5laWdoYm9yaG9vZDtcbiAgJCQuZWxlc2ZuLmNsb3NlZE5laWdoYm91cmhvb2QgPSAkJC5lbGVzZm4uY2xvc2VkTmVpZ2hib3Job29kO1xuICAkJC5lbGVzZm4ub3Blbk5laWdoYm91cmhvb2QgPSAkJC5lbGVzZm4ub3Blbk5laWdoYm9yaG9vZDtcblxuXG4gIC8vIEVkZ2UgZnVuY3Rpb25zXG4gIC8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgJCQuZm4uZWxlcyh7XG4gICAgc291cmNlOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgICAgdmFyIHNyYztcblxuICAgICAgaWYoIGVsZSApe1xuICAgICAgICBzcmMgPSBlbGUuX3ByaXZhdGUuc291cmNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3JjICYmIHNlbGVjdG9yID8gc3JjLmZpbHRlciggc2VsZWN0b3IgKSA6IHNyYztcbiAgICB9LFxuXG4gICAgdGFyZ2V0OiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgICAgdmFyIHRndDtcblxuICAgICAgaWYoIGVsZSApe1xuICAgICAgICB0Z3QgPSBlbGUuX3ByaXZhdGUudGFyZ2V0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGd0ICYmIHNlbGVjdG9yID8gdGd0LmZpbHRlciggc2VsZWN0b3IgKSA6IHRndDtcbiAgICB9LFxuXG4gICAgc291cmNlczogZGVmaW5lU291cmNlRnVuY3Rpb24oe1xuICAgICAgYXR0cjogJ3NvdXJjZSdcbiAgICB9KSxcblxuICAgIHRhcmdldHM6IGRlZmluZVNvdXJjZUZ1bmN0aW9uKHtcbiAgICAgIGF0dHI6ICd0YXJnZXQnXG4gICAgfSlcbiAgfSk7XG4gIFxuICBmdW5jdGlvbiBkZWZpbmVTb3VyY2VGdW5jdGlvbiggcGFyYW1zICl7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgdmFyIHNvdXJjZXMgPSBbXTtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgICAgdmFyIHNyYyA9IGVsZS5fcHJpdmF0ZVsgcGFyYW1zLmF0dHIgXTtcblxuICAgICAgICBpZiggc3JjICl7XG4gICAgICAgICAgc291cmNlcy5wdXNoKCBzcmMgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIGN5LCBzb3VyY2VzLCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgIH07XG4gIH1cblxuICAkJC5mbi5lbGVzKHtcbiAgICBlZGdlc1dpdGg6IGRlZmluZUVkZ2VzV2l0aEZ1bmN0aW9uKCksXG5cbiAgICBlZGdlc1RvOiBkZWZpbmVFZGdlc1dpdGhGdW5jdGlvbih7XG4gICAgICB0aGlzSXM6ICdzb3VyY2UnXG4gICAgfSlcbiAgfSk7XG4gIFxuICBmdW5jdGlvbiBkZWZpbmVFZGdlc1dpdGhGdW5jdGlvbiggcGFyYW1zICl7XG4gICAgXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG90aGVyTm9kZXMpe1xuICAgICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgICAgdmFyIHAgPSBwYXJhbXMgfHwge307XG5cbiAgICAgIC8vIGdldCBlbGVtZW50cyBpZiBhIHNlbGVjdG9yIGlzIHNwZWNpZmllZFxuICAgICAgaWYoICQkLmlzLnN0cmluZyhvdGhlck5vZGVzKSApe1xuICAgICAgICBvdGhlck5vZGVzID0gY3kuJCggb3RoZXJOb2RlcyApO1xuICAgICAgfVxuICAgICAgXG4gICAgICB2YXIgdGhpc0lkcyA9IHRoaXMuX3ByaXZhdGUuaWRzO1xuICAgICAgdmFyIG90aGVySWRzID0gb3RoZXJOb2Rlcy5fcHJpdmF0ZS5pZHM7XG4gICAgICBcbiAgICAgIGZvciggdmFyIGggPSAwOyBoIDwgb3RoZXJOb2Rlcy5sZW5ndGg7IGgrKyApe1xuICAgICAgICB2YXIgZWRnZXMgPSBvdGhlck5vZGVzW2hdLl9wcml2YXRlLmVkZ2VzO1xuICAgICAgICBcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG4gICAgICAgICAgdmFyIGZvdW5kSWQ7XG4gICAgICAgICAgdmFyIGVkZ2VEYXRhID0gZWRnZS5fcHJpdmF0ZS5kYXRhO1xuICAgICAgICAgIHZhciB0aGlzVG9PdGhlciA9IHRoaXNJZHNbIGVkZ2VEYXRhLnNvdXJjZSBdICYmIG90aGVySWRzWyBlZGdlRGF0YS50YXJnZXQgXTtcbiAgICAgICAgICB2YXIgb3RoZXJUb1RoaXMgPSBvdGhlcklkc1sgZWRnZURhdGEuc291cmNlIF0gJiYgdGhpc0lkc1sgZWRnZURhdGEudGFyZ2V0IF07XG4gICAgICAgICAgdmFyIGVkZ2VDb25uZWN0c1RoaXNBbmRPdGhlciA9IHRoaXNUb090aGVyIHx8IG90aGVyVG9UaGlzO1xuXG4gICAgICAgICAgaWYoICFlZGdlQ29ubmVjdHNUaGlzQW5kT3RoZXIgKXsgY29udGludWU7IH1cblxuICAgICAgICAgIGlmKCBwLnRoaXNJcyApe1xuICAgICAgICAgICAgaWYoIHAudGhpc0lzID09PSAnc291cmNlJyAmJiAhdGhpc1RvT3RoZXIgKXsgY29udGludWU7IH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoIHAudGhpc0lzID09PSAndGFyZ2V0JyAmJiAhb3RoZXJUb1RoaXMgKXsgY29udGludWU7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgZWxlbWVudHMucHVzaCggZWRnZSApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIGVsZW1lbnRzLCB7IHVuaXF1ZTogdHJ1ZSB9ICk7XG4gICAgfTtcbiAgfVxuICBcbiAgJCQuZm4uZWxlcyh7XG4gICAgY29ubmVjdGVkRWRnZXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgdmFyIHJldEVsZXMgPSBbXTtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgICBcbiAgICAgIHZhciBlbGVzID0gdGhpcztcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgbm9kZSA9IGVsZXNbaV07XG4gICAgICAgIGlmKCAhbm9kZS5pc05vZGUoKSApeyBjb250aW51ZTsgfVxuXG4gICAgICAgIHZhciBlZGdlcyA9IG5vZGUuX3ByaXZhdGUuZWRnZXM7XG5cbiAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBlZGdlcy5sZW5ndGg7IGorKyApe1xuICAgICAgICAgIHZhciBlZGdlID0gZWRnZXNbal07ICAgICAgICAgIFxuICAgICAgICAgIHJldEVsZXMucHVzaCggZWRnZSApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIHJldEVsZXMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfSxcblxuICAgIGNvbm5lY3RlZE5vZGVzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICAgIHZhciByZXRFbGVzID0gW107XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVkZ2UgPSBlbGVzW2ldO1xuICAgICAgICBpZiggIWVkZ2UuaXNFZGdlKCkgKXsgY29udGludWU7IH1cblxuICAgICAgICByZXRFbGVzLnB1c2goIGVkZ2Uuc291cmNlKClbMF0gKTtcbiAgICAgICAgcmV0RWxlcy5wdXNoKCBlZGdlLnRhcmdldCgpWzBdICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIHJldEVsZXMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfSxcblxuICAgIHBhcmFsbGVsRWRnZXM6IGRlZmluZVBhcmFsbGVsRWRnZXNGdW5jdGlvbigpLFxuXG4gICAgY29kaXJlY3RlZEVkZ2VzOiBkZWZpbmVQYXJhbGxlbEVkZ2VzRnVuY3Rpb24oe1xuICAgICAgY29kaXJlY3RlZDogdHJ1ZVxuICAgIH0pXG4gIH0pO1xuICBcbiAgZnVuY3Rpb24gZGVmaW5lUGFyYWxsZWxFZGdlc0Z1bmN0aW9uKHBhcmFtcyl7XG4gICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgY29kaXJlY3RlZDogZmFsc2VcbiAgICB9O1xuICAgIHBhcmFtcyA9ICQkLnV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgcGFyYW1zKTtcbiAgICBcbiAgICByZXR1cm4gZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCk7XG4gICAgICB2YXIgcCA9IHBhcmFtcztcblxuICAgICAgLy8gbG9vayBhdCBhbGwgdGhlIGVkZ2VzIGluIHRoZSBjb2xsZWN0aW9uXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlZGdlMSA9IGVkZ2VzW2ldO1xuICAgICAgICB2YXIgc3JjMSA9IGVkZ2UxLnNvdXJjZSgpWzBdO1xuICAgICAgICB2YXIgc3JjaWQxID0gc3JjMS5pZCgpO1xuICAgICAgICB2YXIgdGd0MSA9IGVkZ2UxLnRhcmdldCgpWzBdO1xuICAgICAgICB2YXIgdGd0aWQxID0gdGd0MS5pZCgpO1xuICAgICAgICB2YXIgc3JjRWRnZXMxID0gc3JjMS5fcHJpdmF0ZS5lZGdlcztcblxuICAgICAgICAvLyBsb29rIGF0IGVkZ2VzIGNvbm5lY3RlZCB0byB0aGUgc3JjIG5vZGUgb2YgdGhpcyBlZGdlXG4gICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgc3JjRWRnZXMxLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgdmFyIGVkZ2UyID0gc3JjRWRnZXMxW2pdO1xuICAgICAgICAgIHZhciBlZGdlMmRhdGEgPSBlZGdlMi5fcHJpdmF0ZS5kYXRhO1xuICAgICAgICAgIHZhciB0Z3RpZDIgPSBlZGdlMmRhdGEudGFyZ2V0O1xuICAgICAgICAgIHZhciBzcmNpZDIgPSBlZGdlMmRhdGEuc291cmNlO1xuXG4gICAgICAgICAgdmFyIGNvZGlyZWN0ZWQgPSB0Z3RpZDIgPT09IHRndGlkMSAmJiBzcmNpZDIgPT09IHNyY2lkMTtcbiAgICAgICAgICB2YXIgb3BwZGlyZWN0ZWQgPSBzcmNpZDEgPT09IHRndGlkMiAmJiB0Z3RpZDEgPT09IHNyY2lkMjtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiggKHAuY29kaXJlY3RlZCAmJiBjb2RpcmVjdGVkKSB8fCAoIXAuY29kaXJlY3RlZCAmJiAoY29kaXJlY3RlZCB8fCBvcHBkaXJlY3RlZCkpICl7XG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKCBlZGdlMiApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIGN5LCBlbGVtZW50cywgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9O1xuICBcbiAgfVxuXG4gIFxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gICQkLmZuLmVsZXMoe1xuXG4gICAgZml0OiBmdW5jdGlvbigpe30sXG4gICAgY2VudGVyOiBmdW5jdGlvbigpe31cblxuICB9KTtcbiAgXG59KSggY3l0b3NjYXBlICk7XG47KGZ1bmN0aW9uICgkJCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICAvKiAgTWluIGFuZCBNYXggaGVhcCBwcmVkZWZhdWx0cyAqL1xuICBcbiAgJCQuTWluaGVhcCA9IGZ1bmN0aW9uIChjeSwgZWxlcywgdmFsdWVGbikge1xuICAgIHJldHVybiBuZXcgJCQuSGVhcChjeSwgZWxlcywgJCQuSGVhcC5taW5IZWFwQ29tcGFyYXRvciwgdmFsdWVGbik7XG4gIH07XG5cbiAgJCQuTWF4aGVhcCA9IGZ1bmN0aW9uIChjeSwgZWxlcywgdmFsdWVGbikge1xuICAgIHJldHVybiBuZXcgJCQuSGVhcChjeSwgZWxlcywgJCQuSGVhcC5tYXhIZWFwQ29tcGFyYXRvciwgdmFsdWVGbik7XG4gIH07XG4gIFxuICAkJC5IZWFwID0gZnVuY3Rpb24gKGN5LCBlbGVzLCBjb21wYXJhdG9yLCB2YWx1ZUZuKSB7XG4gICAgaWYgKHR5cGVvZiBjb21wYXJhdG9yID09PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiBlbGVzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGlmICh0eXBlb2YgdmFsdWVGbiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdmFsdWVGbiA9ICQkLkhlYXAuaWRGbjtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlSGVhcCA9IFtdLFxuICAgICAgcG9pbnRlcnMgPSB7fSxcbiAgICAgIGVsZW1lbnRzID0gW10sXG4gICAgICBpID0gMCxcbiAgICAgIGlkLFxuICAgICAgaGVhcCxcbiAgICAgIGVsZXNMZW47XG5cbiAgICBlbGVzID0gdGhpcy5nZXRBcmd1bWVudEFzQ29sbGVjdGlvbihlbGVzLCBjeSk7XG4gICAgZWxlc0xlbiA9IGVsZXMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGVsZXNMZW47IGkgKz0gMSkge1xuICAgICAgc291cmNlSGVhcC5wdXNoKHZhbHVlRm4uY2FsbChjeSwgZWxlc1tpXSwgaSwgZWxlcykpO1xuXG4gICAgICBpZCA9IGVsZXNbaV0uaWQoKTtcbiAgICAgIFxuICAgICAgaWYgKHBvaW50ZXJzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICB0aHJvdyBcIkVSUk9SOiBNdWx0aXBsZSBpdGVtcyB3aXRoIHRoZSBzYW1lIGlkIGZvdW5kOiBcIiArIGlkO1xuICAgICAgfVxuICAgICAgXG4gICAgICBwb2ludGVyc1tpZF0gPSBpO1xuICAgICAgZWxlbWVudHMucHVzaChpZCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcHJpdmF0ZSA9IHtcbiAgICAgIGN5OiBjeSxcbiAgICAgIGhlYXA6IHNvdXJjZUhlYXAsXG4gICAgICBwb2ludGVyczogcG9pbnRlcnMsXG4gICAgICBlbGVtZW50czogZWxlbWVudHMsXG4gICAgICBjb21wYXJhdG9yOiBjb21wYXJhdG9yLFxuICAgICAgZXh0cmFjdG9yOiB2YWx1ZUZuLFxuICAgICAgbGVuZ3RoOiBlbGVzTGVuXG4gICAgfTtcblxuICAgIGZvciAoaSA9IE1hdGguZmxvb3IoZWxlc0xlbiAvIDIpOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgaGVhcCA9IHRoaXMuaGVhcGlmeShpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGVhcDtcbiAgfTtcblxuICAvKiBzdGF0aWMgbWV0aG9kcyAqL1xuICAkJC5IZWFwLmlkRm4gPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBub2RlLmlkKCk7XG4gIH07XG5cbiAgJCQuSGVhcC5taW5IZWFwQ29tcGFyYXRvciA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEgPj0gYjtcbiAgfTtcblxuICAkJC5IZWFwLm1heEhlYXBDb21wYXJhdG9yID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYSA8PSBiO1xuICB9O1xuXG4gICQkLmZuLmhlYXAgPSBmdW5jdGlvbiggZm5NYXAsIG9wdGlvbnMgKXtcbiAgICBmb3IoIHZhciBuYW1lIGluIGZuTWFwICl7XG4gICAgICB2YXIgZm4gPSBmbk1hcFtuYW1lXTtcbiAgICAgICQkLkhlYXAucHJvdG90eXBlWyBuYW1lIF0gPSBmbjtcbiAgICB9XG4gIH07XG5cbiAgJCQuaGVhcGZuID0gJCQuSGVhcC5wcm90b3R5cGU7IC8vIHNob3J0IGFsaWFzXG5cbiAgLyogb2JqZWN0IG1ldGhvZHMgKi9cbiAgJCQuaGVhcGZuLnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUubGVuZ3RoO1xuICB9O1xuXG4gICQkLmhlYXBmbi5nZXRBcmd1bWVudEFzQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIChlbGVzLCBjeSkge1xuICAgIHZhciByZXN1bHQ7XG4gICAgaWYodHlwZW9mIGN5ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgfVxuXG4gICAgaWYgKCQkLmlzLmVsZW1lbnRPckNvbGxlY3Rpb24oZWxlcykpIHtcbiAgICAgIHJlc3VsdCA9IGVsZXM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJlc3VsdEFycmF5ID0gW10sXG4gICAgICAgIHNvdXJjZUVsZXMgPSBbXS5jb25jYXQuYXBwbHkoW10sIFtlbGVzXSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlRWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaWQgPSBzb3VyY2VFbGVzW2ldLFxuICAgICAgICAgIGVsZSA9IGN5LmdldEVsZW1lbnRCeUlkKGlkKTtcblxuICAgICAgICBpZihlbGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJlc3VsdEFycmF5LnB1c2goZWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXN1bHQgPSBuZXcgJCQuQ29sbGVjdGlvbihjeSwgcmVzdWx0QXJyYXkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgJCQuaGVhcGZuLmlzSGVhcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJyYXkgPSB0aGlzLl9wcml2YXRlLmhlYXAsXG4gICAgICBhcnJsZW4gPSBhcnJheS5sZW5ndGgsXG4gICAgICBpLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0LFxuICAgICAgbENoZWNrLFxuICAgICAgckNoZWNrLFxuICAgICAgY29tcGFyYXRvciA9IHRoaXMuX3ByaXZhdGUuY29tcGFyYXRvcjtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBhcnJsZW47IGkgKz0gMSkge1xuICAgICAgbGVmdCA9IDIgKiBpICsgMTtcbiAgICAgIHJpZ2h0ID0gbGVmdCArIDE7XG4gICAgICBsQ2hlY2sgPSBsZWZ0IDwgYXJybGVuID8gY29tcGFyYXRvcihhcnJheVtsZWZ0XSwgYXJyYXlbaV0pIDogdHJ1ZTtcbiAgICAgIHJDaGVjayA9IHJpZ2h0IDwgYXJybGVuID8gY29tcGFyYXRvcihhcnJheVtyaWdodF0sIGFycmF5W2ldKSA6IHRydWU7XG5cbiAgICAgIGlmICghbENoZWNrIHx8ICFyQ2hlY2spIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gICQkLmhlYXBmbi5oZWFwU3dhcCA9IGZ1bmN0aW9uIChpLCBqKSB7XG4gICAgdmFyIGhlYXAgPSB0aGlzLl9wcml2YXRlLmhlYXAsXG4gICAgICBwb2ludGVycyA9IHRoaXMuX3ByaXZhdGUucG9pbnRlcnMsXG4gICAgICBlbGVtZW50cyA9IHRoaXMuX3ByaXZhdGUuZWxlbWVudHMsXG4gICAgICBzd2FwVmFsdWUgPSBoZWFwW2ldLFxuICAgICAgc3dhcEVsZW1zID0gZWxlbWVudHNbaV0sXG4gICAgICBpZEkgPSBlbGVtZW50c1tpXSxcbiAgICAgIGlkSiA9IGVsZW1lbnRzW2pdO1xuXG4gICAgaGVhcFtpXSA9IGhlYXBbal07XG4gICAgZWxlbWVudHNbaV0gPSBlbGVtZW50c1tqXTtcblxuICAgIHBvaW50ZXJzW2lkSV0gPSBqO1xuICAgIHBvaW50ZXJzW2lkSl0gPSBpO1xuXG4gICAgaGVhcFtqXSA9IHN3YXBWYWx1ZTtcbiAgICBlbGVtZW50c1tqXSA9IHN3YXBFbGVtcztcbiAgfTtcblxuICAkJC5oZWFwZm4uaGVhcGlmeSA9IGZ1bmN0aW9uIChpLCByb290VG9MZWFmKSB7XG4gICAgdmFyIHRyZWVMZW4gPSAwLFxuICAgICAgY29uZEhlYXAgPSBmYWxzZSxcbiAgICAgIGFycmF5LFxuICAgICAgY3VycmVudCxcbiAgICAgIGxlZnQsXG4gICAgICByaWdodCxcbiAgICAgIGJlc3QsXG4gICAgICBjb21wYXJhdG9yLFxuICAgICAgcGFyZW50O1xuICAgIFxuICAgIGlmICh0eXBlb2Ygcm9vdFRvTGVhZiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcm9vdFRvTGVhZiA9IHRydWU7XG4gICAgfVxuXG4gICAgYXJyYXkgPSB0aGlzLl9wcml2YXRlLmhlYXA7XG4gICAgdHJlZUxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICBjb21wYXJhdG9yID0gdGhpcy5fcHJpdmF0ZS5jb21wYXJhdG9yO1xuICAgIGN1cnJlbnQgPSBpO1xuXG4gICAgd2hpbGUgKCFjb25kSGVhcCkge1xuXG4gICAgICBpZiAocm9vdFRvTGVhZikge1xuICAgICAgICBsZWZ0ID0gMiAqIGN1cnJlbnQgKyAxO1xuICAgICAgICByaWdodCA9IGxlZnQgKyAxO1xuICAgICAgICBiZXN0ID0gY3VycmVudDtcbiAgICAgICAgXG4gICAgICAgIGlmIChsZWZ0IDwgdHJlZUxlbiAmJiAhY29tcGFyYXRvcihhcnJheVtsZWZ0XSwgYXJyYXlbYmVzdF0pKSB7XG4gICAgICAgICAgYmVzdCA9IGxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChyaWdodCA8IHRyZWVMZW4gJiYgIWNvbXBhcmF0b3IoYXJyYXlbcmlnaHRdLCBhcnJheVtiZXN0XSkpIHtcbiAgICAgICAgICBiZXN0ID0gcmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbmRIZWFwID0gYmVzdCA9PT0gY3VycmVudDtcbiAgICAgICAgXG4gICAgICAgIGlmICghY29uZEhlYXApIHtcbiAgICAgICAgICB0aGlzLmhlYXBTd2FwKGJlc3QsIGN1cnJlbnQpO1xuICAgICAgICAgIGN1cnJlbnQgPSBiZXN0O1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmVudCA9IE1hdGguZmxvb3IoKGN1cnJlbnQgLSAxKSAvIDIpO1xuICAgICAgICBiZXN0ID0gY3VycmVudDtcbiAgICAgICAgY29uZEhlYXAgPSBwYXJlbnQgPCAwIHx8IGNvbXBhcmF0b3IoYXJyYXlbYmVzdF0sIGFycmF5W3BhcmVudF0pO1xuXG4gICAgICAgIGlmICghY29uZEhlYXApIHtcbiAgICAgICAgICB0aGlzLmhlYXBTd2FwKGJlc3QsIHBhcmVudCk7XG4gICAgICAgICAgY3VycmVudCA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfSAvLyB3aGlsZVxuICB9O1xuXG4gIC8qIGNvbGxlY3Rpb25PckVsZW1lbnQgKi9cbiAgJCQuaGVhcGZuLmluc2VydCA9IGZ1bmN0aW9uIChlbGVzKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gdGhpcy5nZXRBcmd1bWVudEFzQ29sbGVjdGlvbihlbGVzKSxcbiAgICAgIGVsc2l6ZSA9IGVsZW1lbnRzLmxlbmd0aCxcbiAgICAgIGVsZW1lbnQsXG4gICAgICBlbGluZGV4LFxuICAgICAgZWx2YWx1ZSxcbiAgICAgIGVsaWQsXG4gICAgICBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGVsc2l6ZTsgaSArPSAxKSB7XG4gICAgICBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICBlbGluZGV4ID0gdGhpcy5fcHJpdmF0ZS5oZWFwLmxlbmd0aDtcbiAgICAgIGVsdmFsdWUgPSB0aGlzLl9wcml2YXRlLmV4dHJhY3RvcihlbGVtZW50KTtcbiAgICAgIGVsaWQgPSBlbGVtZW50LmlkKCk7XG5cbiAgICAgIGlmICh0aGlzLl9wcml2YXRlLnBvaW50ZXJzLmhhc093blByb3BlcnR5KGVsaWQpKSB7XG4gICAgICAgIHRocm93IFwiRVJST1I6IE11bHRpcGxlIGl0ZW1zIHdpdGggdGhlIHNhbWUgaWQgZm91bmQ6IFwiICsgZWxpZDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcHJpdmF0ZS5oZWFwLnB1c2goZWx2YWx1ZSk7XG4gICAgICB0aGlzLl9wcml2YXRlLmVsZW1lbnRzLnB1c2goZWxpZCk7XG4gICAgICB0aGlzLl9wcml2YXRlLnBvaW50ZXJzW2VsaWRdID0gZWxpbmRleDtcbiAgICAgIHRoaXMuaGVhcGlmeShlbGluZGV4LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgdGhpcy5fcHJpdmF0ZS5sZW5ndGggPSB0aGlzLl9wcml2YXRlLmhlYXAubGVuZ3RoO1xuICB9O1xuXG4gICQkLmhlYXBmbi5nZXRWYWx1ZUJ5SWQgPSBmdW5jdGlvbiAoZWxlbWVudElkKSB7XG4gICAgaWYgKHRoaXMuX3ByaXZhdGUucG9pbnRlcnMuaGFzT3duUHJvcGVydHkoZWxlbWVudElkKSkge1xuICAgICAgdmFyIGVsZW1lbnRJbmRleCA9IHRoaXMuX3ByaXZhdGUucG9pbnRlcnNbZWxlbWVudElkXTtcblxuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuaGVhcFtlbGVtZW50SW5kZXhdO1xuICAgIH1cbiAgfTtcbiAgXG4gICQkLmhlYXBmbi5jb250YWlucyA9IGZ1bmN0aW9uIChlbGVzKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gdGhpcy5nZXRBcmd1bWVudEFzQ29sbGVjdGlvbihlbGVzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHZhciBlbGVtZW50SWQgPSBlbGVtZW50c1tpXS5pZCgpO1xuXG4gICAgICBpZighdGhpcy5fcHJpdmF0ZS5wb2ludGVycy5oYXNPd25Qcm9wZXJ0eShlbGVtZW50SWQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgXG4gICQkLmhlYXBmbi50b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3ByaXZhdGUubGVuZ3RoID4gMCkge1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdGhpcy5fcHJpdmF0ZS5oZWFwWzBdLFxuICAgICAgICBpZDogdGhpcy5fcHJpdmF0ZS5lbGVtZW50c1swXVxuICAgICAgfTtcblxuICAgIH1cbiAgfTtcblxuICAkJC5oZWFwZm4ucG9wID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9wcml2YXRlLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciB0b3AgPSB0aGlzLnRvcCgpLFxuICAgICAgICBsYXN0SW5kZXggPSB0aGlzLl9wcml2YXRlLmxlbmd0aCAtIDEsXG4gICAgICAgIHJlbW92ZUNhbmRpZGF0ZSxcbiAgICAgICAgcmVtb3ZlVmFsdWUsXG4gICAgICAgIHJlbUlkO1xuXG4gICAgICB0aGlzLmhlYXBTd2FwKDAsIGxhc3RJbmRleCk7XG5cbiAgICAgIHJlbW92ZUNhbmRpZGF0ZSA9IHRoaXMuX3ByaXZhdGUuZWxlbWVudHNbbGFzdEluZGV4XTtcbiAgICAgIHJlbW92ZVZhbHVlID0gdGhpcy5fcHJpdmF0ZS5oZWFwW2xhc3RJbmRleF07XG4gICAgICByZW1JZCA9IHJlbW92ZUNhbmRpZGF0ZTtcblxuICAgICAgdGhpcy5fcHJpdmF0ZS5oZWFwLnBvcCgpO1xuICAgICAgdGhpcy5fcHJpdmF0ZS5lbGVtZW50cy5wb3AoKTtcbiAgICAgIHRoaXMuX3ByaXZhdGUubGVuZ3RoID0gdGhpcy5fcHJpdmF0ZS5oZWFwLmxlbmd0aDtcbiAgICAgIHRoaXMuX3ByaXZhdGUucG9pbnRlcnNbcmVtSWRdID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLmhlYXBpZnkoMCk7XG4gICAgICByZXR1cm4gdG9wO1xuICAgIH1cbiAgfTtcblxuICAkJC5oZWFwZm4uZmluZERpcmVjdGlvbkhlYXBpZnkgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICB2YXIgcGFyZW50ID0gTWF0aC5mbG9vcigoaW5kZXggLSAxKSAvIDIpLFxuICAgICAgYXJyYXkgPSB0aGlzLl9wcml2YXRlLmhlYXAsXG4gICAgICBjb25kSGVhcCA9IHBhcmVudCA8IDAgfHwgdGhpcy5fcHJpdmF0ZS5jb21wYXJhdG9yKGFycmF5W2luZGV4XSwgYXJyYXlbcGFyZW50XSk7XG5cbiAgICB0aGlzLmhlYXBpZnkoaW5kZXgsIGNvbmRIZWFwKTtcbiAgfTtcblxuICAvKiBlZGl0IGlzIGEgbmV3IHZhbHVlIG9yIGZ1bmN0aW9uICovXG4gIC8vIG9ubHkgdmFsdWVzIGluIGhlYXAgYXJlIHVwZGF0ZWQuIGVsZW1lbnRzIHRoZW1zZWx2ZXMgYXJlIG5vdCFcbiAgJCQuaGVhcGZuLmVkaXQgPSBmdW5jdGlvbiAoZWxlcywgZWRpdCkge1xuICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZ2V0QXJndW1lbnRBc0NvbGxlY3Rpb24oZWxlcyk7XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFyIGVsZW1lbnRJZCA9IGVsZW1lbnRzW2ldLmlkKCksXG4gICAgICAgIGVsZW1lbnRJbmRleCA9IHRoaXMuX3ByaXZhdGUucG9pbnRlcnNbZWxlbWVudElkXSxcbiAgICAgICAgZWxlbWVudFZhbHVlID0gdGhpcy5fcHJpdmF0ZS5oZWFwW2VsZW1lbnRJbmRleF07XG4gICAgICBcbiAgICAgIGlmICgkJC5pcy5udW1iZXIoZWRpdCkpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5oZWFwW2VsZW1lbnRJbmRleF0gPSBlZGl0O1xuICAgICAgICBcbiAgICAgIH0gZWxzZSBpZiAoJCQuaXMuZm4oZWRpdCkpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5oZWFwW2VsZW1lbnRJbmRleF0gPSBlZGl0LmNhbGwodGhpcy5fcHJpdmF0ZS5jeSwgZWxlbWVudFZhbHVlLCBlbGVtZW50SW5kZXgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZpbmREaXJlY3Rpb25IZWFwaWZ5KGVsZW1lbnRJbmRleCk7XG4gICAgfVxuICB9O1xuXG4gICQkLmhlYXBmbi5yZW1vdmUgPSBmdW5jdGlvbiAoZWxlcykge1xuICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZ2V0QXJndW1lbnRBc0NvbGxlY3Rpb24oZWxlcyk7XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFyIGVsZW1lbnRJZCA9IGVsZW1lbnRzW2ldLmlkKCksXG4gICAgICAgIGVsZW1lbnRJbmRleCA9IHRoaXMuX3ByaXZhdGUucG9pbnRlcnNbZWxlbWVudElkXSxcbiAgICAgICAgbGFzdEluZGV4ID0gdGhpcy5fcHJpdmF0ZS5sZW5ndGggLSAxLFxuICAgICAgICByZW1vdmVDYW5kaWRhdGUsXG4gICAgICAgIHJlbW92ZVZhbHVlLFxuICAgICAgICByZW1JZDtcblxuICAgICAgaWYgKGVsZW1lbnRJbmRleCAhPT0gbGFzdEluZGV4KSB7XG4gICAgICAgIHRoaXMuaGVhcFN3YXAoZWxlbWVudEluZGV4LCBsYXN0SW5kZXgpO1xuICAgICAgfVxuXG4gICAgICByZW1vdmVDYW5kaWRhdGUgPSB0aGlzLl9wcml2YXRlLmVsZW1lbnRzW2xhc3RJbmRleF07XG4gICAgICByZW1vdmVWYWx1ZSA9IHRoaXMuX3ByaXZhdGUuaGVhcFtsYXN0SW5kZXhdO1xuICAgICAgcmVtSWQgPSByZW1vdmVDYW5kaWRhdGU7XG5cbiAgICAgIHRoaXMuX3ByaXZhdGUuaGVhcC5wb3AoKTtcbiAgICAgIHRoaXMuX3ByaXZhdGUuZWxlbWVudHMucG9wKCk7XG4gICAgICB0aGlzLl9wcml2YXRlLmxlbmd0aCA9IHRoaXMuX3ByaXZhdGUuaGVhcC5sZW5ndGg7XG4gICAgICB0aGlzLl9wcml2YXRlLnBvaW50ZXJzW3JlbUlkXSA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy5maW5kRGlyZWN0aW9uSGVhcGlmeShlbGVtZW50SW5kZXgpO1xuICAgIH1cblxuICAgIHJldHVybiByZW1vdmVWYWx1ZTtcbiAgfTtcblxufSkoY3l0b3NjYXBlKTtcbi8qXG4gIFRoZSBjYW52YXMgcmVuZGVyZXIgd2FzIHdyaXR0ZW4gYnkgWXVlIERvbmcuXG5cbiAgTW9kaWZpY2F0aW9ucyB0cmFja2VkIG9uIEdpdGh1Yi5cbiovXG5cbihmdW5jdGlvbigkJCkgeyAndXNlIHN0cmljdCc7XG5cbiAgQ2FudmFzUmVuZGVyZXIuQ0FOVkFTX0xBWUVSUyA9IDM7XG4gIC8vXG4gIENhbnZhc1JlbmRlcmVyLlNFTEVDVF9CT1ggPSAwO1xuICBDYW52YXNSZW5kZXJlci5EUkFHID0gMTtcbiAgQ2FudmFzUmVuZGVyZXIuTk9ERSA9IDI7XG5cbiAgQ2FudmFzUmVuZGVyZXIuQlVGRkVSX0NPVU5UID0gMztcbiAgLy9cbiAgQ2FudmFzUmVuZGVyZXIuVEVYVFVSRV9CVUZGRVIgPSAwO1xuICBDYW52YXNSZW5kZXJlci5NT1RJT05CTFVSX0JVRkZFUl9OT0RFID0gMTtcbiAgQ2FudmFzUmVuZGVyZXIuTU9USU9OQkxVUl9CVUZGRVJfRFJBRyA9IDI7XG5cbiAgZnVuY3Rpb24gQ2FudmFzUmVuZGVyZXIob3B0aW9ucykgeyAgXG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgdGhpcy5kYXRhID0ge1xuICAgICAgICBcbiAgICAgIHNlbGVjdDogW3VuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgMF0sIC8vIENvb3JkaW5hdGVzIGZvciBzZWxlY3Rpb24gYm94LCBwbHVzIGVuYWJsZWQgZmxhZyBcbiAgICAgIHJlbmRlcmVyOiB0aGlzLCBjeTogb3B0aW9ucy5jeSwgY29udGFpbmVyOiBvcHRpb25zLmN5LmNvbnRhaW5lcigpLFxuICAgICAgXG4gICAgICBjYW52YXNlczogbmV3IEFycmF5KENhbnZhc1JlbmRlcmVyLkNBTlZBU19MQVlFUlMpLFxuICAgICAgY29udGV4dHM6IG5ldyBBcnJheShDYW52YXNSZW5kZXJlci5DQU5WQVNfTEFZRVJTKSxcbiAgICAgIGNhbnZhc05lZWRzUmVkcmF3OiBuZXcgQXJyYXkoQ2FudmFzUmVuZGVyZXIuQ0FOVkFTX0xBWUVSUyksXG4gICAgICBcbiAgICAgIGJ1ZmZlckNhbnZhc2VzOiBuZXcgQXJyYXkoQ2FudmFzUmVuZGVyZXIuQlVGRkVSX0NPVU5UKSxcbiAgICAgIGJ1ZmZlckNvbnRleHRzOiBuZXcgQXJyYXkoQ2FudmFzUmVuZGVyZXIuQ0FOVkFTX0xBWUVSUylcblxuICAgIH07XG4gICAgXG4gICAgLy8tLVBvaW50ZXItcmVsYXRlZCBkYXRhXG4gICAgdGhpcy5ob3ZlckRhdGEgPSB7ZG93bjogbnVsbCwgbGFzdDogbnVsbCwgXG4gICAgICAgIGRvd25UaW1lOiBudWxsLCB0cmlnZ2VyTW9kZTogbnVsbCwgXG4gICAgICAgIGRyYWdnaW5nOiBmYWxzZSwgXG4gICAgICAgIGluaXRpYWxQYW46IFtudWxsLCBudWxsXSwgY2FwdHVyZTogZmFsc2V9O1xuICAgIFxuICAgIHRoaXMudGltZW91dERhdGEgPSB7cGFuVGltZW91dDogbnVsbH07XG4gICAgXG4gICAgdGhpcy5kcmFnRGF0YSA9IHtwb3NzaWJsZURyYWdFbGVtZW50czogW119O1xuICAgIFxuICAgIHRoaXMudG91Y2hEYXRhID0ge3N0YXJ0OiBudWxsLCBjYXB0dXJlOiBmYWxzZSxcbiAgICAgICAgLy8gVGhlc2UgMyBmaWVsZHMgcmVsYXRlZCB0byB0YXAsIHRhcGhvbGQgZXZlbnRzXG4gICAgICAgIHN0YXJ0UG9zaXRpb246IFtudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsXSxcbiAgICAgICAgc2luZ2xlVG91Y2hTdGFydFRpbWU6IG51bGwsXG4gICAgICAgIHNpbmdsZVRvdWNoTW92ZWQ6IHRydWUsXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgbm93OiBbbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF0sIFxuICAgICAgICBlYXJsaWVyOiBbbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF0gfTtcbiAgICAvLy0tXG4gICAgXG4gICAgLy8tLVdoZWVsLXJlbGF0ZWQgZGF0YSBcbiAgICB0aGlzLnpvb21EYXRhID0ge2ZyZWVUb1pvb206IGZhbHNlLCBsYXN0UG9pbnRlclg6IG51bGx9O1xuICAgIC8vLS1cbiAgICBcbiAgICB0aGlzLnJlZHJhd3MgPSAwO1xuICAgIHRoaXMuc2hvd0ZwcyA9IG9wdGlvbnMuc2hvd0ZwcztcblxuICAgIHRoaXMuYmluZGluZ3MgPSBbXTtcbiAgICBcbiAgICB0aGlzLmRhdGEuY2FudmFzQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdmFyIGNvbnRhaW5lclN0eWxlID0gdGhpcy5kYXRhLmNhbnZhc0NvbnRhaW5lci5zdHlsZTtcbiAgICBjb250YWluZXJTdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgY29udGFpbmVyU3R5bGUuekluZGV4ID0gJzAnO1xuICAgIGNvbnRhaW5lclN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG5cbiAgICB0aGlzLmRhdGEuY29udGFpbmVyLmFwcGVuZENoaWxkKCB0aGlzLmRhdGEuY2FudmFzQ29udGFpbmVyICk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IENhbnZhc1JlbmRlcmVyLkNBTlZBU19MQVlFUlM7IGkrKykge1xuICAgICAgdGhpcy5kYXRhLmNhbnZhc2VzW2ldID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICB0aGlzLmRhdGEuY29udGV4dHNbaV0gPSB0aGlzLmRhdGEuY2FudmFzZXNbaV0uZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIHRoaXMuZGF0YS5jYW52YXNlc1tpXS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICB0aGlzLmRhdGEuY2FudmFzZXNbaV0uc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgJ2xheWVyJyArIGkpO1xuICAgICAgdGhpcy5kYXRhLmNhbnZhc2VzW2ldLnN0eWxlLnpJbmRleCA9IFN0cmluZyhDYW52YXNSZW5kZXJlci5DQU5WQVNfTEFZRVJTIC0gaSk7XG4gICAgICB0aGlzLmRhdGEuY2FudmFzQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZGF0YS5jYW52YXNlc1tpXSk7XG4gICAgICBcbiAgICAgIHRoaXMuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tpXSA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmRhdGEudG9wQ2FudmFzID0gdGhpcy5kYXRhLmNhbnZhc2VzWzBdO1xuXG4gICAgdGhpcy5kYXRhLmNhbnZhc2VzW0NhbnZhc1JlbmRlcmVyLk5PREVdLnNldEF0dHJpYnV0ZSgnZGF0YS1pZCcsICdsYXllcicgKyBDYW52YXNSZW5kZXJlci5OT0RFICsgJy1ub2RlJyk7XG4gICAgdGhpcy5kYXRhLmNhbnZhc2VzW0NhbnZhc1JlbmRlcmVyLlNFTEVDVF9CT1hdLnNldEF0dHJpYnV0ZSgnZGF0YS1pZCcsICdsYXllcicgKyBDYW52YXNSZW5kZXJlci5TRUxFQ1RfQk9YICsgJy1zZWxlY3Rib3gnKTtcbiAgICB0aGlzLmRhdGEuY2FudmFzZXNbQ2FudmFzUmVuZGVyZXIuRFJBR10uc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgJ2xheWVyJyArIENhbnZhc1JlbmRlcmVyLkRSQUcgKyAnLWRyYWcnKTtcbiAgICBcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IENhbnZhc1JlbmRlcmVyLkJVRkZFUl9DT1VOVDsgaSsrKSB7XG4gICAgICB0aGlzLmRhdGEuYnVmZmVyQ2FudmFzZXNbaV0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgIHRoaXMuZGF0YS5idWZmZXJDb250ZXh0c1tpXSA9IHRoaXMuZGF0YS5idWZmZXJDYW52YXNlc1tpXS5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgdGhpcy5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgIHRoaXMuZGF0YS5idWZmZXJDYW52YXNlc1tpXS5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCAnYnVmZmVyJyArIGkpO1xuICAgICAgdGhpcy5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldLnN0eWxlLnpJbmRleCA9IFN0cmluZygtaSAtIDEpO1xuICAgICAgdGhpcy5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgIC8vdGhpcy5kYXRhLmNhbnZhc0NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRhdGEuYnVmZmVyQ2FudmFzZXNbaV0pO1xuICAgIH1cblxuICAgIHRoaXMuaGlkZUVkZ2VzT25WaWV3cG9ydCA9IG9wdGlvbnMuaGlkZUVkZ2VzT25WaWV3cG9ydDtcbiAgICB0aGlzLmhpZGVMYWJlbHNPblZpZXdwb3J0ID0gb3B0aW9ucy5oaWRlTGFiZWxzT25WaWV3cG9ydDtcbiAgICB0aGlzLnRleHR1cmVPblZpZXdwb3J0ID0gb3B0aW9ucy50ZXh0dXJlT25WaWV3cG9ydDtcbiAgICB0aGlzLndoZWVsU2Vuc2l0aXZpdHkgPSBvcHRpb25zLndoZWVsU2Vuc2l0aXZpdHk7XG4gICAgdGhpcy5tb3Rpb25CbHVyRW5hYmxlZCA9IG9wdGlvbnMubW90aW9uQmx1cjsgLy8gb24gYnkgZGVmYXVsdFxuICAgIHRoaXMuZm9yY2VkUGl4ZWxSYXRpbyA9IG9wdGlvbnMucGl4ZWxSYXRpbztcbiAgICB0aGlzLm1vdGlvbkJsdXIgPSB0cnVlOyAvLyBmb3IgaW5pdGlhbCBraWNrIG9mZlxuICAgIHRoaXMubW90aW9uQmx1ck9wYWNpdHkgPSBvcHRpb25zLm1vdGlvbkJsdXJPcGFjaXR5O1xuICAgIHRoaXMubW90aW9uQmx1clRyYW5zcGFyZW5jeSA9IDEgLSB0aGlzLm1vdGlvbkJsdXJPcGFjaXR5O1xuICAgIHRoaXMubW90aW9uQmx1clB4UmF0aW8gPSAxO1xuICAgIHRoaXMubWJQeFJCbHVycnkgPSAxOyAvLzAuODtcbiAgICB0aGlzLm1pbk1iTG93UXVhbEZyYW1lcyA9IDQ7XG4gICAgdGhpcy5mdWxsUXVhbGl0eU1iID0gZmFsc2U7XG4gICAgdGhpcy5jbGVhcmVkRm9yTW90aW9uQmx1ciA9IFtdO1xuICAgIHRoaXMuZGVza3RvcFRhcFRocmVzaG9sZCA9IG9wdGlvbnMuZGVza3RvcFRhcFRocmVzaG9sZDtcbiAgICB0aGlzLmRlc2t0b3BUYXBUaHJlc2hvbGQyID0gb3B0aW9ucy5kZXNrdG9wVGFwVGhyZXNob2xkICogb3B0aW9ucy5kZXNrdG9wVGFwVGhyZXNob2xkO1xuICAgIHRoaXMudG91Y2hUYXBUaHJlc2hvbGQgPSBvcHRpb25zLnRvdWNoVGFwVGhyZXNob2xkO1xuICAgIHRoaXMudG91Y2hUYXBUaHJlc2hvbGQyID0gb3B0aW9ucy50b3VjaFRhcFRocmVzaG9sZCAqIG9wdGlvbnMudG91Y2hUYXBUaHJlc2hvbGQ7XG4gICAgdGhpcy50YXBob2xkRHVyYXRpb24gPSA1MDA7XG5cbiAgICB0aGlzLmxvYWQoKTtcbiAgfVxuXG4gIENhbnZhc1JlbmRlcmVyLnBhbk9yQm94U2VsZWN0RGVsYXkgPSA0MDA7XG5cbiAgLy8gd2hldGhlciB0byB1c2UgUGF0aDJEIGNhY2hpbmcgZm9yIGRyYXdpbmdcbiAgdmFyIHBhdGhzSW1wbGQgPSB0eXBlb2YgUGF0aDJEICE9PSAndW5kZWZpbmVkJztcbiAgQ2FudmFzUmVuZGVyZXIudXNlUGF0aHMgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiBwYXRoc0ltcGxkO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICB2YXIgdHlwZXM7XG5cbiAgICBpZiggJCQuaXMuYXJyYXkoIHBhcmFtcy50eXBlICkgKXtcbiAgICAgIHR5cGVzID0gcGFyYW1zLnR5cGU7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZXMgPSBbIHBhcmFtcy50eXBlIF07XG4gICAgfVxuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHR5cGUgPSB0eXBlc1tpXTtcblxuICAgICAgc3dpdGNoKCB0eXBlICl7XG4gICAgICAgIGNhc2UgJ2Rlc3Ryb3knOlxuICAgICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBjYXNlICdhZGQnOlxuICAgICAgICBjYXNlICdyZW1vdmUnOlxuICAgICAgICBjYXNlICdsb2FkJzpcbiAgICAgICAgICB0aGlzLnVwZGF0ZU5vZGVzQ2FjaGUoKTtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUVkZ2VzQ2FjaGUoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd2aWV3cG9ydCc6XG4gICAgICAgICAgdGhpcy5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NhbnZhc1JlbmRlcmVyLlNFTEVDVF9CT1hdID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzdHlsZSc6XG4gICAgICAgICAgdGhpcy51cGRhdGVDYWNoZWRaU29ydGVkRWxlcygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiggdHlwZSA9PT0gJ2xvYWQnIHx8IHR5cGUgPT09ICdyZXNpemUnICl7XG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZUNvbnRhaW5lckNsaWVudENvb3Jkc0NhY2hlKCk7XG4gICAgICAgIHRoaXMubWF0Y2hDYW52YXNTaXplKHRoaXMuZGF0YS5jb250YWluZXIpO1xuICAgICAgfVxuICAgIH0gLy8gZm9yXG4gICAgXG4gICAgdGhpcy5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NhbnZhc1JlbmRlcmVyLk5PREVdID0gdHJ1ZTtcbiAgICB0aGlzLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ2FudmFzUmVuZGVyZXIuRFJBR10gPSB0cnVlO1xuXG4gICAgdGhpcy5yZWRyYXcoKTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmJpbmRpbmdzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgYmluZGluZyA9IHRoaXMuYmluZGluZ3NbaV07XG4gICAgICB2YXIgYiA9IGJpbmRpbmc7XG5cbiAgICAgIGIudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoYi5ldmVudCwgYi5oYW5kbGVyLCBiLnVzZUNhcHR1cmUpO1xuICAgIH1cblxuICAgIGlmKCB0aGlzLnJlbW92ZU9ic2VydmVyICl7XG4gICAgICB0aGlzLnJlbW92ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG5cbiAgICBpZiggdGhpcy5sYWJlbENhbGNEaXYgKXtcbiAgICAgIHRyeXtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLmxhYmVsQ2FsY0Rpdik7XG4gICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAvLyBpZTEwIGlzc3VlICMxMDE0XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFxuXG4gIC8vIGNvcHkgdGhlIG1hdGggZnVuY3Rpb25zIGludG8gdGhlIHJlbmRlcmVyIHByb3RvdHlwZVxuICAvLyB1bmZvcnR1bmF0ZWx5IHRoZXNlIGZ1bmN0aW9ucyBhcmUgdXNlZCBpbnRlcnNwZXJzZWQgdC9vIHRoZSBjb2RlXG4gIC8vIGFuZCB0aGlzIG1ha2VzIHN1cmUgdGhpbmdzIHdvcmsganVzdCBpbiBjYXNlIGEgcmVmIHdhcyBtaXNzZWQgaW4gcmVmYWN0b3JpbmdcbiAgLy8gVE9ETyByZW1vdmUgdGhpcyBldmVudHVhbGx5XG4gIGZvciggdmFyIGZuTmFtZSBpbiAkJC5tYXRoICl7XG4gICAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlWyBmbk5hbWUgXSA9ICQkLm1hdGhbIGZuTmFtZSBdO1xuICB9XG4gIFxuICBcbiAgJCQoJ3JlbmRlcmVyJywgJ2NhbnZhcycsIENhbnZhc1JlbmRlcmVyKTtcbiAgXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIENhbnZhc1JlbmRlcmVyID0gJCQoJ3JlbmRlcmVyJywgJ2NhbnZhcycpO1xuICB2YXIgcmVuZEZ1bmMgPSBDYW52YXNSZW5kZXJlci5wcm90b3R5cGU7XG4gIHZhciBhcnJvd1NoYXBlcyA9IENhbnZhc1JlbmRlcmVyLmFycm93U2hhcGVzID0ge307XG5cbiAgQ2FudmFzUmVuZGVyZXIuYXJyb3dTaGFwZUhlaWdodCA9IDAuMztcblxuICAvLyBDb250cmFjdCBmb3IgYXJyb3cgc2hhcGVzOlxuICAvLyAwLCAwIGlzIGFycm93IHRpcFxuICAvLyAoMCwgMSkgaXMgZGlyZWN0aW9uIHRvd2FyZHMgbm9kZVxuICAvLyAoMSwgMCkgaXMgcmlnaHRcbiAgLy9cbiAgLy8gZnVuY3Rpb25hbCBhcGk6XG4gIC8vIGNvbGxpZGU6IGNoZWNrIHgsIHkgaW4gc2hhcGVcbiAgLy8gcm91Z2hDb2xsaWRlOiBjYWxsZWQgYmVmb3JlIGNvbGxpZGUsIG5vIGZhbHNlIG5lZ2F0aXZlc1xuICAvLyBkcmF3OiBkcmF3XG4gIC8vIHNwYWNpbmc6IGRpc3QoYXJyb3dUaXAsIG5vZGVCb3VuZGFyeSlcbiAgLy8gZ2FwOiBkaXN0KGVkZ2VUaXAsIG5vZGVCb3VuZGFyeSksIGVkZ2VUaXAgbWF5ICE9IGFycm93VGlwXG5cbiAgdmFyIGJiQ29sbGlkZSA9IGZ1bmN0aW9uKHgsIHksIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbiwgcGFkZGluZyl7XG4gICAgdmFyIHgxID0gY2VudGVyWCAtIHdpZHRoLzI7XG4gICAgdmFyIHgyID0gY2VudGVyWCArIHdpZHRoLzI7XG4gICAgdmFyIHkxID0gY2VudGVyWSAtIGhlaWdodC8yO1xuICAgIHZhciB5MiA9IGNlbnRlclkgKyBoZWlnaHQvMjtcblxuICAgIHJldHVybiAoeDEgPD0geCAmJiB4IDw9IHgyKSAmJiAoeTEgPD0geSAmJiB5IDw9IHkyKTtcbiAgfTtcblxuICB2YXIgdHJhbnNmb3JtID0gZnVuY3Rpb24oeCwgeSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKXtcbiAgICBhbmdsZSA9IC1hbmdsZTsgLy8gYi9jIG9mIG5vdGF0aW9uIHVzZWQgaW4gYXJyb3cgZHJhdyBmblxuXG4gICAgdmFyIHhSb3RhdGVkID0geCAqIE1hdGguY29zKGFuZ2xlKSAtIHkgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgdmFyIHlSb3RhdGVkID0geCAqIE1hdGguc2luKGFuZ2xlKSArIHkgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgXG4gICAgdmFyIHhTY2FsZWQgPSB4Um90YXRlZCAqIHNpemU7XG4gICAgdmFyIHlTY2FsZWQgPSB5Um90YXRlZCAqIHNpemU7XG5cbiAgICB2YXIgeFRyYW5zbGF0ZWQgPSB4U2NhbGVkICsgdHJhbnNsYXRpb24ueDtcbiAgICB2YXIgeVRyYW5zbGF0ZWQgPSB5U2NhbGVkICsgdHJhbnNsYXRpb24ueTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgeDogeFRyYW5zbGF0ZWQsXG4gICAgICB5OiB5VHJhbnNsYXRlZFxuICAgIH07XG4gIH07XG5cbiAgYXJyb3dTaGFwZXNbJ2Fycm93J10gPSB7XG4gICAgX3BvaW50czogW1xuICAgICAgLTAuMTUsIC0wLjMsXG4gICAgICAwLCAwLFxuICAgICAgMC4xNSwgLTAuM1xuICAgIF0sXG4gICAgXG4gICAgY29sbGlkZTogZnVuY3Rpb24oeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBwYWRkaW5nKSB7XG4gICAgICB2YXIgcG9pbnRzID0gYXJyb3dTaGFwZXNbJ2Fycm93J10uX3BvaW50cztcbiAgICAgIFxuLy8gICAgICBjb25zb2xlLmxvZyhcImNvbGxpZGUoKTogXCIgKyBkaXJlY3Rpb24pO1xuICAgICAgXG4gICAgICByZXR1cm4gJCQubWF0aC5wb2ludEluc2lkZVBvbHlnb24oXG4gICAgICAgIHgsIHksIHBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBwYWRkaW5nKTtcbiAgICB9LFxuICAgIFxuICAgIHJvdWdoQ29sbGlkZTogYmJDb2xsaWRlLFxuICAgIFxuICAgIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbikge1xuICAgICAgdmFyIHBvaW50cyA9IGFycm93U2hhcGVzWydhcnJvdyddLl9wb2ludHM7XG4gICAgXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgdmFyIHB0ID0gdHJhbnNmb3JtKCBwb2ludHNbaSAqIDJdLCBwb2ludHNbaSAqIDIgKyAxXSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uICk7XG5cbiAgICAgICAgY29udGV4dC5saW5lVG8ocHQueCwgcHQueSk7XG4gICAgICB9XG5cbiAgICB9LFxuICAgIFxuICAgIHNwYWNpbmc6IGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgXG4gICAgZ2FwOiBmdW5jdGlvbihlZGdlKSB7XG4gICAgICByZXR1cm4gZWRnZS5fcHJpdmF0ZS5zdHlsZVsnd2lkdGgnXS5weFZhbHVlICogMjtcbiAgICB9XG4gIH07XG5cbiAgYXJyb3dTaGFwZXNbJ3RyaWFuZ2xlJ10gPSBhcnJvd1NoYXBlc1snYXJyb3cnXTtcbiAgXG4gIGFycm93U2hhcGVzWyd0cmlhbmdsZS1iYWNrY3VydmUnXSA9IHtcbiAgICBfY3RybFB0OiBbIDAsIC0wLjE1IF0sXG5cbiAgICBjb2xsaWRlOiBmdW5jdGlvbih4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcpIHtcbiAgICAgIHZhciBwb2ludHMgPSBhcnJvd1NoYXBlc1sndHJpYW5nbGUnXS5fcG9pbnRzO1xuICAgICAgXG4vLyAgICAgIGNvbnNvbGUubG9nKFwiY29sbGlkZSgpOiBcIiArIGRpcmVjdGlvbik7XG4gICAgICBcbiAgICAgIHJldHVybiAkJC5tYXRoLnBvaW50SW5zaWRlUG9seWdvbihcbiAgICAgICAgeCwgeSwgcG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcpO1xuICAgIH0sXG4gICAgXG4gICAgcm91Z2hDb2xsaWRlOiBiYkNvbGxpZGUsXG4gICAgXG4gICAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKSB7XG4gICAgICB2YXIgcG9pbnRzID0gYXJyb3dTaGFwZXNbJ3RyaWFuZ2xlJ10uX3BvaW50cztcbiAgICAgIHZhciBmaXJzdFB0O1xuICAgIFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICAgIHZhciBwdCA9IHRyYW5zZm9ybSggcG9pbnRzW2kgKiAyXSwgcG9pbnRzW2kgKiAyICsgMV0sIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApO1xuXG4gICAgICAgIGlmKCBpID09PSAwICl7XG4gICAgICAgICAgZmlyc3RQdCA9IHB0O1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5saW5lVG8ocHQueCwgcHQueSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdHJsUHQgPSB0aGlzLl9jdHJsUHQ7XG4gICAgICB2YXIgY3RybFB0VHJhbnMgPSB0cmFuc2Zvcm0oIGN0cmxQdFswXSwgY3RybFB0WzFdLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24gKTtcblxuICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKCBjdHJsUHRUcmFucy54LCBjdHJsUHRUcmFucy55LCBmaXJzdFB0LngsIGZpcnN0UHQueSApO1xuICAgIH0sXG4gICAgXG4gICAgc3BhY2luZzogZnVuY3Rpb24oZWRnZSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcbiAgICBcbiAgICBnYXA6IGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgIHJldHVybiBlZGdlLl9wcml2YXRlLnN0eWxlWyd3aWR0aCddLnB4VmFsdWUgKiAyO1xuICAgIH1cbiAgfTtcbiAgXG5cbiAgYXJyb3dTaGFwZXNbJ3RyaWFuZ2xlLXRlZSddID0ge1xuICAgIF9wb2ludHM6IFtcbiAgICAgIC0wLjE1LCAtMC4zLFxuICAgICAgMCwgMCxcbiAgICAgIDAuMTUsIC0wLjMsXG4gICAgICAtMC4xNSwgLTAuM1xuICAgIF0sXG5cbiAgICBfcG9pbnRzVGVlOiBbXG4gICAgICAtMC4xNSwgLTAuNCxcbiAgICAgIC0wLjE1LCAtMC41LFxuICAgICAgMC4xNSwgLTAuNSxcbiAgICAgIDAuMTUsIC0wLjRcbiAgICBdLFxuICAgIFxuICAgIGNvbGxpZGU6IGZ1bmN0aW9uKHgsIHksIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbiwgcGFkZGluZykge1xuICAgICAgdmFyIHRyaVB0cyA9IGFycm93U2hhcGVzWyd0cmlhbmdsZS10ZWUnXS5fcG9pbnRzO1xuICAgICAgdmFyIHRlZVB0cyA9IGFycm93U2hhcGVzWyd0cmlhbmdsZS10ZWUnXS5fcG9pbnRzVGVlO1xuICAgICAgXG4gICAgICB2YXIgaW5zaWRlID0gJCQubWF0aC5wb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGVlUHRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcpIFxuICAgICAgICB8fCAkJC5tYXRoLnBvaW50SW5zaWRlUG9seWdvbih4LCB5LCB0cmlQdHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbiwgcGFkZGluZyk7XG5cbiAgICAgIHJldHVybiBpbnNpZGU7XG4gICAgfSxcbiAgICBcbiAgICByb3VnaENvbGxpZGU6IGJiQ29sbGlkZSxcbiAgICBcbiAgICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pIHtcbiAgICAgIHZhciB0cmlQdHMgPSBhcnJvd1NoYXBlc1sndHJpYW5nbGUtdGVlJ10uX3BvaW50cztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJpUHRzLmxlbmd0aCAvIDI7IGkrKyl7XG4gICAgICAgIHZhciBwdCA9IHRyYW5zZm9ybSggdHJpUHRzWyBpICogMiBdLCAgdHJpUHRzWyBpICogMiArIDEgXSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uICk7XG4gICAgICAgIFxuICAgICAgICBjb250ZXh0LmxpbmVUbyggcHQueCwgcHQueSApO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGVlUHRzID0gYXJyb3dTaGFwZXNbJ3RyaWFuZ2xlLXRlZSddLl9wb2ludHNUZWU7XG4gICAgICB2YXIgZmlyc3RUZWVQdCA9IHRyYW5zZm9ybSggdGVlUHRzWzBdLCB0ZWVQdHNbMV0sIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApO1xuICAgICAgY29udGV4dC5tb3ZlVG8oIGZpcnN0VGVlUHQueCwgZmlyc3RUZWVQdC55ICk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGVlUHRzLmxlbmd0aCAvIDI7IGkrKyl7XG4gICAgICAgIHZhciBwdCA9IHRyYW5zZm9ybSggdGVlUHRzWyBpICogMiBdLCAgdGVlUHRzWyBpICogMiArIDEgXSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uICk7XG4gICAgICAgIFxuICAgICAgICBjb250ZXh0LmxpbmVUbyggcHQueCwgcHQueSApO1xuICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgc3BhY2luZzogZnVuY3Rpb24oZWRnZSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcbiAgICBcbiAgICBnYXA6IGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgIHJldHVybiBlZGdlLl9wcml2YXRlLnN0eWxlWyd3aWR0aCddLnB4VmFsdWUgKiAyO1xuICAgIH1cbiAgfTtcblxuICBhcnJvd1NoYXBlc1snaGFsZi10cmlhbmdsZS1vdmVyc2hvdCddID0ge1xuICAgIF9wb2ludHM6IFtcbiAgICAgIDAsIC0wLjI1LFxuICAgICAgLTAuNSwgLTAuMjUsXG4gICAgICAwLjUsIDAuMjVcbiAgICBdLFxuICAgIFxuICAgIGxlYXZlUGF0aE9wZW46IHRydWUsXG4gICAgbWF0Y2hFZGdlV2lkdGg6IHRydWUsXG5cbiAgICBjb2xsaWRlOiBmdW5jdGlvbih4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcpIHtcbiAgICAgIHZhciBwb2ludHMgPSB0aGlzLl9wb2ludHM7XG4gICAgICBcbi8vICAgICAgY29uc29sZS5sb2coXCJjb2xsaWRlKCk6IFwiICsgZGlyZWN0aW9uKTtcbiAgICAgIFxuICAgICAgcmV0dXJuICQkLm1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKFxuICAgICAgICB4LCB5LCBwb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbiwgcGFkZGluZyk7XG4gICAgfSxcbiAgICBcbiAgICByb3VnaENvbGxpZGU6IGJiQ29sbGlkZSxcbiAgICBcbiAgICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pIHtcbiAgICAgIHZhciBwb2ludHMgPSB0aGlzLl9wb2ludHM7XG4gICAgXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgdmFyIHB0ID0gdHJhbnNmb3JtKCBwb2ludHNbaSAqIDJdLCBwb2ludHNbaSAqIDIgKyAxXSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uICk7XG5cbiAgICAgICAgY29udGV4dC5saW5lVG8ocHQueCwgcHQueSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBzcGFjaW5nOiBmdW5jdGlvbihlZGdlKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIFxuICAgIGdhcDogZnVuY3Rpb24oZWRnZSkge1xuICAgICAgcmV0dXJuIGVkZ2UuX3ByaXZhdGUuc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZSAqIDI7XG4gICAgfVxuICB9O1xuXG4gIGFycm93U2hhcGVzWydub25lJ10gPSB7XG4gICAgY29sbGlkZTogZnVuY3Rpb24oeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBwYWRkaW5nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBcbiAgICByb3VnaENvbGxpZGU6IGZ1bmN0aW9uKHgsIHksIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbiwgcGFkZGluZykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgXG4gICAgZHJhdzogZnVuY3Rpb24oY29udGV4dCkge1xuICAgIH0sXG4gICAgXG4gICAgc3BhY2luZzogZnVuY3Rpb24oZWRnZSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcbiAgICBcbiAgICBnYXA6IGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfTtcbiAgXG4gIGFycm93U2hhcGVzWydjaXJjbGUnXSA9IHtcbiAgICBfYmFzZVJhZGl1czogMC4xNSxcbiAgICBcbiAgICBjb2xsaWRlOiBmdW5jdGlvbih4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcpIHtcbiAgICAgIC8vIFRyYW5zZm9ybSB4LCB5IHRvIGdldCBub24tcm90YXRlZCBlbGxpcHNlXG4gICAgICBcbiAgICAgIGlmICh3aWR0aCAhPSBoZWlnaHQpIHsgICAgICAgICAgICAgICAgICBcbiAgICAgICAgdmFyIGFzcGVjdFJhdGlvID0gKGhlaWdodCArIHBhZGRpbmcpIC8gKHdpZHRoICsgcGFkZGluZyk7XG4gICAgICAgIHkgLz0gYXNwZWN0UmF0aW87XG4gICAgICAgIGNlbnRlclkgLz0gYXNwZWN0UmF0aW87XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gKE1hdGgucG93KGNlbnRlclggLSB4LCAyKSBcbiAgICAgICAgICArIE1hdGgucG93KGNlbnRlclkgLSB5LCAyKSA8PSBNYXRoLnBvdygod2lkdGggKyBwYWRkaW5nKVxuICAgICAgICAgICAgKiBhcnJvd1NoYXBlc1snY2lyY2xlJ10uX2Jhc2VSYWRpdXMsIDIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAoTWF0aC5wb3coY2VudGVyWCAtIHgsIDIpIFxuICAgICAgICAgICsgTWF0aC5wb3coY2VudGVyWSAtIHksIDIpIDw9IE1hdGgucG93KCh3aWR0aCArIHBhZGRpbmcpXG4gICAgICAgICAgICAqIGFycm93U2hhcGVzWydjaXJjbGUnXS5fYmFzZVJhZGl1cywgMikpO1xuICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgcm91Z2hDb2xsaWRlOiBiYkNvbGxpZGUsXG4gICAgXG4gICAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKSB7XG4gICAgICBjb250ZXh0LmFyYyh0cmFuc2xhdGlvbi54LCB0cmFuc2xhdGlvbi55LCBhcnJvd1NoYXBlc1snY2lyY2xlJ10uX2Jhc2VSYWRpdXMgKiBzaXplLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xuICAgIH0sXG4gICAgXG4gICAgc3BhY2luZzogZnVuY3Rpb24oZWRnZSkge1xuICAgICAgcmV0dXJuIHJlbmRGdW5jLmdldEFycm93V2lkdGgoZWRnZS5fcHJpdmF0ZS5zdHlsZVsnd2lkdGgnXS5weFZhbHVlKVxuICAgICAgICAqIGFycm93U2hhcGVzWydjaXJjbGUnXS5fYmFzZVJhZGl1cztcbiAgICB9LFxuICAgIFxuICAgIGdhcDogZnVuY3Rpb24oZWRnZSkge1xuICAgICAgcmV0dXJuIGVkZ2UuX3ByaXZhdGUuc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZSAqIDI7XG4gICAgfVxuICB9O1xuICBcbiAgYXJyb3dTaGFwZXNbJ2luaGliaXRvciddID0ge1xuICAgIF9wb2ludHM6IFtcbiAgICAgIC0wLjI1LCAwLFxuICAgICAgLTAuMjUsIC0wLjEsXG4gICAgICAwLjI1LCAtMC4xLFxuICAgICAgMC4yNSwgMFxuICAgIF0sXG4gICAgXG4gICAgY29sbGlkZTogZnVuY3Rpb24oeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBwYWRkaW5nKSB7XG4gICAgICB2YXIgcG9pbnRzID0gYXJyb3dTaGFwZXNbJ2luaGliaXRvciddLl9wb2ludHM7XG4gICAgICBcbiAgICAgIHJldHVybiAkJC5tYXRoLnBvaW50SW5zaWRlUG9seWdvbihcbiAgICAgICAgeCwgeSwgcG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcpO1xuICAgIH0sXG4gICAgXG4gICAgcm91Z2hDb2xsaWRlOiBiYkNvbGxpZGUsXG4gICAgXG4gICAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKSB7XG4gICAgICB2YXIgcG9pbnRzID0gYXJyb3dTaGFwZXNbJ2luaGliaXRvciddLl9wb2ludHM7XG4gICAgICBcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgICB2YXIgcHQgPSB0cmFuc2Zvcm0oIHBvaW50c1tpICogMl0sIHBvaW50c1tpICogMiArIDFdLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24gKTtcblxuICAgICAgICBjb250ZXh0LmxpbmVUbyhwdC54LCBwdC55KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIHNwYWNpbmc6IGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0sXG4gICAgXG4gICAgZ2FwOiBmdW5jdGlvbihlZGdlKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH07XG5cbiAgYXJyb3dTaGFwZXNbJ3RlZSddID0gYXJyb3dTaGFwZXNbJ2luaGliaXRvciddO1xuXG4gIGFycm93U2hhcGVzWydzcXVhcmUnXSA9IHtcbiAgICBfcG9pbnRzOiBbXG4gICAgICAtMC4xNSwgMC4wMCxcbiAgICAgIDAuMTUsIDAuMDAsXG4gICAgICAwLjE1LCAtMC4zLFxuICAgICAgLTAuMTUsIC0wLjNcbiAgICBdLFxuICAgIFxuICAgIGNvbGxpZGU6IGZ1bmN0aW9uKHgsIHksIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbiwgcGFkZGluZykge1xuICAgICAgdmFyIHBvaW50cyA9IGFycm93U2hhcGVzWydzcXVhcmUnXS5fcG9pbnRzO1xuICAgICAgXG4gICAgICByZXR1cm4gJCQubWF0aC5wb2ludEluc2lkZVBvbHlnb24oXG4gICAgICAgIHgsIHksIHBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBwYWRkaW5nKTtcbiAgICB9LFxuICAgIFxuICAgIHJvdWdoQ29sbGlkZTogYmJDb2xsaWRlLFxuICAgIFxuICAgIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbikge1xuICAgICAgdmFyIHBvaW50cyA9IGFycm93U2hhcGVzWydzcXVhcmUnXS5fcG9pbnRzO1xuICAgIFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICAgIHZhciBwdCA9IHRyYW5zZm9ybSggcG9pbnRzW2kgKiAyXSwgcG9pbnRzW2kgKiAyICsgMV0sIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApO1xuXG4gICAgICAgIGNvbnRleHQubGluZVRvKHB0LngsIHB0LnkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgc3BhY2luZzogZnVuY3Rpb24oZWRnZSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcblxuICAgIGdhcDogZnVuY3Rpb24oZWRnZSkge1xuICAgICAgcmV0dXJuIGVkZ2UuX3ByaXZhdGUuc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZSAqIDI7XG4gICAgfVxuICB9O1xuXG4gIGFycm93U2hhcGVzWydkaWFtb25kJ10gPSB7XG4gICAgX3BvaW50czogW1xuICAgICAgLTAuMTUsIC0wLjE1LFxuICAgICAgMCwgLTAuMyxcbiAgICAgIDAuMTUsIC0wLjE1LFxuICAgICAgMCwgMFxuICAgIF0sXG5cbiAgICBjb2xsaWRlOiBmdW5jdGlvbih4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcpIHtcbiAgICAgIHZhciBwb2ludHMgPSBhcnJvd1NoYXBlc1snZGlhbW9uZCddLl9wb2ludHM7XG4gICAgICAgICAgXG4gICAgICByZXR1cm4gJCQubWF0aC5wb2ludEluc2lkZVBvbHlnb24oXG4gICAgICAgIHgsIHksIHBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBwYWRkaW5nKTtcbiAgICB9LFxuXG4gICAgcm91Z2hDb2xsaWRlOiBiYkNvbGxpZGUsXG5cbiAgICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pIHtcbiAgICAgIHZhciBwb2ludHMgPSBhcnJvd1NoYXBlc1snZGlhbW9uZCddLl9wb2ludHM7XG4gICAgXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgdmFyIHB0ID0gdHJhbnNmb3JtKCBwb2ludHNbaSAqIDJdLCBwb2ludHNbaSAqIDIgKyAxXSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uICk7XG5cbiAgICAgICAgY29udGV4dC5saW5lVG8ocHQueCwgcHQueSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBzcGFjaW5nOiBmdW5jdGlvbihlZGdlKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIFxuICAgIGdhcDogZnVuY3Rpb24oZWRnZSkge1xuICAgICAgcmV0dXJuIGVkZ2UuX3ByaXZhdGUuc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZTtcbiAgICB9XG4gIH07XG5cbn0pKCBjeXRvc2NhcGUgKTtcbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIENhbnZhc1JlbmRlcmVyID0gJCQoJ3JlbmRlcmVyJywgJ2NhbnZhcycpO1xuICB2YXIgQ1JwID0gQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlO1xuXG4gIENScC5nZXRDYWNoZWROb2RlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhOyB2YXIgY3kgPSB0aGlzLmRhdGEuY3k7XG4gICAgXG4gICAgaWYgKGRhdGEuY2FjaGUgPT0gbnVsbCkge1xuICAgICAgZGF0YS5jYWNoZSA9IHt9O1xuICAgIH1cbiAgICBcbiAgICBpZiAoZGF0YS5jYWNoZS5jYWNoZWROb2RlcyA9PSBudWxsKSB7XG4gICAgICBkYXRhLmNhY2hlLmNhY2hlZE5vZGVzID0gY3kubm9kZXMoKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGRhdGEuY2FjaGUuY2FjaGVkTm9kZXM7XG4gIH07XG4gIFxuICBDUnAudXBkYXRlTm9kZXNDYWNoZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhOyB2YXIgY3kgPSB0aGlzLmRhdGEuY3k7XG4gICAgXG4gICAgaWYgKGRhdGEuY2FjaGUgPT0gbnVsbCkge1xuICAgICAgZGF0YS5jYWNoZSA9IHt9O1xuICAgIH1cbiAgICBcbiAgICBkYXRhLmNhY2hlLmNhY2hlZE5vZGVzID0gY3kubm9kZXMoKTtcbiAgfTtcbiAgXG4gIENScC5nZXRDYWNoZWRFZGdlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhOyB2YXIgY3kgPSB0aGlzLmRhdGEuY3k7XG4gICAgXG4gICAgaWYgKGRhdGEuY2FjaGUgPT0gbnVsbCkge1xuICAgICAgZGF0YS5jYWNoZSA9IHt9O1xuICAgIH1cbiAgICBcbiAgICBpZiAoZGF0YS5jYWNoZS5jYWNoZWRFZGdlcyA9PSBudWxsKSB7XG4gICAgICBkYXRhLmNhY2hlLmNhY2hlZEVkZ2VzID0gY3kuZWRnZXMoKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGRhdGEuY2FjaGUuY2FjaGVkRWRnZXM7XG4gIH07XG4gIFxuICBDUnAudXBkYXRlRWRnZXNDYWNoZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhOyB2YXIgY3kgPSB0aGlzLmRhdGEuY3k7XG4gICAgXG4gICAgaWYgKGRhdGEuY2FjaGUgPT0gbnVsbCkge1xuICAgICAgZGF0YS5jYWNoZSA9IHt9O1xuICAgIH1cbiAgICBcbiAgICBkYXRhLmNhY2hlLmNhY2hlZEVkZ2VzID0gY3kuZWRnZXMoKTtcbiAgfTtcblxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBDYW52YXNSZW5kZXJlciA9ICQkKCdyZW5kZXJlcicsICdjYW52YXMnKTtcbiAgdmFyIENScCA9IENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZTtcblxuICAvLyBQcm9qZWN0IG1vdXNlXG4gIENScC5wcm9qZWN0SW50b1ZpZXdwb3J0ID0gZnVuY3Rpb24oY2xpZW50WCwgY2xpZW50WSkge1xuICAgIHZhciBvZmZzZXRzID0gdGhpcy5maW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzKCk7XG4gICAgdmFyIG9mZnNldExlZnQgPSBvZmZzZXRzWzBdO1xuICAgIHZhciBvZmZzZXRUb3AgPSBvZmZzZXRzWzFdO1xuICAgIFxuICAgIHZhciB4ID0gY2xpZW50WCAtIG9mZnNldExlZnQ7IFxuICAgIHZhciB5ID0gY2xpZW50WSAtIG9mZnNldFRvcDtcbiAgICBcbiAgICB4IC09IHRoaXMuZGF0YS5jeS5wYW4oKS54OyB5IC09IHRoaXMuZGF0YS5jeS5wYW4oKS55OyB4IC89IHRoaXMuZGF0YS5jeS56b29tKCk7IHkgLz0gdGhpcy5kYXRhLmN5Lnpvb20oKTtcbiAgICByZXR1cm4gW3gsIHldO1xuICB9O1xuXG4gIENScC5maW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuZGF0YS5jb250YWluZXI7XG5cbiAgICB2YXIgYmIgPSB0aGlzLmNvbnRhaW5lckJCID0gdGhpcy5jb250YWluZXJCQiB8fCBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICByZXR1cm4gW2JiLmxlZnQsIGJiLnRvcCwgYmIucmlnaHQgLSBiYi5sZWZ0LCBiYi5ib3R0b20gLSBiYi50b3BdO1xuICB9O1xuXG4gIENScC5pbnZhbGlkYXRlQ29udGFpbmVyQ2xpZW50Q29vcmRzQ2FjaGUgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuY29udGFpbmVyQkIgPSBudWxsO1xuICB9O1xuXG4gIC8vIEZpbmQgbmVhcmVzdCBlbGVtZW50XG4gIENScC5maW5kTmVhcmVzdEVsZW1lbnQgPSBmdW5jdGlvbih4LCB5LCB2aXNpYmxlRWxlbWVudHNPbmx5LCBpc1RvdWNoKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGVsZXMgPSB0aGlzLmdldENhY2hlZFpTb3J0ZWRFbGVzKCk7XG4gICAgdmFyIG5lYXIgPSBbXTtcbiAgICB2YXIgem9vbSA9IHRoaXMuZGF0YS5jeS56b29tKCk7XG4gICAgdmFyIGhhc0NvbXBvdW5kcyA9IHRoaXMuZGF0YS5jeS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gICAgdmFyIGVkZ2VUaHJlc2hvbGQgPSAoaXNUb3VjaCA/IDI0IDogOCkgLyB6b29tO1xuICAgIHZhciBub2RlVGhyZXNob2xkID0gKGlzVG91Y2ggPyA4IDogMikgLyB6b29tO1xuXG4gICAgZnVuY3Rpb24gY2hlY2tOb2RlKG5vZGUpe1xuICAgICAgdmFyIHdpZHRoID0gbm9kZS5vdXRlcldpZHRoKCkgKyAyKm5vZGVUaHJlc2hvbGQ7XG4gICAgICB2YXIgaGVpZ2h0ID0gbm9kZS5vdXRlckhlaWdodCgpICsgMipub2RlVGhyZXNob2xkO1xuICAgICAgdmFyIGh3ID0gd2lkdGgvMjtcbiAgICAgIHZhciBoaCA9IGhlaWdodC8yO1xuICAgICAgdmFyIHBvcyA9IG5vZGUuX3ByaXZhdGUucG9zaXRpb247XG5cbiAgICAgIGlmKFxuICAgICAgICBwb3MueCAtIGh3IDw9IHggJiYgeCA8PSBwb3MueCArIGh3IC8vIGJiIGNoZWNrIHhcbiAgICAgICAgICAmJlxuICAgICAgICBwb3MueSAtIGhoIDw9IHkgJiYgeSA8PSBwb3MueSArIGhoIC8vIGJiIGNoZWNrIHlcbiAgICAgICl7XG4gICAgICAgIHZhciB2aXNpYmxlID0gIXZpc2libGVFbGVtZW50c09ubHkgfHwgKCBub2RlLnZpc2libGUoKSAmJiAhbm9kZS50cmFuc3BhcmVudCgpICk7XG5cbiAgICAgICAgLy8gZXhpdCBlYXJseSBpZiBpbnZpc2libGUgZWRnZSBhbmQgbXVzdCBiZSB2aXNpYmxlXG4gICAgICAgIGlmKCB2aXNpYmxlRWxlbWVudHNPbmx5ICYmICF2aXNpYmxlICl7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNoYXBlID0gQ2FudmFzUmVuZGVyZXIubm9kZVNoYXBlc1sgc2VsZi5nZXROb2RlU2hhcGUobm9kZSkgXTtcbiAgICAgICAgdmFyIGJvcmRlcldPID0gbm9kZS5fcHJpdmF0ZS5zdHlsZVsnYm9yZGVyLXdpZHRoJ10ucHhWYWx1ZSAvIDI7XG5cbiAgICAgICAgaWYoXG4gICAgICAgICAgc2hhcGUuY2hlY2tQb2ludCh4LCB5LCAwLCB3aWR0aCwgaGVpZ2h0LCBwb3MueCwgcG9zLnkpXG4gICAgICAgICl7XG4gICAgICAgICAgbmVhci5wdXNoKCBub2RlICk7XG4gICAgICAgIH1cblxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrRWRnZShlZGdlKXtcbiAgICAgIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgICB2YXIgc3R5bGUgPSBlZGdlLl9wcml2YXRlLnN0eWxlO1xuICAgICAgdmFyIHdpZHRoID0gc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZS8yICsgZWRnZVRocmVzaG9sZDsgLy8gbW9yZSBsaWtlIGEgZGlzdGFuY2UgcmFkaXVzIGZyb20gY2VudHJlXG4gICAgICB2YXIgd2lkdGhTcSA9IHdpZHRoICogd2lkdGg7XG4gICAgICB2YXIgd2lkdGgyID0gd2lkdGggKiAyO1xuICAgICAgdmFyIHNyYyA9IGVkZ2UuX3ByaXZhdGUuc291cmNlO1xuICAgICAgdmFyIHRndCA9IGVkZ2UuX3ByaXZhdGUudGFyZ2V0O1xuICAgICAgdmFyIGluRWRnZUJCID0gZmFsc2U7XG4gICAgICB2YXIgc3FEaXN0O1xuXG4gICAgICAvLyBleGl0IGVhcmx5IGlmIGludmlzaWJsZSBlZGdlIGFuZCBtdXN0IGJlIHZpc2libGVcbiAgICAgIHZhciBwYXNzZWRWaXNpYmlsaXR5Q2hlY2s7XG4gICAgICB2YXIgcGFzc2VzVmlzaWJpbGl0eUNoZWNrID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoIHBhc3NlZFZpc2liaWxpdHlDaGVjayAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgcmV0dXJuIHBhc3NlZFZpc2liaWxpdHlDaGVjaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCAhdmlzaWJsZUVsZW1lbnRzT25seSApe1xuICAgICAgICAgIHBhc3NlZFZpc2liaWxpdHlDaGVjayA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmlzaWJsZSA9IGVkZ2UudmlzaWJsZSgpICYmICFlZGdlLnRyYW5zcGFyZW50KCk7XG4gICAgICAgIGlmKCB2aXNpYmxlICl7XG4gICAgICAgICAgcGFzc2VkVmlzaWJpbGl0eUNoZWNrID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhc3NlZFZpc2liaWxpdHlDaGVjayA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuXG4gICAgICBpZiAocnMuZWRnZVR5cGUgPT09ICdzZWxmJyB8fCBycy5lZGdlVHlwZSA9PT0gJ2NvbXBvdW5kJykge1xuICAgICAgICBpZihcbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgKGluRWRnZUJCID0gJCQubWF0aC5pbkJlemllclZpY2luaXR5KHgsIHksIHJzLnN0YXJ0WCwgcnMuc3RhcnRZLCBycy5jcDJheCwgcnMuY3AyYXksIHJzLnNlbGZFZGdlTWlkWCwgcnMuc2VsZkVkZ2VNaWRZLCB3aWR0aFNxKSlcbiAgICAgICAgICAgICAgICAmJiBwYXNzZXNWaXNpYmlsaXR5Q2hlY2soKSAmJlxuICAgICAgICAgICAgICAoIHdpZHRoU3EgPiAoc3FEaXN0ID0gJCQubWF0aC5zcURpc3RhbmNlVG9RdWFkcmF0aWNCZXppZXIoeCwgeSwgcnMuc3RhcnRYLCBycy5zdGFydFksIHJzLmNwMmF4LCBycy5jcDJheSwgcnMuc2VsZkVkZ2VNaWRYLCBycy5zZWxmRWRnZU1pZFkpKSApXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHx8XG4gICAgICAgICAgICAoXG4gICAgICAgICAgICAgIChpbkVkZ2VCQiA9ICQkLm1hdGguaW5CZXppZXJWaWNpbml0eSh4LCB5LCBycy5zZWxmRWRnZU1pZFgsIHJzLnNlbGZFZGdlTWlkWSwgcnMuY3AyY3gsIHJzLmNwMmN5LCBycy5lbmRYLCBycy5lbmRZLCB3aWR0aFNxKSlcbiAgICAgICAgICAgICAgICAmJiBwYXNzZXNWaXNpYmlsaXR5Q2hlY2soKSAmJlxuICAgICAgICAgICAgICAoIHdpZHRoU3EgPiAoc3FEaXN0ID0gJCQubWF0aC5zcURpc3RhbmNlVG9RdWFkcmF0aWNCZXppZXIoeCwgeSwgcnMuc2VsZkVkZ2VNaWRYLCBycy5zZWxmRWRnZU1pZFksIHJzLmNwMmN4LCBycy5jcDJjeSwgcnMuZW5kWCwgcnMuZW5kWSkpIClcbiAgICAgICAgICAgIClcbiAgICAgICAgKXtcbiAgICAgICAgICBuZWFyLnB1c2goIGVkZ2UgKTtcbiAgICAgICAgfVxuICAgICAgXG4gICAgICB9IGVsc2UgaWYgKHJzLmVkZ2VUeXBlID09PSAnaGF5c3RhY2snKSB7XG4gICAgICAgIHZhciByYWRpdXMgPSBzdHlsZVsnaGF5c3RhY2stcmFkaXVzJ10udmFsdWU7XG4gICAgICAgIHZhciBoYWxmUmFkaXVzID0gcmFkaXVzLzI7IC8vIGIvYyBoYXZlIHRvIGhhbGYgd2lkdGgvaGVpZ2h0XG5cbiAgICAgICAgdmFyIHRndFBvcyA9IHRndC5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAgICAgdmFyIHRndFcgPSB0Z3Qud2lkdGgoKTtcbiAgICAgICAgdmFyIHRndEggPSB0Z3QuaGVpZ2h0KCk7XG4gICAgICAgIHZhciBzcmNQb3MgPSBzcmMuX3ByaXZhdGUucG9zaXRpb247XG4gICAgICAgIHZhciBzcmNXID0gc3JjLndpZHRoKCk7XG4gICAgICAgIHZhciBzcmNIID0gc3JjLmhlaWdodCgpO1xuXG4gICAgICAgIHZhciBzdGFydFggPSBzcmNQb3MueCArIHJzLnNvdXJjZS54ICogc3JjVyAqIGhhbGZSYWRpdXM7XG4gICAgICAgIHZhciBzdGFydFkgPSBzcmNQb3MueSArIHJzLnNvdXJjZS55ICogc3JjSCAqIGhhbGZSYWRpdXM7XG4gICAgICAgIHZhciBlbmRYID0gdGd0UG9zLnggKyBycy50YXJnZXQueCAqIHRndFcgKiBoYWxmUmFkaXVzO1xuICAgICAgICB2YXIgZW5kWSA9IHRndFBvcy55ICsgcnMudGFyZ2V0LnkgKiB0Z3RIICogaGFsZlJhZGl1cztcblxuICAgICAgICBpZiggXG4gICAgICAgICAgKGluRWRnZUJCID0gJCQubWF0aC5pbkxpbmVWaWNpbml0eSh4LCB5LCBzdGFydFgsIHN0YXJ0WSwgZW5kWCwgZW5kWSwgd2lkdGgyKSlcbiAgICAgICAgICAgICYmIHBhc3Nlc1Zpc2liaWxpdHlDaGVjaygpICYmXG4gICAgICAgICAgd2lkdGhTcSA+ICggc3FEaXN0ID0gJCQubWF0aC5zcURpc3RhbmNlVG9GaW5pdGVMaW5lKCB4LCB5LCBzdGFydFgsIHN0YXJ0WSwgZW5kWCwgZW5kWSApIClcbiAgICAgICAgKXtcbiAgICAgICAgICBuZWFyLnB1c2goIGVkZ2UgKTtcbiAgICAgICAgfVxuICAgICAgXG4gICAgICB9IGVsc2UgaWYgKHJzLmVkZ2VUeXBlID09PSAnc3RyYWlnaHQnKSB7XG4gICAgICAgIGlmKFxuICAgICAgICAgIChpbkVkZ2VCQiA9ICQkLm1hdGguaW5MaW5lVmljaW5pdHkoeCwgeSwgcnMuc3RhcnRYLCBycy5zdGFydFksIHJzLmVuZFgsIHJzLmVuZFksIHdpZHRoMikpXG4gICAgICAgICAgICAmJiBwYXNzZXNWaXNpYmlsaXR5Q2hlY2soKSAmJlxuICAgICAgICAgIHdpZHRoU3EgPiAoIHNxRGlzdCA9ICQkLm1hdGguc3FEaXN0YW5jZVRvRmluaXRlTGluZSh4LCB5LCBycy5zdGFydFgsIHJzLnN0YXJ0WSwgcnMuZW5kWCwgcnMuZW5kWSkgKVxuICAgICAgICApe1xuICAgICAgICAgIG5lYXIucHVzaCggZWRnZSApO1xuICAgICAgICB9XG4gICAgICBcbiAgICAgIH0gZWxzZSBpZiAocnMuZWRnZVR5cGUgPT09ICdiZXppZXInKSB7XG4gICAgICAgIGlmKFxuICAgICAgICAgIChpbkVkZ2VCQiA9ICQkLm1hdGguaW5CZXppZXJWaWNpbml0eSh4LCB5LCBycy5zdGFydFgsIHJzLnN0YXJ0WSwgcnMuY3AyeCwgcnMuY3AyeSwgcnMuZW5kWCwgcnMuZW5kWSwgd2lkdGhTcSkpXG4gICAgICAgICAgICAmJiBwYXNzZXNWaXNpYmlsaXR5Q2hlY2soKSAmJlxuICAgICAgICAgICh3aWR0aFNxID4gKHNxRGlzdCA9ICQkLm1hdGguc3FEaXN0YW5jZVRvUXVhZHJhdGljQmV6aWVyKHgsIHksIHJzLnN0YXJ0WCwgcnMuc3RhcnRZLCBycy5jcDJ4LCBycy5jcDJ5LCBycy5lbmRYLCBycy5lbmRZKSkgKVxuICAgICAgICApe1xuICAgICAgICAgIG5lYXIucHVzaCggZWRnZSApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIGlmIHdlJ3JlIGNsb3NlIHRvIHRoZSBlZGdlIGJ1dCBkaWRuJ3QgaGl0IGl0LCBtYXliZSB3ZSBoaXQgaXRzIGFycm93c1xuICAgICAgaWYoIGluRWRnZUJCICYmIHBhc3Nlc1Zpc2liaWxpdHlDaGVjaygpICYmIG5lYXIubGVuZ3RoID09PSAwIHx8IG5lYXJbbmVhci5sZW5ndGggLSAxXSAhPT0gZWRnZSApe1xuICAgICAgICB2YXIgc3JjU2hhcGUgPSBDYW52YXNSZW5kZXJlci5hcnJvd1NoYXBlc1sgc3R5bGVbJ3NvdXJjZS1hcnJvdy1zaGFwZSddLnZhbHVlIF07XG4gICAgICAgIHZhciB0Z3RTaGFwZSA9IENhbnZhc1JlbmRlcmVyLmFycm93U2hhcGVzWyBzdHlsZVsndGFyZ2V0LWFycm93LXNoYXBlJ10udmFsdWUgXTtcblxuICAgICAgICB2YXIgc3JjID0gc3JjIHx8IGVkZ2UuX3ByaXZhdGUuc291cmNlO1xuICAgICAgICB2YXIgdGd0ID0gdGd0IHx8IGVkZ2UuX3ByaXZhdGUudGFyZ2V0O1xuXG4gICAgICAgIHZhciB0Z3RQb3MgPSB0Z3QuX3ByaXZhdGUucG9zaXRpb247XG4gICAgICAgIHZhciBzcmNQb3MgPSBzcmMuX3ByaXZhdGUucG9zaXRpb247XG5cbiAgICAgICAgdmFyIHNyY0FyVyA9IHNlbGYuZ2V0QXJyb3dXaWR0aCggc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZSApO1xuICAgICAgICB2YXIgc3JjQXJIID0gc2VsZi5nZXRBcnJvd0hlaWdodCggc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZSApO1xuXG4gICAgICAgIHZhciB0Z3RBclcgPSBzcmNBclc7XG4gICAgICAgIHZhciB0Z3RBckggPSBzcmNBckg7XG5cbiAgICAgICAgaWYoXG4gICAgICAgICAgKFxuICAgICAgICAgICAgc3JjU2hhcGUucm91Z2hDb2xsaWRlKHgsIHksIHJzLmFycm93U3RhcnRYLCBycy5hcnJvd1N0YXJ0WSwgc3JjQXJXLCBzcmNBckgsIFtycy5hcnJvd1N0YXJ0WCAtIHNyY1Bvcy54LCBycy5hcnJvd1N0YXJ0WSAtIHNyY1Bvcy55XSwgZWRnZVRocmVzaG9sZClcbiAgICAgICAgICAgICAgJiYgXG4gICAgICAgICAgICBzcmNTaGFwZS5jb2xsaWRlKHgsIHksIHJzLmFycm93U3RhcnRYLCBycy5hcnJvd1N0YXJ0WSwgc3JjQXJXLCBzcmNBckgsIFtycy5hcnJvd1N0YXJ0WCAtIHNyY1Bvcy54LCBycy5hcnJvd1N0YXJ0WSAtIHNyY1Bvcy55XSwgZWRnZVRocmVzaG9sZClcbiAgICAgICAgICApXG4gICAgICAgICAgICB8fFxuICAgICAgICAgIChcbiAgICAgICAgICAgIHRndFNoYXBlLnJvdWdoQ29sbGlkZSh4LCB5LCBycy5hcnJvd0VuZFgsIHJzLmFycm93RW5kWSwgdGd0QXJXLCB0Z3RBckgsIFtycy5hcnJvd0VuZFggLSB0Z3RQb3MueCwgcnMuYXJyb3dFbmRZIC0gdGd0UG9zLnldLCBlZGdlVGhyZXNob2xkKVxuICAgICAgICAgICAgICAmJlxuICAgICAgICAgICAgdGd0U2hhcGUuY29sbGlkZSh4LCB5LCBycy5hcnJvd0VuZFgsIHJzLmFycm93RW5kWSwgdGd0QXJXLCB0Z3RBckgsIFtycy5hcnJvd0VuZFggLSB0Z3RQb3MueCwgcnMuYXJyb3dFbmRZIC0gdGd0UG9zLnldLCBlZGdlVGhyZXNob2xkKVxuICAgICAgICAgIClcbiAgICAgICAgKXtcbiAgICAgICAgICBuZWFyLnB1c2goIGVkZ2UgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBmb3IgY29tcG91bmQgZ3JhcGhzLCBoaXR0aW5nIGVkZ2UgbWF5IGFjdHVhbGx5IHdhbnQgYSBjb25uZWN0ZWQgbm9kZSBpbnN0ZWFkIChiL2MgZWRnZSBtYXkgaGF2ZSBncmVhdGVyIHotaW5kZXggcHJlY2VkZW5jZSlcbiAgICAgIGlmKCBoYXNDb21wb3VuZHMgJiYgIG5lYXIubGVuZ3RoID4gMCAmJiBuZWFyWyBuZWFyLmxlbmd0aCAtIDEgXSA9PT0gZWRnZSApe1xuICAgICAgICBjaGVja05vZGUoIHNyYyApO1xuICAgICAgICBjaGVja05vZGUoIHRndCApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciggdmFyIGkgPSBlbGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tICl7IC8vIHJldmVyc2Ugb3JkZXIgZm9yIHByZWNlZGVuY2VcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuXG4gICAgICBpZiggbmVhci5sZW5ndGggPiAwICl7IGJyZWFrOyB9IC8vIHNpbmNlIHdlIGNoZWNrIGluIHotb3JkZXIsIGZpcnN0IGZvdW5kIGlzIHRvcCBhbmQgYmVzdCByZXN1bHQgPT4gZXhpdCBlYXJseVxuXG4gICAgICBpZiggZWxlLl9wcml2YXRlLmdyb3VwID09PSAnbm9kZXMnICl7IFxuICAgICAgICBjaGVja05vZGUoIGVsZXNbaV0gKTtcblxuICAgICAgfSBlbHNlICB7IC8vIHRoZW4gZWRnZVxuICAgICAgICBjaGVja0VkZ2UoIGVsZXNbaV0gKTtcbiAgICAgIH1cblxuICAgIH1cbiAgXG4gICAgXG4gICAgaWYoIG5lYXIubGVuZ3RoID4gMCApe1xuICAgICAgcmV0dXJuIG5lYXJbIG5lYXIubGVuZ3RoIC0gMSBdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07IFxuXG4gIC8vICdHaXZlIG1lIGV2ZXJ5dGhpbmcgZnJvbSB0aGlzIGJveCdcbiAgQ1JwLmdldEFsbEluQm94ID0gZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIpIHtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLmdldENhY2hlZE5vZGVzKCk7XG4gICAgdmFyIGVkZ2VzID0gdGhpcy5nZXRDYWNoZWRFZGdlcygpO1xuICAgIHZhciBib3ggPSBbXTtcbiAgICBcbiAgICB2YXIgeDFjID0gTWF0aC5taW4oeDEsIHgyKTtcbiAgICB2YXIgeDJjID0gTWF0aC5tYXgoeDEsIHgyKTtcbiAgICB2YXIgeTFjID0gTWF0aC5taW4oeTEsIHkyKTtcbiAgICB2YXIgeTJjID0gTWF0aC5tYXgoeTEsIHkyKTsgXG5cbiAgICB4MSA9IHgxYzsgXG4gICAgeDIgPSB4MmM7IFxuICAgIHkxID0geTFjOyBcbiAgICB5MiA9IHkyYzsgXG5cbiAgICB2YXIgaGV1cjtcbiAgICBcbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHBvcyA9IG5vZGVzW2ldLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgdmFyIG5TaGFwZSA9IHRoaXMuZ2V0Tm9kZVNoYXBlKG5vZGVzW2ldKTtcbiAgICAgIHZhciB3ID0gdGhpcy5nZXROb2RlV2lkdGgobm9kZXNbaV0pO1xuICAgICAgdmFyIGggPSB0aGlzLmdldE5vZGVIZWlnaHQobm9kZXNbaV0pO1xuICAgICAgdmFyIGJvcmRlciA9IG5vZGVzW2ldLl9wcml2YXRlLnN0eWxlWydib3JkZXItd2lkdGgnXS5weFZhbHVlIC8gMjtcbiAgICAgIHZhciBzaGFwZU9iaiA9IENhbnZhc1JlbmRlcmVyLm5vZGVTaGFwZXNbIG5TaGFwZSBdO1xuXG4gICAgICBpZiAoIHNoYXBlT2JqLmludGVyc2VjdEJveCh4MSwgeTEsIHgyLCB5MiwgdywgaCwgcG9zLngsIHBvcy55LCBib3JkZXIpICl7XG4gICAgICAgIGJveC5wdXNoKG5vZGVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBycyA9IGVkZ2VzW2ldLl9wcml2YXRlLnJzY3JhdGNoO1xuXG4gICAgICBpZiAoZWRnZXNbaV0uX3ByaXZhdGUucnNjcmF0Y2guZWRnZVR5cGUgPT0gJ3NlbGYnKSB7XG4gICAgICAgIGlmICgoaGV1ciA9ICQkLm1hdGguYm94SW5CZXppZXJWaWNpbml0eSh4MSwgeTEsIHgyLCB5MixcbiAgICAgICAgICAgIHJzLnN0YXJ0WCwgcnMuc3RhcnRZLFxuICAgICAgICAgICAgcnMuY3AyYXgsIHJzLmNwMmF5LFxuICAgICAgICAgICAgcnMuZW5kWCwgcnMuZW5kWSwgZWRnZXNbaV0uX3ByaXZhdGUuc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZSkpXG4gICAgICAgICAgICAgICYmXG4gICAgICAgICAgICAoaGV1ciA9PSAyIHx8IChoZXVyID09IDEgJiYgJCQubWF0aC5jaGVja0JlemllckluQm94KHgxLCB5MSwgeDIsIHkyLFxuICAgICAgICAgICAgICBycy5zdGFydFgsIHJzLnN0YXJ0WSxcbiAgICAgICAgICAgICAgcnMuY3AyYXgsIHJzLmNwMmF5LFxuICAgICAgICAgICAgICBycy5lbmRYLCBycy5lbmRZLCBlZGdlc1tpXS5fcHJpdmF0ZS5zdHlsZVsnd2lkdGgnXS5weFZhbHVlKSkpXG4gICAgICAgICAgICAgICAgfHxcbiAgICAgICAgICAoaGV1ciA9ICQkLm1hdGguYm94SW5CZXppZXJWaWNpbml0eSh4MSwgeTEsIHgyLCB5MixcbiAgICAgICAgICAgIHJzLnN0YXJ0WCwgcnMuc3RhcnRZLFxuICAgICAgICAgICAgcnMuY3AyY3gsIHJzLmNwMmN5LFxuICAgICAgICAgICAgcnMuZW5kWCwgcnMuZW5kWSwgZWRnZXNbaV0uX3ByaXZhdGUuc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZSkpXG4gICAgICAgICAgICAgICYmXG4gICAgICAgICAgICAoaGV1ciA9PSAyIHx8IChoZXVyID09IDEgJiYgJCQubWF0aC5jaGVja0JlemllckluQm94KHgxLCB5MSwgeDIsIHkyLFxuICAgICAgICAgICAgICBycy5zdGFydFgsIHJzLnN0YXJ0WSxcbiAgICAgICAgICAgICAgcnMuY3AyY3gsIHJzLmNwMmN5LFxuICAgICAgICAgICAgICBycy5lbmRYLCBycy5lbmRZLCBlZGdlc1tpXS5fcHJpdmF0ZS5zdHlsZVsnd2lkdGgnXS5weFZhbHVlKSkpXG4gICAgICAgICAgKVxuICAgICAgICB7IGJveC5wdXNoKGVkZ2VzW2ldKTsgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAocnMuZWRnZVR5cGUgPT0gJ2JlemllcicgJiZcbiAgICAgICAgKGhldXIgPSAkJC5tYXRoLmJveEluQmV6aWVyVmljaW5pdHkoeDEsIHkxLCB4MiwgeTIsXG4gICAgICAgICAgICBycy5zdGFydFgsIHJzLnN0YXJ0WSxcbiAgICAgICAgICAgIHJzLmNwMngsIHJzLmNwMnksXG4gICAgICAgICAgICBycy5lbmRYLCBycy5lbmRZLCBlZGdlc1tpXS5fcHJpdmF0ZS5zdHlsZVsnd2lkdGgnXS5weFZhbHVlKSlcbiAgICAgICAgICAgICAgJiZcbiAgICAgICAgICAgIChoZXVyID09IDIgfHwgKGhldXIgPT0gMSAmJiAkJC5tYXRoLmNoZWNrQmV6aWVySW5Cb3goeDEsIHkxLCB4MiwgeTIsXG4gICAgICAgICAgICAgIHJzLnN0YXJ0WCwgcnMuc3RhcnRZLFxuICAgICAgICAgICAgICBycy5jcDJ4LCBycy5jcDJ5LFxuICAgICAgICAgICAgICBycy5lbmRYLCBycy5lbmRZLCBlZGdlc1tpXS5fcHJpdmF0ZS5zdHlsZVsnd2lkdGgnXS5weFZhbHVlKSkpKVxuICAgICAgICB7IGJveC5wdXNoKGVkZ2VzW2ldKTsgfVxuICAgIFxuICAgICAgaWYgKHJzLmVkZ2VUeXBlID09ICdzdHJhaWdodCcgJiZcbiAgICAgICAgKGhldXIgPSAkJC5tYXRoLmJveEluQmV6aWVyVmljaW5pdHkoeDEsIHkxLCB4MiwgeTIsXG4gICAgICAgICAgICBycy5zdGFydFgsIHJzLnN0YXJ0WSxcbiAgICAgICAgICAgIHJzLnN0YXJ0WCAqIDAuNSArIHJzLmVuZFggKiAwLjUsIFxuICAgICAgICAgICAgcnMuc3RhcnRZICogMC41ICsgcnMuZW5kWSAqIDAuNSwgXG4gICAgICAgICAgICBycy5lbmRYLCBycy5lbmRZLCBlZGdlc1tpXS5fcHJpdmF0ZS5zdHlsZVsnd2lkdGgnXS5weFZhbHVlKSlcbiAgICAgICAgICAgICAgJiYgLyogY29uc29sZS5sb2coJ3Rlc3QnLCBoZXVyKSA9PSB1bmRlZmluZWQgJiYgKi9cbiAgICAgICAgICAgIChoZXVyID09IDIgfHwgKGhldXIgPT0gMSAmJiAkJC5tYXRoLmNoZWNrU3RyYWlnaHRFZGdlSW5Cb3goeDEsIHkxLCB4MiwgeTIsXG4gICAgICAgICAgICAgIHJzLnN0YXJ0WCwgcnMuc3RhcnRZLFxuICAgICAgICAgICAgICBycy5lbmRYLCBycy5lbmRZLCBlZGdlc1tpXS5fcHJpdmF0ZS5zdHlsZVsnd2lkdGgnXS5weFZhbHVlKSkpKVxuICAgICAgICB7IGJveC5wdXNoKGVkZ2VzW2ldKTsgfVxuXG5cbiAgICAgIGlmIChycy5lZGdlVHlwZSA9PSAnaGF5c3RhY2snKXtcbiAgICAgICAgdmFyIHRndCA9IGVkZ2VzW2ldLnRhcmdldCgpWzBdO1xuICAgICAgICB2YXIgdGd0UG9zID0gdGd0LnBvc2l0aW9uKCk7XG4gICAgICAgIHZhciBzcmMgPSBlZGdlc1tpXS5zb3VyY2UoKVswXTtcbiAgICAgICAgdmFyIHNyY1BvcyA9IHNyYy5wb3NpdGlvbigpO1xuXG4gICAgICAgIHZhciBzdGFydFggPSBzcmNQb3MueCArIHJzLnNvdXJjZS54O1xuICAgICAgICB2YXIgc3RhcnRZID0gc3JjUG9zLnkgKyBycy5zb3VyY2UueTtcbiAgICAgICAgdmFyIGVuZFggPSB0Z3RQb3MueCArIHJzLnRhcmdldC54O1xuICAgICAgICB2YXIgZW5kWSA9IHRndFBvcy55ICsgcnMudGFyZ2V0Lnk7XG5cbiAgICAgICAgdmFyIHN0YXJ0SW5Cb3ggPSAoeDEgPD0gc3RhcnRYICYmIHN0YXJ0WCA8PSB4MikgJiYgKHkxIDw9IHN0YXJ0WSAmJiBzdGFydFkgPD0geTIpO1xuICAgICAgICB2YXIgZW5kSW5Cb3ggPSAoeDEgPD0gZW5kWCAmJiBlbmRYIDw9IHgyKSAmJiAoeTEgPD0gZW5kWSAmJiBlbmRZIDw9IHkyKTtcblxuICAgICAgICBpZiggc3RhcnRJbkJveCAmJiBlbmRJbkJveCApe1xuICAgICAgICAgIGJveC5wdXNoKCBlZGdlc1tpXSApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGJveDtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgZ2l2ZW4gbm9kZS4gSWYgdGhlIHdpZHRoIGlzIHNldCB0byBhdXRvLFxuICAgKiByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgYXV0b1dpZHRoIGZpZWxkLlxuICAgKlxuICAgKiBAcGFyYW0gbm9kZSAgICAgICAgICBhIG5vZGVcbiAgICogQHJldHVybiB7bnVtYmVyfSAgICAgd2lkdGggb2YgdGhlIG5vZGVcbiAgICovXG4gIENScC5nZXROb2RlV2lkdGggPSBmdW5jdGlvbihub2RlKVxuICB7XG4gICAgcmV0dXJuIG5vZGUud2lkdGgoKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaGVpZ2h0IG9mIHRoZSBnaXZlbiBub2RlLiBJZiB0aGUgaGVpZ2h0IGlzIHNldCB0byBhdXRvLFxuICAgKiByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgYXV0b0hlaWdodCBmaWVsZC5cbiAgICpcbiAgICogQHBhcmFtIG5vZGUgICAgICAgICAgYSBub2RlXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgIHdpZHRoIG9mIHRoZSBub2RlXG4gICAqL1xuICBDUnAuZ2V0Tm9kZUhlaWdodCA9IGZ1bmN0aW9uKG5vZGUpXG4gIHtcbiAgICByZXR1cm4gbm9kZS5oZWlnaHQoKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2hhcGUgb2YgdGhlIGdpdmVuIG5vZGUuIElmIHRoZSBoZWlnaHQgb3Igd2lkdGggb2YgdGhlIGdpdmVuIG5vZGVcbiAgICogaXMgc2V0IHRvIGF1dG8sIHRoZSBub2RlIGlzIGNvbnNpZGVyZWQgdG8gYmUgYSBjb21wb3VuZC5cbiAgICpcbiAgICogQHBhcmFtIG5vZGUgICAgICAgICAgYSBub2RlXG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgIHNoYXBlIG9mIHRoZSBub2RlXG4gICAqL1xuICBDUnAuZ2V0Tm9kZVNoYXBlID0gZnVuY3Rpb24obm9kZSlcbiAge1xuICAgIC8vIFRPRE8gb25seSBhbGxvdyByZWN0YW5nbGUgZm9yIGEgY29tcG91bmQgbm9kZT9cbi8vICAgIGlmIChub2RlLl9wcml2YXRlLnN0eWxlWyd3aWR0aCddLnZhbHVlID09ICdhdXRvJyB8fFxuLy8gICAgICAgIG5vZGUuX3ByaXZhdGUuc3R5bGVbJ2hlaWdodCddLnZhbHVlID09ICdhdXRvJylcbi8vICAgIHtcbi8vICAgICAgcmV0dXJuICdyZWN0YW5nbGUnO1xuLy8gICAgfVxuXG4gICAgdmFyIHNoYXBlID0gbm9kZS5fcHJpdmF0ZS5zdHlsZVsnc2hhcGUnXS52YWx1ZTtcblxuICAgIGlmKCBub2RlLmlzUGFyZW50KCkgKXtcbiAgICAgIGlmKCBzaGFwZSA9PT0gJ3JlY3RhbmdsZScgfHwgc2hhcGUgPT09ICdyb3VuZHJlY3RhbmdsZScgKXtcbiAgICAgICAgcmV0dXJuIHNoYXBlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICdyZWN0YW5nbGUnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzaGFwZTtcbiAgfTtcblxuXG4gIENScC5nZXROb2RlUGFkZGluZyA9IGZ1bmN0aW9uKG5vZGUpXG4gIHtcbiAgICB2YXIgbGVmdCA9IG5vZGUuX3ByaXZhdGUuc3R5bGVbJ3BhZGRpbmctbGVmdCddLnB4VmFsdWU7XG4gICAgdmFyIHJpZ2h0ID0gbm9kZS5fcHJpdmF0ZS5zdHlsZVsncGFkZGluZy1yaWdodCddLnB4VmFsdWU7XG4gICAgdmFyIHRvcCA9IG5vZGUuX3ByaXZhdGUuc3R5bGVbJ3BhZGRpbmctdG9wJ10ucHhWYWx1ZTtcbiAgICB2YXIgYm90dG9tID0gbm9kZS5fcHJpdmF0ZS5zdHlsZVsncGFkZGluZy1ib3R0b20nXS5weFZhbHVlO1xuXG4gICAgaWYgKGlzTmFOKGxlZnQpKVxuICAgIHtcbiAgICAgIGxlZnQgPSAwO1xuICAgIH1cblxuICAgIGlmIChpc05hTihyaWdodCkpXG4gICAge1xuICAgICAgcmlnaHQgPSAwO1xuICAgIH1cblxuICAgIGlmIChpc05hTih0b3ApKVxuICAgIHtcbiAgICAgIHRvcCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGlzTmFOKGJvdHRvbSkpXG4gICAge1xuICAgICAgYm90dG9tID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4ge2xlZnQgOiBsZWZ0LFxuICAgICAgcmlnaHQgOiByaWdodCxcbiAgICAgIHRvcCA6IHRvcCxcbiAgICAgIGJvdHRvbSA6IGJvdHRvbX07XG4gIH07XG5cbiAgQ1JwLnpPcmRlclNvcnQgPSAkJC5Db2xsZWN0aW9uLnpJbmRleFNvcnQ7XG5cbiAgQ1JwLnVwZGF0ZUNhY2hlZFpTb3J0ZWRFbGVzID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmdldENhY2hlZFpTb3J0ZWRFbGVzKCB0cnVlICk7XG4gIH07XG5cbiAgQ1JwLmdldENhY2hlZFpTb3J0ZWRFbGVzID0gZnVuY3Rpb24oIGZvcmNlUmVjYWxjICl7XG4gICAgdmFyIGxhc3ROb2RlcyA9IHRoaXMubGFzdFpPcmRlckNhY2hlZE5vZGVzO1xuICAgIHZhciBsYXN0RWRnZXMgPSB0aGlzLmxhc3RaT3JkZXJDYWNoZWRFZGdlcztcbiAgICB2YXIgbm9kZXMgPSB0aGlzLmdldENhY2hlZE5vZGVzKCk7XG4gICAgdmFyIGVkZ2VzID0gdGhpcy5nZXRDYWNoZWRFZGdlcygpO1xuICAgIHZhciBlbGVzID0gW107XG5cbiAgICBpZiggZm9yY2VSZWNhbGMgfHwgIWxhc3ROb2RlcyB8fCAhbGFzdEVkZ2VzIHx8IGxhc3ROb2RlcyAhPT0gbm9kZXMgfHwgbGFzdEVkZ2VzICE9PSBlZGdlcyApeyBcbiAgICAgIC8vY29uc29sZS50aW1lKCdjYWNoZXpvcmRlcicpXG4gICAgICBcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgaWYoIG5vZGVzW2ldLnZpc2libGUoKSAmJiAhbm9kZXNbaV0udHJhbnNwYXJlbnQoKSApe1xuICAgICAgICAgIGVsZXMucHVzaCggbm9kZXNbaV0gKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIGlmKCBlZGdlc1tpXS52aXNpYmxlKCkgJiYgIWVkZ2VzW2ldLnRyYW5zcGFyZW50KCkgKXtcbiAgICAgICAgICBlbGVzLnB1c2goIGVkZ2VzW2ldICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWxlcy5zb3J0KCB0aGlzLnpPcmRlclNvcnQgKTtcbiAgICAgIHRoaXMuY2FjaGVkWlNvcnRlZEVsZXMgPSBlbGVzO1xuICAgICAgLy9jb25zb2xlLmxvZygnbWFrZSBjYWNoZScpXG5cbiAgICAgIC8vY29uc29sZS50aW1lRW5kKCdjYWNoZXpvcmRlcicpXG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZXMgPSB0aGlzLmNhY2hlZFpTb3J0ZWRFbGVzO1xuICAgICAgLy9jb25zb2xlLmxvZygncmVhZCBjYWNoZScpXG4gICAgfVxuXG4gICAgdGhpcy5sYXN0Wk9yZGVyQ2FjaGVkTm9kZXMgPSBub2RlcztcbiAgICB0aGlzLmxhc3RaT3JkZXJDYWNoZWRFZGdlcyA9IGVkZ2VzO1xuXG4gICAgcmV0dXJuIGVsZXM7XG4gIH07XG5cbiAgQ1JwLnByb2plY3RCZXppZXIgPSBmdW5jdGlvbihlZGdlKXtcbiAgICB2YXIgcWJlemllckF0ID0gJCQubWF0aC5xYmV6aWVyQXQ7XG4gICAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICB2YXIgYnB0cyA9IGVkZ2UuX3ByaXZhdGUucnN0eWxlLmJlemllclB0cyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gcHVzaEJlemllclB0cyhwdHMpe1xuICAgICAgYnB0cy5wdXNoKHtcbiAgICAgICAgeDogcWJlemllckF0KCBwdHNbMF0sIHB0c1syXSwgcHRzWzRdLCAwLjA1ICksXG4gICAgICAgIHk6IHFiZXppZXJBdCggcHRzWzFdLCBwdHNbM10sIHB0c1s1XSwgMC4wNSApXG4gICAgICB9KTtcblxuICAgICAgYnB0cy5wdXNoKHtcbiAgICAgICAgeDogcWJlemllckF0KCBwdHNbMF0sIHB0c1syXSwgcHRzWzRdLCAwLjI1ICksXG4gICAgICAgIHk6IHFiZXppZXJBdCggcHRzWzFdLCBwdHNbM10sIHB0c1s1XSwgMC4yNSApXG4gICAgICB9KTtcblxuICAgICAgYnB0cy5wdXNoKHtcbiAgICAgICAgeDogcWJlemllckF0KCBwdHNbMF0sIHB0c1syXSwgcHRzWzRdLCAwLjQgKSxcbiAgICAgICAgeTogcWJlemllckF0KCBwdHNbMV0sIHB0c1szXSwgcHRzWzVdLCAwLjQgKVxuICAgICAgfSk7XG5cbiAgICAgIHZhciBtaWQgPSB7XG4gICAgICAgIHg6IHFiZXppZXJBdCggcHRzWzBdLCBwdHNbMl0sIHB0c1s0XSwgMC41ICksXG4gICAgICAgIHk6IHFiZXppZXJBdCggcHRzWzFdLCBwdHNbM10sIHB0c1s1XSwgMC41IClcbiAgICAgIH07XG5cbiAgICAgIGJwdHMucHVzaCggbWlkICk7XG5cbiAgICAgIGlmKCBycy5lZGdlVHlwZSA9PT0gJ3NlbGYnIHx8IHJzLmVkZ2VUeXBlID09PSAnY29tcG91bmQnICl7XG4gICAgICAgIHJzLm1pZFggPSBycy5zZWxmRWRnZU1pZFg7XG4gICAgICAgIHJzLm1pZFkgPSBycy5zZWxmRWRnZU1pZFk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBycy5taWRYID0gbWlkLng7XG4gICAgICAgIHJzLm1pZFkgPSBtaWQueTtcbiAgICAgIH1cblxuICAgICAgYnB0cy5wdXNoKHtcbiAgICAgICAgeDogcWJlemllckF0KCBwdHNbMF0sIHB0c1syXSwgcHRzWzRdLCAwLjYgKSxcbiAgICAgICAgeTogcWJlemllckF0KCBwdHNbMV0sIHB0c1szXSwgcHRzWzVdLCAwLjYgKVxuICAgICAgfSk7XG5cbiAgICAgIGJwdHMucHVzaCh7XG4gICAgICAgIHg6IHFiZXppZXJBdCggcHRzWzBdLCBwdHNbMl0sIHB0c1s0XSwgMC43NSApLFxuICAgICAgICB5OiBxYmV6aWVyQXQoIHB0c1sxXSwgcHRzWzNdLCBwdHNbNV0sIDAuNzUgKVxuICAgICAgfSk7XG5cbiAgICAgIGJwdHMucHVzaCh7XG4gICAgICAgIHg6IHFiZXppZXJBdCggcHRzWzBdLCBwdHNbMl0sIHB0c1s0XSwgMC45NSApLFxuICAgICAgICB5OiBxYmV6aWVyQXQoIHB0c1sxXSwgcHRzWzNdLCBwdHNbNV0sIDAuOTUgKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYoIHJzLmVkZ2VUeXBlID09PSAnc2VsZicgKXtcbiAgICAgIHB1c2hCZXppZXJQdHMoIFtycy5zdGFydFgsIHJzLnN0YXJ0WSwgcnMuY3AyYXgsIHJzLmNwMmF5LCBycy5zZWxmRWRnZU1pZFgsIHJzLnNlbGZFZGdlTWlkWV0gKTtcbiAgICAgIHB1c2hCZXppZXJQdHMoIFtycy5zZWxmRWRnZU1pZFgsIHJzLnNlbGZFZGdlTWlkWSwgcnMuY3AyY3gsIHJzLmNwMmN5LCBycy5lbmRYLCBycy5lbmRZXSApO1xuICAgIH0gZWxzZSBpZiggcnMuZWRnZVR5cGUgPT09ICdiZXppZXInICl7XG4gICAgICBwdXNoQmV6aWVyUHRzKCBbcnMuc3RhcnRYLCBycy5zdGFydFksIHJzLmNwMngsIHJzLmNwMnksIHJzLmVuZFgsIHJzLmVuZFldICk7XG4gICAgfVxuICB9O1xuXG4gIENScC5yZWNhbGN1bGF0ZU5vZGVMYWJlbFByb2plY3Rpb24gPSBmdW5jdGlvbiggbm9kZSApeyBcbiAgICB2YXIgY29udGVudCA9IG5vZGUuX3ByaXZhdGUuc3R5bGVbJ2NvbnRlbnQnXS5zdHJWYWx1ZTtcbiAgICBpZiggIWNvbnRlbnQgfHwgY29udGVudC5tYXRjaCgvXlxccyskLykgKXsgcmV0dXJuOyB9XG5cbiAgICB2YXIgdGV4dFgsIHRleHRZO1xuICAgIHZhciBub2RlV2lkdGggPSBub2RlLm91dGVyV2lkdGgoKTtcbiAgICB2YXIgbm9kZUhlaWdodCA9IG5vZGUub3V0ZXJIZWlnaHQoKTtcbiAgICB2YXIgbm9kZVBvcyA9IG5vZGUuX3ByaXZhdGUucG9zaXRpb247XG4gICAgdmFyIHRleHRIYWxpZ24gPSBub2RlLl9wcml2YXRlLnN0eWxlWyd0ZXh0LWhhbGlnbiddLnN0clZhbHVlO1xuICAgIHZhciB0ZXh0VmFsaWduID0gbm9kZS5fcHJpdmF0ZS5zdHlsZVsndGV4dC12YWxpZ24nXS5zdHJWYWx1ZTtcbiAgICB2YXIgcnMgPSBub2RlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIHZhciByc3R5bGUgPSBub2RlLl9wcml2YXRlLnJzdHlsZTtcblxuICAgIHN3aXRjaCggdGV4dEhhbGlnbiApe1xuICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgIHRleHRYID0gbm9kZVBvcy54IC0gbm9kZVdpZHRoIC8gMjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgdGV4dFggPSBub2RlUG9zLnggKyBub2RlV2lkdGggLyAyO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDogLy8gZS5nLiBjZW50ZXJcbiAgICAgICAgdGV4dFggPSBub2RlUG9zLng7XG4gICAgfVxuXG4gICAgc3dpdGNoKCB0ZXh0VmFsaWduICl7XG4gICAgICBjYXNlICd0b3AnOlxuICAgICAgICB0ZXh0WSA9IG5vZGVQb3MueSAtIG5vZGVIZWlnaHQgLyAyO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgdGV4dFkgPSBub2RlUG9zLnkgKyBub2RlSGVpZ2h0IC8gMjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6IC8vIGUuZy4gbWlkZGxlXG4gICAgICAgIHRleHRZID0gbm9kZVBvcy55O1xuICAgIH1cbiAgXG4gICAgcnMubGFiZWxYID0gdGV4dFg7XG4gICAgcnMubGFiZWxZID0gdGV4dFk7XG4gICAgcnN0eWxlLmxhYmVsWCA9IHRleHRYO1xuICAgIHJzdHlsZS5sYWJlbFkgPSB0ZXh0WTtcblxuICAgIHRoaXMuYXBwbHlMYWJlbERpbWVuc2lvbnMoIG5vZGUgKTtcbiAgfTtcblxuICBDUnAucmVjYWxjdWxhdGVFZGdlTGFiZWxQcm9qZWN0aW9uID0gZnVuY3Rpb24oIGVkZ2UgKXtcbiAgICB2YXIgY29udGVudCA9IGVkZ2UuX3ByaXZhdGUuc3R5bGVbJ2NvbnRlbnQnXS5zdHJWYWx1ZTtcbiAgICBpZiggIWNvbnRlbnQgfHwgY29udGVudC5tYXRjaCgvXlxccyskLykgKXsgcmV0dXJuOyB9XG5cbiAgICB2YXIgdGV4dFgsIHRleHRZOyAgXG4gICAgdmFyIGVkZ2VDZW50ZXJYLCBlZGdlQ2VudGVyWTtcbiAgICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICAgIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuICAgIC8vdmFyIHN0eWxlID0gX3Auc3R5bGU7XG4gICAgdmFyIHJzdHlsZSA9IF9wLnJzdHlsZTtcbiAgICBcbiAgICBpZiAocnMuZWRnZVR5cGUgPT0gJ3NlbGYnKSB7XG4gICAgICBlZGdlQ2VudGVyWCA9IHJzLnNlbGZFZGdlTWlkWDtcbiAgICAgIGVkZ2VDZW50ZXJZID0gcnMuc2VsZkVkZ2VNaWRZO1xuICAgIH0gZWxzZSBpZiAocnMuZWRnZVR5cGUgPT0gJ3N0cmFpZ2h0Jykge1xuICAgICAgZWRnZUNlbnRlclggPSAocnMuc3RhcnRYICsgcnMuZW5kWCkgLyAyO1xuICAgICAgZWRnZUNlbnRlclkgPSAocnMuc3RhcnRZICsgcnMuZW5kWSkgLyAyO1xuICAgIH0gZWxzZSBpZiAocnMuZWRnZVR5cGUgPT0gJ2JlemllcicpIHtcbiAgICAgIGVkZ2VDZW50ZXJYID0gJCQubWF0aC5xYmV6aWVyQXQoIHJzLnN0YXJ0WCwgcnMuY3AyeCwgcnMuZW5kWCwgMC41ICk7XG4gICAgICBlZGdlQ2VudGVyWSA9ICQkLm1hdGgucWJlemllckF0KCBycy5zdGFydFksIHJzLmNwMnksIHJzLmVuZFksIDAuNSApO1xuICAgIH0gZWxzZSBpZiAocnMuZWRnZVR5cGUgPT0gJ2hheXN0YWNrJykge1xuICAgICAgLy8gdmFyIHNyYyA9IF9wLnNvdXJjZTtcbiAgICAgIC8vIHZhciB0Z3QgPSBfcC50YXJnZXQ7XG4gICAgICAvLyB2YXIgc3JjUG9zID0gc3JjLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgLy8gdmFyIHRndFBvcyA9IHRndC5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAgIHZhciBwdHMgPSBycy5oYXlzdGFja1B0cztcblxuICAgICAgZWRnZUNlbnRlclggPSAoIHB0c1swXSArIHB0c1syXSApLzI7XG4gICAgICBlZGdlQ2VudGVyWSA9ICggcHRzWzFdICsgcHRzWzNdICkvMjtcbiAgICB9XG4gICAgXG4gICAgdGV4dFggPSBlZGdlQ2VudGVyWDtcbiAgICB0ZXh0WSA9IGVkZ2VDZW50ZXJZO1xuXG4gICAgLy8gYWRkIGNlbnRlciBwb2ludCB0byBzdHlsZSBzbyBib3VuZGluZyBib3ggY2FsY3VsYXRpb25zIGNhbiB1c2UgaXRcbiAgICBycy5sYWJlbFggPSB0ZXh0WDtcbiAgICBycy5sYWJlbFkgPSB0ZXh0WTtcbiAgICByc3R5bGUubGFiZWxYID0gdGV4dFg7XG4gICAgcnN0eWxlLmxhYmVsWSA9IHRleHRZO1xuXG4gICAgdGhpcy5hcHBseUxhYmVsRGltZW5zaW9ucyggZWRnZSApO1xuICB9O1xuXG4gIENScC5hcHBseUxhYmVsRGltZW5zaW9ucyA9IGZ1bmN0aW9uKCBlbGUgKXtcbiAgICB2YXIgcnMgPSBlbGUuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdmFyIHJzdHlsZSA9IGVsZS5fcHJpdmF0ZS5yc3R5bGU7XG5cbiAgICB2YXIgdGV4dCA9IHRoaXMuZ2V0TGFiZWxUZXh0KCBlbGUgKTtcbiAgICB2YXIgbGFiZWxEaW1zID0gdGhpcy5jYWxjdWxhdGVMYWJlbERpbWVuc2lvbnMoIGVsZSwgdGV4dCApO1xuIFxuICAgIHJzdHlsZS5sYWJlbFdpZHRoID0gbGFiZWxEaW1zLndpZHRoO1xuICAgIHJzLmxhYmVsV2lkdGggPSBsYWJlbERpbXMud2lkdGg7XG4gXG4gICAgcnN0eWxlLmxhYmVsSGVpZ2h0ID0gbGFiZWxEaW1zLmhlaWdodDtcbiAgICBycy5sYWJlbEhlaWdodCA9IGxhYmVsRGltcy5oZWlnaHQ7XG4gIH07XG5cbiAgQ1JwLmdldExhYmVsVGV4dCA9IGZ1bmN0aW9uKCBlbGUgKXsgXG4gICAgdmFyIHN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuICAgIHZhciB0ZXh0ID0gZWxlLl9wcml2YXRlLnN0eWxlWydjb250ZW50J10uc3RyVmFsdWU7XG4gICAgdmFyIHRleHRUcmFuc2Zvcm0gPSBzdHlsZVsndGV4dC10cmFuc2Zvcm0nXS52YWx1ZTtcbiAgICB2YXIgcnNjcmF0Y2ggPSBlbGUuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgXG4gICAgaWYgKHRleHRUcmFuc2Zvcm0gPT0gJ25vbmUnKSB7XG4gICAgfSBlbHNlIGlmICh0ZXh0VHJhbnNmb3JtID09ICd1cHBlcmNhc2UnKSB7XG4gICAgICB0ZXh0ID0gdGV4dC50b1VwcGVyQ2FzZSgpO1xuICAgIH0gZWxzZSBpZiAodGV4dFRyYW5zZm9ybSA9PSAnbG93ZXJjYXNlJykge1xuICAgICAgdGV4dCA9IHRleHQudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiggc3R5bGVbJ3RleHQtd3JhcCddLnZhbHVlID09PSAnd3JhcCcgKXtcbiAgICAgIC8vY29uc29sZS5sb2coJ3dyYXAnKTsgXG4gICAgICBcbiAgICAgIC8vIHNhdmUgcmVjYWxjIGlmIHRoZSBsYWJlbCBpcyB0aGUgc2FtZSBhcyBiZWZvcmVcbiAgICAgIGlmKCByc2NyYXRjaC5sYWJlbFdyYXBLZXkgPT09IHJzY3JhdGNoLmxhYmVsS2V5ICl7IFxuICAgICAgICAvLyBjb25zb2xlLmxvZygnd3JhcCBjYWNoZSBoaXQnKTtcbiAgICAgICAgcmV0dXJuIHJzY3JhdGNoLmxhYmVsV3JhcENhY2hlZFRleHQ7XG4gICAgICB9XG4gICAgICAvLyBjb25zb2xlLmxvZygnd3JhcCBjYWNoZSBtaXNzJyk7XG5cbiAgICAgIHZhciBsaW5lcyA9IHRleHQuc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIG1heFcgPSBzdHlsZVsndGV4dC1tYXgtd2lkdGgnXS5weFZhbHVlO1xuICAgICAgdmFyIHdyYXBwZWRMaW5lcyA9IFtdO1xuXG4gICAgICBmb3IoIHZhciBsID0gMDsgbCA8IGxpbmVzLmxlbmd0aDsgbCsrICl7XG4gICAgICAgIHZhciBsaW5lID0gbGluZXNbbF07XG4gICAgICAgIHZhciBsaW5lRGltcyA9IHRoaXMuY2FsY3VsYXRlTGFiZWxEaW1lbnNpb25zKCBlbGUsIGxpbmUsICdsaW5lPScgKyBsaW5lICk7XG4gICAgICAgIHZhciBsaW5lVyA9IGxpbmVEaW1zLndpZHRoO1xuXG4gICAgICAgIGlmKCBsaW5lVyA+IG1heFcgKXsgLy8gbGluZSBpcyB0b28gbG9uZ1xuICAgICAgICAgIHZhciB3b3JkcyA9IGxpbmUuc3BsaXQoL1xccysvKTsgLy8gTkI6IGFzc3VtZSBjb2xsYXBzZWQgd2hpdGVzcGFjZSBpbnRvIHNpbmdsZSBzcGFjZVxuICAgICAgICAgIHZhciBzdWJsaW5lID0gJyc7XG5cbiAgICAgICAgICBmb3IoIHZhciB3ID0gMDsgdyA8IHdvcmRzLmxlbmd0aDsgdysrICl7XG4gICAgICAgICAgICB2YXIgd29yZCA9IHdvcmRzW3ddO1xuICAgICAgICAgICAgdmFyIHRlc3RMaW5lID0gc3VibGluZS5sZW5ndGggPT09IDAgPyB3b3JkIDogc3VibGluZSArICcgJyArIHdvcmQ7XG4gICAgICAgICAgICB2YXIgdGVzdERpbXMgPSB0aGlzLmNhbGN1bGF0ZUxhYmVsRGltZW5zaW9ucyggZWxlLCB0ZXN0TGluZSwgJ3Rlc3RMaW5lPScgKyB0ZXN0TGluZSApO1xuICAgICAgICAgICAgdmFyIHRlc3RXID0gdGVzdERpbXMud2lkdGg7XG5cbiAgICAgICAgICAgIGlmKCB0ZXN0VyA8PSBtYXhXICl7IC8vIHdvcmQgZml0cyBvbiBjdXJyZW50IGxpbmVcbiAgICAgICAgICAgICAgc3VibGluZSArPSB3b3JkICsgJyAnO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8gd29yZCBzdGFydHMgbmV3IGxpbmVcbiAgICAgICAgICAgICAgd3JhcHBlZExpbmVzLnB1c2goIHN1YmxpbmUgKTtcbiAgICAgICAgICAgICAgc3VibGluZSA9IHdvcmQgKyAnICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaWYgdGhlcmUncyByZW1haW5pbmcgdGV4dCwgcHV0IGl0IGluIGEgd3JhcHBlZCBsaW5lXG4gICAgICAgICAgaWYoICFzdWJsaW5lLm1hdGNoKC9eXFxzKyQvKSApe1xuICAgICAgICAgICAgd3JhcHBlZExpbmVzLnB1c2goIHN1YmxpbmUgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7IC8vIGxpbmUgaXMgYWxyZWFkeSBzaG9ydCBlbm91Z2hcbiAgICAgICAgICB3cmFwcGVkTGluZXMucHVzaCggbGluZSApO1xuICAgICAgICB9XG4gICAgICB9IC8vIGZvclxuXG4gICAgICByc2NyYXRjaC5sYWJlbFdyYXBDYWNoZWRMaW5lcyA9IHdyYXBwZWRMaW5lcztcbiAgICAgIHJzY3JhdGNoLmxhYmVsV3JhcENhY2hlZFRleHQgPSB0ZXh0ID0gd3JhcHBlZExpbmVzLmpvaW4oJ1xcbicpO1xuICAgICAgcnNjcmF0Y2gubGFiZWxXcmFwS2V5ID0gcnNjcmF0Y2gubGFiZWxLZXk7XG5cbiAgICAgIC8vIGNvbnNvbGUubG9nKHRleHQpXG4gICAgfSAvLyBpZiB3cmFwXG5cbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcblxuICBDUnAuY2FsY3VsYXRlTGFiZWxEaW1lbnNpb25zID0gZnVuY3Rpb24oIGVsZSwgdGV4dCwgZXh0cmFLZXkgKXtcbiAgICB2YXIgciA9IHRoaXM7XG4gICAgdmFyIHN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuICAgIHZhciBmU3R5bGUgPSBzdHlsZVsnZm9udC1zdHlsZSddLnN0clZhbHVlO1xuICAgIHZhciBzaXplID0gc3R5bGVbJ2ZvbnQtc2l6ZSddLnB4VmFsdWUgKyAncHgnO1xuICAgIHZhciBmYW1pbHkgPSBzdHlsZVsnZm9udC1mYW1pbHknXS5zdHJWYWx1ZTtcbiAgICAvLyB2YXIgdmFyaWFudCA9IHN0eWxlWydmb250LXZhcmlhbnQnXS5zdHJWYWx1ZTtcbiAgICB2YXIgd2VpZ2h0ID0gc3R5bGVbJ2ZvbnQtd2VpZ2h0J10uc3RyVmFsdWU7XG5cbiAgICB2YXIgY2FjaGVLZXkgPSBlbGUuX3ByaXZhdGUubGFiZWxLZXk7XG5cbiAgICBpZiggZXh0cmFLZXkgKXtcbiAgICAgIGNhY2hlS2V5ICs9ICckQCQnICsgZXh0cmFLZXk7XG4gICAgfVxuXG4gICAgdmFyIGNhY2hlID0gci5sYWJlbERpbUNhY2hlIHx8IChyLmxhYmVsRGltQ2FjaGUgPSB7fSk7XG5cbiAgICBpZiggY2FjaGVbY2FjaGVLZXldICl7XG4gICAgICByZXR1cm4gY2FjaGVbY2FjaGVLZXldO1xuICAgIH1cblxuICAgIHZhciBkaXYgPSB0aGlzLmxhYmVsQ2FsY0RpdjtcblxuICAgIGlmKCAhZGl2ICl7XG4gICAgICBkaXYgPSB0aGlzLmxhYmVsQ2FsY0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCggZGl2ICk7XG4gICAgfVxuXG4gICAgdmFyIGRzID0gZGl2LnN0eWxlO1xuXG4gICAgLy8gZnJvbSBlbGUgc3R5bGVcbiAgICBkcy5mb250RmFtaWx5ID0gZmFtaWx5O1xuICAgIGRzLmZvbnRTdHlsZSA9IGZTdHlsZTtcbiAgICBkcy5mb250U2l6ZSA9IHNpemU7XG4gICAgLy8gZHMuZm9udFZhcmlhbnQgPSB2YXJpYW50O1xuICAgIGRzLmZvbnRXZWlnaHQgPSB3ZWlnaHQ7XG5cbiAgICAvLyBmb3JjZWQgc3R5bGVcbiAgICBkcy5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgZHMubGVmdCA9ICctOTk5OXB4JztcbiAgICBkcy50b3AgPSAnLTk5OTlweCc7XG4gICAgZHMuekluZGV4ID0gJy0xJztcbiAgICBkcy52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgZHMucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICBkcy5wYWRkaW5nID0gJzAnO1xuICAgIGRzLmxpbmVIZWlnaHQgPSAnMSc7XG5cbiAgICBpZiggc3R5bGVbJ3RleHQtd3JhcCddLnZhbHVlID09PSAnd3JhcCcgKXtcbiAgICAgIGRzLndoaXRlU3BhY2UgPSAncHJlJzsgLy8gc28gbmV3bGluZXMgYXJlIHRha2VuIGludG8gYWNjb3VudFxuICAgIH0gZWxzZSB7XG4gICAgICBkcy53aGl0ZVNwYWNlID0gJ25vcm1hbCc7XG4gICAgfVxuXG4gICAgLy8gcHV0IGxhYmVsIGNvbnRlbnQgaW4gZGl2XG4gICAgZGl2LnRleHRDb250ZW50ID0gdGV4dDtcblxuICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICAgIHdpZHRoOiBkaXYuY2xpZW50V2lkdGgsXG4gICAgICBoZWlnaHQ6IGRpdi5jbGllbnRIZWlnaHRcbiAgICB9O1xuXG4gICAgcmV0dXJuIGNhY2hlW2NhY2hlS2V5XTtcbiAgfTsgIFxuXG4gIENScC5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUgPSBmdW5jdGlvbiggZWxlcyApe1xuICAgIHZhciBlZGdlcyA9IFtdO1xuICAgIHZhciBub2RlcyA9IFtdO1xuICAgIHZhciBoYW5kbGVkRWRnZSA9IHt9O1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgIHZhciBzdHlsZSA9IF9wLnN0eWxlO1xuICAgICAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG4gICAgICB2YXIgcnN0eWxlID0gX3AucnN0eWxlO1xuICAgICAgdmFyIGlkID0gX3AuZGF0YS5pZDtcbiAgICAgIHZhciBiYlN0eWxlU2FtZSA9IHJzLmJvdW5kaW5nQm94S2V5ICE9IG51bGwgJiYgX3AuYm91bmRpbmdCb3hLZXkgPT09IHJzLmJvdW5kaW5nQm94S2V5O1xuICAgICAgdmFyIGxhYmVsU3R5bGVTYW1lID0gcnMubGFiZWxLZXkgIT0gbnVsbCAmJiBfcC5sYWJlbEtleSA9PT0gcnMubGFiZWxLZXk7XG4gICAgICB2YXIgc3R5bGVTYW1lID0gYmJTdHlsZVNhbWUgJiYgbGFiZWxTdHlsZVNhbWU7XG5cbiAgICAgIGlmKCBlbGUuX3ByaXZhdGUuZ3JvdXAgPT09ICdub2RlcycgKXtcbiAgICAgICAgdmFyIHBvcyA9IF9wLnBvc2l0aW9uO1xuICAgICAgICB2YXIgcG9zU2FtZSA9IHJzdHlsZS5ub2RlWCAhPSBudWxsICYmIHJzdHlsZS5ub2RlWSAhPSBudWxsICYmIHBvcy54ID09PSByc3R5bGUubm9kZVggJiYgcG9zLnkgPT09IHJzdHlsZS5ub2RlWTtcbiAgICAgICAgdmFyIHdTYW1lID0gcnN0eWxlLm5vZGVXICE9IG51bGwgJiYgcnN0eWxlLm5vZGVXID09PSBzdHlsZVsnd2lkdGgnXS5weFZhbHVlO1xuICAgICAgICB2YXIgaFNhbWUgPSByc3R5bGUubm9kZUggIT0gbnVsbCAmJiByc3R5bGUubm9kZUggPT09IHN0eWxlWydoZWlnaHQnXS5weFZhbHVlO1xuXG4gICAgICAgIGlmKCAhcG9zU2FtZSB8fCAhc3R5bGVTYW1lIHx8ICF3U2FtZSB8fCAhaFNhbWUgKXtcbiAgICAgICAgICBub2Rlcy5wdXNoKCBlbGUgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJzdHlsZS5ub2RlWCA9IHBvcy54O1xuICAgICAgICByc3R5bGUubm9kZVkgPSBwb3MueTtcbiAgICAgICAgcnN0eWxlLm5vZGVXID0gc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZTtcbiAgICAgICAgcnN0eWxlLm5vZGVIID0gc3R5bGVbJ2hlaWdodCddLnB4VmFsdWU7XG4gICAgICB9IGVsc2UgeyAvLyBlZGdlc1xuXG4gICAgICAgIHZhciBzcmNQb3MgPSBlbGUuX3ByaXZhdGUuc291cmNlLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgICB2YXIgdGd0UG9zID0gZWxlLl9wcml2YXRlLnRhcmdldC5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAgICAgdmFyIHNyY1NhbWUgPSByc3R5bGUuc3JjWCAhPSBudWxsICYmIHJzdHlsZS5zcmNZICE9IG51bGwgJiYgc3JjUG9zLnggPT09IHJzdHlsZS5zcmNYICYmIHNyY1Bvcy55ID09PSByc3R5bGUuc3JjWTtcbiAgICAgICAgdmFyIHRndFNhbWUgPSByc3R5bGUudGd0WCAhPSBudWxsICYmIHJzdHlsZS50Z3RZICE9IG51bGwgJiYgdGd0UG9zLnggPT09IHJzdHlsZS50Z3RYICYmIHRndFBvcy55ID09PSByc3R5bGUudGd0WTtcbiAgICAgICAgdmFyIHBvc2l0aW9uc1NhbWUgPSBzcmNTYW1lICYmIHRndFNhbWU7XG5cbiAgICAgICAgaWYoICFwb3NpdGlvbnNTYW1lIHx8ICFzdHlsZVNhbWUgKXtcbiAgICAgICAgICB2YXIgY3VydmVUeXBlID0gX3Auc3R5bGVbJ2N1cnZlLXN0eWxlJ10udmFsdWU7XG5cbiAgICAgICAgICBpZiggY3VydmVUeXBlID09PSAnYmV6aWVyJyApe1xuICAgICAgICAgICAgaWYoICFoYW5kbGVkRWRnZVsgaWQgXSApe1xuICAgICAgICAgICAgICBlZGdlcy5wdXNoKCBlbGUgKTtcbiAgICAgICAgICAgICAgaGFuZGxlZEVkZ2VbIGlkIF0gPSB0cnVlO1xuXG4gICAgICAgICAgICAgIHZhciBwYXJhbGxlbEVkZ2VzID0gZWxlLnBhcmFsbGVsRWRnZXMoKTtcbiAgICAgICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwYXJhbGxlbEVkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICAgICAgdmFyIHBFZGdlID0gcGFyYWxsZWxFZGdlc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgcElkID0gcEVkZ2UuX3ByaXZhdGUuZGF0YS5pZDtcblxuICAgICAgICAgICAgICAgIGlmKCAhaGFuZGxlZEVkZ2VbIHBJZCBdICl7XG4gICAgICAgICAgICAgICAgICBlZGdlcy5wdXNoKCBwRWRnZSApO1xuICAgICAgICAgICAgICAgICAgaGFuZGxlZEVkZ2VbIHBJZCBdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWRnZXMucHVzaCggZWxlICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGlmIHBvc2l0aW9ucyBkaWZmXG5cbiAgICAgICAgLy8gdXBkYXRlIHJzdHlsZSBwb3NpdGlvbnNcbiAgICAgICAgcnN0eWxlLnNyY1ggPSBzcmNQb3MueDtcbiAgICAgICAgcnN0eWxlLnNyY1kgPSBzcmNQb3MueTtcbiAgICAgICAgcnN0eWxlLnRndFggPSB0Z3RQb3MueDtcbiAgICAgICAgcnN0eWxlLnRndFkgPSB0Z3RQb3MueTtcblxuICAgICAgfSAvLyBpZiBlZGdlc1xuXG4gICAgICBycy5ib3VuZGluZ0JveEtleSA9IF9wLmJvdW5kaW5nQm94S2V5O1xuICAgICAgcnMubGFiZWxLZXkgPSBfcC5sYWJlbEtleTtcbiAgICB9XG5cbiAgICB0aGlzLnJlY2FsY3VsYXRlRWRnZVByb2plY3Rpb25zKCBlZGdlcyApO1xuICAgIHRoaXMucmVjYWxjdWxhdGVMYWJlbFByb2plY3Rpb25zKCBub2RlcywgZWRnZXMgKTtcbiAgfTtcblxuICBDUnAucmVjYWxjdWxhdGVMYWJlbFByb2plY3Rpb25zID0gZnVuY3Rpb24oIG5vZGVzLCBlZGdlcyApe1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHRoaXMucmVjYWxjdWxhdGVOb2RlTGFiZWxQcm9qZWN0aW9uKCBub2Rlc1tpXSApO1xuICAgIH1cblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHRoaXMucmVjYWxjdWxhdGVFZGdlTGFiZWxQcm9qZWN0aW9uKCBlZGdlc1tpXSApO1xuICAgIH1cbiAgfTtcblxuICBDUnAucmVjYWxjdWxhdGVFZGdlUHJvamVjdGlvbnMgPSBmdW5jdGlvbiggZWRnZXMgKXtcbiAgICB0aGlzLmZpbmRFZGdlQ29udHJvbFBvaW50cyggZWRnZXMgKTtcbiAgfTtcblxuXG4gIC8vIEZpbmQgZWRnZSBjb250cm9sIHBvaW50c1xuICBDUnAuZmluZEVkZ2VDb250cm9sUG9pbnRzID0gZnVuY3Rpb24oZWRnZXMpIHtcbiAgICBpZiggIWVkZ2VzIHx8IGVkZ2VzLmxlbmd0aCA9PT0gMCApeyByZXR1cm47IH1cblxuICAgIHZhciBjeSA9IHRoaXMuZGF0YS5jeTtcbiAgICB2YXIgaGFzQ29tcG91bmRzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICAgIHZhciBoYXNoVGFibGUgPSB7fTtcbiAgICB2YXIgcGFpcklkcyA9IFtdO1xuICAgIHZhciBoYXlzdGFja0VkZ2VzID0gW107XG5cbiAgICAvLyBjcmVhdGUgYSB0YWJsZSBvZiBlZGdlIChzcmMsIHRndCkgPT4gbGlzdCBvZiBlZGdlcyBiZXR3ZWVuIHRoZW1cbiAgICB2YXIgcGFpcklkO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspe1xuICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tpXTtcbiAgICAgIHZhciBzdHlsZSA9IGVkZ2UuX3ByaXZhdGUuc3R5bGU7XG4gICAgICB2YXIgZWRnZUlzVW5idW5kbGVkID0gc3R5bGVbJ2N1cnZlLXN0eWxlJ10udmFsdWUgPT09ICd1bmJ1bmRsZWQtYmV6aWVyJztcblxuICAgICAgLy8gaWdub3JlIGVkZ2VzIHdobyBhcmUgbm90IHRvIGJlIGRpc3BsYXllZFxuICAgICAgLy8gdGhleSBzaG91bGRuJ3QgdGFrZSB1cCBzcGFjZVxuICAgICAgaWYoIHN0eWxlLmRpc3BsYXkudmFsdWUgPT09ICdub25lJyApe1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYoIHN0eWxlWydjdXJ2ZS1zdHlsZSddLnZhbHVlID09PSAnaGF5c3RhY2snICl7XG4gICAgICAgIGhheXN0YWNrRWRnZXMucHVzaCggZWRnZSApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNyY0lkID0gZWRnZS5fcHJpdmF0ZS5kYXRhLnNvdXJjZTtcbiAgICAgIHZhciB0Z3RJZCA9IGVkZ2UuX3ByaXZhdGUuZGF0YS50YXJnZXQ7XG5cbiAgICAgIHBhaXJJZCA9IHNyY0lkID4gdGd0SWQgP1xuICAgICAgICB0Z3RJZCArICctJyArIHNyY0lkIDpcbiAgICAgICAgc3JjSWQgKyAnLScgKyB0Z3RJZCA7XG5cbiAgICAgIGlmKCBlZGdlSXNVbmJ1bmRsZWQgKXtcbiAgICAgICAgcGFpcklkID0gJ3VuYnVuZGxlZCcgKyBlZGdlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNoVGFibGVbcGFpcklkXSA9PSBudWxsKSB7XG4gICAgICAgIGhhc2hUYWJsZVtwYWlySWRdID0gW107XG4gICAgICAgIHBhaXJJZHMucHVzaCggcGFpcklkICk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGhhc2hUYWJsZVtwYWlySWRdLnB1c2goIGVkZ2UgKTtcblxuICAgICAgaWYoIGVkZ2VJc1VuYnVuZGxlZCApe1xuICAgICAgICBoYXNoVGFibGVbcGFpcklkXS5oYXNVbmJ1bmRsZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzcmMsIHRndCwgc3JjUG9zLCB0Z3RQb3MsIHNyY1csIHNyY0gsIHRndFcsIHRndEgsIHNyY1NoYXBlLCB0Z3RTaGFwZSwgc3JjQm9yZGVyLCB0Z3RCb3JkZXI7XG4gICAgdmFyIHZlY3Rvck5vcm1JbnZlcnNlO1xuICAgIHZhciBiYWRCZXppZXI7XG4gICAgXG4gICAgLy8gZm9yIGVhY2ggcGFpciAoc3JjLCB0Z3QpLCBjcmVhdGUgdGhlIGN0cmwgcHRzXG4gICAgLy8gTmVzdGVkIGZvciBsb29wIGlzIE9LOyB0b3RhbCBudW1iZXIgb2YgaXRlcmF0aW9ucyBmb3IgYm90aCBsb29wcyA9IGVkZ2VDb3VudCAgXG4gICAgZm9yICh2YXIgcCA9IDA7IHAgPCBwYWlySWRzLmxlbmd0aDsgcCsrKSB7XG4gICAgICBwYWlySWQgPSBwYWlySWRzW3BdO1xuICAgICAgdmFyIHBhaXJFZGdlcyA9IGhhc2hUYWJsZVtwYWlySWRdO1xuICAgIFxuICAgICAgLy8gZm9yIGVhY2ggcGFpciBpZCwgdGhlIGVkZ2VzIHNob3VsZCBiZSBzb3J0ZWQgYnkgaW5kZXhcbiAgICAgIHBhaXJFZGdlcy5zb3J0KGZ1bmN0aW9uKGVkZ2UxLCBlZGdlMil7XG4gICAgICAgIHJldHVybiBlZGdlMS5fcHJpdmF0ZS5pbmRleCAtIGVkZ2UyLl9wcml2YXRlLmluZGV4O1xuICAgICAgfSk7XG5cbiAgICAgIHNyYyA9IHBhaXJFZGdlc1swXS5fcHJpdmF0ZS5zb3VyY2U7XG4gICAgICB0Z3QgPSBwYWlyRWRnZXNbMF0uX3ByaXZhdGUudGFyZ2V0O1xuXG4gICAgICAvLyBtYWtlIHN1cmUgc3JjL3RndCBkaXN0aW5jdGlvbiBpcyBjb25zaXN0ZW50XG4gICAgICAvLyAoc3JjL3RndCBpbiB0aGlzIGNhc2UgYXJlIGp1c3QgZm9yIGN0cmxwdHMgYW5kIGRvbid0IGFjdHVhbGx5IGhhdmUgdG8gYmUgdHJ1ZSBzcmMvdGd0KVxuICAgICAgaWYoIHNyYy5fcHJpdmF0ZS5kYXRhLmlkID4gdGd0Ll9wcml2YXRlLmRhdGEuaWQgKXtcbiAgICAgICAgdmFyIHRlbXAgPSBzcmM7XG4gICAgICAgIHNyYyA9IHRndDtcbiAgICAgICAgdGd0ID0gdGVtcDtcbiAgICAgIH1cblxuICAgICAgc3JjUG9zID0gc3JjLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgdGd0UG9zID0gdGd0Ll9wcml2YXRlLnBvc2l0aW9uO1xuXG4gICAgICBzcmNXID0gdGhpcy5nZXROb2RlV2lkdGgoc3JjKTtcbiAgICAgIHNyY0ggPSB0aGlzLmdldE5vZGVIZWlnaHQoc3JjKTtcblxuICAgICAgdGd0VyA9IHRoaXMuZ2V0Tm9kZVdpZHRoKHRndCk7XG4gICAgICB0Z3RIID0gdGhpcy5nZXROb2RlSGVpZ2h0KHRndCk7XG5cbiAgICAgIHNyY1NoYXBlID0gQ2FudmFzUmVuZGVyZXIubm9kZVNoYXBlc1sgdGhpcy5nZXROb2RlU2hhcGUoc3JjKSBdO1xuICAgICAgdGd0U2hhcGUgPSBDYW52YXNSZW5kZXJlci5ub2RlU2hhcGVzWyB0aGlzLmdldE5vZGVTaGFwZSh0Z3QpIF07XG5cbiAgICAgIHNyY0JvcmRlciA9IHNyYy5fcHJpdmF0ZS5zdHlsZVsnYm9yZGVyLXdpZHRoJ10ucHhWYWx1ZTtcbiAgICAgIHRndEJvcmRlciA9IHRndC5fcHJpdmF0ZS5zdHlsZVsnYm9yZGVyLXdpZHRoJ10ucHhWYWx1ZTtcblxuICAgICAgYmFkQmV6aWVyID0gZmFsc2U7XG4gICAgICBcblxuICAgICAgaWYoIChwYWlyRWRnZXMubGVuZ3RoID4gMSAmJiBzcmMgIT09IHRndCkgfHwgcGFpckVkZ2VzLmhhc1VuYnVuZGxlZCApe1xuXG4gICAgICAgIC8vIHB0IG91dHNpZGUgc3JjIHNoYXBlIHRvIGNhbGMgZGlzdGFuY2UvZGlzcGxhY2VtZW50IGZyb20gc3JjIHRvIHRndFxuICAgICAgICB2YXIgc3JjT3V0c2lkZSA9IHNyY1NoYXBlLmludGVyc2VjdExpbmUoXG4gICAgICAgICAgc3JjUG9zLngsXG4gICAgICAgICAgc3JjUG9zLnksXG4gICAgICAgICAgc3JjVyxcbiAgICAgICAgICBzcmNILFxuICAgICAgICAgIHRndFBvcy54LFxuICAgICAgICAgIHRndFBvcy55LFxuICAgICAgICAgIHNyY0JvcmRlciAvIDJcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBwdCBvdXRzaWRlIHRndCBzaGFwZSB0byBjYWxjIGRpc3RhbmNlL2Rpc3BsYWNlbWVudCBmcm9tIHNyYyB0byB0Z3RcbiAgICAgICAgdmFyIHRndE91dHNpZGUgPSB0Z3RTaGFwZS5pbnRlcnNlY3RMaW5lKFxuICAgICAgICAgIHRndFBvcy54LFxuICAgICAgICAgIHRndFBvcy55LFxuICAgICAgICAgIHRndFcsXG4gICAgICAgICAgdGd0SCxcbiAgICAgICAgICBzcmNQb3MueCxcbiAgICAgICAgICBzcmNQb3MueSxcbiAgICAgICAgICB0Z3RCb3JkZXIgLyAyXG4gICAgICAgICk7XG5cbiAgICAgICAgdmFyIG1pZHB0U3JjUHRzID0ge1xuICAgICAgICAgIHgxOiBzcmNPdXRzaWRlWzBdLFxuICAgICAgICAgIHgyOiB0Z3RPdXRzaWRlWzBdLFxuICAgICAgICAgIHkxOiBzcmNPdXRzaWRlWzFdLFxuICAgICAgICAgIHkyOiB0Z3RPdXRzaWRlWzFdXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGR5ID0gKCB0Z3RPdXRzaWRlWzFdIC0gc3JjT3V0c2lkZVsxXSApO1xuICAgICAgICB2YXIgZHggPSAoIHRndE91dHNpZGVbMF0gLSBzcmNPdXRzaWRlWzBdICk7XG4gICAgICAgIHZhciBsID0gTWF0aC5zcXJ0KCBkeCpkeCArIGR5KmR5ICk7XG5cbiAgICAgICAgdmFyIHZlY3RvciA9IHtcbiAgICAgICAgICB4OiBkeCxcbiAgICAgICAgICB5OiBkeVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgdmFyIHZlY3Rvck5vcm0gPSB7XG4gICAgICAgICAgeDogdmVjdG9yLngvbCxcbiAgICAgICAgICB5OiB2ZWN0b3IueS9sXG4gICAgICAgIH07XG4gICAgICAgIHZlY3Rvck5vcm1JbnZlcnNlID0ge1xuICAgICAgICAgIHg6IC12ZWN0b3JOb3JtLnksXG4gICAgICAgICAgeTogdmVjdG9yTm9ybS54XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gaWYgc3JjIGludGVyc2VjdGlvbiBpcyBpbnNpZGUgdGd0IG9yIHRndCBpbnRlcnNlY3Rpb24gaXMgaW5zaWRlIHNyYywgdGhlbiBubyBjdHJsIHB0cyB0byBkcmF3XG4gICAgICAgIGlmKCBcbiAgICAgICAgICB0Z3RTaGFwZS5jaGVja1BvaW50KCBzcmNPdXRzaWRlWzBdLCBzcmNPdXRzaWRlWzFdLCB0Z3RCb3JkZXIvMiwgdGd0VywgdGd0SCwgdGd0UG9zLngsIHRndFBvcy55ICkgIHx8XG4gICAgICAgICAgc3JjU2hhcGUuY2hlY2tQb2ludCggdGd0T3V0c2lkZVswXSwgdGd0T3V0c2lkZVsxXSwgc3JjQm9yZGVyLzIsIHNyY1csIHNyY0gsIHNyY1Bvcy54LCBzcmNQb3MueSApIFxuICAgICAgICApe1xuICAgICAgICAgIHZlY3Rvck5vcm1JbnZlcnNlID0ge307XG4gICAgICAgICAgYmFkQmV6aWVyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIGVkZ2U7XG4gICAgICB2YXIgcnM7XG4gICAgICBcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFpckVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVkZ2UgPSBwYWlyRWRnZXNbaV07XG4gICAgICAgIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICAgICAgXG4gICAgICAgIHZhciBlZGdlSW5kZXgxID0gcnMubGFzdEVkZ2VJbmRleDtcbiAgICAgICAgdmFyIGVkZ2VJbmRleDIgPSBpO1xuXG4gICAgICAgIHZhciBudW1FZGdlczEgPSBycy5sYXN0TnVtRWRnZXM7XG4gICAgICAgIHZhciBudW1FZGdlczIgPSBwYWlyRWRnZXMubGVuZ3RoO1xuXG4gICAgICAgIHZhciBlU3R5bGUgPSBlZGdlLl9wcml2YXRlLnN0eWxlO1xuICAgICAgICB2YXIgc3RlcFNpemUgPSBlU3R5bGVbJ2NvbnRyb2wtcG9pbnQtc3RlcC1zaXplJ10ucHhWYWx1ZTtcbiAgICAgICAgdmFyIHN0ZXBEaXN0ID0gZVN0eWxlWydjb250cm9sLXBvaW50LWRpc3RhbmNlJ10gIT09IHVuZGVmaW5lZCA/IGVTdHlsZVsnY29udHJvbC1wb2ludC1kaXN0YW5jZSddLnB4VmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBzdGVwV2VpZ2h0ID0gZVN0eWxlWydjb250cm9sLXBvaW50LXdlaWdodCddLnZhbHVlO1xuICAgICAgICB2YXIgZWRnZUlzVW5idW5kbGVkID0gZVN0eWxlWydjdXJ2ZS1zdHlsZSddLnZhbHVlID09PSAndW5idW5kbGVkLWJlemllcic7XG4gICAgICAgIFxuICAgICAgICB2YXIgc3dhcHBlZERpcmVjdGlvbiA9IGVkZ2UuX3ByaXZhdGUuc291cmNlICE9PSBzcmM7XG5cbiAgICAgICAgaWYoIHN3YXBwZWREaXJlY3Rpb24gJiYgZWRnZUlzVW5idW5kbGVkICl7XG4gICAgICAgICAgc3RlcERpc3QgKj0gLTE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3JjWDEgPSBycy5sYXN0U3JjQ3RsUHRYO1xuICAgICAgICB2YXIgc3JjWDIgPSBzcmNQb3MueDtcbiAgICAgICAgdmFyIHNyY1kxID0gcnMubGFzdFNyY0N0bFB0WTtcbiAgICAgICAgdmFyIHNyY1kyID0gc3JjUG9zLnk7XG4gICAgICAgIHZhciBzcmNXMSA9IHJzLmxhc3RTcmNDdGxQdFc7XG4gICAgICAgIHZhciBzcmNXMiA9IHNyYy5vdXRlcldpZHRoKCk7XG4gICAgICAgIHZhciBzcmNIMSA9IHJzLmxhc3RTcmNDdGxQdEg7XG4gICAgICAgIHZhciBzcmNIMiA9IHNyYy5vdXRlckhlaWdodCgpO1xuXG4gICAgICAgIHZhciB0Z3RYMSA9IHJzLmxhc3RUZ3RDdGxQdFg7XG4gICAgICAgIHZhciB0Z3RYMiA9IHRndFBvcy54O1xuICAgICAgICB2YXIgdGd0WTEgPSBycy5sYXN0VGd0Q3RsUHRZO1xuICAgICAgICB2YXIgdGd0WTIgPSB0Z3RQb3MueTtcbiAgICAgICAgdmFyIHRndFcxID0gcnMubGFzdFRndEN0bFB0VztcbiAgICAgICAgdmFyIHRndFcyID0gdGd0Lm91dGVyV2lkdGgoKTtcbiAgICAgICAgdmFyIHRndEgxID0gcnMubGFzdFRndEN0bFB0SDtcbiAgICAgICAgdmFyIHRndEgyID0gdGd0Lm91dGVySGVpZ2h0KCk7XG5cbiAgICAgICAgdmFyIHdpZHRoMSA9IHJzLmxhc3RXO1xuICAgICAgICB2YXIgd2lkdGgyID0gZVN0eWxlWydjb250cm9sLXBvaW50LXN0ZXAtc2l6ZSddLnB4VmFsdWU7XG5cbiAgICAgICAgaWYoIGJhZEJlemllciApe1xuICAgICAgICAgIHJzLmJhZEJlemllciA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcnMuYmFkQmV6aWVyID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggc3JjWDEgPT09IHNyY1gyICYmIHNyY1kxID09PSBzcmNZMiAmJiBzcmNXMSA9PT0gc3JjVzIgJiYgc3JjSDEgPT09IHNyY0gyXG4gICAgICAgICYmICB0Z3RYMSA9PT0gdGd0WDIgJiYgdGd0WTEgPT09IHRndFkyICYmIHRndFcxID09PSB0Z3RXMiAmJiB0Z3RIMSA9PT0gdGd0SDJcbiAgICAgICAgJiYgIHdpZHRoMSA9PT0gd2lkdGgyXG4gICAgICAgICYmICAoKGVkZ2VJbmRleDEgPT09IGVkZ2VJbmRleDIgJiYgbnVtRWRnZXMxID09PSBudW1FZGdlczIpIHx8IGVkZ2VJc1VuYnVuZGxlZCkgKXtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZWRnZSBjdHJsIHB0IGNhY2hlIEhJVCcpXG4gICAgICAgICAgY29udGludWU7IC8vIHRoZW4gdGhlIGNvbnRyb2wgcG9pbnRzIGhhdmVuJ3QgY2hhbmdlZCBhbmQgd2UgY2FuIHNraXAgY2FsY3VsYXRpbmcgdGhlbVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJzLmxhc3RTcmNDdGxQdFggPSBzcmNYMjtcbiAgICAgICAgICBycy5sYXN0U3JjQ3RsUHRZID0gc3JjWTI7XG4gICAgICAgICAgcnMubGFzdFNyY0N0bFB0VyA9IHNyY1cyO1xuICAgICAgICAgIHJzLmxhc3RTcmNDdGxQdEggPSBzcmNIMjtcbiAgICAgICAgICBycy5sYXN0VGd0Q3RsUHRYID0gdGd0WDI7XG4gICAgICAgICAgcnMubGFzdFRndEN0bFB0WSA9IHRndFkyO1xuICAgICAgICAgIHJzLmxhc3RUZ3RDdGxQdFcgPSB0Z3RXMjtcbiAgICAgICAgICBycy5sYXN0VGd0Q3RsUHRIID0gdGd0SDI7XG4gICAgICAgICAgcnMubGFzdEVkZ2VJbmRleCA9IGVkZ2VJbmRleDI7XG4gICAgICAgICAgcnMubGFzdE51bUVkZ2VzID0gbnVtRWRnZXMyO1xuICAgICAgICAgIHJzLmxhc3RXaWR0aCA9IHdpZHRoMjtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZWRnZSBjdHJsIHB0IGNhY2hlIE1JU1MnKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2VsZi1lZGdlXG4gICAgICAgIGlmICggc3JjID09PSB0Z3QgKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICBycy5lZGdlVHlwZSA9ICdzZWxmJztcbiAgICAgICAgICBcbiAgICAgICAgICB2YXIgaiA9IGk7XG4gICAgICAgICAgdmFyIGxvb3BEaXN0ID0gc3RlcFNpemU7XG5cbiAgICAgICAgICBpZiggZWRnZUlzVW5idW5kbGVkICl7XG4gICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgIGxvb3BEaXN0ID0gc3RlcERpc3Q7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gTmV3IC0tIGZpeCBmb3IgbGFyZ2Ugbm9kZXNcbiAgICAgICAgICBycy5jcDJheCA9IHNyY1Bvcy54O1xuICAgICAgICAgIHJzLmNwMmF5ID0gc3JjUG9zLnkgLSAoMSArIE1hdGgucG93KHNyY0gsIDEuMTIpIC8gMTAwKSAqIGxvb3BEaXN0ICogKGogLyAzICsgMSk7XG4gICAgICAgICAgXG4gICAgICAgICAgcnMuY3AyY3ggPSBzcmNQb3MueCAtICgxICsgTWF0aC5wb3coc3JjVywgMS4xMikgLyAxMDApICogbG9vcERpc3QgKiAoaiAvIDMgKyAxKTtcbiAgICAgICAgICBycy5jcDJjeSA9IHNyY1Bvcy55O1xuICAgICAgICAgIFxuICAgICAgICAgIHJzLnNlbGZFZGdlTWlkWCA9IChycy5jcDJheCArIHJzLmNwMmN4KSAvIDIuMDtcbiAgICAgICAgICBycy5zZWxmRWRnZU1pZFkgPSAocnMuY3AyYXkgKyBycy5jcDJjeSkgLyAyLjA7XG4gICAgICAgIFxuICAgICAgICAvLyBDb21wb3VuZCBlZGdlXG4gICAgICAgIH0gZWxzZSBpZihcbiAgICAgICAgICBoYXNDb21wb3VuZHMgJiZcbiAgICAgICAgICAoIHNyYy5pc1BhcmVudCgpIHx8IHNyYy5pc0NoaWxkKCkgfHwgdGd0LmlzUGFyZW50KCkgfHwgdGd0LmlzQ2hpbGQoKSApICYmXG4gICAgICAgICAgKCBzcmMucGFyZW50cygpLmFueVNhbWUodGd0KSB8fCB0Z3QucGFyZW50cygpLmFueVNhbWUoc3JjKSApXG4gICAgICAgICl7XG5cbiAgICAgICAgICBycy5lZGdlVHlwZSA9ICdjb21wb3VuZCc7XG5cbiAgICAgICAgICAvLyBiZWNhdXNlIHRoZSBsaW5lIGFwcHJveGltYXRpb24gZG9lc24ndCBhcHBseSBmb3IgY29tcG91bmQgYmV6aWVyc1xuICAgICAgICAgIC8vIChsb29wL3NlbGYgZWRnZXMgYXJlIGFscmVhZHkgZWxpZGVkIGIvYyBvZiBjaGVhcCBzcmM9PXRndCBjaGVjaylcbiAgICAgICAgICBycy5iYWRCZXppZXIgPSBmYWxzZTtcblxuICAgICAgICAgIHZhciBqID0gaTtcbiAgICAgICAgICB2YXIgbG9vcERpc3QgPSBzdGVwU2l6ZTtcblxuICAgICAgICAgIGlmKCBlZGdlSXNVbmJ1bmRsZWQgKXtcbiAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgbG9vcERpc3QgPSBzdGVwRGlzdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBcbiAgICAgICAgICB2YXIgbG9vcFcgPSA1MDtcblxuICAgICAgICAgIHZhciBsb29wYVBvcyA9IHtcbiAgICAgICAgICAgIHg6IHNyY1Bvcy54IC0gc3JjVy8yLFxuICAgICAgICAgICAgeTogc3JjUG9zLnkgLSBzcmNILzJcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIGxvb3BiUG9zID0ge1xuICAgICAgICAgICAgeDogdGd0UG9zLnggLSB0Z3RXLzIsXG4gICAgICAgICAgICB5OiB0Z3RQb3MueSAtIHRndEgvMlxuICAgICAgICAgIH07XG5cbiAgICAgICAgICB2YXIgbWluQ29tcG91bmRTdHJldGNoID0gMTtcblxuICAgICAgICAgIHJzLmNwMmF4ID0gbG9vcGFQb3MueDtcbiAgICAgICAgICBycy5jb21wb3VuZFN0cmV0Y2hBID0gTWF0aC5tYXgoIG1pbkNvbXBvdW5kU3RyZXRjaCwgTWF0aC5sb2coc3JjVyAqIDAuMDEpICk7IC8vIGF2b2lkcyBjYXNlcyB3aXRoIGltcG9zc2libGUgYmV6aWVyc1xuICAgICAgICAgIHJzLmNwMmF5ID0gbG9vcGFQb3MueSAtICgxICsgTWF0aC5wb3cobG9vcFcsIDEuMTIpIC8gMTAwKSAqIGxvb3BEaXN0ICogKGogLyAzICsgMSkgKiBycy5jb21wb3VuZFN0cmV0Y2hBO1xuICAgICAgICAgIFxuICAgICAgICAgIHJzLmNvbXBvdW5kU3RyZXRjaEIgPSBNYXRoLm1heCggbWluQ29tcG91bmRTdHJldGNoLCBNYXRoLmxvZyh0Z3RXICogMC4wMSkgKTsgLy8gYXZvaWRzIGNhc2VzIHdpdGggaW1wb3NzaWJsZSBiZXppZXJzXG4gICAgICAgICAgcnMuY3AyY3ggPSBsb29wYlBvcy54IC0gKDEgKyBNYXRoLnBvdyhsb29wVywgMS4xMikgLyAxMDApICogbG9vcERpc3QgKiAoaiAvIDMgKyAxKSAqIHJzLmNvbXBvdW5kU3RyZXRjaEI7XG4gICAgICAgICAgcnMuY3AyY3kgPSBsb29wYlBvcy55O1xuICAgICAgICAgIFxuICAgICAgICAgIHJzLnNlbGZFZGdlTWlkWCA9IChycy5jcDJheCArIHJzLmNwMmN4KSAvIDIuMDtcbiAgICAgICAgICBycy5zZWxmRWRnZU1pZFkgPSAocnMuY3AyYXkgKyBycy5jcDJjeSkgLyAyLjA7XG5cbiAgICAgICAgLy8gU3RyYWlnaHQgZWRnZVxuICAgICAgICB9IGVsc2UgaWYgKHBhaXJFZGdlcy5sZW5ndGggJSAyID09PSAxXG4gICAgICAgICAgJiYgaSA9PT0gTWF0aC5mbG9vcihwYWlyRWRnZXMubGVuZ3RoIC8gMilcbiAgICAgICAgICAmJiAhZWRnZUlzVW5idW5kbGVkICkge1xuICAgICAgICAgIFxuICAgICAgICAgIHJzLmVkZ2VUeXBlID0gJ3N0cmFpZ2h0JztcbiAgICAgICAgICBcbiAgICAgICAgLy8gQmV6aWVyIGVkZ2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbm9ybVN0ZXBEaXN0ID0gKDAuNSAtIHBhaXJFZGdlcy5sZW5ndGggLyAyICsgaSkgKiBzdGVwU2l6ZTtcbiAgICAgICAgICB2YXIgbWFuU3RlcERpc3Q7XG4gICAgICAgICAgdmFyIHNpZ24gPSAkJC5tYXRoLnNpZ251bSggbm9ybVN0ZXBEaXN0ICk7XG5cbiAgICAgICAgICBpZiggZWRnZUlzVW5idW5kbGVkICl7XG4gICAgICAgICAgICBtYW5TdGVwRGlzdCA9IHN0ZXBEaXN0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYW5TdGVwRGlzdCA9IHN0ZXBEaXN0ICE9PSB1bmRlZmluZWQgPyBzaWduICogc3RlcERpc3QgOiB1bmRlZmluZWQ7IFxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBkaXN0YW5jZUZyb21NaWRwb2ludCA9IG1hblN0ZXBEaXN0ICE9PSB1bmRlZmluZWQgPyBtYW5TdGVwRGlzdCA6IG5vcm1TdGVwRGlzdDtcbiAgICAgICAgICBcbiAgICAgICAgICB2YXIgdzEgPSAoMSAtIHN0ZXBXZWlnaHQpO1xuICAgICAgICAgIHZhciB3MiA9IHN0ZXBXZWlnaHQ7XG5cbiAgICAgICAgICBpZiggc3dhcHBlZERpcmVjdGlvbiApe1xuICAgICAgICAgICAgdzEgPSBzdGVwV2VpZ2h0O1xuICAgICAgICAgICAgdzIgPSAoMSAtIHN0ZXBXZWlnaHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBhZGp1c3RlZE1pZHB0ID0ge1xuICAgICAgICAgICAgeDogbWlkcHRTcmNQdHMueDEgKiB3MSArIG1pZHB0U3JjUHRzLngyICogdzIsXG4gICAgICAgICAgICB5OiBtaWRwdFNyY1B0cy55MSAqIHcxICsgbWlkcHRTcmNQdHMueTIgKiB3MlxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBycy5lZGdlVHlwZSA9ICdiZXppZXInO1xuICAgICAgICAgIFxuICAgICAgICAgIHJzLmNwMnggPSBhZGp1c3RlZE1pZHB0LnggKyB2ZWN0b3JOb3JtSW52ZXJzZS54ICogZGlzdGFuY2VGcm9tTWlkcG9pbnQ7XG4gICAgICAgICAgcnMuY3AyeSA9IGFkanVzdGVkTWlkcHQueSArIHZlY3Rvck5vcm1JbnZlcnNlLnkgKiBkaXN0YW5jZUZyb21NaWRwb2ludDtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhlZGdlLCBtaWRQb2ludFgsIGRpc3BsYWNlbWVudFgsIGRpc3RhbmNlRnJvbU1pZHBvaW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmQgZW5kcHRzIGZvciBlZGdlXG4gICAgICAgIHRoaXMuZmluZEVuZHBvaW50cyggZWRnZSApO1xuXG4gICAgICAgIHZhciBiYWRTdGFydCA9ICEkJC5pcy5udW1iZXIoIHJzLnN0YXJ0WCApIHx8ICEkJC5pcy5udW1iZXIoIHJzLnN0YXJ0WSApO1xuICAgICAgICB2YXIgYmFkQVN0YXJ0ID0gISQkLmlzLm51bWJlciggcnMuYXJyb3dTdGFydFggKSB8fCAhJCQuaXMubnVtYmVyKCBycy5hcnJvd1N0YXJ0WSApO1xuICAgICAgICB2YXIgYmFkRW5kID0gISQkLmlzLm51bWJlciggcnMuZW5kWCApIHx8ICEkJC5pcy5udW1iZXIoIHJzLmVuZFkgKTtcbiAgICAgICAgdmFyIGJhZEFFbmQgPSAhJCQuaXMubnVtYmVyKCBycy5hcnJvd0VuZFggKSB8fCAhJCQuaXMubnVtYmVyKCBycy5hcnJvd0VuZFkgKTtcblxuICAgICAgICB2YXIgbWluQ3BBRGlzdEZhY3RvciA9IDM7XG4gICAgICAgIHZhciBhcnJvd1cgPSB0aGlzLmdldEFycm93V2lkdGgoIGVkZ2UuX3ByaXZhdGUuc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZSApICogQ2FudmFzUmVuZGVyZXIuYXJyb3dTaGFwZUhlaWdodDtcbiAgICAgICAgdmFyIG1pbkNwQURpc3QgPSBtaW5DcEFEaXN0RmFjdG9yICogYXJyb3dXO1xuICAgICAgICB2YXIgc3RhcnRBQ3BEaXN0ID0gJCQubWF0aC5kaXN0YW5jZSggeyB4OiBycy5jcDJ4LCB5OiBycy5jcDJ5IH0sIHsgeDogcnMuc3RhcnRYLCB5OiBycy5zdGFydFkgfSApO1xuICAgICAgICB2YXIgY2xvc2VTdGFydEFDcCA9IHN0YXJ0QUNwRGlzdCA8IG1pbkNwQURpc3Q7XG4gICAgICAgIHZhciBlbmRBQ3BEaXN0ID0gJCQubWF0aC5kaXN0YW5jZSggeyB4OiBycy5jcDJ4LCB5OiBycy5jcDJ5IH0sIHsgeDogcnMuZW5kWCwgeTogcnMuZW5kWSB9ICk7XG4gICAgICAgIHZhciBjbG9zZUVuZEFDcCA9IGVuZEFDcERpc3QgPCBtaW5DcEFEaXN0O1xuXG4gICAgICAgIGlmKCBycy5lZGdlVHlwZSA9PT0gJ2JlemllcicgKXtcbiAgICAgICAgICB2YXIgb3ZlcmxhcHBpbmcgPSBmYWxzZTtcblxuICAgICAgICAgIGlmKCBiYWRTdGFydCB8fCBiYWRBU3RhcnQgfHwgY2xvc2VTdGFydEFDcCApe1xuICAgICAgICAgICAgb3ZlcmxhcHBpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBwcm9qZWN0IGNvbnRyb2wgcG9pbnQgYWxvbmcgbGluZSBmcm9tIHNyYyBjZW50cmUgdG8gb3V0c2lkZSB0aGUgc3JjIHNoYXBlXG4gICAgICAgICAgICAvLyAob3RoZXJ3aXNlIGludGVyc2VjdGlvbiB3aWxsIHlpZWxkIG5vdGhpbmcpXG4gICAgICAgICAgICB2YXIgY3BEID0geyAvLyBkZWx0YVxuICAgICAgICAgICAgICB4OiBycy5jcDJ4IC0gc3JjUG9zLngsXG4gICAgICAgICAgICAgIHk6IHJzLmNwMnkgLSBzcmNQb3MueVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBjcEwgPSBNYXRoLnNxcnQoIGNwRC54KmNwRC54ICsgY3BELnkqY3BELnkgKTsgLy8gbGVuZ3RoIG9mIGxpbmVcbiAgICAgICAgICAgIHZhciBjcE0gPSB7IC8vIG5vcm1hbGlzZWQgZGVsdGFcbiAgICAgICAgICAgICAgeDogY3BELnggLyBjcEwsXG4gICAgICAgICAgICAgIHk6IGNwRC55IC8gY3BMXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHJhZGl1cyA9IE1hdGgubWF4KHNyY1csIHNyY0gpO1xuICAgICAgICAgICAgdmFyIGNwUHJvaiA9IHsgLy8gKjIgcmFkaXVzIGd1YXJhbnRlZXMgb3V0c2lkZSBzaGFwZVxuICAgICAgICAgICAgICB4OiBycy5jcDJ4ICsgY3BNLnggKiAyICogcmFkaXVzLFxuICAgICAgICAgICAgICB5OiBycy5jcDJ5ICsgY3BNLnkgKiAyICogcmFkaXVzXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgc3JjQ3RybFB0SW50biA9IHNyY1NoYXBlLmludGVyc2VjdExpbmUoXG4gICAgICAgICAgICAgIHNyY1Bvcy54LFxuICAgICAgICAgICAgICBzcmNQb3MueSxcbiAgICAgICAgICAgICAgc3JjVyxcbiAgICAgICAgICAgICAgc3JjSCxcbiAgICAgICAgICAgICAgY3BQcm9qLngsXG4gICAgICAgICAgICAgIGNwUHJvai55LFxuICAgICAgICAgICAgICBzcmNCb3JkZXIgLyAyXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiggY2xvc2VTdGFydEFDcCApe1xuICAgICAgICAgICAgICBycy5jcDJ4ID0gcnMuY3AyeCArIGNwTS54ICogKG1pbkNwQURpc3QgLSBzdGFydEFDcERpc3QpOyBcbiAgICAgICAgICAgICAgcnMuY3AyeSA9IHJzLmNwMnkgKyBjcE0ueSAqIChtaW5DcEFEaXN0IC0gc3RhcnRBQ3BEaXN0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJzLmNwMnggPSBzcmNDdHJsUHRJbnRuWzBdICsgY3BNLnggKiBtaW5DcEFEaXN0OyBcbiAgICAgICAgICAgICAgcnMuY3AyeSA9IHNyY0N0cmxQdEludG5bMV0gKyBjcE0ueSAqIG1pbkNwQURpc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIGJhZEVuZCB8fCBiYWRBRW5kIHx8IGNsb3NlRW5kQUNwICl7XG4gICAgICAgICAgICBvdmVybGFwcGluZyA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIHByb2plY3QgY29udHJvbCBwb2ludCBhbG9uZyBsaW5lIGZyb20gdGd0IGNlbnRyZSB0byBvdXRzaWRlIHRoZSB0Z3Qgc2hhcGVcbiAgICAgICAgICAgIC8vIChvdGhlcndpc2UgaW50ZXJzZWN0aW9uIHdpbGwgeWllbGQgbm90aGluZylcbiAgICAgICAgICAgIHZhciBjcEQgPSB7IC8vIGRlbHRhXG4gICAgICAgICAgICAgIHg6IHJzLmNwMnggLSB0Z3RQb3MueCxcbiAgICAgICAgICAgICAgeTogcnMuY3AyeSAtIHRndFBvcy55XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGNwTCA9IE1hdGguc3FydCggY3BELngqY3BELnggKyBjcEQueSpjcEQueSApOyAvLyBsZW5ndGggb2YgbGluZVxuICAgICAgICAgICAgdmFyIGNwTSA9IHsgLy8gbm9ybWFsaXNlZCBkZWx0YVxuICAgICAgICAgICAgICB4OiBjcEQueCAvIGNwTCxcbiAgICAgICAgICAgICAgeTogY3BELnkgLyBjcExcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgcmFkaXVzID0gTWF0aC5tYXgoc3JjVywgc3JjSCk7XG4gICAgICAgICAgICB2YXIgY3BQcm9qID0geyAvLyAqMiByYWRpdXMgZ3VhcmFudGVlcyBvdXRzaWRlIHNoYXBlXG4gICAgICAgICAgICAgIHg6IHJzLmNwMnggKyBjcE0ueCAqIDIgKiByYWRpdXMsXG4gICAgICAgICAgICAgIHk6IHJzLmNwMnkgKyBjcE0ueSAqIDIgKiByYWRpdXNcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciB0Z3RDdHJsUHRJbnRuID0gdGd0U2hhcGUuaW50ZXJzZWN0TGluZShcbiAgICAgICAgICAgICAgdGd0UG9zLngsXG4gICAgICAgICAgICAgIHRndFBvcy55LFxuICAgICAgICAgICAgICB0Z3RXLFxuICAgICAgICAgICAgICB0Z3RILFxuICAgICAgICAgICAgICBjcFByb2oueCxcbiAgICAgICAgICAgICAgY3BQcm9qLnksXG4gICAgICAgICAgICAgIHRndEJvcmRlciAvIDJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmKCBjbG9zZUVuZEFDcCApe1xuICAgICAgICAgICAgICBycy5jcDJ4ID0gcnMuY3AyeCArIGNwTS54ICogKG1pbkNwQURpc3QgLSBlbmRBQ3BEaXN0KTsgXG4gICAgICAgICAgICAgIHJzLmNwMnkgPSBycy5jcDJ5ICsgY3BNLnkgKiAobWluQ3BBRGlzdCAtIGVuZEFDcERpc3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcnMuY3AyeCA9IHRndEN0cmxQdEludG5bMF0gKyBjcE0ueCAqIG1pbkNwQURpc3Q7IFxuICAgICAgICAgICAgICBycy5jcDJ5ID0gdGd0Q3RybFB0SW50blsxXSArIGNwTS55ICogbWluQ3BBRGlzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCBvdmVybGFwcGluZyApe1xuICAgICAgICAgICAgLy8gcmVjYWxjIGVuZHB0c1xuICAgICAgICAgICAgdGhpcy5maW5kRW5kcG9pbnRzKCBlZGdlICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYoIHJzLmVkZ2VUeXBlID09PSAnc3RyYWlnaHQnICl7XG4gICAgICAgICAgcnMubWlkWCA9ICggc3JjWDIgKyB0Z3RYMiApLzI7XG4gICAgICAgICAgcnMubWlkWSA9ICggc3JjWTIgKyB0Z3RZMiApLzI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwcm9qZWN0IHRoZSBlZGdlIGludG8gcnN0eWxlXG4gICAgICAgIHRoaXMucHJvamVjdEJlemllciggZWRnZSApO1xuICAgICAgICB0aGlzLnJlY2FsY3VsYXRlRWRnZUxhYmVsUHJvamVjdGlvbiggZWRnZSApO1xuXG4gICAgICB9XG4gICAgfVxuICAgICAgXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBoYXlzdGFja0VkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWRnZSA9IGhheXN0YWNrRWRnZXNbaV07XG4gICAgICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICAgICAgdmFyIHJzY3JhdGNoID0gX3AucnNjcmF0Y2g7XG4gICAgICB2YXIgcnMgPSByc2NyYXRjaDtcblxuICAgICAgaWYoICFyc2NyYXRjaC5oYXlzdGFjayApe1xuICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLnJhbmRvbSgpICogMiAqIE1hdGguUEk7XG5cbiAgICAgICAgcnNjcmF0Y2guc291cmNlID0ge1xuICAgICAgICAgIHg6IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgICB5OiBNYXRoLnNpbihhbmdsZSlcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLnJhbmRvbSgpICogMiAqIE1hdGguUEk7XG5cbiAgICAgICAgcnNjcmF0Y2gudGFyZ2V0ID0ge1xuICAgICAgICAgIHg6IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgICB5OiBNYXRoLnNpbihhbmdsZSlcbiAgICAgICAgfTtcblxuICAgICAgfVxuXG4gICAgICB2YXIgc3JjID0gX3Auc291cmNlO1xuICAgICAgdmFyIHRndCA9IF9wLnRhcmdldDtcbiAgICAgIHZhciBzcmNQb3MgPSBzcmMuX3ByaXZhdGUucG9zaXRpb247XG4gICAgICB2YXIgdGd0UG9zID0gdGd0Ll9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgdmFyIHNyY1cgPSBzcmMud2lkdGgoKTtcbiAgICAgIHZhciB0Z3RXID0gdGd0LndpZHRoKCk7XG4gICAgICB2YXIgc3JjSCA9IHNyYy5oZWlnaHQoKTtcbiAgICAgIHZhciB0Z3RIID0gdGd0LmhlaWdodCgpO1xuICAgICAgdmFyIHJhZGl1cyA9IHN0eWxlWydoYXlzdGFjay1yYWRpdXMnXS52YWx1ZTtcbiAgICAgIHZhciBoYWxmUmFkaXVzID0gcmFkaXVzLzI7IC8vIGIvYyBoYXZlIHRvIGhhbGYgd2lkdGgvaGVpZ2h0XG5cbiAgICAgIHJzLmhheXN0YWNrUHRzID0gW1xuICAgICAgICBycy5zb3VyY2UueCAqIHNyY1cgKiBoYWxmUmFkaXVzICsgc3JjUG9zLngsXG4gICAgICAgIHJzLnNvdXJjZS55ICogc3JjSCAqIGhhbGZSYWRpdXMgKyBzcmNQb3MueSxcbiAgICAgICAgcnMudGFyZ2V0LnggKiB0Z3RXICogaGFsZlJhZGl1cyArIHRndFBvcy54LFxuICAgICAgICBycy50YXJnZXQueSAqIHRndEggKiBoYWxmUmFkaXVzICsgdGd0UG9zLnlcbiAgICAgIF07XG5cbiAgICAgIC8vIGFsd2F5cyBvdmVycmlkZSBhcyBoYXlzdGFjayBpbiBjYXNlIHNldCB0byBkaWZmZXJlbnQgdHlwZSBwcmV2aW91c2x5XG4gICAgICByc2NyYXRjaC5lZGdlVHlwZSA9ICdoYXlzdGFjayc7XG4gICAgICByc2NyYXRjaC5oYXlzdGFjayA9IHRydWU7XG5cbiAgICAgIHRoaXMucmVjYWxjdWxhdGVFZGdlTGFiZWxQcm9qZWN0aW9uKCBlZGdlICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhc2hUYWJsZTtcbiAgfTtcblxuICBDUnAuZmluZEVuZHBvaW50cyA9IGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICB2YXIgaW50ZXJzZWN0O1xuXG4gICAgdmFyIHNvdXJjZSA9IGVkZ2Uuc291cmNlKClbMF07XG4gICAgdmFyIHRhcmdldCA9IGVkZ2UudGFyZ2V0KClbMF07XG4gICAgXG4gICAgdmFyIHRndEFyU2hhcGUgPSBlZGdlLl9wcml2YXRlLnN0eWxlWyd0YXJnZXQtYXJyb3ctc2hhcGUnXS52YWx1ZTtcbiAgICB2YXIgc3JjQXJTaGFwZSA9IGVkZ2UuX3ByaXZhdGUuc3R5bGVbJ3NvdXJjZS1hcnJvdy1zaGFwZSddLnZhbHVlO1xuXG4gICAgdmFyIHRndEJvcmRlclcgPSB0YXJnZXQuX3ByaXZhdGUuc3R5bGVbJ2JvcmRlci13aWR0aCddLnB4VmFsdWU7XG4gICAgdmFyIHNyY0JvcmRlclcgPSBzb3VyY2UuX3ByaXZhdGUuc3R5bGVbJ2JvcmRlci13aWR0aCddLnB4VmFsdWU7XG5cbiAgICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIFxuICAgIGlmIChycy5lZGdlVHlwZSA9PSAnc2VsZicgfHwgcnMuZWRnZVR5cGUgPT0gJ2NvbXBvdW5kJykge1xuICAgICAgXG4gICAgICB2YXIgY3AgPSBbcnMuY3AyY3gsIHJzLmNwMmN5XTtcbiAgICAgIFxuICAgICAgaW50ZXJzZWN0ID0gQ2FudmFzUmVuZGVyZXIubm9kZVNoYXBlc1t0aGlzLmdldE5vZGVTaGFwZSh0YXJnZXQpXS5pbnRlcnNlY3RMaW5lKFxuICAgICAgICB0YXJnZXQuX3ByaXZhdGUucG9zaXRpb24ueCxcbiAgICAgICAgdGFyZ2V0Ll9wcml2YXRlLnBvc2l0aW9uLnksXG4gICAgICAgIHRoaXMuZ2V0Tm9kZVdpZHRoKHRhcmdldCksXG4gICAgICAgIHRoaXMuZ2V0Tm9kZUhlaWdodCh0YXJnZXQpLFxuICAgICAgICBjcFswXSxcbiAgICAgICAgY3BbMV0sIFxuICAgICAgICB0Z3RCb3JkZXJXIC8gMlxuICAgICAgKTtcbiAgICAgIFxuICAgICAgdmFyIGFycm93RW5kID0gJCQubWF0aC5zaG9ydGVuSW50ZXJzZWN0aW9uKGludGVyc2VjdCwgY3AsXG4gICAgICAgIENhbnZhc1JlbmRlcmVyLmFycm93U2hhcGVzW3RndEFyU2hhcGVdLnNwYWNpbmcoZWRnZSkpO1xuICAgICAgdmFyIGVkZ2VFbmQgPSAkJC5tYXRoLnNob3J0ZW5JbnRlcnNlY3Rpb24oaW50ZXJzZWN0LCBjcCxcbiAgICAgICAgQ2FudmFzUmVuZGVyZXIuYXJyb3dTaGFwZXNbdGd0QXJTaGFwZV0uZ2FwKGVkZ2UpKTtcbiAgICAgIFxuICAgICAgcnMuZW5kWCA9IGVkZ2VFbmRbMF07XG4gICAgICBycy5lbmRZID0gZWRnZUVuZFsxXTtcbiAgICAgIFxuICAgICAgcnMuYXJyb3dFbmRYID0gYXJyb3dFbmRbMF07XG4gICAgICBycy5hcnJvd0VuZFkgPSBhcnJvd0VuZFsxXTtcbiAgICAgIFxuICAgICAgdmFyIGNwID0gW3JzLmNwMmF4LCBycy5jcDJheV07XG5cbiAgICAgIGludGVyc2VjdCA9IENhbnZhc1JlbmRlcmVyLm5vZGVTaGFwZXNbdGhpcy5nZXROb2RlU2hhcGUoc291cmNlKV0uaW50ZXJzZWN0TGluZShcbiAgICAgICAgc291cmNlLl9wcml2YXRlLnBvc2l0aW9uLngsXG4gICAgICAgIHNvdXJjZS5fcHJpdmF0ZS5wb3NpdGlvbi55LFxuICAgICAgICB0aGlzLmdldE5vZGVXaWR0aChzb3VyY2UpLFxuICAgICAgICB0aGlzLmdldE5vZGVIZWlnaHQoc291cmNlKSxcbiAgICAgICAgY3BbMF0sIC8vaGFsZlBvaW50WCxcbiAgICAgICAgY3BbMV0sIC8vaGFsZlBvaW50WVxuICAgICAgICBzcmNCb3JkZXJXIC8gMlxuICAgICAgKTtcbiAgICAgIFxuICAgICAgdmFyIGFycm93U3RhcnQgPSAkJC5tYXRoLnNob3J0ZW5JbnRlcnNlY3Rpb24oaW50ZXJzZWN0LCBjcCxcbiAgICAgICAgQ2FudmFzUmVuZGVyZXIuYXJyb3dTaGFwZXNbc3JjQXJTaGFwZV0uc3BhY2luZyhlZGdlKSk7XG4gICAgICB2YXIgZWRnZVN0YXJ0ID0gJCQubWF0aC5zaG9ydGVuSW50ZXJzZWN0aW9uKGludGVyc2VjdCwgY3AsXG4gICAgICAgIENhbnZhc1JlbmRlcmVyLmFycm93U2hhcGVzW3NyY0FyU2hhcGVdLmdhcChlZGdlKSk7XG4gICAgICBcbiAgICAgIHJzLnN0YXJ0WCA9IGVkZ2VTdGFydFswXTtcbiAgICAgIHJzLnN0YXJ0WSA9IGVkZ2VTdGFydFsxXTtcblxuXG4gICAgICBycy5hcnJvd1N0YXJ0WCA9IGFycm93U3RhcnRbMF07XG4gICAgICBycy5hcnJvd1N0YXJ0WSA9IGFycm93U3RhcnRbMV07XG4gICAgICBcbiAgICB9IGVsc2UgaWYgKHJzLmVkZ2VUeXBlID09ICdzdHJhaWdodCcpIHtcbiAgICBcbiAgICAgIGludGVyc2VjdCA9IENhbnZhc1JlbmRlcmVyLm5vZGVTaGFwZXNbdGhpcy5nZXROb2RlU2hhcGUodGFyZ2V0KV0uaW50ZXJzZWN0TGluZShcbiAgICAgICAgdGFyZ2V0Ll9wcml2YXRlLnBvc2l0aW9uLngsXG4gICAgICAgIHRhcmdldC5fcHJpdmF0ZS5wb3NpdGlvbi55LFxuICAgICAgICB0aGlzLmdldE5vZGVXaWR0aCh0YXJnZXQpLFxuICAgICAgICB0aGlzLmdldE5vZGVIZWlnaHQodGFyZ2V0KSxcbiAgICAgICAgc291cmNlLnBvc2l0aW9uKCkueCxcbiAgICAgICAgc291cmNlLnBvc2l0aW9uKCkueSxcbiAgICAgICAgdGd0Qm9yZGVyVyAvIDIpO1xuICAgICAgICBcbiAgICAgIGlmIChpbnRlcnNlY3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJzLm5vQXJyb3dQbGFjZW1lbnQgPSB0cnVlO1xuICAgICAgICAvLyByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBycy5ub0Fycm93UGxhY2VtZW50ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHZhciBhcnJvd0VuZCA9ICQkLm1hdGguc2hvcnRlbkludGVyc2VjdGlvbihpbnRlcnNlY3QsXG4gICAgICAgIFtzb3VyY2UucG9zaXRpb24oKS54LCBzb3VyY2UucG9zaXRpb24oKS55XSxcbiAgICAgICAgQ2FudmFzUmVuZGVyZXIuYXJyb3dTaGFwZXNbdGd0QXJTaGFwZV0uc3BhY2luZyhlZGdlKSk7XG4gICAgICB2YXIgZWRnZUVuZCA9ICQkLm1hdGguc2hvcnRlbkludGVyc2VjdGlvbihpbnRlcnNlY3QsXG4gICAgICAgIFtzb3VyY2UucG9zaXRpb24oKS54LCBzb3VyY2UucG9zaXRpb24oKS55XSxcbiAgICAgICAgQ2FudmFzUmVuZGVyZXIuYXJyb3dTaGFwZXNbdGd0QXJTaGFwZV0uZ2FwKGVkZ2UpKTtcblxuICAgICAgcnMuZW5kWCA9IGVkZ2VFbmRbMF07XG4gICAgICBycy5lbmRZID0gZWRnZUVuZFsxXTtcbiAgICAgIFxuICAgICAgcnMuYXJyb3dFbmRYID0gYXJyb3dFbmRbMF07XG4gICAgICBycy5hcnJvd0VuZFkgPSBhcnJvd0VuZFsxXTtcbiAgICBcbiAgICAgIGludGVyc2VjdCA9IENhbnZhc1JlbmRlcmVyLm5vZGVTaGFwZXNbdGhpcy5nZXROb2RlU2hhcGUoc291cmNlKV0uaW50ZXJzZWN0TGluZShcbiAgICAgICAgc291cmNlLl9wcml2YXRlLnBvc2l0aW9uLngsXG4gICAgICAgIHNvdXJjZS5fcHJpdmF0ZS5wb3NpdGlvbi55LFxuICAgICAgICB0aGlzLmdldE5vZGVXaWR0aChzb3VyY2UpLFxuICAgICAgICB0aGlzLmdldE5vZGVIZWlnaHQoc291cmNlKSxcbiAgICAgICAgdGFyZ2V0LnBvc2l0aW9uKCkueCxcbiAgICAgICAgdGFyZ2V0LnBvc2l0aW9uKCkueSxcbiAgICAgICAgc3JjQm9yZGVyVyAvIDIpO1xuICAgICAgXG4gICAgICBpZiAoaW50ZXJzZWN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBycy5ub0Fycm93UGxhY2VtZW50ID0gdHJ1ZTtcbiAgICAgICAvLyByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBycy5ub0Fycm93UGxhY2VtZW50ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qXG4gICAgICBjb25zb2xlLmxvZyhcIjE6IFwiXG4gICAgICAgICsgQ2FudmFzUmVuZGVyZXIuYXJyb3dTaGFwZXNbc3JjQXJTaGFwZV0sXG4gICAgICAgICAgc3JjQXJTaGFwZSk7XG4gICAgICAqL1xuICAgICAgdmFyIGFycm93U3RhcnQgPSAkJC5tYXRoLnNob3J0ZW5JbnRlcnNlY3Rpb24oaW50ZXJzZWN0LFxuICAgICAgICBbdGFyZ2V0LnBvc2l0aW9uKCkueCwgdGFyZ2V0LnBvc2l0aW9uKCkueV0sXG4gICAgICAgIENhbnZhc1JlbmRlcmVyLmFycm93U2hhcGVzW3NyY0FyU2hhcGVdLnNwYWNpbmcoZWRnZSkpO1xuICAgICAgdmFyIGVkZ2VTdGFydCA9ICQkLm1hdGguc2hvcnRlbkludGVyc2VjdGlvbihpbnRlcnNlY3QsXG4gICAgICAgIFt0YXJnZXQucG9zaXRpb24oKS54LCB0YXJnZXQucG9zaXRpb24oKS55XSxcbiAgICAgICAgQ2FudmFzUmVuZGVyZXIuYXJyb3dTaGFwZXNbc3JjQXJTaGFwZV0uZ2FwKGVkZ2UpKTtcblxuICAgICAgcnMuc3RhcnRYID0gZWRnZVN0YXJ0WzBdO1xuICAgICAgcnMuc3RhcnRZID0gZWRnZVN0YXJ0WzFdO1xuICAgICAgXG4gICAgICBycy5hcnJvd1N0YXJ0WCA9IGFycm93U3RhcnRbMF07XG4gICAgICBycy5hcnJvd1N0YXJ0WSA9IGFycm93U3RhcnRbMV07XG4gICAgICBcbiAgICAgIGlmKCAhJCQuaXMubnVtYmVyKHJzLnN0YXJ0WCkgfHwgISQkLmlzLm51bWJlcihycy5zdGFydFkpIHx8ICEkJC5pcy5udW1iZXIocnMuZW5kWCkgfHwgISQkLmlzLm51bWJlcihycy5lbmRZKSApe1xuICAgICAgICBycy5iYWRMaW5lID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJzLmJhZExpbmUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgICAgICAgIFxuICAgIH0gZWxzZSBpZiAocnMuZWRnZVR5cGUgPT0gJ2JlemllcicpIHtcbiAgICAgIC8vIGlmKCB3aW5kb3cuYmFkQXJyb3cpIGRlYnVnZ2VyO1xuICAgICAgdmFyIGNwID0gW3JzLmNwMngsIHJzLmNwMnldO1xuICAgICAgXG4gICAgICBpbnRlcnNlY3QgPSBDYW52YXNSZW5kZXJlci5ub2RlU2hhcGVzW1xuICAgICAgICB0aGlzLmdldE5vZGVTaGFwZSh0YXJnZXQpXS5pbnRlcnNlY3RMaW5lKFxuICAgICAgICB0YXJnZXQuX3ByaXZhdGUucG9zaXRpb24ueCxcbiAgICAgICAgdGFyZ2V0Ll9wcml2YXRlLnBvc2l0aW9uLnksXG4gICAgICAgIHRoaXMuZ2V0Tm9kZVdpZHRoKHRhcmdldCksXG4gICAgICAgIHRoaXMuZ2V0Tm9kZUhlaWdodCh0YXJnZXQpLFxuICAgICAgICBjcFswXSwgLy9oYWxmUG9pbnRYLFxuICAgICAgICBjcFsxXSwgLy9oYWxmUG9pbnRZXG4gICAgICAgIHRndEJvcmRlclcgLyAyXG4gICAgICApO1xuICAgICAgXG4gICAgICAvKlxuICAgICAgY29uc29sZS5sb2coXCIyOiBcIlxuICAgICAgICArIENhbnZhc1JlbmRlcmVyLmFycm93U2hhcGVzW3NyY0FyU2hhcGVdLFxuICAgICAgICAgIHNyY0FyU2hhcGUpO1xuICAgICAgKi9cbiAgICAgIHZhciBhcnJvd0VuZCA9ICQkLm1hdGguc2hvcnRlbkludGVyc2VjdGlvbihpbnRlcnNlY3QsIGNwLFxuICAgICAgICBDYW52YXNSZW5kZXJlci5hcnJvd1NoYXBlc1t0Z3RBclNoYXBlXS5zcGFjaW5nKGVkZ2UpKTtcbiAgICAgIHZhciBlZGdlRW5kID0gJCQubWF0aC5zaG9ydGVuSW50ZXJzZWN0aW9uKGludGVyc2VjdCwgY3AsXG4gICAgICAgIENhbnZhc1JlbmRlcmVyLmFycm93U2hhcGVzW3RndEFyU2hhcGVdLmdhcChlZGdlKSk7XG4gICAgICBcbiAgICAgIHJzLmVuZFggPSBlZGdlRW5kWzBdO1xuICAgICAgcnMuZW5kWSA9IGVkZ2VFbmRbMV07XG4gICAgICBcbiAgICAgIHJzLmFycm93RW5kWCA9IGFycm93RW5kWzBdO1xuICAgICAgcnMuYXJyb3dFbmRZID0gYXJyb3dFbmRbMV07XG4gICAgICBcbiAgICAgIGludGVyc2VjdCA9IENhbnZhc1JlbmRlcmVyLm5vZGVTaGFwZXNbXG4gICAgICAgIHRoaXMuZ2V0Tm9kZVNoYXBlKHNvdXJjZSldLmludGVyc2VjdExpbmUoXG4gICAgICAgIHNvdXJjZS5fcHJpdmF0ZS5wb3NpdGlvbi54LFxuICAgICAgICBzb3VyY2UuX3ByaXZhdGUucG9zaXRpb24ueSxcbiAgICAgICAgdGhpcy5nZXROb2RlV2lkdGgoc291cmNlKSxcbiAgICAgICAgdGhpcy5nZXROb2RlSGVpZ2h0KHNvdXJjZSksXG4gICAgICAgIGNwWzBdLCAvL2hhbGZQb2ludFgsXG4gICAgICAgIGNwWzFdLCAvL2hhbGZQb2ludFlcbiAgICAgICAgc3JjQm9yZGVyVyAvIDJcbiAgICAgICk7XG4gICAgICBcbiAgICAgIHZhciBhcnJvd1N0YXJ0ID0gJCQubWF0aC5zaG9ydGVuSW50ZXJzZWN0aW9uKFxuICAgICAgICBpbnRlcnNlY3QsIFxuICAgICAgICBjcCxcbiAgICAgICAgQ2FudmFzUmVuZGVyZXIuYXJyb3dTaGFwZXNbc3JjQXJTaGFwZV0uc3BhY2luZyhlZGdlKVxuICAgICAgKTtcbiAgICAgIHZhciBlZGdlU3RhcnQgPSAkJC5tYXRoLnNob3J0ZW5JbnRlcnNlY3Rpb24oXG4gICAgICAgIGludGVyc2VjdCwgXG4gICAgICAgIGNwLFxuICAgICAgICBDYW52YXNSZW5kZXJlci5hcnJvd1NoYXBlc1tzcmNBclNoYXBlXS5nYXAoZWRnZSlcbiAgICAgICk7XG4gICAgXG4gICAgICBycy5zdGFydFggPSBlZGdlU3RhcnRbMF07XG4gICAgICBycy5zdGFydFkgPSBlZGdlU3RhcnRbMV07XG4gICAgICBcbiAgICAgIHJzLmFycm93U3RhcnRYID0gYXJyb3dTdGFydFswXTtcbiAgICAgIHJzLmFycm93U3RhcnRZID0gYXJyb3dTdGFydFsxXTtcbiAgICAgIFxuICAgICAgLy8gaWYoIGlzTmFOKHJzLnN0YXJ0WCkgfHwgaXNOYU4ocnMuc3RhcnRZKSApe1xuICAgICAgLy8gICBkZWJ1Z2dlcjtcbiAgICAgIC8vIH1cblxuICAgIH0gZWxzZSBpZiAocnMuaXNBcmNFZGdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9O1xuXG4gIC8vIEZpbmQgYWRqYWNlbnQgZWRnZXNcbiAgQ1JwLmZpbmRFZGdlcyA9IGZ1bmN0aW9uKG5vZGVTZXQpIHtcbiAgICBcbiAgICB2YXIgZWRnZXMgPSB0aGlzLmdldENhY2hlZEVkZ2VzKCk7XG4gICAgXG4gICAgdmFyIGhhc2hUYWJsZSA9IHt9O1xuICAgIHZhciBhZGphY2VudEVkZ2VzID0gW107XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlU2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBoYXNoVGFibGVbbm9kZVNldFtpXS5fcHJpdmF0ZS5kYXRhLmlkXSA9IG5vZGVTZXRbaV07XG4gICAgfVxuICAgIFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChoYXNoVGFibGVbZWRnZXNbaV0uX3ByaXZhdGUuZGF0YS5zb3VyY2VdXG4gICAgICAgIHx8IGhhc2hUYWJsZVtlZGdlc1tpXS5fcHJpdmF0ZS5kYXRhLnRhcmdldF0pIHtcbiAgICAgICAgXG4gICAgICAgIGFkamFjZW50RWRnZXMucHVzaChlZGdlc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBhZGphY2VudEVkZ2VzO1xuICB9O1xuXG4gIENScC5nZXRBcnJvd1dpZHRoID0gQ1JwLmdldEFycm93SGVpZ2h0ID0gZnVuY3Rpb24oZWRnZVdpZHRoKSB7XG4gICAgdmFyIGNhY2hlID0gdGhpcy5hcnJvd1dpZHRoQ2FjaGUgPSB0aGlzLmFycm93V2lkdGhDYWNoZSB8fCB7fTtcblxuICAgIHZhciBjYWNoZWRWYWwgPSBjYWNoZVtlZGdlV2lkdGhdO1xuICAgIGlmKCBjYWNoZWRWYWwgKXtcbiAgICAgIHJldHVybiBjYWNoZWRWYWw7XG4gICAgfVxuXG4gICAgY2FjaGVkVmFsID0gIE1hdGgubWF4KE1hdGgucG93KGVkZ2VXaWR0aCAqIDEzLjM3LCAwLjkpLCAyOSk7XG4gICAgY2FjaGVbZWRnZVdpZHRoXSA9IGNhY2hlZFZhbDtcblxuICAgIHJldHVybiBjYWNoZWRWYWw7XG4gIH07XG5cblxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBDYW52YXNSZW5kZXJlciA9ICQkKCdyZW5kZXJlcicsICdjYW52YXMnKTtcbiAgdmFyIENScCA9IENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZTtcblxuLy8gRHJhdyBlZGdlXG4gIENScC5kcmF3RWRnZSA9IGZ1bmN0aW9uKGNvbnRleHQsIGVkZ2UsIGRyYXdPdmVybGF5SW5zdGVhZCkge1xuICAgIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdmFyIHVzZVBhdGhzID0gQ2FudmFzUmVuZGVyZXIudXNlUGF0aHMoKTtcblxuICAgIC8vIGlmIGJlemllciBjdHJsIHB0cyBjYW4gbm90IGJlIGNhbGN1bGF0ZWQsIHRoZW4gZGllXG4gICAgaWYoIHJzLmJhZEJlemllciB8fCAoIChycy5lZGdlVHlwZSA9PT0gJ2JlemllcicgfHwgcnMuZWRnZVR5cGUgPT09ICdzdHJhaWdodCcpICYmIGlzTmFOKHJzLnN0YXJ0WCkpICl7IC8vIGV4dHJhIGlzTmFOKCkgZm9yIHNhZmFyaSA3LjEgYi9jIGl0IG1hbmdsZXMgY3RybHB0IGNhbGNzXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlID0gZWRnZS5fcHJpdmF0ZS5zdHlsZTtcbiAgICBcbiAgICAvLyBFZGdlIGxpbmUgd2lkdGhcbiAgICBpZiAoc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZSA8PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG92ZXJsYXlQYWRkaW5nID0gc3R5bGVbJ292ZXJsYXktcGFkZGluZyddLnB4VmFsdWU7XG4gICAgdmFyIG92ZXJsYXlPcGFjaXR5ID0gc3R5bGVbJ292ZXJsYXktb3BhY2l0eSddLnZhbHVlO1xuICAgIHZhciBvdmVybGF5Q29sb3IgPSBzdHlsZVsnb3ZlcmxheS1jb2xvciddLnZhbHVlO1xuXG4gICAgLy8gRWRnZSBjb2xvciAmIG9wYWNpdHlcbiAgICBpZiggZHJhd092ZXJsYXlJbnN0ZWFkICl7XG5cbiAgICAgIGlmKCBvdmVybGF5T3BhY2l0eSA9PT0gMCApeyAvLyBleGl0IGVhcmx5IGlmIG5vIG92ZXJsYXlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0cm9rZVN0eWxlKGNvbnRleHQsIG92ZXJsYXlDb2xvclswXSwgb3ZlcmxheUNvbG9yWzFdLCBvdmVybGF5Q29sb3JbMl0sIG92ZXJsYXlPcGFjaXR5KTtcbiAgICAgIGNvbnRleHQubGluZUNhcCA9ICdyb3VuZCc7XG5cbiAgICAgIGlmKCBlZGdlLl9wcml2YXRlLnJzY3JhdGNoLmVkZ2VUeXBlID09ICdzZWxmJyAmJiAhdXNlUGF0aHMgKXtcbiAgICAgICAgY29udGV4dC5saW5lQ2FwID0gJ2J1dHQnO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsaW5lQ29sb3IgPSBzdHlsZVsnbGluZS1jb2xvciddLnZhbHVlO1xuXG4gICAgICB0aGlzLnN0cm9rZVN0eWxlKGNvbnRleHQsIGxpbmVDb2xvclswXSwgbGluZUNvbG9yWzFdLCBsaW5lQ29sb3JbMl0sIHN0eWxlLm9wYWNpdHkudmFsdWUpO1xuICAgICAgXG4gICAgICBjb250ZXh0LmxpbmVDYXAgPSAnYnV0dCc7IFxuICAgIH1cbiAgICBcbiAgICB2YXIgc3RhcnROb2RlLCBlbmROb2RlLCBzb3VyY2UsIHRhcmdldDtcbiAgICBzb3VyY2UgPSBzdGFydE5vZGUgPSBlZGdlLl9wcml2YXRlLnNvdXJjZTtcbiAgICB0YXJnZXQgPSBlbmROb2RlID0gZWRnZS5fcHJpdmF0ZS50YXJnZXQ7XG5cbiAgICAvLyB2YXIgdGFyZ2V0UG9zID0gdGFyZ2V0Ll9wcml2YXRlLnBvc2l0aW9uO1xuICAgIC8vIHZhciB0YXJnZXRXID0gdGFyZ2V0LndpZHRoKCk7XG4gICAgLy8gdmFyIHRhcmdldEggPSB0YXJnZXQuaGVpZ2h0KCk7XG4gICAgLy8gdmFyIHNvdXJjZVBvcyA9IHNvdXJjZS5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAvLyB2YXIgc291cmNlVyA9IHNvdXJjZS53aWR0aCgpO1xuICAgIC8vIHZhciBzb3VyY2VIID0gc291cmNlLmhlaWdodCgpO1xuXG5cbiAgICB2YXIgZWRnZVdpZHRoID0gc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZSArIChkcmF3T3ZlcmxheUluc3RlYWQgPyAyICogb3ZlcmxheVBhZGRpbmcgOiAwKTtcbiAgICB2YXIgbGluZVN0eWxlID0gZHJhd092ZXJsYXlJbnN0ZWFkID8gJ3NvbGlkJyA6IHN0eWxlWydsaW5lLXN0eWxlJ10udmFsdWU7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSBlZGdlV2lkdGg7XG4gICAgXG4gICAgdmFyIHNoYWRvd0JsdXIgPSBzdHlsZVsnc2hhZG93LWJsdXInXS5weFZhbHVlO1xuICAgIHZhciBzaGFkb3dPcGFjaXR5ID0gc3R5bGVbJ3NoYWRvdy1vcGFjaXR5J10udmFsdWU7XG4gICAgdmFyIHNoYWRvd0NvbG9yID0gc3R5bGVbJ3NoYWRvdy1jb2xvciddLnZhbHVlO1xuICAgIHZhciBzaGFkb3dPZmZzZXRYID0gc3R5bGVbJ3NoYWRvdy1vZmZzZXQteCddLnB4VmFsdWU7XG4gICAgdmFyIHNoYWRvd09mZnNldFkgPSBzdHlsZVsnc2hhZG93LW9mZnNldC15J10ucHhWYWx1ZTtcblxuICAgIHRoaXMuc2hhZG93U3R5bGUoY29udGV4dCwgIHNoYWRvd0NvbG9yLCBkcmF3T3ZlcmxheUluc3RlYWQgPyAwIDogc2hhZG93T3BhY2l0eSwgc2hhZG93Qmx1ciwgc2hhZG93T2Zmc2V0WCwgc2hhZG93T2Zmc2V0WSk7XG4gICAgXG4gICAgLy8gaWYoIHJzLmVkZ2VUeXBlICE9PSAnaGF5c3RhY2snICl7XG4gICAgLy8gICB0aGlzLmZpbmRFbmRwb2ludHMoZWRnZSk7XG4gICAgLy8gfVxuICAgIFxuICAgIGlmKCBycy5lZGdlVHlwZSA9PT0gJ2hheXN0YWNrJyApe1xuICAgICAgLy8gdmFyIHJhZGl1cyA9IHN0eWxlWydoYXlzdGFjay1yYWRpdXMnXS52YWx1ZTtcbiAgICAgIC8vIHZhciBoYWxmUmFkaXVzID0gcmFkaXVzLzI7IC8vIGIvYyBoYXZlIHRvIGhhbGYgd2lkdGgvaGVpZ2h0XG5cbiAgICAgIHRoaXMuZHJhd1N0eWxlZEVkZ2UoXG4gICAgICAgIGVkZ2UsIFxuICAgICAgICBjb250ZXh0LCBcbiAgICAgICAgcnMuaGF5c3RhY2tQdHMsXG4gICAgICAgIGxpbmVTdHlsZSxcbiAgICAgICAgZWRnZVdpZHRoXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAocnMuZWRnZVR5cGUgPT09ICdzZWxmJyB8fCBycy5lZGdlVHlwZSA9PT0gJ2NvbXBvdW5kJykge1xuICAgICAgXG4gICAgICB2YXIgZGV0YWlscyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgICB2YXIgcG9pbnRzID0gW2RldGFpbHMuc3RhcnRYLCBkZXRhaWxzLnN0YXJ0WSwgZGV0YWlscy5jcDJheCxcbiAgICAgICAgZGV0YWlscy5jcDJheSwgZGV0YWlscy5zZWxmRWRnZU1pZFgsIGRldGFpbHMuc2VsZkVkZ2VNaWRZLFxuICAgICAgICBkZXRhaWxzLnNlbGZFZGdlTWlkWCwgZGV0YWlscy5zZWxmRWRnZU1pZFksXG4gICAgICAgIGRldGFpbHMuY3AyY3gsIGRldGFpbHMuY3AyY3ksIGRldGFpbHMuZW5kWCwgZGV0YWlscy5lbmRZXTtcblxuICAgICAgdGhpcy5kcmF3U3R5bGVkRWRnZShlZGdlLCBjb250ZXh0LCBwb2ludHMsIGxpbmVTdHlsZSwgZWRnZVdpZHRoKTtcbiAgICAgIFxuICAgIH0gZWxzZSBpZiAocnMuZWRnZVR5cGUgPT09ICdzdHJhaWdodCcpIHtcbiAgICAgIFxuICAgICAgdmFyIG5vZGVEaXJlY3Rpb25YID0gZW5kTm9kZS5fcHJpdmF0ZS5wb3NpdGlvbi54IC0gc3RhcnROb2RlLl9wcml2YXRlLnBvc2l0aW9uLng7XG4gICAgICB2YXIgbm9kZURpcmVjdGlvblkgPSBlbmROb2RlLl9wcml2YXRlLnBvc2l0aW9uLnkgLSBzdGFydE5vZGUuX3ByaXZhdGUucG9zaXRpb24ueTtcbiAgICAgIFxuICAgICAgdmFyIGVkZ2VEaXJlY3Rpb25YID0gcnMuZW5kWCAtIHJzLnN0YXJ0WDtcbiAgICAgIHZhciBlZGdlRGlyZWN0aW9uWSA9IHJzLmVuZFkgLSBycy5zdGFydFk7XG4gICAgICBcbiAgICAgIGlmIChub2RlRGlyZWN0aW9uWCAqIGVkZ2VEaXJlY3Rpb25YXG4gICAgICAgICsgbm9kZURpcmVjdGlvblkgKiBlZGdlRGlyZWN0aW9uWSA8IDApIHtcbiAgICAgICAgXG4gICAgICAgIHJzLnN0cmFpZ2h0RWRnZVRvb1Nob3J0ID0gdHJ1ZTsgIFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgXG4gICAgICAgIHZhciBkZXRhaWxzID0gcnM7XG4gICAgICAgIHRoaXMuZHJhd1N0eWxlZEVkZ2UoZWRnZSwgY29udGV4dCwgW2RldGFpbHMuc3RhcnRYLCBkZXRhaWxzLnN0YXJ0WSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlscy5lbmRYLCBkZXRhaWxzLmVuZFldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lU3R5bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VXaWR0aCk7XG4gICAgICAgIFxuICAgICAgICBycy5zdHJhaWdodEVkZ2VUb29TaG9ydCA9IGZhbHNlOyAgXG4gICAgICB9ICBcbiAgICB9IGVsc2Uge1xuICAgICAgXG4gICAgICB2YXIgZGV0YWlscyA9IHJzO1xuICAgICAgXG4gICAgICB0aGlzLmRyYXdTdHlsZWRFZGdlKGVkZ2UsIGNvbnRleHQsIFtkZXRhaWxzLnN0YXJ0WCwgZGV0YWlscy5zdGFydFksXG4gICAgICAgIGRldGFpbHMuY3AyeCwgZGV0YWlscy5jcDJ5LCBkZXRhaWxzLmVuZFgsIGRldGFpbHMuZW5kWV0sXG4gICAgICAgIGxpbmVTdHlsZSxcbiAgICAgICAgZWRnZVdpZHRoKTtcbiAgICAgIFxuICAgIH1cbiAgICBcbiAgICBpZiggcnMuZWRnZVR5cGUgPT09ICdoYXlzdGFjaycgKXtcbiAgICAgIHRoaXMuZHJhd0Fycm93aGVhZHMoY29udGV4dCwgZWRnZSwgZHJhd092ZXJsYXlJbnN0ZWFkKTtcbiAgICB9IGVsc2UgaWYgKCBycy5ub0Fycm93UGxhY2VtZW50ICE9PSB0cnVlICYmIHJzLnN0YXJ0WCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICB0aGlzLmRyYXdBcnJvd2hlYWRzKGNvbnRleHQsIGVkZ2UsIGRyYXdPdmVybGF5SW5zdGVhZCk7XG4gICAgfVxuXG4gICAgdGhpcy5zaGFkb3dTdHlsZShjb250ZXh0LCAndHJhbnNwYXJlbnQnLCAwKTsgLy8gcmVzZXQgZm9yIG5leHQgZ3V5XG5cbiAgfTtcbiAgXG4gIFxuICBDUnAuZHJhd1N0eWxlZEVkZ2UgPSBmdW5jdGlvbihcbiAgICAgIGVkZ2UsIGNvbnRleHQsIHB0cywgdHlwZSwgd2lkdGgpIHtcblxuICAgIC8vIDMgcG9pbnRzIGdpdmVuIC0+IGFzc3VtZSBCZXppZXJcbiAgICAvLyAyIC0+IGFzc3VtZSBzdHJhaWdodFxuICAgIFxuICAgIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdmFyIGNhbnZhc0N4dCA9IGNvbnRleHQ7XG4gICAgdmFyIHBhdGg7XG4gICAgdmFyIHBhdGhDYWNoZUhpdCA9IGZhbHNlO1xuICAgIHZhciB1c2VQYXRocyA9IENhbnZhc1JlbmRlcmVyLnVzZVBhdGhzKCk7XG5cblxuICAgIGlmKCB1c2VQYXRocyApe1xuXG4gICAgICB2YXIgcGF0aENhY2hlS2V5ID0gcHRzO1xuICAgICAgdmFyIGtleUxlbmd0aE1hdGNoZXMgPSBycy5wYXRoQ2FjaGVLZXkgJiYgcGF0aENhY2hlS2V5Lmxlbmd0aCA9PT0gcnMucGF0aENhY2hlS2V5Lmxlbmd0aDtcbiAgICAgIHZhciBrZXlNYXRjaGVzID0ga2V5TGVuZ3RoTWF0Y2hlcztcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGtleU1hdGNoZXMgJiYgaSA8IHBhdGhDYWNoZUtleS5sZW5ndGg7IGkrKyApe1xuICAgICAgICBpZiggcnMucGF0aENhY2hlS2V5W2ldICE9PSBwYXRoQ2FjaGVLZXlbaV0gKXtcbiAgICAgICAgICBrZXlNYXRjaGVzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoIGtleU1hdGNoZXMgKXtcbiAgICAgICAgcGF0aCA9IGNvbnRleHQgPSBycy5wYXRoQ2FjaGU7XG4gICAgICAgIHBhdGhDYWNoZUhpdCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRoID0gY29udGV4dCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgICAgcnMucGF0aENhY2hlS2V5ID0gcGF0aENhY2hlS2V5O1xuICAgICAgICBycy5wYXRoQ2FjaGUgPSBwYXRoO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYoIGNhbnZhc0N4dC5zZXRMaW5lRGFzaCApeyAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICAgIHN3aXRjaCggdHlwZSApe1xuICAgICAgICBjYXNlICdkb3R0ZWQnOlxuICAgICAgICAgIGNhbnZhc0N4dC5zZXRMaW5lRGFzaChbIDEsIDEgXSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGFzaGVkJzpcbiAgICAgICAgICBjYW52YXNDeHQuc2V0TGluZURhc2goWyA2LCAzIF0pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3NvbGlkJzpcbiAgICAgICAgICBjYW52YXNDeHQuc2V0TGluZURhc2goWyBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiggIXBhdGhDYWNoZUhpdCApe1xuICAgICAgaWYoIGNvbnRleHQuYmVnaW5QYXRoICl7IGNvbnRleHQuYmVnaW5QYXRoKCk7IH1cbiAgICAgIGNvbnRleHQubW92ZVRvKHB0c1swXSwgcHRzWzFdKTtcbiAgICAgIFxuICAgICAgaWYoIHB0cy5sZW5ndGggPT09IDYgJiYgIXJzLmJhZEJlemllciApeyAvLyBiZXppZXJcbiAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHB0c1syXSwgcHRzWzNdLCBwdHNbNF0sIHB0c1s1XSk7XG4gICAgICB9IGVsc2UgaWYoIHB0cy5sZW5ndGggPT09IDEyICYmICFycy5iYWRCZXppZXIgKXsgLy8gZG91YmxlIGJlemllciBsb29wXG4gICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhwdHNbMl0sIHB0c1szXSwgcHRzWzRdLCBwdHNbNV0pO1xuICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8ocHRzWzhdLCBwdHNbOV0sIHB0c1sxMF0sIHB0c1sxMV0pO1xuICAgICAgfSBlbHNlIGlmKCBwdHMubGVuZ3RoID09PSA0ICYmICFycy5iYWRMaW5lICl7IC8vIGxpbmVcbiAgICAgICAgY29udGV4dC5saW5lVG8ocHRzWzJdLCBwdHNbM10pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnRleHQgPSBjYW52YXNDeHQ7XG4gICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICBjb250ZXh0LnN0cm9rZSggcGF0aCApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIH1cbiAgXG4gICAgLy8gcmVzZXQgYW55IGxpbmUgZGFzaGVzXG4gICAgaWYoIGNvbnRleHQuc2V0TGluZURhc2ggKXsgLy8gZm9yIHZlcnkgb3V0b2ZkYXRlIGJyb3dzZXJzXG4gICAgICBjb250ZXh0LnNldExpbmVEYXNoKFsgXSk7XG4gICAgfVxuXG4gIH07XG5cbiAgQ1JwLmRyYXdBcnJvd2hlYWRzID0gZnVuY3Rpb24oY29udGV4dCwgZWRnZSwgZHJhd092ZXJsYXlJbnN0ZWFkKSB7XG4gICAgaWYoIGRyYXdPdmVybGF5SW5zdGVhZCApeyByZXR1cm47IH0gLy8gZG9uJ3QgZG8gYW55dGhpbmcgZm9yIG92ZXJsYXlzIFxuXG4gICAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGlzSGF5c3RhY2sgPSBycy5lZGdlVHlwZSA9PT0gJ2hheXN0YWNrJztcblxuICAgIC8vIERpc3BsYWNlbWVudCBnaXZlcyBkaXJlY3Rpb24gZm9yIGFycm93aGVhZCBvcmllbnRhdGlvblxuICAgIHZhciBkaXNwWCwgZGlzcFk7XG4gICAgdmFyIHN0YXJ0WCwgc3RhcnRZLCBlbmRYLCBlbmRZO1xuXG4gICAgdmFyIHNyY1BvcyA9IGVkZ2Uuc291cmNlKCkucG9zaXRpb24oKTtcbiAgICB2YXIgdGd0UG9zID0gZWRnZS50YXJnZXQoKS5wb3NpdGlvbigpO1xuXG4gICAgaWYoIGlzSGF5c3RhY2sgKXtcbiAgICAgIHN0YXJ0WCA9IHJzLmhheXN0YWNrUHRzWzBdO1xuICAgICAgc3RhcnRZID0gcnMuaGF5c3RhY2tQdHNbMV07XG4gICAgICBlbmRYID0gcnMuaGF5c3RhY2tQdHNbMl07XG4gICAgICBlbmRZID0gcnMuaGF5c3RhY2tQdHNbM107XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0WCA9IHJzLmFycm93U3RhcnRYO1xuICAgICAgc3RhcnRZID0gcnMuYXJyb3dTdGFydFk7XG4gICAgICBlbmRYID0gcnMuYXJyb3dFbmRYO1xuICAgICAgZW5kWSA9IHJzLmFycm93RW5kWTtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGUgPSBlZGdlLl9wcml2YXRlLnN0eWxlO1xuICAgIFxuICAgIGZ1bmN0aW9uIGRyYXdBcnJvd2hlYWQoIHByZWZpeCwgeCwgeSwgZGlzcFgsIGRpc3BZICl7XG4gICAgICB2YXIgYXJyb3dTaGFwZSA9IHN0eWxlW3ByZWZpeCArICctYXJyb3ctc2hhcGUnXS52YWx1ZTtcblxuICAgICAgaWYoIGFycm93U2hhcGUgPT09ICdub25lJyApe1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBnY28gPSBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjtcblxuICAgICAgdmFyIGFycm93Q2xlYXJGaWxsID0gc3R5bGVbcHJlZml4ICsgJy1hcnJvdy1maWxsJ10udmFsdWUgPT09ICdob2xsb3cnID8gJ2JvdGgnIDogJ2ZpbGxlZCc7XG4gICAgICB2YXIgYXJyb3dGaWxsID0gc3R5bGVbcHJlZml4ICsgJy1hcnJvdy1maWxsJ10udmFsdWU7XG5cbiAgICAgIGlmKCBhcnJvd1NoYXBlID09PSAnaGFsZi10cmlhbmdsZS1vdmVyc2hvdCcgKXtcbiAgICAgICAgYXJyb3dGaWxsID0gJ2hvbGxvdyc7XG4gICAgICAgIGFycm93Q2xlYXJGaWxsID0gJ2hvbGxvdyc7XG4gICAgICB9XG5cbiAgICAgIGlmKCBzdHlsZS5vcGFjaXR5LnZhbHVlICE9PSAxIHx8IGFycm93RmlsbCA9PT0gJ2hvbGxvdycgKXsgLy8gdGhlbiBleHRyYSBjbGVhciBpcyBuZWVkZWRcbiAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3V0JztcbiAgICAgICAgXG4gICAgICAgIHNlbGYuZmlsbFN0eWxlKGNvbnRleHQsIDI1NSwgMjU1LCAyNTUsIDEpO1xuICAgICAgICBzZWxmLnN0cm9rZVN0eWxlKGNvbnRleHQsIDI1NSwgMjU1LCAyNTUsIDEpO1xuICAgICAgICBcbiAgICAgICAgc2VsZi5kcmF3QXJyb3dTaGFwZSggZWRnZSwgcHJlZml4LCBjb250ZXh0LCBcbiAgICAgICAgICBhcnJvd0NsZWFyRmlsbCwgc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZSwgc3R5bGVbcHJlZml4ICsgJy1hcnJvdy1zaGFwZSddLnZhbHVlLCBcbiAgICAgICAgICB4LCB5LCBkaXNwWCwgZGlzcFlcbiAgICAgICAgKTtcblxuICAgICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGdjbztcbiAgICAgIH0gLy8gb3RoZXJ3aXNlLCB0aGUgb3BhcXVlIGFycm93IGNsZWFycyBpdCBmb3IgZnJlZSA6KVxuXG4gICAgICB2YXIgY29sb3IgPSBzdHlsZVtwcmVmaXggKyAnLWFycm93LWNvbG9yJ10udmFsdWU7XG4gICAgICBzZWxmLmZpbGxTdHlsZShjb250ZXh0LCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBzdHlsZS5vcGFjaXR5LnZhbHVlKTtcbiAgICAgIHNlbGYuc3Ryb2tlU3R5bGUoY29udGV4dCwgY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSwgc3R5bGUub3BhY2l0eS52YWx1ZSk7XG5cbiAgICAgIHNlbGYuZHJhd0Fycm93U2hhcGUoIGVkZ2UsIHByZWZpeCwgY29udGV4dCwgXG4gICAgICAgIGFycm93RmlsbCwgc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZSwgc3R5bGVbcHJlZml4ICsgJy1hcnJvdy1zaGFwZSddLnZhbHVlLCBcbiAgICAgICAgeCwgeSwgZGlzcFgsIGRpc3BZXG4gICAgICApO1xuICAgIH1cblxuICAgIGRpc3BYID0gc3RhcnRYIC0gc3JjUG9zLng7XG4gICAgZGlzcFkgPSBzdGFydFkgLSBzcmNQb3MueTtcblxuICAgIGlmKCAhaXNIYXlzdGFjayAmJiAhaXNOYU4oc3RhcnRYKSAmJiAhaXNOYU4oc3RhcnRZKSAmJiAhaXNOYU4oZGlzcFgpICYmICFpc05hTihkaXNwWSkgKXtcbiAgICAgIGRyYXdBcnJvd2hlYWQoICdzb3VyY2UnLCBzdGFydFgsIHN0YXJ0WSwgZGlzcFgsIGRpc3BZICk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gd2luZG93LmJhZEFycm93ID0gdHJ1ZTtcbiAgICAgIC8vIGRlYnVnZ2VyO1xuICAgIH1cbiAgICBcbiAgICB2YXIgbWlkWCA9IHJzLm1pZFg7XG4gICAgdmFyIG1pZFkgPSBycy5taWRZO1xuXG4gICAgaWYoIGlzSGF5c3RhY2sgKXtcbiAgICAgIG1pZFggPSAoIHN0YXJ0WCArIGVuZFggKS8yO1xuICAgICAgbWlkWSA9ICggc3RhcnRZICsgZW5kWSApLzI7XG4gICAgfVxuXG4gICAgZGlzcFggPSBzdGFydFggLSBlbmRYO1xuICAgIGRpc3BZID0gc3RhcnRZIC0gZW5kWTtcblxuICAgIGlmKCBycy5lZGdlVHlwZSA9PT0gJ3NlbGYnICl7XG4gICAgICBkaXNwWCA9IDE7XG4gICAgICBkaXNwWSA9IC0xO1xuICAgIH1cblxuICAgIGlmKCAhaXNOYU4obWlkWCkgJiYgIWlzTmFOKG1pZFkpICl7XG4gICAgICBkcmF3QXJyb3doZWFkKCAnbWlkLXRhcmdldCcsIG1pZFgsIG1pZFksIGRpc3BYLCBkaXNwWSApO1xuICAgIH1cblxuICAgIGRpc3BYICo9IC0xO1xuICAgIGRpc3BZICo9IC0xO1xuXG4gICAgaWYoICFpc05hTihtaWRYKSAmJiAhaXNOYU4obWlkWSkgKXtcbiAgICAgIGRyYXdBcnJvd2hlYWQoICdtaWQtc291cmNlJywgbWlkWCwgbWlkWSwgZGlzcFgsIGRpc3BZICk7XG4gICAgfVxuICAgIFxuICAgIGRpc3BYID0gZW5kWCAtIHRndFBvcy54O1xuICAgIGRpc3BZID0gZW5kWSAtIHRndFBvcy55O1xuICAgIFxuICAgIGlmKCAhaXNIYXlzdGFjayAmJiAhaXNOYU4oZW5kWCkgJiYgIWlzTmFOKGVuZFkpICYmICFpc05hTihkaXNwWCkgJiYgIWlzTmFOKGRpc3BZKSApe1xuICAgICAgZHJhd0Fycm93aGVhZCggJ3RhcmdldCcsIGVuZFgsIGVuZFksIGRpc3BYLCBkaXNwWSApO1xuICAgIH1cbiAgfTtcbiAgXG4gIC8vIERyYXcgYXJyb3dzaGFwZVxuICBDUnAuZHJhd0Fycm93U2hhcGUgPSBmdW5jdGlvbihlZGdlLCBhcnJvd1R5cGUsIGNvbnRleHQsIGZpbGwsIGVkZ2VXaWR0aCwgc2hhcGUsIHgsIHksIGRpc3BYLCBkaXNwWSkge1xuICAgIHZhciB1c2VQYXRocyA9IENhbnZhc1JlbmRlcmVyLnVzZVBhdGhzKCk7XG4gICAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICB2YXIgcGF0aENhY2hlSGl0ID0gZmFsc2U7XG4gICAgdmFyIHBhdGg7XG4gICAgdmFyIGNhbnZhc0NvbnRleHQgPSBjb250ZXh0O1xuICAgIHZhciB0cmFuc2xhdGlvbiA9IHsgeDogeCwgeTogeSB9O1xuXG4gICAgLy8gTmVnYXRpdmUgb2YgdGhlIGFuZ2xlXG4gICAgdmFyIGFuZ2xlID0gTWF0aC5hc2luKGRpc3BZIC8gKE1hdGguc3FydChkaXNwWCAqIGRpc3BYICsgZGlzcFkgKiBkaXNwWSkpKTtcbiAgXG4gICAgaWYgKGRpc3BYIDwgMCkge1xuICAgICAgYW5nbGUgPSBhbmdsZSArIE1hdGguUEkgLyAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbmdsZSA9IC0gKE1hdGguUEkgLyAyICsgYW5nbGUpO1xuICAgIH1cbiAgICBcbiAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0QXJyb3dXaWR0aCggZWRnZVdpZHRoICk7XG4gICAgdmFyIHNoYXBlSW1wbCA9IENhbnZhc1JlbmRlcmVyLmFycm93U2hhcGVzW3NoYXBlXTtcblxuICAgIC8vIGNvbnRleHQudHJhbnNsYXRlKHgsIHkpO1xuXG4gICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICB2YXIgcGF0aENhY2hlS2V5ID0gc2l6ZSArICckJyArIHNoYXBlICsgJyQnICsgYW5nbGUgKyAnJCcgKyB4ICsgJyQnICsgeTtcbiAgICAgIHJzLmFycm93UGF0aENhY2hlS2V5ID0gcnMuYXJyb3dQYXRoQ2FjaGVLZXkgfHwge307XG4gICAgICBycy5hcnJvd1BhdGhDYWNoZSA9IHJzLmFycm93UGF0aENhY2hlIHx8IHt9O1xuXG4gICAgICB2YXIgYWxyZWFkeUNhY2hlZCA9IHJzLmFycm93UGF0aENhY2hlS2V5W2Fycm93VHlwZV0gPT09IHBhdGhDYWNoZUtleTtcbiAgICAgIGlmKCBhbHJlYWR5Q2FjaGVkICl7XG4gICAgICAgIHBhdGggPSBjb250ZXh0ID0gcnMuYXJyb3dQYXRoQ2FjaGVbYXJyb3dUeXBlXTtcbiAgICAgICAgcGF0aENhY2hlSGl0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdGggPSBjb250ZXh0ID0gbmV3IFBhdGgyRCgpO1xuICAgICAgICBycy5hcnJvd1BhdGhDYWNoZUtleVthcnJvd1R5cGVdID0gcGF0aENhY2hlS2V5O1xuICAgICAgICBycy5hcnJvd1BhdGhDYWNoZVthcnJvd1R5cGVdID0gcGF0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiggY29udGV4dC5iZWdpblBhdGggKXsgY29udGV4dC5iZWdpblBhdGgoKTsgfVxuXG4gICAgaWYoICFwYXRoQ2FjaGVIaXQgKXtcbiAgICAgIHNoYXBlSW1wbC5kcmF3KGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbik7XG4gICAgfVxuICAgIFxuICAgIGlmKCAhc2hhcGVJbXBsLmxlYXZlUGF0aE9wZW4gJiYgY29udGV4dC5jbG9zZVBhdGggKXtcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgfVxuXG4gICAgY29udGV4dCA9IGNhbnZhc0NvbnRleHQ7XG5cbiAgICBpZiggZmlsbCA9PT0gJ2ZpbGxlZCcgfHwgZmlsbCA9PT0gJ2JvdGgnICl7XG4gICAgICBpZiggdXNlUGF0aHMgKXtcbiAgICAgICAgY29udGV4dC5maWxsKCBwYXRoICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiggZmlsbCA9PT0gJ2hvbGxvdycgfHwgZmlsbCA9PT0gJ2JvdGgnICl7XG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9ICggc2hhcGVJbXBsLm1hdGNoRWRnZVdpZHRoID8gZWRnZVdpZHRoIDogMSApO1xuICAgICAgY29udGV4dC5saW5lSm9pbiA9ICdtaXRlcic7XG5cbiAgICAgIGlmKCB1c2VQYXRocyApe1xuICAgICAgICBjb250ZXh0LnN0cm9rZSggcGF0aCApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICAgIFxuICAgIH1cblxuICAgIC8vIGNvbnRleHQudHJhbnNsYXRlKC14LCAteSk7XG4gIH07XG5cbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgQ2FudmFzUmVuZGVyZXIgPSAkJCgncmVuZGVyZXInLCAnY2FudmFzJyk7XG4gIHZhciBDUnAgPSBDYW52YXNSZW5kZXJlci5wcm90b3R5cGU7XG5cbiAgQ1JwLmdldENhY2hlZEltYWdlID0gZnVuY3Rpb24odXJsLCBvbkxvYWQpIHtcbiAgICB2YXIgciA9IHRoaXM7XG4gICAgdmFyIGltYWdlQ2FjaGUgPSByLmltYWdlQ2FjaGUgPSByLmltYWdlQ2FjaGUgfHwge307XG5cbiAgICBpZiggaW1hZ2VDYWNoZVt1cmxdICYmIGltYWdlQ2FjaGVbdXJsXS5pbWFnZSApe1xuICAgICAgcmV0dXJuIGltYWdlQ2FjaGVbdXJsXS5pbWFnZTtcbiAgICB9XG4gICAgXG4gICAgdmFyIGNhY2hlID0gaW1hZ2VDYWNoZVt1cmxdID0gaW1hZ2VDYWNoZVt1cmxdIHx8IHt9O1xuXG4gICAgdmFyIGltYWdlID0gY2FjaGUuaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkKTtcbiAgICBpbWFnZS5zcmMgPSB1cmw7XG4gICAgXG4gICAgcmV0dXJuIGltYWdlO1xuICB9O1xuICBcbiAgQ1JwLnNhZmVEcmF3SW1hZ2UgPSBmdW5jdGlvbiggY29udGV4dCwgaW1nLCBpeCwgaXksIGl3LCBpaCwgeCwgeSwgdywgaCApe1xuICAgIHZhciByID0gdGhpcztcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29udGV4dC5kcmF3SW1hZ2UoIGltZywgaXgsIGl5LCBpdywgaWgsIHgsIHksIHcsIGggKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NhbnZhc1JlbmRlcmVyLk5PREVdID0gdHJ1ZTtcbiAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDYW52YXNSZW5kZXJlci5EUkFHXSA9IHRydWU7XG4gICAgICBcbiAgICAgIHIuZHJhd2luZ0ltYWdlID0gdHJ1ZTtcbiAgICAgIFxuICAgICAgci5yZWRyYXcoKTtcbiAgICB9XG4gIH07XG4gIFxuICBDUnAuZHJhd0luc2NyaWJlZEltYWdlID0gZnVuY3Rpb24oY29udGV4dCwgaW1nLCBub2RlKSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIHZhciBub2RlWCA9IG5vZGUuX3ByaXZhdGUucG9zaXRpb24ueDtcbiAgICB2YXIgbm9kZVkgPSBub2RlLl9wcml2YXRlLnBvc2l0aW9uLnk7XG4gICAgdmFyIHN0eWxlID0gbm9kZS5fcHJpdmF0ZS5zdHlsZTtcbiAgICB2YXIgZml0ID0gc3R5bGVbJ2JhY2tncm91bmQtZml0J10udmFsdWU7XG4gICAgdmFyIHhQb3MgPSBzdHlsZVsnYmFja2dyb3VuZC1wb3NpdGlvbi14J107XG4gICAgdmFyIHlQb3MgPSBzdHlsZVsnYmFja2dyb3VuZC1wb3NpdGlvbi15J107XG4gICAgdmFyIHJlcGVhdCA9IHN0eWxlWydiYWNrZ3JvdW5kLXJlcGVhdCddLnZhbHVlO1xuICAgIHZhciBub2RlVyA9IG5vZGUud2lkdGgoKTtcbiAgICB2YXIgbm9kZUggPSBub2RlLmhlaWdodCgpO1xuICAgIHZhciBycyA9IG5vZGUuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdmFyIGNsaXAgPSBzdHlsZVsnYmFja2dyb3VuZC1jbGlwJ10udmFsdWU7XG4gICAgdmFyIHNob3VsZENsaXAgPSBjbGlwID09PSAnbm9kZSc7XG4gICAgdmFyIGltZ09wYWNpdHkgPSBzdHlsZVsnYmFja2dyb3VuZC1pbWFnZS1vcGFjaXR5J10udmFsdWU7XG4gICAgXG4gICAgdmFyIHcgPSBpbWcud2lkdGg7XG4gICAgdmFyIGggPSBpbWcuaGVpZ2h0O1xuICAgIFxuICAgIGlmKCB3ID09PSAwIHx8IGggPT09IDAgKXtcbiAgICAgIHJldHVybjsgLy8gbm8gcG9pbnQgaW4gZHJhd2luZyBlbXB0eSBpbWFnZSAoYW5kIGNocm9tZSBpcyBicm9rZW4gaW4gdGhpcyBjYXNlKVxuICAgIH1cblxuICAgIHZhciBiZ1cgPSBzdHlsZVsnYmFja2dyb3VuZC13aWR0aCddO1xuICAgIGlmKCBiZ1cudmFsdWUgIT09ICdhdXRvJyApe1xuICAgICAgaWYoIGJnVy51bml0cyA9PT0gJyUnICl7XG4gICAgICAgIHcgPSBiZ1cudmFsdWUvMTAwICogbm9kZVc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3ID0gYmdXLnB4VmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGJnSCA9IHN0eWxlWydiYWNrZ3JvdW5kLWhlaWdodCddO1xuICAgIGlmKCBiZ0gudmFsdWUgIT09ICdhdXRvJyApe1xuICAgICAgaWYoIGJnSC51bml0cyA9PT0gJyUnICl7XG4gICAgICAgIGggPSBiZ0gudmFsdWUvMTAwICogbm9kZUg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoID0gYmdILnB4VmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoIHcgPT09IDAgfHwgaCA9PT0gMCApe1xuICAgICAgcmV0dXJuOyAvLyBubyBwb2ludCBpbiBkcmF3aW5nIGVtcHR5IGltYWdlIChhbmQgY2hyb21lIGlzIGJyb2tlbiBpbiB0aGlzIGNhc2UpXG4gICAgfVxuXG4gICAgaWYoIGZpdCA9PT0gJ2NvbnRhaW4nICl7XG4gICAgICB2YXIgc2NhbGUgPSBNYXRoLm1pbiggbm9kZVcvdywgbm9kZUgvaCApO1xuXG4gICAgICB3ICo9IHNjYWxlO1xuICAgICAgaCAqPSBzY2FsZTtcblxuICAgIH0gZWxzZSBpZiggZml0ID09PSAnY292ZXInICl7XG4gICAgICB2YXIgc2NhbGUgPSBNYXRoLm1heCggbm9kZVcvdywgbm9kZUgvaCApO1xuXG4gICAgICB3ICo9IHNjYWxlO1xuICAgICAgaCAqPSBzY2FsZTtcbiAgICB9XG5cbiAgICB2YXIgeCA9IChub2RlWCAtIG5vZGVXLzIpOyAvLyBsZWZ0XG4gICAgaWYoIHhQb3MudW5pdHMgPT09ICclJyApe1xuICAgICAgeCArPSAobm9kZVcgLSB3KSAqIHhQb3MudmFsdWUvMTAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ICs9IHhQb3MucHhWYWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgeSA9IChub2RlWSAtIG5vZGVILzIpOyAvLyB0b3BcbiAgICBpZiggeVBvcy51bml0cyA9PT0gJyUnICl7XG4gICAgICB5ICs9IChub2RlSCAtIGgpICogeVBvcy52YWx1ZS8xMDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHkgKz0geVBvcy5weFZhbHVlO1xuICAgIH1cblxuICAgIGlmKCBycy5wYXRoQ2FjaGUgKXtcbiAgICAgIHggLT0gbm9kZVg7XG4gICAgICB5IC09IG5vZGVZO1xuXG4gICAgICBub2RlWCA9IDA7XG4gICAgICBub2RlWSA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGdBbHBoYSA9IGNvbnRleHQuZ2xvYmFsQWxwaGE7XG5cbiAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gaW1nT3BhY2l0eTtcblxuICAgIGlmKCByZXBlYXQgPT09ICduby1yZXBlYXQnICl7XG5cbiAgICAgIGlmKCBzaG91bGRDbGlwICl7XG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuXG4gICAgICAgIGlmKCBycy5wYXRoQ2FjaGUgKXtcbiAgICAgICAgICBjb250ZXh0LmNsaXAoIHJzLnBhdGhDYWNoZSApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIENhbnZhc1JlbmRlcmVyLm5vZGVTaGFwZXNbci5nZXROb2RlU2hhcGUobm9kZSldLmRyYXdQYXRoKFxuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIG5vZGVYLCBub2RlWSwgXG4gICAgICAgICAgICBub2RlVywgbm9kZUgpO1xuXG4gICAgICAgICAgY29udGV4dC5jbGlwKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gY29udGV4dC5kcmF3SW1hZ2UoIGltZywgMCwgMCwgaW1nLndpZHRoLCBpbWcuaGVpZ2h0LCB4LCB5LCB3LCBoICk7XG4gICAgICByLnNhZmVEcmF3SW1hZ2UoIGNvbnRleHQsIGltZywgMCwgMCwgaW1nLndpZHRoLCBpbWcuaGVpZ2h0LCB4LCB5LCB3LCBoICk7XG5cbiAgICAgIGlmKCBzaG91bGRDbGlwICl7XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGF0dGVybiA9IGNvbnRleHQuY3JlYXRlUGF0dGVybiggaW1nLCByZXBlYXQgKTtcbiAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gcGF0dGVybjtcblxuICAgICAgQ2FudmFzUmVuZGVyZXIubm9kZVNoYXBlc1tyLmdldE5vZGVTaGFwZShub2RlKV0uZHJhd1BhdGgoXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICBub2RlWCwgbm9kZVksIFxuICAgICAgICAgIG5vZGVXLCBub2RlSCk7XG5cbiAgICAgICAgY29udGV4dC50cmFuc2xhdGUoeCwgeSk7XG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSgteCwgLXkpO1xuICAgIH1cblxuICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBnQWxwaGE7XG4gICAgXG4gIH07XG5cbiAgXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIENhbnZhc1JlbmRlcmVyID0gJCQoJ3JlbmRlcmVyJywgJ2NhbnZhcycpO1xuICB2YXIgQ1JwID0gQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlO1xuXG4gIC8vIERyYXcgZWRnZSB0ZXh0XG4gIENScC5kcmF3RWRnZVRleHQgPSBmdW5jdGlvbihjb250ZXh0LCBlZGdlKSB7XG4gICAgdmFyIHRleHQgPSBlZGdlLl9wcml2YXRlLnN0eWxlWydjb250ZW50J10uc3RyVmFsdWU7XG5cbiAgICBpZiggIXRleHQgfHwgdGV4dC5tYXRjaCgvXlxccyskLykgKXtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiggdGhpcy5oaWRlRWRnZXNPblZpZXdwb3J0ICYmICh0aGlzLmRyYWdEYXRhLmRpZERyYWcgfHwgdGhpcy5waW5jaGluZyB8fCB0aGlzLmhvdmVyRGF0YS5kcmFnZ2luZyB8fCB0aGlzLmRhdGEud2hlZWwgfHwgdGhpcy5zd2lwZVBhbm5pbmcpICl7IHJldHVybjsgfSAvLyBzYXZlIGN5Y2xlcyBvbiBwaW5jaGluZ1xuXG4gICAgdmFyIGNvbXB1dGVkU2l6ZSA9IGVkZ2UuX3ByaXZhdGUuc3R5bGVbJ2ZvbnQtc2l6ZSddLnB4VmFsdWUgKiBlZGdlLmN5KCkuem9vbSgpO1xuICAgIHZhciBtaW5TaXplID0gZWRnZS5fcHJpdmF0ZS5zdHlsZVsnbWluLXpvb21lZC1mb250LXNpemUnXS5weFZhbHVlO1xuXG4gICAgaWYoIGNvbXB1dGVkU2l6ZSA8IG1pblNpemUgKXtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgdGV4dCBkcmF3IHBvc2l0aW9uXG5cbiAgICBjb250ZXh0LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgXG4gICAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICBpZiggISQkLmlzLm51bWJlciggcnMubGFiZWxYICkgfHwgISQkLmlzLm51bWJlciggcnMubGFiZWxZICkgKXsgcmV0dXJuOyB9IC8vIG5vIHBvcyA9PiBsYWJlbCBjYW4ndCBiZSByZW5kZXJlZFxuXG4gICAgdmFyIHN0eWxlID0gZWRnZS5fcHJpdmF0ZS5zdHlsZTtcbiAgICB2YXIgYXV0b3JvdGF0ZSA9IHN0eWxlWydlZGdlLXRleHQtcm90YXRpb24nXS5zdHJWYWx1ZSA9PT0gJ2F1dG9yb3RhdGUnO1xuICAgIHZhciB0aGV0YSwgZHgsIGR5O1xuXG4gICAgaWYoIGF1dG9yb3RhdGUgKXtcbiAgICAgIHN3aXRjaCggcnMuZWRnZVR5cGUgKXtcbiAgICAgICAgY2FzZSAnaGF5c3RhY2snOlxuICAgICAgICAgIGR4ID0gcnMuaGF5c3RhY2tQdHNbMl0gLSBycy5oYXlzdGFja1B0c1swXTtcbiAgICAgICAgICBkeSA9IHJzLmhheXN0YWNrUHRzWzNdIC0gcnMuaGF5c3RhY2tQdHNbMV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgZHggPSBycy5lbmRYIC0gcnMuc3RhcnRYO1xuICAgICAgICAgIGR5ID0gcnMuZW5kWSAtIHJzLnN0YXJ0WTtcbiAgICAgIH1cblxuICAgICAgdGhldGEgPSBNYXRoLmF0YW4oIGR5IC8gZHggKTtcblxuICAgICAgY29udGV4dC50cmFuc2xhdGUocnMubGFiZWxYLCBycy5sYWJlbFkpO1xuICAgICAgY29udGV4dC5yb3RhdGUodGhldGEpO1xuXG4gICAgICB0aGlzLmRyYXdUZXh0KGNvbnRleHQsIGVkZ2UsIDAsIDApO1xuXG4gICAgICBjb250ZXh0LnJvdGF0ZSgtdGhldGEpO1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoLXJzLmxhYmVsWCwgLXJzLmxhYmVsWSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZHJhd1RleHQoY29udGV4dCwgZWRnZSwgcnMubGFiZWxYLCBycy5sYWJlbFkpO1xuICAgIH1cblxuICB9O1xuXG4gIC8vIERyYXcgbm9kZSB0ZXh0XG4gIENScC5kcmF3Tm9kZVRleHQgPSBmdW5jdGlvbihjb250ZXh0LCBub2RlKSB7XG4gICAgdmFyIHRleHQgPSBub2RlLl9wcml2YXRlLnN0eWxlWydjb250ZW50J10uc3RyVmFsdWU7XG5cbiAgICBpZiAoICF0ZXh0IHx8IHRleHQubWF0Y2goL15cXHMrJC8pICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjb21wdXRlZFNpemUgPSBub2RlLl9wcml2YXRlLnN0eWxlWydmb250LXNpemUnXS5weFZhbHVlICogbm9kZS5jeSgpLnpvb20oKTtcbiAgICB2YXIgbWluU2l6ZSA9IG5vZGUuX3ByaXZhdGUuc3R5bGVbJ21pbi16b29tZWQtZm9udC1zaXplJ10ucHhWYWx1ZTtcblxuICAgIGlmKCBjb21wdXRlZFNpemUgPCBtaW5TaXplICl7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gdGhpcy5yZWNhbGN1bGF0ZU5vZGVMYWJlbFByb2plY3Rpb24oIG5vZGUgKTtcblxuICAgIHZhciB0ZXh0SGFsaWduID0gbm9kZS5fcHJpdmF0ZS5zdHlsZVsndGV4dC1oYWxpZ24nXS5zdHJWYWx1ZTtcbiAgICB2YXIgdGV4dFZhbGlnbiA9IG5vZGUuX3ByaXZhdGUuc3R5bGVbJ3RleHQtdmFsaWduJ10uc3RyVmFsdWU7XG4gICAgdmFyIHJzID0gbm9kZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICBpZiggISQkLmlzLm51bWJlciggcnMubGFiZWxYICkgfHwgISQkLmlzLm51bWJlciggcnMubGFiZWxZICkgKXsgcmV0dXJuOyB9IC8vIG5vIHBvcyA9PiBsYWJlbCBjYW4ndCBiZSByZW5kZXJlZFxuXG4gICAgc3dpdGNoKCB0ZXh0SGFsaWduICl7XG4gICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgY29udGV4dC50ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICBjb250ZXh0LnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6IC8vIGUuZy4gY2VudGVyXG4gICAgICAgIGNvbnRleHQudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgfVxuXG4gICAgc3dpdGNoKCB0ZXh0VmFsaWduICl7XG4gICAgICBjYXNlICd0b3AnOlxuICAgICAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9ICdib3R0b20nO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAndG9wJztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6IC8vIGUuZy4gY2VudGVyXG4gICAgICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgfVxuXG4gICAgdGhpcy5kcmF3VGV4dChjb250ZXh0LCBub2RlLCBycy5sYWJlbFgsIHJzLmxhYmVsWSk7XG4gIH07XG5cbiAgQ1JwLmdldEZvbnRDYWNoZSA9IGZ1bmN0aW9uKGNvbnRleHQpe1xuICAgIHZhciBjYWNoZTtcblxuICAgIHRoaXMuZm9udENhY2hlcyA9IHRoaXMuZm9udENhY2hlcyB8fCBbXTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5mb250Q2FjaGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICBjYWNoZSA9IHRoaXMuZm9udENhY2hlc1tpXTtcblxuICAgICAgaWYoIGNhY2hlLmNvbnRleHQgPT09IGNvbnRleHQgKXtcbiAgICAgICAgcmV0dXJuIGNhY2hlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNhY2hlID0ge1xuICAgICAgY29udGV4dDogY29udGV4dFxuICAgIH07XG4gICAgdGhpcy5mb250Q2FjaGVzLnB1c2goY2FjaGUpO1xuXG4gICAgcmV0dXJuIGNhY2hlO1xuICB9O1xuXG4gIC8vIHNldCB1cCBjYW52YXMgY29udGV4dCB3aXRoIGZvbnRcbiAgLy8gcmV0dXJucyB0cmFuc2Zvcm1lZCB0ZXh0IHN0cmluZ1xuICBDUnAuc2V0dXBUZXh0U3R5bGUgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlbWVudCApe1xuICAgIC8vIEZvbnQgc3R5bGVcbiAgICB2YXIgcGFyZW50T3BhY2l0eSA9IGVsZW1lbnQuZWZmZWN0aXZlT3BhY2l0eSgpO1xuICAgIHZhciBzdHlsZSA9IGVsZW1lbnQuX3ByaXZhdGUuc3R5bGU7XG4gICAgdmFyIGxhYmVsU3R5bGUgPSBzdHlsZVsnZm9udC1zdHlsZSddLnN0clZhbHVlO1xuICAgIHZhciBsYWJlbFNpemUgPSBzdHlsZVsnZm9udC1zaXplJ10ucHhWYWx1ZSArICdweCc7XG4gICAgdmFyIGxhYmVsRmFtaWx5ID0gc3R5bGVbJ2ZvbnQtZmFtaWx5J10uc3RyVmFsdWU7XG4gICAgdmFyIGxhYmVsV2VpZ2h0ID0gc3R5bGVbJ2ZvbnQtd2VpZ2h0J10uc3RyVmFsdWU7XG4gICAgdmFyIG9wYWNpdHkgPSBzdHlsZVsndGV4dC1vcGFjaXR5J10udmFsdWUgKiBzdHlsZVsnb3BhY2l0eSddLnZhbHVlICogcGFyZW50T3BhY2l0eTtcbiAgICB2YXIgb3V0bGluZU9wYWNpdHkgPSBzdHlsZVsndGV4dC1vdXRsaW5lLW9wYWNpdHknXS52YWx1ZSAqIG9wYWNpdHk7XG4gICAgdmFyIGNvbG9yID0gc3R5bGVbJ2NvbG9yJ10udmFsdWU7XG4gICAgdmFyIG91dGxpbmVDb2xvciA9IHN0eWxlWyd0ZXh0LW91dGxpbmUtY29sb3InXS52YWx1ZTtcbiAgICB2YXIgc2hhZG93Qmx1ciA9IHN0eWxlWyd0ZXh0LXNoYWRvdy1ibHVyJ10ucHhWYWx1ZTtcbiAgICB2YXIgc2hhZG93T3BhY2l0eSA9IHN0eWxlWyd0ZXh0LXNoYWRvdy1vcGFjaXR5J10udmFsdWU7XG4gICAgdmFyIHNoYWRvd0NvbG9yID0gc3R5bGVbJ3RleHQtc2hhZG93LWNvbG9yJ10udmFsdWU7XG4gICAgdmFyIHNoYWRvd09mZnNldFggPSBzdHlsZVsndGV4dC1zaGFkb3ctb2Zmc2V0LXgnXS5weFZhbHVlO1xuICAgIHZhciBzaGFkb3dPZmZzZXRZID0gc3R5bGVbJ3RleHQtc2hhZG93LW9mZnNldC15J10ucHhWYWx1ZTtcblxuICAgIHZhciBmb250Q2FjaGVLZXkgPSBlbGVtZW50Ll9wcml2YXRlLmZvbnRLZXk7XG4gICAgdmFyIGNhY2hlID0gdGhpcy5nZXRGb250Q2FjaGUoY29udGV4dCk7XG5cbiAgICBpZiggY2FjaGUua2V5ICE9PSBmb250Q2FjaGVLZXkgKXtcbiAgICAgIGNvbnRleHQuZm9udCA9IGxhYmVsU3R5bGUgKyAnICcgKyBsYWJlbFdlaWdodCArICcgJyArIGxhYmVsU2l6ZSArICcgJyArIGxhYmVsRmFtaWx5O1xuXG4gICAgICBjYWNoZS5rZXkgPSBmb250Q2FjaGVLZXk7XG4gICAgfVxuXG4gICAgdmFyIHRleHQgPSB0aGlzLmdldExhYmVsVGV4dCggZWxlbWVudCApO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRleHQgZHJhdyBwb3NpdGlvbiBiYXNlZCBvbiB0ZXh0IGFsaWdubWVudFxuXG4gICAgLy8gc28gdGV4dCBvdXRsaW5lcyBhcmVuJ3QgamFnZ2VkXG4gICAgY29udGV4dC5saW5lSm9pbiA9ICdyb3VuZCc7XG5cbiAgICB0aGlzLmZpbGxTdHlsZShjb250ZXh0LCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBvcGFjaXR5KTtcblxuICAgIHRoaXMuc3Ryb2tlU3R5bGUoY29udGV4dCwgb3V0bGluZUNvbG9yWzBdLCBvdXRsaW5lQ29sb3JbMV0sIG91dGxpbmVDb2xvclsyXSwgb3V0bGluZU9wYWNpdHkpO1xuXG4gICAgdGhpcy5zaGFkb3dTdHlsZShjb250ZXh0LCBzaGFkb3dDb2xvciwgc2hhZG93T3BhY2l0eSwgc2hhZG93Qmx1ciwgc2hhZG93T2Zmc2V0WCwgc2hhZG93T2Zmc2V0WSk7XG5cbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcblxuICBmdW5jdGlvbiByb3VuZFJlY3QoY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpIHtcbiAgICB2YXIgcmFkaXVzID0gcmFkaXVzIHx8IDU7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oeCArIHJhZGl1cywgeSk7XG4gICAgY3R4LmxpbmVUbyh4ICsgd2lkdGggLSByYWRpdXMsIHkpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgcmFkaXVzKTtcbiAgICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHJhZGl1cyk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSByYWRpdXMsIHkgKyBoZWlnaHQpO1xuICAgIGN0eC5saW5lVG8oeCArIHJhZGl1cywgeSArIGhlaWdodCk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIHJhZGl1cyk7XG4gICAgY3R4LmxpbmVUbyh4LCB5ICsgcmFkaXVzKTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgcmFkaXVzLCB5KTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgY3R4LmZpbGwoKTtcbiAgfVxuXG4gIC8vIERyYXcgdGV4dFxuICBDUnAuZHJhd1RleHQgPSBmdW5jdGlvbihjb250ZXh0LCBlbGVtZW50LCB0ZXh0WCwgdGV4dFkpIHtcbiAgICB2YXIgX3AgPSBlbGVtZW50Ll9wcml2YXRlO1xuICAgIHZhciBzdHlsZSA9IF9wLnN0eWxlO1xuICAgIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG4gICAgdmFyIHJzY3JhdGNoID0gX3AucnNjcmF0Y2g7XG4gICAgdmFyIHBhcmVudE9wYWNpdHkgPSBlbGVtZW50LmVmZmVjdGl2ZU9wYWNpdHkoKTtcbiAgICBpZiggcGFyZW50T3BhY2l0eSA9PT0gMCB8fCBzdHlsZVsndGV4dC1vcGFjaXR5J10udmFsdWUgPT09IDApeyByZXR1cm47IH1cblxuICAgIHZhciB0ZXh0ID0gdGhpcy5zZXR1cFRleHRTdHlsZSggY29udGV4dCwgZWxlbWVudCApO1xuICAgIHZhciBoYWxpZ24gPSBzdHlsZVsndGV4dC1oYWxpZ24nXS52YWx1ZTtcbiAgICB2YXIgdmFsaWduID0gc3R5bGVbJ3RleHQtdmFsaWduJ10udmFsdWU7XG5cbiAgICBpZiggZWxlbWVudC5pc0VkZ2UoKSApe1xuICAgICAgaGFsaWduID0gJ2NlbnRlcic7XG4gICAgICB2YWxpZ24gPSAnY2VudGVyJztcbiAgICB9XG5cbiAgICBpZiAoIHRleHQgIT0gbnVsbCAmJiAhaXNOYU4odGV4dFgpICYmICFpc05hTih0ZXh0WSkpIHtcbiAgICAgIHZhciBiYWNrZ3JvdW5kT3BhY2l0eSA9IHN0eWxlWyd0ZXh0LWJhY2tncm91bmQtb3BhY2l0eSddLnZhbHVlO1xuICAgICAgdmFyIGJvcmRlck9wYWNpdHkgPSBzdHlsZVsndGV4dC1ib3JkZXItb3BhY2l0eSddLnZhbHVlO1xuICAgICAgdmFyIHRleHRCb3JkZXJXaWR0aCA9IHN0eWxlWyd0ZXh0LWJvcmRlci13aWR0aCddLnB4VmFsdWU7XG4gICAgICBcbiAgICAgIGlmKCBiYWNrZ3JvdW5kT3BhY2l0eSA+IDAgfHwgKHRleHRCb3JkZXJXaWR0aCA+IDAgJiYgYm9yZGVyT3BhY2l0eSA+IDApICl7XG4gICAgICAgIHZhciBtYXJnaW4gPSA0ICsgdGV4dEJvcmRlcldpZHRoLzI7XG5cbiAgICAgICAgaWYgKGVsZW1lbnQuaXNOb2RlKCkpIHtcbiAgICAgICAgICAvL01vdmUgdGV4dFgsIHRleHRZIHRvIGluY2x1ZGUgdGhlIGJhY2tncm91bmQgbWFyZ2luc1xuICAgICAgICAgIGlmICh2YWxpZ24gPT09ICd0b3AnKSB7XG4gICAgICAgICAgICB0ZXh0WSAtPSBtYXJnaW47XG4gICAgICAgICAgfSBlbHNlIGlmICh2YWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgICB0ZXh0WSArPSBtYXJnaW47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgdGV4dFggLT0gbWFyZ2luO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaGFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICB0ZXh0WCArPSBtYXJnaW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJnV2lkdGggPSByc3R5bGUubGFiZWxXaWR0aDtcbiAgICAgICAgdmFyIGJnSGVpZ2h0ID0gcnN0eWxlLmxhYmVsSGVpZ2h0O1xuICAgICAgICB2YXIgYmdYID0gdGV4dFg7XG5cbiAgICAgICAgaWYgKGhhbGlnbikge1xuICAgICAgICAgIGlmIChoYWxpZ24gPT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIGJnWCA9IGJnWCAtIGJnV2lkdGggLyAyO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaGFsaWduID09ICdsZWZ0Jykge1xuICAgICAgICAgICAgYmdYID0gYmdYLSBiZ1dpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBiZ1kgPSB0ZXh0WTtcblxuICAgICAgICBpZiAoZWxlbWVudC5pc05vZGUoKSkge1xuICAgICAgICAgIGlmICh2YWxpZ24gPT0gJ3RvcCcpIHtcbiAgICAgICAgICAgICBiZ1kgPSBiZ1kgLSBiZ0hlaWdodDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbGlnbiA9PSAnY2VudGVyJykge1xuICAgICAgICAgICAgYmdZID0gYmdZLSBiZ0hlaWdodCAvIDI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJnWSA9IGJnWSAtIGJnSGVpZ2h0IC8gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHlsZVsnZWRnZS10ZXh0LXJvdGF0aW9uJ10uc3RyVmFsdWUgPT09ICdhdXRvcm90YXRlJykge1xuICAgICAgICAgIHRleHRZID0gMDtcbiAgICAgICAgICBiZ1dpZHRoICs9IDQ7XG4gICAgICAgICAgYmdYID0gdGV4dFggLSBiZ1dpZHRoIC8gMjtcbiAgICAgICAgICBiZ1kgPSB0ZXh0WSAtIGJnSGVpZ2h0IC8gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBBZGp1c3Qgd2l0aCBib3JkZXIgd2lkdGggJiBtYXJnaW5cbiAgICAgICAgICBiZ1ggLT0gbWFyZ2luO1xuICAgICAgICAgIGJnWSAtPSBtYXJnaW47XG4gICAgICAgICAgYmdIZWlnaHQgKz0gbWFyZ2luKjI7XG4gICAgICAgICAgYmdXaWR0aCArPSBtYXJnaW4qMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBiYWNrZ3JvdW5kT3BhY2l0eSA+IDAgKXtcbiAgICAgICAgICB2YXIgdGV4dEZpbGwgPSBjb250ZXh0LmZpbGxTdHlsZTtcbiAgICAgICAgICB2YXIgdGV4dEJhY2tncm91bmRDb2xvciA9IHN0eWxlWyd0ZXh0LWJhY2tncm91bmQtY29sb3InXS52YWx1ZTtcblxuICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoJyArIHRleHRCYWNrZ3JvdW5kQ29sb3JbMF0gKyAnLCcgKyB0ZXh0QmFja2dyb3VuZENvbG9yWzFdICsgJywnICsgdGV4dEJhY2tncm91bmRDb2xvclsyXSArICcsJyArIGJhY2tncm91bmRPcGFjaXR5ICogcGFyZW50T3BhY2l0eSArICcpJztcbiAgICAgICAgICB2YXIgc3R5bGVTaGFwZSA9IHN0eWxlWyd0ZXh0LWJhY2tncm91bmQtc2hhcGUnXS5zdHJWYWx1ZTtcbiAgICAgICAgICBpZiAoc3R5bGVTaGFwZSA9PSAncm91bmRyZWN0YW5nbGUnKSB7XG4gICAgICAgICAgICByb3VuZFJlY3QoY29udGV4dCwgYmdYLCBiZ1ksIGJnV2lkdGgsIGJnSGVpZ2h0LCAyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dC5maWxsUmVjdChiZ1gsYmdZLGJnV2lkdGgsYmdIZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHRleHRGaWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIHRleHRCb3JkZXJXaWR0aCA+IDAgJiYgYm9yZGVyT3BhY2l0eSA+IDAgKXtcbiAgICAgICAgICB2YXIgdGV4dFN0cm9rZSA9IGNvbnRleHQuc3Ryb2tlU3R5bGU7XG4gICAgICAgICAgdmFyIHRleHRMaW5lV2lkdGggPSBjb250ZXh0LmxpbmVXaWR0aDtcbiAgICAgICAgICB2YXIgdGV4dEJvcmRlckNvbG9yID0gc3R5bGVbJ3RleHQtYm9yZGVyLWNvbG9yJ10udmFsdWU7XG4gICAgICAgICAgdmFyIHRleHRCb3JkZXJTdHlsZSA9IHN0eWxlWyd0ZXh0LWJvcmRlci1zdHlsZSddLnZhbHVlO1xuXG4gICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICdyZ2JhKCcgKyB0ZXh0Qm9yZGVyQ29sb3JbMF0gKyAnLCcgKyB0ZXh0Qm9yZGVyQ29sb3JbMV0gKyAnLCcgKyB0ZXh0Qm9yZGVyQ29sb3JbMl0gKyAnLCcgKyBib3JkZXJPcGFjaXR5ICogcGFyZW50T3BhY2l0eSArICcpJztcbiAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHRleHRCb3JkZXJXaWR0aDtcblxuICAgICAgICAgIGlmKCBjb250ZXh0LnNldExpbmVEYXNoICl7IC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgICAgICAgICAgc3dpdGNoKCB0ZXh0Qm9yZGVyU3R5bGUgKXtcbiAgICAgICAgICAgICAgY2FzZSAnZG90dGVkJzpcbiAgICAgICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFsgMSwgMSBdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnZGFzaGVkJzpcbiAgICAgICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFsgNCwgMiBdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnZG91YmxlJzpcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHRleHRCb3JkZXJXaWR0aC80OyAvLyA1MCUgcmVzZXJ2ZWQgZm9yIHdoaXRlIGJldHdlZW4gdGhlIHR3byBib3JkZXJzXG4gICAgICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbIF0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdzb2xpZCc6XG4gICAgICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbIF0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdChiZ1gsYmdZLGJnV2lkdGgsYmdIZWlnaHQpO1xuXG4gICAgICAgICAgaWYoIHRleHRCb3JkZXJTdHlsZSA9PT0gJ2RvdWJsZScgKXtcbiAgICAgICAgICAgIHZhciB3aGl0ZVdpZHRoID0gdGV4dEJvcmRlcldpZHRoLzI7XG5cbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdChiZ1grd2hpdGVXaWR0aCxiZ1krd2hpdGVXaWR0aCxiZ1dpZHRoLXdoaXRlV2lkdGgqMixiZ0hlaWdodC13aGl0ZVdpZHRoKjIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCBjb250ZXh0LnNldExpbmVEYXNoICl7IC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbIF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHRleHRMaW5lV2lkdGg7XG4gICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHRleHRTdHJva2U7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICB2YXIgbGluZVdpZHRoID0gMiAgKiBzdHlsZVsndGV4dC1vdXRsaW5lLXdpZHRoJ10ucHhWYWx1ZTsgLy8gKjIgYi9jIHRoZSBzdHJva2UgaXMgZHJhd24gY2VudHJlZCBvbiB0aGUgbWlkZGxlXG5cbiAgICAgIGlmKCBsaW5lV2lkdGggPiAwICl7XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgfVxuXG4gICAgICBpZiggc3R5bGVbJ3RleHQtd3JhcCddLnZhbHVlID09PSAnd3JhcCcgKXsgLy9jb25zb2xlLmxvZygnZHJhdyB3cmFwJyk7XG4gICAgICAgIHZhciBsaW5lcyA9IHJzY3JhdGNoLmxhYmVsV3JhcENhY2hlZExpbmVzO1xuICAgICAgICB2YXIgbGluZUhlaWdodCA9IHJzdHlsZS5sYWJlbEhlaWdodCAvIGxpbmVzLmxlbmd0aDtcblxuICAgICAgICAvL2NvbnNvbGUubG9nKCdsaW5lcycsIGxpbmVzKTtcblxuICAgICAgICBzd2l0Y2goIHZhbGlnbiApe1xuICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICB0ZXh0WSAtPSAobGluZXMubGVuZ3RoIC0gMSkgKiBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgLy8gbm90aGluZyByZXF1aXJlZFxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICB0ZXh0WSAtPSAobGluZXMubGVuZ3RoIC0gMSkgKiBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciggdmFyIGwgPSAwOyBsIDwgbGluZXMubGVuZ3RoOyBsKysgKXtcbiAgICAgICAgICBpZiggbGluZVdpZHRoID4gMCApe1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2VUZXh0KCBsaW5lc1tsXSwgdGV4dFgsIHRleHRZICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5maWxsVGV4dCggbGluZXNbbF0sIHRleHRYLCB0ZXh0WSApO1xuXG4gICAgICAgICAgdGV4dFkgKz0gbGluZUhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhciBmb250U2l6ZSA9IHN0eWxlWydmb250LXNpemUnXS5weFZhbHVlO1xuICAgICAgICAvLyB3cmFwVGV4dChjb250ZXh0LCB0ZXh0LCB0ZXh0WCwgdGV4dFksIHN0eWxlWyd0ZXh0LW1heC13aWR0aCddLnB4VmFsdWUsIGZvbnRTaXplICsgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiggbGluZVdpZHRoID4gMCApe1xuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlVGV4dCggdGV4dCwgdGV4dFgsIHRleHRZICk7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0LmZpbGxUZXh0KCB0ZXh0LCB0ZXh0WCwgdGV4dFkgKTtcbiAgICAgIH1cblxuXG4gICAgICB0aGlzLnNoYWRvd1N0eWxlKGNvbnRleHQsICd0cmFuc3BhcmVudCcsIDApOyAvLyByZXNldCBmb3IgbmV4dCBndXlcbiAgICB9XG4gIH07XG5cblxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBDYW52YXNSZW5kZXJlciA9ICQkKCdyZW5kZXJlcicsICdjYW52YXMnKTtcbiAgdmFyIENScCA9IENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZTtcblxuICAvLyBEcmF3IG5vZGVcbiAgQ1JwLmRyYXdOb2RlID0gZnVuY3Rpb24oY29udGV4dCwgbm9kZSwgZHJhd092ZXJsYXlJbnN0ZWFkKSB7XG5cbiAgICB2YXIgciA9IHRoaXM7XG4gICAgdmFyIG5vZGVXaWR0aCwgbm9kZUhlaWdodDtcbiAgICB2YXIgc3R5bGUgPSBub2RlLl9wcml2YXRlLnN0eWxlO1xuICAgIHZhciBycyA9IG5vZGUuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdmFyIF9wID0gbm9kZS5fcHJpdmF0ZTtcbiAgICBcbiAgICB2YXIgdXNlUGF0aHMgPSBDYW52YXNSZW5kZXJlci51c2VQYXRocygpO1xuICAgIHZhciBjYW52YXNDb250ZXh0ID0gY29udGV4dDtcbiAgICB2YXIgcGF0aDtcbiAgICB2YXIgcGF0aENhY2hlSGl0ID0gZmFsc2U7XG5cbiAgICB2YXIgb3ZlcmxheVBhZGRpbmcgPSBzdHlsZVsnb3ZlcmxheS1wYWRkaW5nJ10ucHhWYWx1ZTtcbiAgICB2YXIgb3ZlcmxheU9wYWNpdHkgPSBzdHlsZVsnb3ZlcmxheS1vcGFjaXR5J10udmFsdWU7XG4gICAgdmFyIG92ZXJsYXlDb2xvciA9IHN0eWxlWydvdmVybGF5LWNvbG9yJ10udmFsdWU7XG5cbiAgICBpZiggZHJhd092ZXJsYXlJbnN0ZWFkICYmIG92ZXJsYXlPcGFjaXR5ID09PSAwICl7IC8vIGV4aXQgZWFybHkgaWYgZHJhd2luZyBvdmVybGF5IGJ1dCBub25lIHRvIGRyYXdcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50T3BhY2l0eSA9IG5vZGUuZWZmZWN0aXZlT3BhY2l0eSgpO1xuICAgIGlmKCBwYXJlbnRPcGFjaXR5ID09PSAwICl7IHJldHVybjsgfVxuXG4gICAgbm9kZVdpZHRoID0gdGhpcy5nZXROb2RlV2lkdGgobm9kZSk7XG4gICAgbm9kZUhlaWdodCA9IHRoaXMuZ2V0Tm9kZUhlaWdodChub2RlKTtcbiAgICBcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHN0eWxlWydib3JkZXItd2lkdGgnXS5weFZhbHVlO1xuXG4gICAgaWYoIGRyYXdPdmVybGF5SW5zdGVhZCA9PT0gdW5kZWZpbmVkIHx8ICFkcmF3T3ZlcmxheUluc3RlYWQgKXtcblxuICAgICAgdmFyIHVybCA9IHN0eWxlWydiYWNrZ3JvdW5kLWltYWdlJ10udmFsdWVbMl0gfHxcbiAgICAgICAgc3R5bGVbJ2JhY2tncm91bmQtaW1hZ2UnXS52YWx1ZVsxXTtcbiAgICAgIHZhciBpbWFnZTtcblxuICAgICAgaWYgKHVybCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIFxuICAgICAgICAvLyBnZXQgaW1hZ2UsIGFuZCBpZiBub3QgbG9hZGVkIHRoZW4gYXNrIHRvIHJlZHJhdyB3aGVuIGxhdGVyIGxvYWRlZFxuICAgICAgICBpbWFnZSA9IHRoaXMuZ2V0Q2FjaGVkSW1hZ2UodXJsLCBmdW5jdGlvbigpe1xuICAgICAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDYW52YXNSZW5kZXJlci5OT0RFXSA9IHRydWU7XG4gICAgICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NhbnZhc1JlbmRlcmVyLkRSQUddID0gdHJ1ZTtcbiAgICAgICAgICBcbiAgICAgICAgICByLmRyYXdpbmdJbWFnZSA9IHRydWU7XG4gICAgICAgICAgXG4gICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICB2YXIgcHJldkJnaW5nID0gX3AuYmFja2dyb3VuZGluZztcbiAgICAgICAgX3AuYmFja2dyb3VuZGluZyA9ICFpbWFnZS5jb21wbGV0ZTtcblxuICAgICAgICBpZiggcHJldkJnaW5nICE9PSBfcC5iYWNrZ3JvdW5kaW5nICl7IC8vIHVwZGF0ZSBzdHlsZSBiL2MgOmJhY2tncm91bmRpbmcgc3RhdGUgY2hhbmdlZFxuICAgICAgICAgIG5vZGUudXBkYXRlU3R5bGUoIGZhbHNlICk7XG4gICAgICAgIH1cbiAgICAgIH0gXG5cbiAgICAgIC8vIE5vZGUgY29sb3IgJiBvcGFjaXR5XG5cbiAgICAgIHZhciBiZ0NvbG9yID0gc3R5bGVbJ2JhY2tncm91bmQtY29sb3InXS52YWx1ZTtcbiAgICAgIHZhciBib3JkZXJDb2xvciA9IHN0eWxlWydib3JkZXItY29sb3InXS52YWx1ZTtcbiAgICAgIHZhciBib3JkZXJTdHlsZSA9IHN0eWxlWydib3JkZXItc3R5bGUnXS52YWx1ZTtcblxuICAgICAgdGhpcy5maWxsU3R5bGUoY29udGV4dCwgYmdDb2xvclswXSwgYmdDb2xvclsxXSwgYmdDb2xvclsyXSwgc3R5bGVbJ2JhY2tncm91bmQtb3BhY2l0eSddLnZhbHVlICogcGFyZW50T3BhY2l0eSk7XG4gICAgICBcbiAgICAgIHRoaXMuc3Ryb2tlU3R5bGUoY29udGV4dCwgYm9yZGVyQ29sb3JbMF0sIGJvcmRlckNvbG9yWzFdLCBib3JkZXJDb2xvclsyXSwgc3R5bGVbJ2JvcmRlci1vcGFjaXR5J10udmFsdWUgKiBwYXJlbnRPcGFjaXR5KTtcbiAgICAgIFxuICAgICAgdmFyIHNoYWRvd0JsdXIgPSBzdHlsZVsnc2hhZG93LWJsdXInXS5weFZhbHVlO1xuICAgICAgdmFyIHNoYWRvd09wYWNpdHkgPSBzdHlsZVsnc2hhZG93LW9wYWNpdHknXS52YWx1ZTtcbiAgICAgIHZhciBzaGFkb3dDb2xvciA9IHN0eWxlWydzaGFkb3ctY29sb3InXS52YWx1ZTtcbiAgICAgIHZhciBzaGFkb3dPZmZzZXRYID0gc3R5bGVbJ3NoYWRvdy1vZmZzZXQteCddLnB4VmFsdWU7XG4gICAgICB2YXIgc2hhZG93T2Zmc2V0WSA9IHN0eWxlWydzaGFkb3ctb2Zmc2V0LXknXS5weFZhbHVlO1xuXG4gICAgICB0aGlzLnNoYWRvd1N0eWxlKGNvbnRleHQsIHNoYWRvd0NvbG9yLCBzaGFkb3dPcGFjaXR5LCBzaGFkb3dCbHVyLCBzaGFkb3dPZmZzZXRYLCBzaGFkb3dPZmZzZXRZKTtcblxuICAgICAgY29udGV4dC5saW5lSm9pbiA9ICdtaXRlcic7IC8vIHNvIGJvcmRlcnMgYXJlIHNxdWFyZSB3aXRoIHRoZSBub2RlIHNoYXBlXG5cbiAgICAgIGlmKCBjb250ZXh0LnNldExpbmVEYXNoICl7IC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgICAgICBzd2l0Y2goIGJvcmRlclN0eWxlICl7XG4gICAgICAgICAgY2FzZSAnZG90dGVkJzpcbiAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWyAxLCAxIF0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdkYXNoZWQnOlxuICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbIDQsIDIgXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3NvbGlkJzpcbiAgICAgICAgICBjYXNlICdkb3VibGUnOlxuICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbIF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgXG4gICAgICB2YXIgc3R5bGVTaGFwZSA9IHN0eWxlWydzaGFwZSddLnN0clZhbHVlO1xuXG4gICAgICB2YXIgcG9zID0gbm9kZS5fcHJpdmF0ZS5wb3NpdGlvbjtcblxuICAgICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICAgIHZhciBwYXRoQ2FjaGVLZXkgPSBzdHlsZVNoYXBlICsgJyQnICsgbm9kZVdpZHRoICsnJCcgKyBub2RlSGVpZ2h0O1xuXG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKCBwb3MueCwgcG9zLnkgKTtcblxuICAgICAgICBpZiggcnMucGF0aENhY2hlS2V5ID09PSBwYXRoQ2FjaGVLZXkgKXtcbiAgICAgICAgICBwYXRoID0gY29udGV4dCA9IHJzLnBhdGhDYWNoZTtcbiAgICAgICAgICBwYXRoQ2FjaGVIaXQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGggPSBjb250ZXh0ID0gbmV3IFBhdGgyRCgpO1xuICAgICAgICAgIHJzLnBhdGhDYWNoZUtleSA9IHBhdGhDYWNoZUtleTtcbiAgICAgICAgICBycy5wYXRoQ2FjaGUgPSBwYXRoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKCAhcGF0aENhY2hlSGl0ICl7XG5cbiAgICAgICAgdmFyIG5wb3MgPSBwb3M7XG5cbiAgICAgICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICAgICAgbnBvcyA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIENhbnZhc1JlbmRlcmVyLm5vZGVTaGFwZXNbdGhpcy5nZXROb2RlU2hhcGUobm9kZSldLmRyYXdQYXRoKFxuICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICBucG9zLngsXG4gICAgICAgICAgICAgIG5wb3MueSxcbiAgICAgICAgICAgICAgbm9kZVdpZHRoLFxuICAgICAgICAgICAgICBub2RlSGVpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dCA9IGNhbnZhc0NvbnRleHQ7XG5cbiAgICAgIGlmKCB1c2VQYXRocyApe1xuICAgICAgICBjb250ZXh0LmZpbGwoIHBhdGggKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNoYWRvd1N0eWxlKGNvbnRleHQsICd0cmFuc3BhcmVudCcsIDApOyAvLyByZXNldCBmb3IgbmV4dCBndXlcblxuICAgICAgaWYgKHVybCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmKCBpbWFnZS5jb21wbGV0ZSApe1xuICAgICAgICAgIHRoaXMuZHJhd0luc2NyaWJlZEltYWdlKGNvbnRleHQsIGltYWdlLCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgfSBcbiAgICAgIFxuICAgICAgdmFyIGRhcmtuZXNzID0gc3R5bGVbJ2JhY2tncm91bmQtYmxhY2tlbiddLnZhbHVlO1xuICAgICAgdmFyIGJvcmRlcldpZHRoID0gc3R5bGVbJ2JvcmRlci13aWR0aCddLnB4VmFsdWU7XG5cbiAgICAgIGlmKCB0aGlzLmhhc1BpZShub2RlKSApe1xuICAgICAgICB0aGlzLmRyYXdQaWUoIGNvbnRleHQsIG5vZGUsIHBhcmVudE9wYWNpdHkgKTtcblxuICAgICAgICAvLyByZWRyYXcgcGF0aCBmb3IgYmxhY2tlbiBhbmQgYm9yZGVyXG4gICAgICAgIGlmKCBkYXJrbmVzcyAhPT0gMCB8fCBib3JkZXJXaWR0aCAhPT0gMCApe1xuXG4gICAgICAgICAgaWYoICF1c2VQYXRocyApe1xuICAgICAgICAgICAgQ2FudmFzUmVuZGVyZXIubm9kZVNoYXBlc1t0aGlzLmdldE5vZGVTaGFwZShub2RlKV0uZHJhd1BhdGgoXG4gICAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgICAgICBwb3MueCxcbiAgICAgICAgICAgICAgICBwb3MueSxcbiAgICAgICAgICAgICAgICBub2RlV2lkdGgsXG4gICAgICAgICAgICAgICAgbm9kZUhlaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKCBkYXJrbmVzcyA+IDAgKXtcbiAgICAgICAgdGhpcy5maWxsU3R5bGUoY29udGV4dCwgMCwgMCwgMCwgZGFya25lc3MpO1xuXG4gICAgICAgIGlmKCB1c2VQYXRocyApe1xuICAgICAgICAgIGNvbnRleHQuZmlsbCggcGF0aCApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgfSBlbHNlIGlmKCBkYXJrbmVzcyA8IDAgKXtcbiAgICAgICAgdGhpcy5maWxsU3R5bGUoY29udGV4dCwgMjU1LCAyNTUsIDI1NSwgLWRhcmtuZXNzKTtcbiAgICAgICAgXG4gICAgICAgIGlmKCB1c2VQYXRocyApe1xuICAgICAgICAgIGNvbnRleHQuZmlsbCggcGF0aCApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEJvcmRlciB3aWR0aCwgZHJhdyBib3JkZXJcbiAgICAgIGlmIChib3JkZXJXaWR0aCA+IDApIHtcblxuICAgICAgICBpZiggdXNlUGF0aHMgKXtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZSggcGF0aCApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggYm9yZGVyU3R5bGUgPT09ICdkb3VibGUnICl7XG4gICAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBzdHlsZVsnYm9yZGVyLXdpZHRoJ10ucHhWYWx1ZS8zO1xuXG4gICAgICAgICAgdmFyIGdjbyA9IGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uO1xuICAgICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW91dCc7XG5cbiAgICAgICAgICBpZiggdXNlUGF0aHMgKXtcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCBwYXRoICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBnY287XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICBpZiggdXNlUGF0aHMgKXtcbiAgICAgICAgY29udGV4dC50cmFuc2xhdGUoIC1wb3MueCwgLXBvcy55ICk7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlc2V0IGluIGNhc2Ugd2UgY2hhbmdlZCB0aGUgYm9yZGVyIHN0eWxlXG4gICAgICBpZiggY29udGV4dC5zZXRMaW5lRGFzaCApeyAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbIF0pO1xuICAgICAgfVxuXG4gICAgLy8gZHJhdyB0aGUgb3ZlcmxheVxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGlmKCBvdmVybGF5T3BhY2l0eSA+IDAgKXtcbiAgICAgICAgdGhpcy5maWxsU3R5bGUoY29udGV4dCwgb3ZlcmxheUNvbG9yWzBdLCBvdmVybGF5Q29sb3JbMV0sIG92ZXJsYXlDb2xvclsyXSwgb3ZlcmxheU9wYWNpdHkpO1xuXG4gICAgICAgIENhbnZhc1JlbmRlcmVyLm5vZGVTaGFwZXNbJ3JvdW5kcmVjdGFuZ2xlJ10uZHJhd1BhdGgoXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICBub2RlLl9wcml2YXRlLnBvc2l0aW9uLngsXG4gICAgICAgICAgbm9kZS5fcHJpdmF0ZS5wb3NpdGlvbi55LFxuICAgICAgICAgIG5vZGVXaWR0aCArIG92ZXJsYXlQYWRkaW5nICogMixcbiAgICAgICAgICBub2RlSGVpZ2h0ICsgb3ZlcmxheVBhZGRpbmcgKiAyXG4gICAgICAgICk7XG5cbiAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICB9XG4gICAgfVxuXG4gIH07XG5cbiAgLy8gZG9lcyB0aGUgbm9kZSBoYXZlIGF0IGxlYXN0IG9uZSBwaWUgcGllY2U/XG4gIENScC5oYXNQaWUgPSBmdW5jdGlvbihub2RlKXtcbiAgICBub2RlID0gbm9kZVswXTsgLy8gZW5zdXJlIGVsZSByZWZcbiAgICBcbiAgICByZXR1cm4gbm9kZS5fcHJpdmF0ZS5oYXNQaWU7XG4gIH07XG5cbiAgQ1JwLmRyYXdQaWUgPSBmdW5jdGlvbiggY29udGV4dCwgbm9kZSwgbm9kZU9wYWNpdHkgKXtcbiAgICBub2RlID0gbm9kZVswXTsgLy8gZW5zdXJlIGVsZSByZWZcblxuICAgIHZhciBfcCA9IG5vZGUuX3ByaXZhdGU7XG4gICAgdmFyIHN0eWxlID0gX3Auc3R5bGU7XG4gICAgdmFyIHBpZVNpemUgPSBzdHlsZVsncGllLXNpemUnXTtcbiAgICB2YXIgbm9kZVcgPSB0aGlzLmdldE5vZGVXaWR0aCggbm9kZSApO1xuICAgIHZhciBub2RlSCA9IHRoaXMuZ2V0Tm9kZUhlaWdodCggbm9kZSApO1xuICAgIHZhciB4ID0gX3AucG9zaXRpb24ueDtcbiAgICB2YXIgeSA9IF9wLnBvc2l0aW9uLnk7XG4gICAgdmFyIHJhZGl1cyA9IE1hdGgubWluKCBub2RlVywgbm9kZUggKSAvIDI7IC8vIG11c3QgZml0IGluIG5vZGVcbiAgICB2YXIgbGFzdFBlcmNlbnQgPSAwOyAvLyB3aGF0ICUgdG8gY29udGludWUgZHJhd2luZyBwaWUgc2xpY2VzIGZyb20gb24gWzAsIDFdXG4gICAgdmFyIHVzZVBhdGhzID0gQ2FudmFzUmVuZGVyZXIudXNlUGF0aHMoKTtcblxuICAgIGlmKCB1c2VQYXRocyApe1xuICAgICAgeCA9IDA7XG4gICAgICB5ID0gMDtcbiAgICB9XG5cbiAgICBpZiggcGllU2l6ZS51bml0cyA9PT0gJyUnICl7XG4gICAgICByYWRpdXMgPSByYWRpdXMgKiBwaWVTaXplLnZhbHVlIC8gMTAwO1xuICAgIH0gZWxzZSBpZiggcGllU2l6ZS5weFZhbHVlICE9PSB1bmRlZmluZWQgKXtcbiAgICAgIHJhZGl1cyA9IHBpZVNpemUucHhWYWx1ZSAvIDI7XG4gICAgfVxuXG4gICAgZm9yKCB2YXIgaSA9IDE7IGkgPD0gJCQuc3R5bGUucGllQmFja2dyb3VuZE47IGkrKyApeyAvLyAxLi5OXG4gICAgICB2YXIgc2l6ZSA9IHN0eWxlWydwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtc2l6ZSddLnZhbHVlO1xuICAgICAgdmFyIGNvbG9yID0gc3R5bGVbJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1jb2xvciddLnZhbHVlO1xuICAgICAgdmFyIG9wYWNpdHkgPSBzdHlsZVsncGllLScgKyBpICsgJy1iYWNrZ3JvdW5kLW9wYWNpdHknXS52YWx1ZSAqIG5vZGVPcGFjaXR5O1xuICAgICAgdmFyIHBlcmNlbnQgPSBzaXplIC8gMTAwOyAvLyBtYXAgaW50ZWdlciByYW5nZSBbMCwgMTAwXSB0byBbMCwgMV1cbiAgICAgIHZhciBhbmdsZVN0YXJ0ID0gMS41ICogTWF0aC5QSSArIDIgKiBNYXRoLlBJICogbGFzdFBlcmNlbnQ7IC8vIHN0YXJ0IGF0IDEyIG8nY2xvY2sgYW5kIGdvIGNsb2Nrd2lzZVxuICAgICAgdmFyIGFuZ2xlRGVsdGEgPSAyICogTWF0aC5QSSAqIHBlcmNlbnQ7XG4gICAgICB2YXIgYW5nbGVFbmQgPSBhbmdsZVN0YXJ0ICsgYW5nbGVEZWx0YTtcblxuICAgICAgLy8gaWdub3JlIGlmXG4gICAgICAvLyAtIHplcm8gc2l6ZVxuICAgICAgLy8gLSB3ZSdyZSBhbHJlYWR5IGJleW9uZCB0aGUgZnVsbCBjaXJjbGVcbiAgICAgIC8vIC0gYWRkaW5nIHRoZSBjdXJyZW50IHNsaWNlIHdvdWxkIGdvIGJleW9uZCB0aGUgZnVsbCBjaXJjbGVcbiAgICAgIGlmKCBzaXplID09PSAwIHx8IGxhc3RQZXJjZW50ID49IDEgfHwgbGFzdFBlcmNlbnQgKyBwZXJjZW50ID4gMSApe1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGNvbnRleHQubW92ZVRvKHgsIHkpO1xuICAgICAgY29udGV4dC5hcmMoIHgsIHksIHJhZGl1cywgYW5nbGVTdGFydCwgYW5nbGVFbmQgKTtcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG5cbiAgICAgIHRoaXMuZmlsbFN0eWxlKGNvbnRleHQsIGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIG9wYWNpdHkpO1xuXG4gICAgICBjb250ZXh0LmZpbGwoKTtcblxuICAgICAgbGFzdFBlcmNlbnQgKz0gcGVyY2VudDtcbiAgICB9XG5cbiAgfTtcblxuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgQ2FudmFzUmVuZGVyZXIgPSAkJCgncmVuZGVyZXInLCAnY2FudmFzJyk7XG4gIHZhciBDUiA9IENhbnZhc1JlbmRlcmVyO1xuICB2YXIgQ1JwID0gQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlO1xuXG4gIC8vIHZhciBpc0ZpcmVmb3ggPSB0eXBlb2YgSW5zdGFsbFRyaWdnZXIgIT09ICd1bmRlZmluZWQnO1xuXG4gIENScC5nZXRQaXhlbFJhdGlvID0gZnVuY3Rpb24oKXsgXG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLmRhdGEuY29udGV4dHNbMF07XG5cbiAgICBpZiggdGhpcy5mb3JjZWRQaXhlbFJhdGlvICE9IG51bGwgKXtcbiAgICAgIHJldHVybiB0aGlzLmZvcmNlZFBpeGVsUmF0aW87XG4gICAgfVxuXG4gICAgdmFyIGJhY2tpbmdTdG9yZSA9IGNvbnRleHQuYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgY29udGV4dC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICBjb250ZXh0Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgIGNvbnRleHQubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICBjb250ZXh0Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICBjb250ZXh0LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMTtcblxuICAgIC8vY29uc29sZS5sb2cod2luZG93LmRldmljZVBpeGVsUmF0aW8sIGJhY2tpbmdTdG9yZSk7XG5cbiAgICAvLyBpZiggaXNGaXJlZm94ICl7IC8vIGJlY2F1c2UgZmYgY2FuJ3Qgc2NhbGUgY2FudmFzIHByb3Blcmx5XG4gICAgLy8gICByZXR1cm4gMTtcbiAgICAvLyB9XG5cbiAgICByZXR1cm4gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIC8gYmFja2luZ1N0b3JlO1xuICB9O1xuXG4gIENScC5wYWludENhY2hlID0gZnVuY3Rpb24oY29udGV4dCl7XG4gICAgdmFyIGNhY2hlcyA9IHRoaXMucGFpbnRDYWNoZXMgPSB0aGlzLnBhaW50Q2FjaGVzIHx8IFtdO1xuICAgIHZhciBuZWVkVG9DcmVhdGVDYWNoZSA9IHRydWU7XG4gICAgdmFyIGNhY2hlO1xuXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGNhY2hlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgY2FjaGUgPSBjYWNoZXNbaV07XG5cbiAgICAgIGlmKCBjYWNoZS5jb250ZXh0ID09PSBjb250ZXh0ICl7XG4gICAgICAgIG5lZWRUb0NyZWF0ZUNhY2hlID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKCBuZWVkVG9DcmVhdGVDYWNoZSApe1xuICAgICAgY2FjaGUgPSB7XG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICAgIH07XG4gICAgICBjYWNoZXMucHVzaCggY2FjaGUgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FjaGU7XG4gIH07XG5cbiAgQ1JwLmZpbGxTdHlsZSA9IGZ1bmN0aW9uKGNvbnRleHQsIHIsIGcsIGIsIGEpe1xuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEgKyAnKSc7XG4gICAgXG4gICAgLy8gdHVybiBvZmYgZm9yIG5vdywgc2VlbXMgY29udGV4dCBkb2VzIGl0cyBvd24gY2FjaGluZ1xuXG4gICAgLy8gdmFyIGNhY2hlID0gdGhpcy5wYWludENhY2hlKGNvbnRleHQpO1xuXG4gICAgLy8gdmFyIGZpbGxTdHlsZSA9ICdyZ2JhKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhICsgJyknO1xuXG4gICAgLy8gaWYoIGNhY2hlLmZpbGxTdHlsZSAhPT0gZmlsbFN0eWxlICl7XG4gICAgLy8gICBjb250ZXh0LmZpbGxTdHlsZSA9IGNhY2hlLmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcbiAgICAvLyB9XG4gIH07XG5cbiAgQ1JwLnN0cm9rZVN0eWxlID0gZnVuY3Rpb24oY29udGV4dCwgciwgZywgYiwgYSl7XG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICdyZ2JhKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhICsgJyknO1xuICAgIFxuICAgIC8vIHR1cm4gb2ZmIGZvciBub3csIHNlZW1zIGNvbnRleHQgZG9lcyBpdHMgb3duIGNhY2hpbmdcblxuICAgIC8vIHZhciBjYWNoZSA9IHRoaXMucGFpbnRDYWNoZShjb250ZXh0KTtcblxuICAgIC8vIHZhciBzdHJva2VTdHlsZSA9ICdyZ2JhKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhICsgJyknO1xuXG4gICAgLy8gaWYoIGNhY2hlLnN0cm9rZVN0eWxlICE9PSBzdHJva2VTdHlsZSApe1xuICAgIC8vICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNhY2hlLnN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGU7XG4gICAgLy8gfVxuICB9O1xuICBcbiAgQ1JwLnNoYWRvd1N0eWxlID0gZnVuY3Rpb24oY29udGV4dCwgY29sb3IsIG9wYWNpdHksIGJsdXIsIG9mZnNldFgsIG9mZnNldFkpe1xuICAgIHZhciB6b29tID0gdGhpcy5kYXRhLmN5Lnpvb20oKTtcblxuICAgIHZhciBjYWNoZSA9IHRoaXMucGFpbnRDYWNoZShjb250ZXh0KTtcbiAgICBcbiAgICAvLyBkb24ndCBtYWtlIGV4cGVuc2l2ZSBjaGFuZ2VzIHRvIHRoZSBzaGFkb3cgc3R5bGUgaWYgaXQncyBub3QgdXNlZFxuICAgIGlmKCBjYWNoZS5zaGFkb3dPcGFjaXR5ID09PSAwICYmIG9wYWNpdHkgPT09IDAgKXtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYWNoZS5zaGFkb3dPcGFjaXR5ID0gb3BhY2l0eTtcblxuICAgIGlmIChvcGFjaXR5ID4gMCkge1xuICAgICAgY29udGV4dC5zaGFkb3dCbHVyID0gYmx1ciAqIHpvb207XG4gICAgICBjb250ZXh0LnNoYWRvd0NvbG9yID0gXCJyZ2JhKFwiICsgY29sb3JbMF0gKyBcIixcIiArIGNvbG9yWzFdICsgXCIsXCIgKyBjb2xvclsyXSArIFwiLFwiICsgb3BhY2l0eSArIFwiKVwiO1xuICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRYID0gb2Zmc2V0WCAqIHpvb207XG4gICAgICBjb250ZXh0LnNoYWRvd09mZnNldFkgPSBvZmZzZXRZICogem9vbTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5zaGFkb3dCbHVyID0gMDtcbiAgICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSBcInRyYW5zcGFyZW50XCI7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlc2l6ZSBjYW52YXNcbiAgQ1JwLm1hdGNoQ2FudmFzU2l6ZSA9IGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIHZhciB3aWR0aCA9IGNvbnRhaW5lci5jbGllbnRXaWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gY29udGFpbmVyLmNsaWVudEhlaWdodDtcbiAgICB2YXIgcGl4ZWxSYXRpbyA9IHRoaXMuZ2V0UGl4ZWxSYXRpbygpO1xuICAgIHZhciBtYlB4UmF0aW8gPSB0aGlzLm1vdGlvbkJsdXJQeFJhdGlvO1xuXG4gICAgaWYoXG4gICAgICBjb250YWluZXIgPT09IHRoaXMuZGF0YS5idWZmZXJDYW52YXNlc1tDUi5NT1RJT05CTFVSX0JVRkZFUl9OT0RFXSB8fFxuICAgICAgY29udGFpbmVyID09PSB0aGlzLmRhdGEuYnVmZmVyQ2FudmFzZXNbQ1IuTU9USU9OQkxVUl9CVUZGRVJfRFJBR11cbiAgICApe1xuICAgICAgcGl4ZWxSYXRpbyA9IG1iUHhSYXRpbztcbiAgICB9XG5cbiAgICB2YXIgY2FudmFzV2lkdGggPSB3aWR0aCAqIHBpeGVsUmF0aW87XG4gICAgdmFyIGNhbnZhc0hlaWdodCA9IGhlaWdodCAqIHBpeGVsUmF0aW87XG4gICAgdmFyIGNhbnZhcztcblxuICAgIGlmKCBjYW52YXNXaWR0aCA9PT0gdGhpcy5jYW52YXNXaWR0aCAmJiBjYW52YXNIZWlnaHQgPT09IHRoaXMuY2FudmFzSGVpZ2h0ICl7XG4gICAgICByZXR1cm47IC8vIHNhdmUgY3ljbGVzIGlmIHNhbWVcbiAgICB9XG5cbiAgICB0aGlzLmZvbnRDYWNoZXMgPSBudWxsOyAvLyByZXNpemluZyByZXNldHMgdGhlIHN0eWxlXG5cbiAgICB2YXIgY2FudmFzQ29udGFpbmVyID0gZGF0YS5jYW52YXNDb250YWluZXI7XG4gICAgY2FudmFzQ29udGFpbmVyLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgIGNhbnZhc0NvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBDYW52YXNSZW5kZXJlci5DQU5WQVNfTEFZRVJTOyBpKyspIHtcblxuICAgICAgY2FudmFzID0gZGF0YS5jYW52YXNlc1tpXTtcbiAgICAgIFxuICAgICAgaWYgKGNhbnZhcy53aWR0aCAhPT0gY2FudmFzV2lkdGggfHwgY2FudmFzLmhlaWdodCAhPT0gY2FudmFzSGVpZ2h0KSB7XG4gICAgICAgIFxuICAgICAgICBjYW52YXMud2lkdGggPSBjYW52YXNXaWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodDtcblxuICAgICAgICBjYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IENhbnZhc1JlbmRlcmVyLkJVRkZFUl9DT1VOVDsgaSsrKSB7XG4gICAgICBcbiAgICAgIGNhbnZhcyA9IGRhdGEuYnVmZmVyQ2FudmFzZXNbaV07XG4gICAgICBcbiAgICAgIGlmIChjYW52YXMud2lkdGggIT09IGNhbnZhc1dpZHRoIHx8IGNhbnZhcy5oZWlnaHQgIT09IGNhbnZhc0hlaWdodCkge1xuICAgICAgICBcbiAgICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNIZWlnaHQ7XG5cbiAgICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnRleHR1cmVNdWx0ID0gMTtcbiAgICBpZiggcGl4ZWxSYXRpbyA8PSAxICl7XG4gICAgICBjYW52YXMgPSBkYXRhLmJ1ZmZlckNhbnZhc2VzWyBDYW52YXNSZW5kZXJlci5URVhUVVJFX0JVRkZFUiBdO1xuXG4gICAgICB0aGlzLnRleHR1cmVNdWx0ID0gMjtcbiAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhc1dpZHRoICogdGhpcy50ZXh0dXJlTXVsdDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNIZWlnaHQgKiB0aGlzLnRleHR1cmVNdWx0O1xuICAgIH1cblxuICAgIHRoaXMuY2FudmFzV2lkdGggPSBjYW52YXNXaWR0aDtcbiAgICB0aGlzLmNhbnZhc0hlaWdodCA9IGNhbnZhc0hlaWdodDtcblxuICB9O1xuXG4gIENScC5yZW5kZXJUbyA9IGZ1bmN0aW9uKCBjeHQsIHpvb20sIHBhbiwgcHhSYXRpbyApe1xuICAgIHRoaXMucmVkcmF3KHtcbiAgICAgIGZvcmNlZENvbnRleHQ6IGN4dCxcbiAgICAgIGZvcmNlZFpvb206IHpvb20sXG4gICAgICBmb3JjZWRQYW46IHBhbixcbiAgICAgIGRyYXdBbGxMYXllcnM6IHRydWUsXG4gICAgICBmb3JjZWRQeFJhdGlvOiBweFJhdGlvXG4gICAgfSk7XG4gIH07XG5cbiAgQ1JwLnRpbWVUb1JlbmRlciA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMucmVkcmF3VG90YWxUaW1lIC8gdGhpcy5yZWRyYXdDb3VudDtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlci5taW5SZWRyYXdMaW1pdCA9IDEwMDAvNjA7IC8vIHBlb3BsZSBjYW4ndCBzZWUgbXVjaCBiZXR0ZXIgdGhhbiA2MGZwc1xuICBDYW52YXNSZW5kZXJlci5tYXhSZWRyYXdMaW1pdCA9IDEwMDA7ICAvLyBkb24ndCBjYXAgbWF4IGIvYyBpdCdzIG1vcmUgaW1wb3J0YW50IHRvIGJlIHJlc3BvbnNpdmUgdGhhbiBzbW9vdGhcbiAgQ2FudmFzUmVuZGVyZXIubW90aW9uQmx1ckRlbGF5ID0gMTAwO1xuXG4gIC8vIFJlZHJhdyBmcmFtZVxuICBDUnAucmVkcmF3ID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBjb25zb2xlLmxvZygncmVkcmF3KCknKTtcblxuICAgIHZhciBmb3JjZWRDb250ZXh0ID0gb3B0aW9ucy5mb3JjZWRDb250ZXh0O1xuICAgIHZhciBkcmF3QWxsTGF5ZXJzID0gb3B0aW9ucy5kcmF3QWxsTGF5ZXJzO1xuICAgIHZhciBkcmF3T25seU5vZGVMYXllciA9IG9wdGlvbnMuZHJhd09ubHlOb2RlTGF5ZXI7XG4gICAgdmFyIGZvcmNlZFpvb20gPSBvcHRpb25zLmZvcmNlZFpvb207XG4gICAgdmFyIGZvcmNlZFBhbiA9IG9wdGlvbnMuZm9yY2VkUGFuO1xuICAgIHZhciByID0gdGhpcztcbiAgICB2YXIgcGl4ZWxSYXRpbyA9IG9wdGlvbnMuZm9yY2VkUHhSYXRpbyA9PT0gdW5kZWZpbmVkID8gdGhpcy5nZXRQaXhlbFJhdGlvKCkgOiBvcHRpb25zLmZvcmNlZFB4UmF0aW87XG4gICAgdmFyIGN5ID0gci5kYXRhLmN5OyB2YXIgZGF0YSA9IHIuZGF0YTsgXG4gICAgdmFyIG5lZWREcmF3ID0gZGF0YS5jYW52YXNOZWVkc1JlZHJhdztcbiAgICB2YXIgdGV4dHVyZURyYXcgPSByLnRleHR1cmVPblZpZXdwb3J0ICYmICFmb3JjZWRDb250ZXh0ICYmIChyLnBpbmNoaW5nIHx8IHIuaG92ZXJEYXRhLmRyYWdnaW5nIHx8IHIuc3dpcGVQYW5uaW5nIHx8IHIuZGF0YS53aGVlbFpvb21pbmcpO1xuICAgIHZhciBtb3Rpb25CbHVyID0gb3B0aW9ucy5tb3Rpb25CbHVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1vdGlvbkJsdXIgOiByLm1vdGlvbkJsdXI7XG4gICAgdmFyIG1iUHhSYXRpbyA9IHIubW90aW9uQmx1clB4UmF0aW87XG4gICAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gICAgdmFyIGluTm9kZURyYWdHZXN0dXJlID0gci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzO1xuICAgIHZhciBpbkJveFNlbGVjdGlvbiA9IHIuaG92ZXJEYXRhLnNlbGVjdGluZyB8fCByLnRvdWNoRGF0YS5zZWxlY3RpbmcgPyB0cnVlIDogZmFsc2U7XG4gICAgbW90aW9uQmx1ciA9IG1vdGlvbkJsdXIgJiYgIWZvcmNlZENvbnRleHQgJiYgci5tb3Rpb25CbHVyRW5hYmxlZCAmJiAhaW5Cb3hTZWxlY3Rpb247XG4gICAgdmFyIG1vdGlvbkJsdXJGYWRlRWZmZWN0ID0gbW90aW9uQmx1cjtcblxuICAgIC8vIGNvbnNvbGUubG9nKCd0ZXh0dXJlRHJhdz8nLCB0ZXh0dXJlRHJhdyk7XG5cblxuICAgIGlmKCAhZm9yY2VkQ29udGV4dCAmJiByLm1vdGlvbkJsdXJUaW1lb3V0ICl7XG4gICAgICBjbGVhclRpbWVvdXQoIHIubW90aW9uQmx1clRpbWVvdXQgKTtcbiAgICB9XG5cbiAgICBpZiggIWZvcmNlZENvbnRleHQgJiYgdGhpcy5yZWRyYXdUaW1lb3V0ICl7XG4gICAgICBjbGVhclRpbWVvdXQoIHRoaXMucmVkcmF3VGltZW91dCApO1xuICAgIH1cbiAgICB0aGlzLnJlZHJhd1RpbWVvdXQgPSBudWxsO1xuXG4gICAgaWYoIHRoaXMuYXZlcmFnZVJlZHJhd1RpbWUgPT09IHVuZGVmaW5lZCApeyB0aGlzLmF2ZXJhZ2VSZWRyYXdUaW1lID0gMDsgfVxuXG4gICAgdmFyIG1pblJlZHJhd0xpbWl0ID0gQ2FudmFzUmVuZGVyZXIubWluUmVkcmF3TGltaXQ7IFxuICAgIHZhciBtYXhSZWRyYXdMaW1pdCA9IENhbnZhc1JlbmRlcmVyLm1heFJlZHJhd0xpbWl0O1xuXG4gICAgdmFyIHJlZHJhd0xpbWl0ID0gdGhpcy5hdmVyYWdlUmVkcmF3VGltZTsgLy8gZXN0aW1hdGUgdGhlIGlkZWFsIHJlZHJhdyBsaW1pdCBiYXNlZCBvbiBob3cgZmFzdCB3ZSBjYW4gZHJhd1xuICAgIHJlZHJhd0xpbWl0ID0gbWluUmVkcmF3TGltaXQgPiByZWRyYXdMaW1pdCA/IG1pblJlZHJhd0xpbWl0IDogcmVkcmF3TGltaXQ7XG4gICAgcmVkcmF3TGltaXQgPSByZWRyYXdMaW1pdCA8IG1heFJlZHJhd0xpbWl0ID8gcmVkcmF3TGltaXQgOiBtYXhSZWRyYXdMaW1pdDtcblxuICAgIC8vY29uc29sZS5sb2coJy0tXFxuaWRlYWw6ICVpOyBlZmZlY3RpdmU6ICVpJywgdGhpcy5hdmVyYWdlUmVkcmF3VGltZSwgcmVkcmF3TGltaXQpO1xuXG4gICAgaWYoIHRoaXMubGFzdERyYXdUaW1lID09PSB1bmRlZmluZWQgKXsgdGhpcy5sYXN0RHJhd1RpbWUgPSAwOyB9XG5cbiAgICB2YXIgbm93VGltZSA9IERhdGUubm93KCk7XG4gICAgdmFyIHRpbWVFbGFwc2VkID0gbm93VGltZSAtIHRoaXMubGFzdERyYXdUaW1lO1xuICAgIHZhciBjYWxsQWZ0ZXJMaW1pdCA9IHRpbWVFbGFwc2VkID49IHJlZHJhd0xpbWl0O1xuXG4gICAgaWYoICFmb3JjZWRDb250ZXh0ICYmICFyLmNsZWFyaW5nTW90aW9uQmx1ciApe1xuICAgICAgaWYoICFjYWxsQWZ0ZXJMaW1pdCB8fCB0aGlzLmN1cnJlbnRseURyYXdpbmcgKXtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJy0tIHNraXAnLCByZWRyYXdMaW1pdCk7XG5cbiAgICAgICAgLy8gd2UgaGF2ZSBuZXcgdGhpbmdzIHRvIGRyYXcgYnV0IHdlJ3JlIGJ1c3ksIHNvIHRyeSBhZ2FpbiB3aGVuIHBvc3NpYmx5IGZyZWVcbiAgICAgICAgdGhpcy5yZWRyYXdUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgIH0sIHJlZHJhd0xpbWl0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxhc3REcmF3VGltZSA9IG5vd1RpbWU7XG4gICAgICB0aGlzLmN1cnJlbnRseURyYXdpbmcgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmKCBtb3Rpb25CbHVyICl7XG4gICAgICBpZiggci5tYkZyYW1lcyA9PSBudWxsICl7XG4gICAgICAgIHIubWJGcmFtZXMgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiggIXIuZHJhd2luZ0ltYWdlICl7IC8vIGltYWdlIGxvYWRpbmcgZnJhbWVzIGRvbid0IGNvdW50IHRvd2FyZHMgbW90aW9uIGJsdXIgYmx1cnJ5IGZyYW1lc1xuICAgICAgICByLm1iRnJhbWVzKys7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmKCByLm1iRnJhbWVzIDwgMyApeyAvLyBuZWVkIHNldmVyYWwgZnJhbWVzIGJlZm9yZSBldmVuIGhpZ2ggcXVhbGl0eSBtb3Rpb25ibHVyXG4gICAgICAgIG1vdGlvbkJsdXJGYWRlRWZmZWN0ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIGdvIHRvIGxvd2VyIHF1YWxpdHkgYmx1cnJ5IGZyYW1lcyB3aGVuIHNldmVyYWwgbS9iIGZyYW1lcyBoYXZlIGJlZW4gcmVuZGVyZWQgKGF2b2lkcyBmbGFzaGluZylcbiAgICAgIGlmKCByLm1iRnJhbWVzID4gci5taW5NYkxvd1F1YWxGcmFtZXMgKXtcbiAgICAgICAgLy9yLmZ1bGxRdWFsaXR5TWIgPSBmYWxzZTtcbiAgICAgICAgci5tb3Rpb25CbHVyUHhSYXRpbyA9IHIubWJQeFJCbHVycnk7XG4gICAgICB9XG4gICAgfSBcblxuICAgIC8vIGNvbnNvbGUubG9nKCdtYjogJXMsIE46ICVzLCBxOiAlcycsIG1vdGlvbkJsdXIsIHIubWJGcmFtZXMsIHIubW90aW9uQmx1clB4UmF0aW8pO1xuXG4gICAgaWYoIHIuY2xlYXJpbmdNb3Rpb25CbHVyICl7XG4gICAgICAvL3IuZnVsbFF1YWxpdHlNYiA9IHRydWU7IC8vIFRPRE8gZW5hYmxlIHdoZW4gZG9lc24ndCBjYXVzZSBzY2FsZWQgZmxhc2hpbmcgaXNzdWVcblxuICAgICAgci5tb3Rpb25CbHVyUHhSYXRpbyA9IDE7XG4gICAgfVxuXG5cbiAgICB2YXIgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblxuICAgIC8vIGNvbnNvbGUubG9nKCctLSByZWRyYXcgLS0nKVxuICAgIFxuICAgIGZ1bmN0aW9uIGRyYXdUb0NvbnRleHQoKXsgXG4gICAgICAvLyBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgLy8gY29uc29sZS5wcm9maWxlKCdkcmF3JyArIHN0YXJ0VGltZSlcbiAgICAgIFxuICAgICAgLy8gYi9jIGRyYXdUb0NvbnRleHQoKSBtYXkgYmUgYXN5bmMgdy5yLnQuIHJlZHJhdygpLCBrZWVwIHRyYWNrIG9mIGxhc3QgdGV4dHVyZSBmcmFtZVxuICAgICAgLy8gYmVjYXVzZSBhIHJvZ3VlIGFzeW5jIHRleHR1cmUgZnJhbWUgd291bGQgY2xlYXIgbmVlZERyYXdcbiAgICAgIGlmKCByLnRleHR1cmVEcmF3TGFzdEZyYW1lICYmICF0ZXh0dXJlRHJhdyApe1xuICAgICAgICBuZWVkRHJhd1tDUi5OT0RFXSA9IHRydWU7XG4gICAgICAgIG5lZWREcmF3W0NSLlNFTEVDVF9CT1hdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gY29uc29sZS5sb2coJ2RyYXdUb0NvbnRleHQoKScpO1xuICAgICAgLy8gY29uc29sZS5sb2coICduZWVkRHJhdycsIG5lZWREcmF3W0NSLk5PREVdLCBuZWVkRHJhd1tDUi5EUkFHXSwgbmVlZERyYXdbQ1IuU0VMRUNUX0JPWF0gKTtcblxuICAgICAgdmFyIGVkZ2VzID0gci5nZXRDYWNoZWRFZGdlcygpO1xuICAgICAgdmFyIGNvcmVTdHlsZSA9IGN5LnN0eWxlKCkuX3ByaXZhdGUuY29yZVN0eWxlO1xuICAgICAgXG4gICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICAgIHZhciBlZmZlY3RpdmVab29tID0gZm9yY2VkWm9vbSAhPT0gdW5kZWZpbmVkID8gZm9yY2VkWm9vbSA6IHpvb207XG4gICAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgICB2YXIgZWZmZWN0aXZlUGFuID0ge1xuICAgICAgICB4OiBwYW4ueCxcbiAgICAgICAgeTogcGFuLnlcbiAgICAgIH07XG5cbiAgICAgIHZhciB2cCA9IHtcbiAgICAgICAgem9vbTogem9vbSxcbiAgICAgICAgcGFuOiB7XG4gICAgICAgICAgeDogcGFuLngsXG4gICAgICAgICAgeTogcGFuLnlcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBwcmV2VnAgPSByLnByZXZWaWV3cG9ydDtcbiAgICAgIHZhciB2aWV3cG9ydElzRGlmZiA9IHByZXZWcCA9PT0gdW5kZWZpbmVkIHx8IHZwLnpvb20gIT09IHByZXZWcC56b29tIHx8IHZwLnBhbi54ICE9PSBwcmV2VnAucGFuLnggfHwgdnAucGFuLnkgIT09IHByZXZWcC5wYW4ueTtcblxuICAgICAgLy8gd2Ugd2FudCB0aGUgbG93IHF1YWxpdHkgbW90aW9uYmx1ciBvbmx5IHdoZW4gdGhlIHZpZXdwb3J0IGlzIGJlaW5nIG1hbmlwdWxhdGVkIGV0YyAod2hlcmUgaXQncyBub3Qgbm90aWNlZClcbiAgICAgIGlmKCAhdmlld3BvcnRJc0RpZmYgJiYgIShpbk5vZGVEcmFnR2VzdHVyZSAmJiAhaGFzQ29tcG91bmROb2RlcykgKXtcbiAgICAgICAgci5tb3Rpb25CbHVyUHhSYXRpbyA9IDE7XG4gICAgICB9XG5cbiAgICAgIGlmKCBmb3JjZWRQYW4gKXtcbiAgICAgICAgZWZmZWN0aXZlUGFuID0gZm9yY2VkUGFuO1xuICAgICAgfVxuXG4gICAgICAvLyBhcHBseSBwaXhlbCByYXRpb1xuXG4gICAgICBlZmZlY3RpdmVab29tICo9IHBpeGVsUmF0aW87XG4gICAgICBlZmZlY3RpdmVQYW4ueCAqPSBwaXhlbFJhdGlvO1xuICAgICAgZWZmZWN0aXZlUGFuLnkgKj0gcGl4ZWxSYXRpbztcbiAgICAgIFxuICAgICAgdmFyIGVsZXMgPSB7XG4gICAgICAgIGRyYWc6IHtcbiAgICAgICAgICBub2RlczogW10sXG4gICAgICAgICAgZWRnZXM6IFtdLFxuICAgICAgICAgIGVsZXM6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIG5vbmRyYWc6IHtcbiAgICAgICAgICBub2RlczogW10sXG4gICAgICAgICAgZWRnZXM6IFtdLFxuICAgICAgICAgIGVsZXM6IFtdXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIG1iY2xlYXIoIGNvbnRleHQsIHgsIHksIHcsIGggKXtcbiAgICAgICAgdmFyIGdjbyA9IGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uO1xuXG4gICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW91dCc7XG4gICAgICAgIHIuZmlsbFN0eWxlKCBjb250ZXh0LCAyNTUsIDI1NSwgMjU1LCByLm1vdGlvbkJsdXJUcmFuc3BhcmVuY3kgKTtcbiAgICAgICAgY29udGV4dC5maWxsUmVjdCh4LCB5LCB3LCBoKTtcblxuICAgICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGdjbztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc2V0Q29udGV4dFRyYW5zZm9ybShjb250ZXh0LCBjbGVhcil7XG4gICAgICAgIHZhciBlUGFuLCBlWm9vbSwgdywgaDtcblxuICAgICAgICBpZiggLyohci5mdWxsUXVhbGl0eU1iICYmKi8gIXIuY2xlYXJpbmdNb3Rpb25CbHVyICYmIChjb250ZXh0ID09PSBkYXRhLmJ1ZmZlckNvbnRleHRzW0NSLk1PVElPTkJMVVJfQlVGRkVSX05PREVdIHx8IGNvbnRleHQgPT09IGRhdGEuYnVmZmVyQ29udGV4dHNbQ1IuTU9USU9OQkxVUl9CVUZGRVJfRFJBR10pICl7XG4gICAgICAgICAgZVBhbiA9IHtcbiAgICAgICAgICAgIHg6IHBhbi54ICogbWJQeFJhdGlvLFxuICAgICAgICAgICAgeTogcGFuLnkgKiBtYlB4UmF0aW9cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgZVpvb20gPSB6b29tICogbWJQeFJhdGlvO1xuXG4gICAgICAgICAgdyA9IHIuY2FudmFzV2lkdGggKiBtYlB4UmF0aW87XG4gICAgICAgICAgaCA9IHIuY2FudmFzSGVpZ2h0ICogbWJQeFJhdGlvO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVQYW4gPSBlZmZlY3RpdmVQYW47XG4gICAgICAgICAgZVpvb20gPSBlZmZlY3RpdmVab29tO1xuXG4gICAgICAgICAgdyA9IHIuY2FudmFzV2lkdGg7XG4gICAgICAgICAgaCA9IHIuY2FudmFzSGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cbiAgICAgICAgaWYoIGNsZWFyID09PSAnbW90aW9uQmx1cicgKXsgXG4gICAgICAgICAgbWJjbGVhcihjb250ZXh0LCAwLCAwLCB3LCBoKTtcbiAgICAgICAgfSBlbHNlIGlmKCAhZm9yY2VkQ29udGV4dCAmJiAoY2xlYXIgPT09IHVuZGVmaW5lZCB8fCBjbGVhcikgKXtcbiAgICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB3LCBoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoICFkcmF3QWxsTGF5ZXJzICl7XG4gICAgICAgICAgY29udGV4dC50cmFuc2xhdGUoIGVQYW4ueCwgZVBhbi55ICk7XG4gICAgICAgICAgY29udGV4dC5zY2FsZSggZVpvb20sIGVab29tICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoIGZvcmNlZFBhbiApe1xuICAgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKCBmb3JjZWRQYW4ueCwgZm9yY2VkUGFuLnkgKTtcbiAgICAgICAgfSBcbiAgICAgICAgaWYoIGZvcmNlZFpvb20gKXtcbiAgICAgICAgICBjb250ZXh0LnNjYWxlKCBmb3JjZWRab29tLCBmb3JjZWRab29tICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoICF0ZXh0dXJlRHJhdyApe1xuICAgICAgICByLnRleHR1cmVEcmF3TGFzdEZyYW1lID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmKCB0ZXh0dXJlRHJhdyApe1xuICAgICAgICAvLyBjb25zb2xlLmxvZygndGV4dHVyZURyYXcnKVxuICAgICAgICBcbiAgICAgICAgci50ZXh0dXJlRHJhd0xhc3RGcmFtZSA9IHRydWU7XG5cbiAgICAgICAgdmFyIGJiO1xuXG4gICAgICAgIGlmKCAhci50ZXh0dXJlQ2FjaGUgKXtcbiAgICAgICAgICByLnRleHR1cmVDYWNoZSA9IHt9O1xuXG4gICAgICAgICAgYmIgPSByLnRleHR1cmVDYWNoZS5iYiA9IGN5LmVsZW1lbnRzKCkuYm91bmRpbmdCb3goKTtcblxuICAgICAgICAgIHIudGV4dHVyZUNhY2hlLnRleHR1cmUgPSByLmRhdGEuYnVmZmVyQ2FudmFzZXNbIENhbnZhc1JlbmRlcmVyLlRFWFRVUkVfQlVGRkVSIF07XG5cbiAgICAgICAgICB2YXIgY3h0ID0gci5kYXRhLmJ1ZmZlckNvbnRleHRzWyBDYW52YXNSZW5kZXJlci5URVhUVVJFX0JVRkZFUiBdO1xuXG4gICAgICAgICAgY3h0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgICBjeHQuY2xlYXJSZWN0KDAsIDAsIHIuY2FudmFzV2lkdGggKiByLnRleHR1cmVNdWx0LCByLmNhbnZhc0hlaWdodCAqIHIudGV4dHVyZU11bHQpO1xuICAgICAgICAgIFxuICAgICAgICAgIHIucmVkcmF3KHtcbiAgICAgICAgICAgIGZvcmNlZENvbnRleHQ6IGN4dCxcbiAgICAgICAgICAgIGRyYXdPbmx5Tm9kZUxheWVyOiB0cnVlLFxuICAgICAgICAgICAgZm9yY2VkUHhSYXRpbzogcGl4ZWxSYXRpbyAqIHIudGV4dHVyZU11bHRcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciB2cCA9IHIudGV4dHVyZUNhY2hlLnZpZXdwb3J0ID0ge1xuICAgICAgICAgICAgem9vbTogY3kuem9vbSgpLFxuICAgICAgICAgICAgcGFuOiBjeS5wYW4oKSxcbiAgICAgICAgICAgIHdpZHRoOiByLmNhbnZhc1dpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiByLmNhbnZhc0hlaWdodFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICB2cC5tcGFuID0ge1xuICAgICAgICAgICAgeDogKDAgLSB2cC5wYW4ueCkvdnAuem9vbSxcbiAgICAgICAgICAgIHk6ICgwIC0gdnAucGFuLnkpL3ZwLnpvb21cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgbmVlZERyYXdbQ1IuRFJBR10gPSBmYWxzZTtcbiAgICAgICAgbmVlZERyYXdbQ1IuTk9ERV0gPSBmYWxzZTtcblxuICAgICAgICB2YXIgY29udGV4dCA9IGRhdGEuY29udGV4dHNbQ1IuTk9ERV07XG5cbiAgICAgICAgdmFyIHRleHR1cmUgPSByLnRleHR1cmVDYWNoZS50ZXh0dXJlO1xuICAgICAgICB2YXIgdnAgPSByLnRleHR1cmVDYWNoZS52aWV3cG9ydDtcbiAgICAgICAgYmIgPSByLnRleHR1cmVDYWNoZS5iYjtcblxuICAgICAgICBjb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcblxuICAgICAgICBpZiggbW90aW9uQmx1ciApe1xuICAgICAgICAgIG1iY2xlYXIoY29udGV4dCwgMCwgMCwgdnAud2lkdGgsIHZwLmhlaWdodCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdnAud2lkdGgsIHZwLmhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3V0c2lkZUJnQ29sb3IgPSBjb3JlU3R5bGVbJ291dHNpZGUtdGV4dHVyZS1iZy1jb2xvciddLnZhbHVlO1xuICAgICAgICB2YXIgb3V0c2lkZUJnT3BhY2l0eSA9IGNvcmVTdHlsZVsnb3V0c2lkZS10ZXh0dXJlLWJnLW9wYWNpdHknXS52YWx1ZTtcbiAgICAgICAgci5maWxsU3R5bGUoIGNvbnRleHQsIG91dHNpZGVCZ0NvbG9yWzBdLCBvdXRzaWRlQmdDb2xvclsxXSwgb3V0c2lkZUJnQ29sb3JbMl0sIG91dHNpZGVCZ09wYWNpdHkgKTtcbiAgICAgICAgY29udGV4dC5maWxsUmVjdCggMCwgMCwgdnAud2lkdGgsIHZwLmhlaWdodCApO1xuXG4gICAgICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgICAgICBcbiAgICAgICAgc2V0Q29udGV4dFRyYW5zZm9ybSggY29udGV4dCwgZmFsc2UgKTtcblxuICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCggdnAubXBhbi54LCB2cC5tcGFuLnksIHZwLndpZHRoL3ZwLnpvb20vcGl4ZWxSYXRpbywgdnAuaGVpZ2h0L3ZwLnpvb20vcGl4ZWxSYXRpbyApO1xuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZSggdGV4dHVyZSwgdnAubXBhbi54LCB2cC5tcGFuLnksIHZwLndpZHRoL3ZwLnpvb20vcGl4ZWxSYXRpbywgdnAuaGVpZ2h0L3ZwLnpvb20vcGl4ZWxSYXRpbyApO1xuXG4gICAgICB9IGVsc2UgaWYoIHIudGV4dHVyZU9uVmlld3BvcnQgJiYgIWZvcmNlZENvbnRleHQgKXsgLy8gY2xlYXIgdGhlIGNhY2hlIHNpbmNlIHdlIGRvbid0IG5lZWQgaXRcbiAgICAgICAgci50ZXh0dXJlQ2FjaGUgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgdnBNYW5pcCA9IChyLnBpbmNoaW5nIHx8IHIuaG92ZXJEYXRhLmRyYWdnaW5nIHx8IHIuc3dpcGVQYW5uaW5nIHx8IHIuZGF0YS53aGVlbFpvb21pbmcgfHwgci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzKTtcbiAgICAgIHZhciBoaWRlRWRnZXMgPSByLmhpZGVFZGdlc09uVmlld3BvcnQgJiYgdnBNYW5pcDtcbiAgICAgIHZhciBoaWRlTGFiZWxzID0gci5oaWRlTGFiZWxzT25WaWV3cG9ydCAmJiB2cE1hbmlwO1xuXG4gICAgICBpZiAobmVlZERyYXdbQ1IuRFJBR10gfHwgbmVlZERyYXdbQ1IuTk9ERV0gfHwgZHJhd0FsbExheWVycyB8fCBkcmF3T25seU5vZGVMYXllcikge1xuICAgICAgICAvL05CIDogVkVSWSBFWFBFTlNJVkVcblxuICAgICAgICBpZiggaGlkZUVkZ2VzICl7IFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHIuZmluZEVkZ2VDb250cm9sUG9pbnRzKGVkZ2VzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB6RWxlcyA9IHIuZ2V0Q2FjaGVkWlNvcnRlZEVsZXMoKTtcbiAgICAgICAgdmFyIGV4dGVudCA9IGN5LmV4dGVudCgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgekVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWxlID0gekVsZXNbaV07XG4gICAgICAgICAgdmFyIGxpc3Q7XG4gICAgICAgICAgdmFyIGJiID0gZm9yY2VkQ29udGV4dCA/IG51bGwgOiBlbGUuYm91bmRpbmdCb3goKTtcbiAgICAgICAgICB2YXIgaW5zaWRlRXh0ZW50ID0gZm9yY2VkQ29udGV4dCA/IHRydWUgOiAkJC5tYXRoLmJvdW5kaW5nQm94ZXNJbnRlcnNlY3QoIGV4dGVudCwgYmIgKTtcblxuICAgICAgICAgIGlmKCAhaW5zaWRlRXh0ZW50ICl7IGNvbnRpbnVlOyB9IC8vIG5vIG5lZWQgdG8gcmVuZGVyXG5cbiAgICAgICAgICBpZiAoIGVsZS5fcHJpdmF0ZS5yc2NyYXRjaC5pbkRyYWdMYXllciApIHtcbiAgICAgICAgICAgIGxpc3QgPSBlbGVzLmRyYWc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpc3QgPSBlbGVzLm5vbmRyYWc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGlzdC5lbGVzLnB1c2goIGVsZSApO1xuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICAgIFxuICAgICAgXG4gICAgICBmdW5jdGlvbiBkcmF3RWxlbWVudHMoIGxpc3QsIGNvbnRleHQgKXtcbiAgICAgICAgdmFyIGVsZXMgPSBsaXN0LmVsZXM7XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICAgICAgICBpZiggZWxlLmlzTm9kZSgpICl7XG4gICAgICAgICAgICByLmRyYXdOb2RlKGNvbnRleHQsIGVsZSk7XG5cbiAgICAgICAgICAgIGlmKCAhaGlkZUxhYmVscyApe1xuICAgICAgICAgICAgICByLmRyYXdOb2RlVGV4dChjb250ZXh0LCBlbGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByLmRyYXdOb2RlKGNvbnRleHQsIGVsZSwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmKCAhaGlkZUVkZ2VzICkge1xuICAgICAgICAgICAgci5kcmF3RWRnZShjb250ZXh0LCBlbGUpO1xuXG4gICAgICAgICAgICBpZiggIWhpZGVMYWJlbHMgKXtcbiAgICAgICAgICAgICAgci5kcmF3RWRnZVRleHQoY29udGV4dCwgZWxlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgci5kcmF3RWRnZShjb250ZXh0LCBlbGUsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIHZhciBuZWVkTWJDbGVhciA9IFtdO1xuXG4gICAgICBuZWVkTWJDbGVhcltDUi5OT0RFXSA9ICFuZWVkRHJhd1tDUi5OT0RFXSAmJiBtb3Rpb25CbHVyICYmICFyLmNsZWFyZWRGb3JNb3Rpb25CbHVyW0NSLk5PREVdIHx8IHIuY2xlYXJpbmdNb3Rpb25CbHVyO1xuICAgICAgaWYoIG5lZWRNYkNsZWFyW0NSLk5PREVdICl7IHIuY2xlYXJlZEZvck1vdGlvbkJsdXJbQ1IuTk9ERV0gPSB0cnVlOyB9XG5cbiAgICAgIG5lZWRNYkNsZWFyW0NSLkRSQUddID0gIW5lZWREcmF3W0NSLkRSQUddICYmIG1vdGlvbkJsdXIgJiYgIXIuY2xlYXJlZEZvck1vdGlvbkJsdXJbQ1IuRFJBR10gfHwgci5jbGVhcmluZ01vdGlvbkJsdXI7XG4gICAgICBpZiggbmVlZE1iQ2xlYXJbQ1IuRFJBR10gKXsgci5jbGVhcmVkRm9yTW90aW9uQmx1cltDUi5EUkFHXSA9IHRydWU7IH1cblxuICAgICAgLy8gY29uc29sZS5sb2coJy0tJyk7XG5cbiAgICAgIC8vIGlmKCBuZWVkRHJhd1tDUi5EUkFHXSAmJiBtb3Rpb25CbHVyICYmIG5lZWREcmF3W0NSLk5PREVdICYmIGluTm9kZURyYWdHZXN0dXJlICl7XG4gICAgICAvLyAgIGNvbnNvbGUubG9nKCdOT0RFIGJsdXJjbGVhbicpO1xuICAgICAgLy8gXG4gICAgICAvLyAgIHZhciBjb250ZXh0ID0gZGF0YS5jb250ZXh0c1tDUi5OT0RFXTtcbiAgICAgIC8vIFxuICAgICAgLy8gICBzZXRDb250ZXh0VHJhbnNmb3JtKCBjb250ZXh0LCB0cnVlICk7XG4gICAgICAvLyAgIGRyYXdFbGVtZW50cyhlbGVzLm5vbmRyYWcsIGNvbnRleHQpO1xuICAgICAgLy8gXG4gICAgICAvLyAgIG5lZWREcmF3W0NSLk5PREVdID0gZmFsc2U7IFxuICAgICAgLy8gICBuZWVkTWJDbGVhcltDUi5OT0RFXSA9IGZhbHNlO1xuICAgICAgLy8gXG4gICAgICAvLyB9IGVsc2UgXG4gICAgICBpZiggbmVlZERyYXdbQ1IuTk9ERV0gfHwgZHJhd0FsbExheWVycyB8fCBkcmF3T25seU5vZGVMYXllciB8fCBuZWVkTWJDbGVhcltDUi5OT0RFXSApe1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnTk9ERScsIG5lZWREcmF3W0NSLk5PREVdLCBuZWVkTWJDbGVhcltDUi5OT0RFXSk7XG5cbiAgICAgICAgdmFyIHVzZUJ1ZmZlciA9IG1vdGlvbkJsdXIgJiYgIW5lZWRNYkNsZWFyW0NSLk5PREVdICYmIG1iUHhSYXRpbyAhPT0gMTtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBmb3JjZWRDb250ZXh0IHx8ICggdXNlQnVmZmVyID8gci5kYXRhLmJ1ZmZlckNvbnRleHRzWyBDUi5NT1RJT05CTFVSX0JVRkZFUl9OT0RFIF0gOiBkYXRhLmNvbnRleHRzW0NSLk5PREVdICk7XG4gICAgICAgIHZhciBjbGVhciA9IG1vdGlvbkJsdXIgJiYgIXVzZUJ1ZmZlciA/ICdtb3Rpb25CbHVyJyA6IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyBpZiggbmVlZERyYXdbQ1IuRFJBR10gJiYgbmVlZERyYXdbQ1IuTk9ERV0gKXtcbiAgICAgICAgLy8gICBjbGVhciA9IHRydWU7XG4gICAgICAgIC8vIH1cblxuICAgICAgICBzZXRDb250ZXh0VHJhbnNmb3JtKCBjb250ZXh0LCBjbGVhciApO1xuICAgICAgICBkcmF3RWxlbWVudHMoZWxlcy5ub25kcmFnLCBjb250ZXh0KTtcbiAgICAgICAgXG4gICAgICAgIGlmKCAhZHJhd0FsbExheWVycyAmJiAhbW90aW9uQmx1ciApe1xuICAgICAgICAgIG5lZWREcmF3W0NSLk5PREVdID0gZmFsc2U7IFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICggIWRyYXdPbmx5Tm9kZUxheWVyICYmIChuZWVkRHJhd1tDUi5EUkFHXSB8fCBkcmF3QWxsTGF5ZXJzIHx8IG5lZWRNYkNsZWFyW0NSLkRSQUddKSApIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0RSQUcnKTtcblxuICAgICAgICB2YXIgdXNlQnVmZmVyID0gbW90aW9uQmx1ciAmJiAhbmVlZE1iQ2xlYXJbQ1IuRFJBR10gJiYgbWJQeFJhdGlvICE9PSAxO1xuICAgICAgICB2YXIgY29udGV4dCA9IGZvcmNlZENvbnRleHQgfHwgKCB1c2VCdWZmZXIgPyByLmRhdGEuYnVmZmVyQ29udGV4dHNbIENSLk1PVElPTkJMVVJfQlVGRkVSX0RSQUcgXSA6IGRhdGEuY29udGV4dHNbQ1IuRFJBR10gKTtcbiAgICAgICAgXG4gICAgICAgIHNldENvbnRleHRUcmFuc2Zvcm0oIGNvbnRleHQsIG1vdGlvbkJsdXIgJiYgIXVzZUJ1ZmZlciA/ICdtb3Rpb25CbHVyJyA6IHVuZGVmaW5lZCApO1xuICAgICAgICBkcmF3RWxlbWVudHMoZWxlcy5kcmFnLCBjb250ZXh0KTtcbiAgICAgICAgXG4gICAgICAgIGlmKCAhZHJhd0FsbExheWVycyAmJiAhbW90aW9uQmx1ciApe1xuICAgICAgICAgIG5lZWREcmF3W0NSLkRSQUddID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYoIHIuc2hvd0ZwcyB8fCAoIWRyYXdPbmx5Tm9kZUxheWVyICYmIChuZWVkRHJhd1tDUi5TRUxFQ1RfQk9YXSAmJiAhZHJhd0FsbExheWVycykpICkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygncmVkcmF3aW5nIHNlbGVjdGlvbiBib3gnKTtcbiAgICAgICAgXG4gICAgICAgIHZhciBjb250ZXh0ID0gZm9yY2VkQ29udGV4dCB8fCBkYXRhLmNvbnRleHRzW0NSLlNFTEVDVF9CT1hdO1xuXG4gICAgICAgIHNldENvbnRleHRUcmFuc2Zvcm0oIGNvbnRleHQgKTtcblxuICAgICAgICBpZiggZGF0YS5zZWxlY3RbNF0gPT0gMSAmJiAoIHIuaG92ZXJEYXRhLnNlbGVjdGluZyB8fCByLnRvdWNoRGF0YS5zZWxlY3RpbmcgKSApe1xuICAgICAgICAgIHZhciB6b29tID0gZGF0YS5jeS56b29tKCk7XG4gICAgICAgICAgdmFyIGJvcmRlcldpZHRoID0gY29yZVN0eWxlWydzZWxlY3Rpb24tYm94LWJvcmRlci13aWR0aCddLnZhbHVlIC8gem9vbTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoO1xuICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gXCJyZ2JhKFwiIFxuICAgICAgICAgICAgKyBjb3JlU3R5bGVbJ3NlbGVjdGlvbi1ib3gtY29sb3InXS52YWx1ZVswXSArIFwiLFwiXG4gICAgICAgICAgICArIGNvcmVTdHlsZVsnc2VsZWN0aW9uLWJveC1jb2xvciddLnZhbHVlWzFdICsgXCIsXCJcbiAgICAgICAgICAgICsgY29yZVN0eWxlWydzZWxlY3Rpb24tYm94LWNvbG9yJ10udmFsdWVbMl0gKyBcIixcIlxuICAgICAgICAgICAgKyBjb3JlU3R5bGVbJ3NlbGVjdGlvbi1ib3gtb3BhY2l0eSddLnZhbHVlICsgXCIpXCI7XG4gICAgICAgICAgXG4gICAgICAgICAgY29udGV4dC5maWxsUmVjdChcbiAgICAgICAgICAgIGRhdGEuc2VsZWN0WzBdLFxuICAgICAgICAgICAgZGF0YS5zZWxlY3RbMV0sXG4gICAgICAgICAgICBkYXRhLnNlbGVjdFsyXSAtIGRhdGEuc2VsZWN0WzBdLFxuICAgICAgICAgICAgZGF0YS5zZWxlY3RbM10gLSBkYXRhLnNlbGVjdFsxXSk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGJvcmRlcldpZHRoID4gMCkge1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IFwicmdiYShcIiBcbiAgICAgICAgICAgICAgKyBjb3JlU3R5bGVbJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJ10udmFsdWVbMF0gKyBcIixcIlxuICAgICAgICAgICAgICArIGNvcmVTdHlsZVsnc2VsZWN0aW9uLWJveC1ib3JkZXItY29sb3InXS52YWx1ZVsxXSArIFwiLFwiXG4gICAgICAgICAgICAgICsgY29yZVN0eWxlWydzZWxlY3Rpb24tYm94LWJvcmRlci1jb2xvciddLnZhbHVlWzJdICsgXCIsXCJcbiAgICAgICAgICAgICAgKyBjb3JlU3R5bGVbJ3NlbGVjdGlvbi1ib3gtb3BhY2l0eSddLnZhbHVlICsgXCIpXCI7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdChcbiAgICAgICAgICAgICAgZGF0YS5zZWxlY3RbMF0sXG4gICAgICAgICAgICAgIGRhdGEuc2VsZWN0WzFdLFxuICAgICAgICAgICAgICBkYXRhLnNlbGVjdFsyXSAtIGRhdGEuc2VsZWN0WzBdLFxuICAgICAgICAgICAgICBkYXRhLnNlbGVjdFszXSAtIGRhdGEuc2VsZWN0WzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiggZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiAmJiAhci5ob3ZlckRhdGEuc2VsZWN0aW5nICl7XG4gICAgICAgICAgdmFyIHpvb20gPSBkYXRhLmN5Lnpvb20oKTtcbiAgICAgICAgICB2YXIgcG9zID0gZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbjtcblxuICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gXCJyZ2JhKFwiIFxuICAgICAgICAgICAgKyBjb3JlU3R5bGVbJ2FjdGl2ZS1iZy1jb2xvciddLnZhbHVlWzBdICsgXCIsXCJcbiAgICAgICAgICAgICsgY29yZVN0eWxlWydhY3RpdmUtYmctY29sb3InXS52YWx1ZVsxXSArIFwiLFwiXG4gICAgICAgICAgICArIGNvcmVTdHlsZVsnYWN0aXZlLWJnLWNvbG9yJ10udmFsdWVbMl0gKyBcIixcIlxuICAgICAgICAgICAgKyBjb3JlU3R5bGVbJ2FjdGl2ZS1iZy1vcGFjaXR5J10udmFsdWUgKyBcIilcIjtcblxuICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgY29udGV4dC5hcmMocG9zLngsIHBvcy55LCBjb3JlU3R5bGVbJ2FjdGl2ZS1iZy1zaXplJ10ucHhWYWx1ZSAvIHpvb20sIDAsIDIgKiBNYXRoLlBJKTsgXG4gICAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciB0aW1lVG9SZW5kZXIgPSByLmF2ZXJhZ2VSZWRyYXdUaW1lO1xuICAgICAgICBpZiggci5zaG93RnBzICYmIHRpbWVUb1JlbmRlciApe1xuICAgICAgICAgIHRpbWVUb1JlbmRlciA9IE1hdGgucm91bmQoIHRpbWVUb1JlbmRlciApO1xuICAgICAgICAgIHZhciBmcHMgPSBNYXRoLnJvdW5kKDEwMDAvdGltZVRvUmVuZGVyKTtcblxuICAgICAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXG4gICAgICAgICAgLy9jb250ZXh0LmZvbnQgPSAnMjBweCBoZWx2ZXRpY2EnO1xuICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoMjU1LCAwLCAwLCAwLjc1KSc7XG4gICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwgMCwgMCwgMC43NSknO1xuICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gMTtcbiAgICAgICAgICBjb250ZXh0LmZpbGxUZXh0KCAnMSBmcmFtZSA9ICcgKyB0aW1lVG9SZW5kZXIgKyAnIG1zID0gJyArIGZwcyArICcgZnBzJywgMCwgMjApO1xuXG4gICAgICAgICAgdmFyIG1heEZwcyA9IDYwO1xuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdCgwLCAzMCwgMjUwLCAyMCk7XG4gICAgICAgICAgY29udGV4dC5maWxsUmVjdCgwLCAzMCwgMjUwICogTWF0aC5taW4oZnBzL21heEZwcywgMSksIDIwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCAhZHJhd0FsbExheWVycyApe1xuICAgICAgICAgIG5lZWREcmF3W0NSLlNFTEVDVF9CT1hdID0gZmFsc2U7IFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG1vdGlvbmJsdXI6IGJsaXQgcmVuZGVyZWQgYmx1cnJ5IGZyYW1lc1xuICAgICAgaWYoIG1vdGlvbkJsdXIgJiYgbWJQeFJhdGlvICE9PSAxICl7XG4gICAgICAgIHZhciBjeHROb2RlID0gZGF0YS5jb250ZXh0c1tDUi5OT0RFXTtcbiAgICAgICAgdmFyIHR4dE5vZGUgPSByLmRhdGEuYnVmZmVyQ2FudmFzZXNbIENSLk1PVElPTkJMVVJfQlVGRkVSX05PREUgXTtcblxuICAgICAgICB2YXIgY3h0RHJhZyA9IGRhdGEuY29udGV4dHNbQ1IuRFJBR107XG4gICAgICAgIHZhciB0eHREcmFnID0gci5kYXRhLmJ1ZmZlckNhbnZhc2VzWyBDUi5NT1RJT05CTFVSX0JVRkZFUl9EUkFHIF07XG5cbiAgICAgICAgdmFyIGRyYXdNb3Rpb25CbHVyID0gZnVuY3Rpb24oIGN4dCwgdHh0LCBuZWVkQ2xlYXIgKXtcbiAgICAgICAgICBjeHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXG4gICAgICAgICAgaWYoIG5lZWRDbGVhciB8fCAhbW90aW9uQmx1ckZhZGVFZmZlY3QgKXtcbiAgICAgICAgICAgIGN4dC5jbGVhclJlY3QoIDAsIDAsIHIuY2FudmFzV2lkdGgsIHIuY2FudmFzSGVpZ2h0ICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1iY2xlYXIoIGN4dCwgMCwgMCwgci5jYW52YXNXaWR0aCwgci5jYW52YXNIZWlnaHQgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgdmFyIHB4ciA9IC8qci5mdWxsUXVhbGl0eU1iID8gMSA6Ki8gbWJQeFJhdGlvO1xuXG4gICAgICAgICAgY3h0LmRyYXdJbWFnZSggXG4gICAgICAgICAgICB0eHQsIC8vIGltZ1xuICAgICAgICAgICAgMCwgMCwgLy8gc3gsIHN5XG4gICAgICAgICAgICByLmNhbnZhc1dpZHRoICogcHhyLCByLmNhbnZhc0hlaWdodCAqIHB4ciwgLy8gc3csIHNoXG4gICAgICAgICAgICAwLCAwLCAvLyB4LCB5XG4gICAgICAgICAgICByLmNhbnZhc1dpZHRoLCByLmNhbnZhc0hlaWdodCAvLyB3LCBoXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiggbmVlZERyYXdbQ1IuTk9ERV0gfHwgbmVlZE1iQ2xlYXJbQ1IuTk9ERV0gKXtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnbWIgTk9ERScsIG5lZWRNYkNsZWFyW0NSLk5PREVdKTtcblxuICAgICAgICAgIGRyYXdNb3Rpb25CbHVyKCBjeHROb2RlLCB0eHROb2RlLCBuZWVkTWJDbGVhcltDUi5OT0RFXSApO1xuICAgICAgICAgIG5lZWREcmF3W0NSLk5PREVdID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggbmVlZERyYXdbQ1IuRFJBR10gfHwgbmVlZE1iQ2xlYXJbQ1IuRFJBR10gKXtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnbWIgRFJBRycpO1xuXG4gICAgICAgICAgZHJhd01vdGlvbkJsdXIoIGN4dERyYWcsIHR4dERyYWcsIG5lZWRNYkNsZWFyW0NSLkRSQUddICk7XG4gICAgICAgICAgbmVlZERyYXdbQ1IuRFJBR10gPSBmYWxzZTtcbiAgICAgICAgICAvL25lZWRNYkNsZWFyW0NSLk5PREVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG5cbiAgICAgIHZhciBlbmRUaW1lID0gRGF0ZS5ub3coKTtcblxuICAgICAgaWYoIHIuYXZlcmFnZVJlZHJhd1RpbWUgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICByLmF2ZXJhZ2VSZWRyYXdUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgIH1cblxuICAgICAgaWYoIHIucmVkcmF3Q291bnQgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICByLnJlZHJhd0NvdW50ID0gMDtcbiAgICAgIH1cblxuICAgICAgci5yZWRyYXdDb3VudCsrO1xuXG4gICAgICBpZiggci5yZWRyYXdUb3RhbFRpbWUgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICByLnJlZHJhd1RvdGFsVGltZSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHIucmVkcmF3VG90YWxUaW1lICs9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICByLmxhc3RSZWRyYXdUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcblxuICAgICAgLy8gdXNlIGEgd2VpZ2h0ZWQgYXZlcmFnZSB3aXRoIGEgYmlhcyBmcm9tIHRoZSBwcmV2aW91cyBhdmVyYWdlIHNvIHdlIGRvbid0IHNwaWtlIHNvIGVhc2lseVxuICAgICAgci5hdmVyYWdlUmVkcmF3VGltZSA9IHIuYXZlcmFnZVJlZHJhd1RpbWUvMiArIChlbmRUaW1lIC0gc3RhcnRUaW1lKS8yO1xuICAgICAgLy9jb25zb2xlLmxvZygnYWN0dWFsOiAlaSwgYXZlcmFnZTogJWknLCBlbmRUaW1lIC0gc3RhcnRUaW1lLCB0aGlzLmF2ZXJhZ2VSZWRyYXdUaW1lKTtcblxuICAgICAgci5jdXJyZW50bHlEcmF3aW5nID0gZmFsc2U7XG5cbiAgICAgIHIucHJldlZpZXdwb3J0ID0gdnA7XG5cbiAgICAgIC8vIGNvbnNvbGUucHJvZmlsZUVuZCgnZHJhdycgKyBzdGFydFRpbWUpXG5cbiAgICAgIGlmKCByLmNsZWFyaW5nTW90aW9uQmx1ciApe1xuICAgICAgICByLmNsZWFyaW5nTW90aW9uQmx1ciA9IGZhbHNlO1xuICAgICAgICByLm1vdGlvbkJsdXJDbGVhcmVkID0gdHJ1ZTtcbiAgICAgICAgci5tb3Rpb25CbHVyID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYoIG1vdGlvbkJsdXIgKXsgXG4gICAgICAgIHIubW90aW9uQmx1clRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgci5tb3Rpb25CbHVyVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ21iIENMRUFSJyk7XG5cbiAgICAgICAgICByLmNsZWFyZWRGb3JNb3Rpb25CbHVyW0NSLk5PREVdID0gZmFsc2U7XG4gICAgICAgICAgci5jbGVhcmVkRm9yTW90aW9uQmx1cltDUi5EUkFHXSA9IGZhbHNlO1xuICAgICAgICAgIHIubW90aW9uQmx1ciA9IGZhbHNlO1xuICAgICAgICAgIHIuY2xlYXJpbmdNb3Rpb25CbHVyID0gIXRleHR1cmVEcmF3O1xuICAgICAgICAgIHIubWJGcmFtZXMgPSAwO1xuXG4gICAgICAgICAgbmVlZERyYXdbQ1IuTk9ERV0gPSB0cnVlOyBcbiAgICAgICAgICBuZWVkRHJhd1tDUi5EUkFHXSA9IHRydWU7IFxuXG4gICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgfSwgQ2FudmFzUmVuZGVyZXIubW90aW9uQmx1ckRlbGF5KTtcbiAgICAgIH1cblxuICAgICAgci5kcmF3aW5nSW1hZ2UgPSBmYWxzZTtcblxuICAgIH0gLy8gZHJhdyB0byBjb250ZXh0XG5cbiAgICBpZiggIWZvcmNlZENvbnRleHQgKXtcbiAgICAgICQkLnV0aWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGRyYXdUb0NvbnRleHQpOyAvLyBtYWtlcyBkaXJlY3QgcmVuZGVycyB0byBzY3JlZW4gYSBiaXQgbW9yZSByZXNwb25zaXZlXG4gICAgfSBlbHNlIHtcbiAgICAgIGRyYXdUb0NvbnRleHQoKTtcbiAgICB9XG5cbiAgICBpZiggIWZvcmNlZENvbnRleHQgJiYgIXIuaW5pdHJlbmRlciApe1xuICAgICAgci5pbml0cmVuZGVyID0gdHJ1ZTtcbiAgICAgIGN5LnRyaWdnZXIoJ2luaXRyZW5kZXInKTtcbiAgICB9XG5cbiAgICBpZiggIWZvcmNlZENvbnRleHQgKXtcbiAgICAgIGN5LnRyaWdnZXJPblJlbmRlcigpO1xuICAgIH1cbiAgICBcbiAgfTtcblxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBDYW52YXNSZW5kZXJlciA9ICQkKCdyZW5kZXJlcicsICdjYW52YXMnKTtcbiAgdmFyIENScCA9IENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZTtcblxuICAvLyBATyBQb2x5Z29uIGRyYXdpbmdcbiAgQ1JwLmRyYXdQb2x5Z29uUGF0aCA9IGZ1bmN0aW9uKFxuICAgIGNvbnRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHBvaW50cykge1xuXG4gICAgdmFyIGhhbGZXID0gd2lkdGggLyAyO1xuICAgIHZhciBoYWxmSCA9IGhlaWdodCAvIDI7XG5cbiAgICBpZiggY29udGV4dC5iZWdpblBhdGggKXsgY29udGV4dC5iZWdpblBhdGgoKTsgfVxuXG4gICAgY29udGV4dC5tb3ZlVG8oIHggKyBoYWxmVyAqIHBvaW50c1swXSwgeSArIGhhbGZIICogcG9pbnRzWzFdICk7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgIGNvbnRleHQubGluZVRvKCB4ICsgaGFsZlcgKiBwb2ludHNbaSAqIDJdLCB5ICsgaGFsZkggKiBwb2ludHNbaSAqIDIgKyAxXSApO1xuICAgIH1cbiAgICBcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9O1xuICBcbiAgQ1JwLmRyYXdQb2x5Z29uID0gZnVuY3Rpb24oXG4gICAgY29udGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgcG9pbnRzKSB7XG5cbiAgICAvLyBEcmF3IHBhdGhcbiAgICB0aGlzLmRyYXdQb2x5Z29uUGF0aChjb250ZXh0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBwb2ludHMpO1xuICAgIFxuICAgIC8vIEZpbGwgcGF0aFxuICAgIGNvbnRleHQuZmlsbCgpO1xuICB9O1xuICBcbiAgLy8gUm91bmQgcmVjdGFuZ2xlIGRyYXdpbmdcbiAgQ1JwLmRyYXdSb3VuZFJlY3RhbmdsZVBhdGggPSBmdW5jdGlvbihcbiAgICBjb250ZXh0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpIHtcbiAgICBcbiAgICB2YXIgaGFsZldpZHRoID0gd2lkdGggLyAyO1xuICAgIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcbiAgICB2YXIgY29ybmVyUmFkaXVzID0gJCQubWF0aC5nZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyh3aWR0aCwgaGVpZ2h0KTtcbiAgICBcbiAgICBpZiggY29udGV4dC5iZWdpblBhdGggKXsgY29udGV4dC5iZWdpblBhdGgoKTsgfVxuICAgIFxuICAgIC8vIFN0YXJ0IGF0IHRvcCBtaWRkbGVcbiAgICBjb250ZXh0Lm1vdmVUbyh4LCB5IC0gaGFsZkhlaWdodCk7XG4gICAgLy8gQXJjIGZyb20gbWlkZGxlIHRvcCB0byByaWdodCBzaWRlXG4gICAgY29udGV4dC5hcmNUbyh4ICsgaGFsZldpZHRoLCB5IC0gaGFsZkhlaWdodCwgeCArIGhhbGZXaWR0aCwgeSwgY29ybmVyUmFkaXVzKTtcbiAgICAvLyBBcmMgZnJvbSByaWdodCBzaWRlIHRvIGJvdHRvbVxuICAgIGNvbnRleHQuYXJjVG8oeCArIGhhbGZXaWR0aCwgeSArIGhhbGZIZWlnaHQsIHgsIHkgKyBoYWxmSGVpZ2h0LCBjb3JuZXJSYWRpdXMpO1xuICAgIC8vIEFyYyBmcm9tIGJvdHRvbSB0byBsZWZ0IHNpZGVcbiAgICBjb250ZXh0LmFyY1RvKHggLSBoYWxmV2lkdGgsIHkgKyBoYWxmSGVpZ2h0LCB4IC0gaGFsZldpZHRoLCB5LCBjb3JuZXJSYWRpdXMpO1xuICAgIC8vIEFyYyBmcm9tIGxlZnQgc2lkZSB0byB0b3BCb3JkZXJcbiAgICBjb250ZXh0LmFyY1RvKHggLSBoYWxmV2lkdGgsIHkgLSBoYWxmSGVpZ2h0LCB4LCB5IC0gaGFsZkhlaWdodCwgY29ybmVyUmFkaXVzKTtcbiAgICAvLyBKb2luIGxpbmVcbiAgICBjb250ZXh0LmxpbmVUbyh4LCB5IC0gaGFsZkhlaWdodCk7XG4gICAgXG4gICAgXG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfTtcbiAgXG4gIENScC5kcmF3Um91bmRSZWN0YW5nbGUgPSBmdW5jdGlvbihcbiAgICBjb250ZXh0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpIHtcbiAgICBcbiAgICB0aGlzLmRyYXdSb3VuZFJlY3RhbmdsZVBhdGgoY29udGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKTtcbiAgICBcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgfTtcblxuXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIENhbnZhc1JlbmRlcmVyID0gJCQoJ3JlbmRlcmVyJywgJ2NhbnZhcycpO1xuICB2YXIgQ1JwID0gQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlO1xuXG4gIENScC5jcmVhdGVCdWZmZXIgPSBmdW5jdGlvbih3LCBoKSB7XG4gICAgdmFyIGJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGJ1ZmZlci53aWR0aCA9IHc7XG4gICAgYnVmZmVyLmhlaWdodCA9IGg7XG4gICAgXG4gICAgcmV0dXJuIFtidWZmZXIsIGJ1ZmZlci5nZXRDb250ZXh0KCcyZCcpXTtcbiAgfTtcblxuICBDUnAuYnVmZmVyQ2FudmFzSW1hZ2UgPSBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIHZhciBjeSA9IGRhdGEuY3k7XG4gICAgdmFyIGJiID0gY3kuZWxlbWVudHMoKS5ib3VuZGluZ0JveCgpO1xuICAgIHZhciB3aWR0aCA9IG9wdGlvbnMuZnVsbCA/IE1hdGguY2VpbChiYi53KSA6IHRoaXMuZGF0YS5jb250YWluZXIuY2xpZW50V2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IG9wdGlvbnMuZnVsbCA/IE1hdGguY2VpbChiYi5oKSA6IHRoaXMuZGF0YS5jb250YWluZXIuY2xpZW50SGVpZ2h0O1xuICAgIHZhciBzY2FsZSA9IDE7XG5cbiAgICBpZiggb3B0aW9ucy5zY2FsZSAhPT0gdW5kZWZpbmVkICl7XG4gICAgICB3aWR0aCAqPSBvcHRpb25zLnNjYWxlO1xuICAgICAgaGVpZ2h0ICo9IG9wdGlvbnMuc2NhbGU7XG5cbiAgICAgIHNjYWxlID0gb3B0aW9ucy5zY2FsZTtcbiAgICB9IGVsc2UgaWYoICQkLmlzLm51bWJlcihvcHRpb25zLm1heFdpZHRoKSB8fCAkJC5pcy5udW1iZXIob3B0aW9ucy5tYXhIZWlnaHQpICl7XG4gICAgICB2YXIgbWF4U2NhbGVXID0gSW5maW5pdHk7XG4gICAgICB2YXIgbWF4U2NhbGVIID0gSW5maW5pdHk7XG5cbiAgICAgIGlmKCAkJC5pcy5udW1iZXIob3B0aW9ucy5tYXhXaWR0aCkgKXtcbiAgICAgICAgbWF4U2NhbGVXID0gc2NhbGUgKiBvcHRpb25zLm1heFdpZHRoIC8gd2lkdGg7XG4gICAgICB9XG5cbiAgICAgIGlmKCAkJC5pcy5udW1iZXIob3B0aW9ucy5tYXhIZWlnaHQpICl7XG4gICAgICAgIG1heFNjYWxlSCA9IHNjYWxlICogb3B0aW9ucy5tYXhIZWlnaHQgLyBoZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIHNjYWxlID0gTWF0aC5taW4oIG1heFNjYWxlVywgbWF4U2NhbGVIICk7XG5cbiAgICAgIHdpZHRoICo9IHNjYWxlO1xuICAgICAgaGVpZ2h0ICo9IHNjYWxlO1xuICAgIH1cblxuICAgIHZhciBidWZmQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cbiAgICBidWZmQ2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgYnVmZkNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICBidWZmQ2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgIGJ1ZmZDYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcblxuICAgIHZhciBidWZmQ3h0ID0gYnVmZkNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgLy8gUmFzdGVyaXplIHRoZSBsYXllcnMsIGJ1dCBvbmx5IGlmIGNvbnRhaW5lciBoYXMgbm9uemVybyBzaXplXG4gICAgaWYgKHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwKSB7XG5cbiAgICAgIGJ1ZmZDeHQuY2xlYXJSZWN0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XG5cbiAgICAgIGlmKCBvcHRpb25zLmJnICl7XG4gICAgICAgIGJ1ZmZDeHQuZmlsbFN0eWxlID0gb3B0aW9ucy5iZztcbiAgICAgICAgYnVmZkN4dC5yZWN0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XG4gICAgICAgIGJ1ZmZDeHQuZmlsbCgpO1xuICAgICAgfVxuXG4gICAgICBidWZmQ3h0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdzb3VyY2Utb3Zlcic7XG5cbiAgICAgIGlmKCBvcHRpb25zLmZ1bGwgKXsgLy8gZHJhdyB0aGUgZnVsbCBib3VuZHMgb2YgdGhlIGdyYXBoXG4gICAgICAgIHRoaXMucmVkcmF3KHtcbiAgICAgICAgICBmb3JjZWRDb250ZXh0OiBidWZmQ3h0LFxuICAgICAgICAgIGRyYXdBbGxMYXllcnM6IHRydWUsXG4gICAgICAgICAgZm9yY2VkWm9vbTogc2NhbGUsXG4gICAgICAgICAgZm9yY2VkUGFuOiB7IHg6IC1iYi54MSpzY2FsZSwgeTogLWJiLnkxKnNjYWxlIH0sXG4gICAgICAgICAgZm9yY2VkUHhSYXRpbzogMVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7IC8vIGRyYXcgdGhlIGN1cnJlbnQgdmlld1xuICAgICAgICB2YXIgY3lQYW4gPSBjeS5wYW4oKTtcbiAgICAgICAgdmFyIHBhbiA9IHtcbiAgICAgICAgICB4OiBjeVBhbi54ICogc2NhbGUsXG4gICAgICAgICAgeTogY3lQYW4ueSAqIHNjYWxlXG4gICAgICAgIH07XG4gICAgICAgIHZhciB6b29tID0gY3kuem9vbSgpICogc2NhbGU7XG5cbiAgICAgICAgdGhpcy5yZWRyYXcoe1xuICAgICAgICAgIGZvcmNlZENvbnRleHQ6IGJ1ZmZDeHQsXG4gICAgICAgICAgZHJhd0FsbExheWVyczogdHJ1ZSxcbiAgICAgICAgICBmb3JjZWRab29tOiB6b29tLFxuICAgICAgICAgIGZvcmNlZFBhbjogcGFuLFxuICAgICAgICAgIGZvcmNlZFB4UmF0aW86IDFcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZDYW52YXM7XG4gIH07IFxuXG4gIENScC5wbmcgPSBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlckNhbnZhc0ltYWdlKCBvcHRpb25zICkudG9EYXRhVVJMKCdpbWFnZS9wbmcnKTtcbiAgfTtcbiAgXG4gIENScC5qcGcgPSBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlckNhbnZhc0ltYWdlKCBvcHRpb25zICkudG9EYXRhVVJMKCdpbWFnZS9qcGVnJyk7XG4gIH07XG5cbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgQ2FudmFzUmVuZGVyZXIgPSAkJCgncmVuZGVyZXInLCAnY2FudmFzJyk7XG4gIHZhciBDUiA9IENhbnZhc1JlbmRlcmVyO1xuICB2YXIgQ1JwID0gQ1IucHJvdG90eXBlO1xuXG4gIENScC5yZWdpc3RlckJpbmRpbmcgPSBmdW5jdGlvbih0YXJnZXQsIGV2ZW50LCBoYW5kbGVyLCB1c2VDYXB0dXJlKXtcbiAgICB0aGlzLmJpbmRpbmdzLnB1c2goe1xuICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICBldmVudDogZXZlbnQsXG4gICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgdXNlQ2FwdHVyZTogdXNlQ2FwdHVyZVxuICAgIH0pO1xuXG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIHVzZUNhcHR1cmUpO1xuICB9O1xuXG4gIENScC5ub2RlSXNEcmFnZ2FibGUgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKG5vZGUuX3ByaXZhdGUuc3R5bGVbJ29wYWNpdHknXS52YWx1ZSAhPT0gMFxuICAgICAgJiYgbm9kZS5fcHJpdmF0ZS5zdHlsZVsndmlzaWJpbGl0eSddLnZhbHVlID09ICd2aXNpYmxlJ1xuICAgICAgJiYgbm9kZS5fcHJpdmF0ZS5zdHlsZVsnZGlzcGxheSddLnZhbHVlID09ICdlbGVtZW50J1xuICAgICAgJiYgIW5vZGUubG9ja2VkKClcbiAgICAgICYmIG5vZGUuZ3JhYmJhYmxlKCkgKSB7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBDUnAubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByID0gdGhpcztcblxuICAgIHZhciBnZXREcmFnTGlzdElkcyA9IGZ1bmN0aW9uKG9wdHMpe1xuICAgICAgdmFyIGxpc3RIYXNJZDtcblxuICAgICAgaWYoIG9wdHMuYWRkVG9MaXN0ICYmIHIuZGF0YS5jeS5oYXNDb21wb3VuZE5vZGVzKCkgKXsgLy8gb25seSBuZWVkZWQgZm9yIGNvbXBvdW5kIGdyYXBoc1xuICAgICAgICBpZiggIW9wdHMuYWRkVG9MaXN0Lmhhc0lkICl7IC8vIGJ1aWxkIGlkcyBsb29rdXAgaWYgZG9lc24ndCBhbHJlYWR5IGV4aXN0XG4gICAgICAgICAgb3B0cy5hZGRUb0xpc3QuaGFzSWQgPSB7fTtcblxuICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgb3B0cy5hZGRUb0xpc3QubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgIHZhciBlbGUgPSBvcHRzLmFkZFRvTGlzdFtpXTtcblxuICAgICAgICAgICAgb3B0cy5hZGRUb0xpc3QuaGFzSWRbIGVsZS5pZCgpIF0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxpc3RIYXNJZCA9IG9wdHMuYWRkVG9MaXN0Lmhhc0lkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGlzdEhhc0lkIHx8IHt9O1xuICAgIH07XG5cbiAgICAvLyBoZWxwZXIgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHdoaWNoIGNoaWxkIG5vZGVzIGFuZCBpbm5lciBlZGdlc1xuICAgIC8vIG9mIGEgY29tcG91bmQgbm9kZSB0byBiZSBkcmFnZ2VkIGFzIHdlbGwgYXMgdGhlIGdyYWJiZWQgYW5kIHNlbGVjdGVkIG5vZGVzXG4gICAgdmFyIGFkZERlc2NlbmRhbnRzVG9EcmFnID0gZnVuY3Rpb24obm9kZSwgb3B0cyl7XG4gICAgICBpZiggIW5vZGUuX3ByaXZhdGUuY3kuaGFzQ29tcG91bmROb2RlcygpICl7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYoIG9wdHMuaW5EcmFnTGF5ZXIgPT0gbnVsbCAmJiBvcHRzLmFkZFRvTGlzdCA9PSBudWxsICl7IHJldHVybjsgfSAvLyBub3RoaW5nIHRvIGRvXG5cbiAgICAgIHZhciBsaXN0SGFzSWQgPSBnZXREcmFnTGlzdElkcyggb3B0cyApO1xuXG4gICAgICB2YXIgaW5uZXJOb2RlcyA9IG5vZGUuZGVzY2VuZGFudHMoKTtcblxuICAgICAgLy8gVE9ETyBkbyBub3QgZHJhZyBoaWRkZW4gY2hpbGRyZW4gJiBjaGlsZHJlbiBvZiBoaWRkZW4gY2hpbGRyZW4/XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGlubmVyTm9kZXMuc2l6ZSgpOyBpKysgKXtcbiAgICAgICAgdmFyIGlOb2RlID0gaW5uZXJOb2Rlc1tpXTtcbiAgICAgICAgdmFyIF9wID0gaU5vZGUuX3ByaXZhdGU7XG5cbiAgICAgICAgaWYoIG9wdHMuaW5EcmFnTGF5ZXIgKXtcbiAgICAgICAgICBfcC5yc2NyYXRjaC5pbkRyYWdMYXllciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggb3B0cy5hZGRUb0xpc3QgJiYgIWxpc3RIYXNJZFsgaU5vZGUuaWQoKSBdICl7XG4gICAgICAgICAgb3B0cy5hZGRUb0xpc3QucHVzaCggaU5vZGUgKTtcbiAgICAgICAgICBsaXN0SGFzSWRbIGlOb2RlLmlkKCkgXSA9IHRydWU7XG5cbiAgICAgICAgICBfcC5ncmFiYmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlZGdlcyA9IF9wLmVkZ2VzO1xuICAgICAgICBmb3IoIHZhciBqID0gMDsgb3B0cy5pbkRyYWdMYXllciAmJiBqIDwgZWRnZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICBlZGdlc1tqXS5fcHJpdmF0ZS5yc2NyYXRjaC5pbkRyYWdMYXllciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gYWRkcyB0aGUgZ2l2ZW4gbm9kZXMsIGFuZCBpdHMgZWRnZXMgdG8gdGhlIGRyYWcgbGF5ZXJcbiAgICB2YXIgYWRkTm9kZVRvRHJhZyA9IGZ1bmN0aW9uKG5vZGUsIG9wdHMpe1xuXG4gICAgICB2YXIgX3AgPSBub2RlLl9wcml2YXRlO1xuICAgICAgdmFyIGxpc3RIYXNJZCA9IGdldERyYWdMaXN0SWRzKCBvcHRzICk7XG5cbiAgICAgIGlmKCBvcHRzLmluRHJhZ0xheWVyICl7XG4gICAgICAgIF9wLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYoIG9wdHMuYWRkVG9MaXN0ICYmICFsaXN0SGFzSWRbIG5vZGUuaWQoKSBdICl7XG4gICAgICAgIG9wdHMuYWRkVG9MaXN0LnB1c2goIG5vZGUgKTtcbiAgICAgICAgbGlzdEhhc0lkWyBub2RlLmlkKCkgXSA9IHRydWU7XG5cbiAgICAgICAgX3AuZ3JhYmJlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBlZGdlcyA9IF9wLmVkZ2VzO1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IG9wdHMuaW5EcmFnTGF5ZXIgJiYgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIGVkZ2VzW2ldLl9wcml2YXRlLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgYWRkRGVzY2VuZGFudHNUb0RyYWcoIG5vZGUsIG9wdHMgKTsgLy8gYWx3YXlzIGFkZCB0byBkcmFnXG5cbiAgICAgIC8vIGFsc28gYWRkIG5vZGVzIGFuZCBlZGdlcyByZWxhdGVkIHRvIHRoZSB0b3Btb3N0IGFuY2VzdG9yXG4gICAgICB1cGRhdGVBbmNlc3RvcnNJbkRyYWdMYXllciggbm9kZSwge1xuICAgICAgICBpbkRyYWdMYXllcjogb3B0cy5pbkRyYWdMYXllclxuICAgICAgfSApO1xuICAgIH07XG4gICAgXG4gICAgdmFyIGZyZWVEcmFnZ2VkRWxlbWVudHMgPSBmdW5jdGlvbiggZHJhZ2dlZEVsZW1lbnRzICl7XG4gICAgICBpZiggIWRyYWdnZWRFbGVtZW50cyApeyByZXR1cm47IH1cbiAgICAgIFxuICAgICAgZm9yICh2YXIgaT0wOyBpIDwgZHJhZ2dlZEVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgdmFyIGRFaV9wID0gZHJhZ2dlZEVsZW1lbnRzW2ldLl9wcml2YXRlO1xuXG4gICAgICAgIGlmKGRFaV9wLmdyb3VwID09PSAnbm9kZXMnKSB7XG4gICAgICAgICAgZEVpX3AucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSBmYWxzZTtcbiAgICAgICAgICBkRWlfcC5ncmFiYmVkID0gZmFsc2U7XG5cbiAgICAgICAgICB2YXIgc0VkZ2VzID0gZEVpX3AuZWRnZXM7XG4gICAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBzRWRnZXMubGVuZ3RoOyBqKysgKXsgc0VkZ2VzW2pdLl9wcml2YXRlLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gZmFsc2U7IH1cblxuICAgICAgICAgIC8vIGZvciBjb21wb3VuZCBub2RlcywgYWxzbyByZW1vdmUgcmVsYXRlZCBub2RlcyBhbmQgZWRnZXMgZnJvbSB0aGUgZHJhZyBsYXllclxuICAgICAgICAgIHVwZGF0ZUFuY2VzdG9yc0luRHJhZ0xheWVyKGRyYWdnZWRFbGVtZW50c1tpXSwgeyBpbkRyYWdMYXllcjogZmFsc2UgfSk7XG5cbiAgICAgICAgfSBlbHNlIGlmKCBkRWlfcC5ncm91cCA9PT0gJ2VkZ2VzJyApe1xuICAgICAgICAgIGRFaV9wLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBoZWxwZXIgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHdoaWNoIGFuY2VzdG9yIG5vZGVzIGFuZCBlZGdlcyBzaG91bGQgZ29cbiAgICAvLyB0byB0aGUgZHJhZyBsYXllciAob3Igc2hvdWxkIGJlIHJlbW92ZWQgZnJvbSBkcmFnIGxheWVyKS5cbiAgICB2YXIgdXBkYXRlQW5jZXN0b3JzSW5EcmFnTGF5ZXIgPSBmdW5jdGlvbihub2RlLCBvcHRzKSB7XG5cbiAgICAgIGlmKCBvcHRzLmluRHJhZ0xheWVyID09IG51bGwgJiYgb3B0cy5hZGRUb0xpc3QgPT0gbnVsbCApeyByZXR1cm47IH0gLy8gbm90aGluZyB0byBkb1xuXG4gICAgICAvLyBmaW5kIHRvcC1sZXZlbCBwYXJlbnRcbiAgICAgIHZhciBwYXJlbnQgPSBub2RlO1xuXG4gICAgICBpZiggIW5vZGUuX3ByaXZhdGUuY3kuaGFzQ29tcG91bmROb2RlcygpICl7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgd2hpbGUoIHBhcmVudC5wYXJlbnQoKS5ub25lbXB0eSgpICl7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQoKVswXTtcbiAgICAgIH1cblxuICAgICAgLy8gbm8gcGFyZW50IG5vZGU6IG5vIG5vZGVzIHRvIGFkZCB0byB0aGUgZHJhZyBsYXllclxuICAgICAgaWYoIHBhcmVudCA9PSBub2RlICl7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vZGVzID0gcGFyZW50LmRlc2NlbmRhbnRzKClcbiAgICAgICAgLm1lcmdlKCBwYXJlbnQgKVxuICAgICAgICAudW5tZXJnZSggbm9kZSApXG4gICAgICAgIC51bm1lcmdlKCBub2RlLmRlc2NlbmRhbnRzKCkgKVxuICAgICAgO1xuXG4gICAgICB2YXIgZWRnZXMgPSBub2Rlcy5jb25uZWN0ZWRFZGdlcygpO1xuXG4gICAgICB2YXIgbGlzdEhhc0lkID0gZ2V0RHJhZ0xpc3RJZHMoIG9wdHMgKTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5zaXplKCk7IGkrKyApe1xuICAgICAgICBpZiggb3B0cy5pbkRyYWdMYXllciAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgbm9kZXNbaV0uX3ByaXZhdGUucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSBvcHRzLmluRHJhZ0xheWVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIG9wdHMuYWRkVG9MaXN0ICYmICFsaXN0SGFzSWRbIG5vZGVzW2ldLmlkKCkgXSApe1xuICAgICAgICAgIG9wdHMuYWRkVG9MaXN0LnB1c2goIG5vZGVzW2ldICk7XG4gICAgICAgICAgbGlzdEhhc0lkWyBub2Rlc1tpXS5pZCgpIF0gPSB0cnVlO1xuXG4gICAgICAgICAgbm9kZXNbaV0uX3ByaXZhdGUuZ3JhYmJlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yKCB2YXIgaiA9IDA7IG9wdHMuaW5EcmFnTGF5ZXIgIT09IHVuZGVmaW5lZCAmJiBqIDwgZWRnZXMubGVuZ3RoOyBqKysgKSB7XG4gICAgICAgIGVkZ2VzW2pdLl9wcml2YXRlLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gb3B0cy5pbkRyYWdMYXllcjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYoIHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJyApe1xuICAgICAgci5yZW1vdmVPYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uKCBtdXRucyApe1xuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG11dG5zLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIG11dG4gPSBtdXRuc1tpXTtcbiAgICAgICAgICB2YXIgck5vZGVzID0gbXV0bi5yZW1vdmVkTm9kZXM7XG5cbiAgICAgICAgICBpZiggck5vZGVzICl7IGZvciggdmFyIGogPSAwOyBqIDwgck5vZGVzLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgICB2YXIgck5vZGUgPSByTm9kZXNbal07XG5cbiAgICAgICAgICAgIGlmKCByTm9kZSA9PT0gci5kYXRhLmNvbnRhaW5lciApe1xuICAgICAgICAgICAgICByLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByLnJlbW92ZU9ic2VydmVyLm9ic2VydmUoIHIuZGF0YS5jb250YWluZXIucGFyZW50Tm9kZSwgeyBjaGlsZExpc3Q6IHRydWUgfSApO1xuICAgIH0gZWxzZSB7XG4gICAgICByLnJlZ2lzdGVyQmluZGluZyhyLmRhdGEuY29udGFpbmVyLCAnRE9NTm9kZVJlbW92ZWQnLCBmdW5jdGlvbihlKXtcbiAgICAgICAgci5kZXN0cm95KCk7XG4gICAgICB9KTtcbiAgICB9XG5cblxuXG4gICAgLy8gYXV0byByZXNpemVcbiAgICByLnJlZ2lzdGVyQmluZGluZyh3aW5kb3csICdyZXNpemUnLCAkJC51dGlsLmRlYm91bmNlKCBmdW5jdGlvbihlKSB7XG4gICAgICByLmludmFsaWRhdGVDb250YWluZXJDbGllbnRDb29yZHNDYWNoZSgpO1xuXG4gICAgICByLm1hdGNoQ2FudmFzU2l6ZShyLmRhdGEuY29udGFpbmVyKTtcbiAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDUi5OT0RFXSA9IHRydWU7XG4gICAgICByLnJlZHJhdygpO1xuICAgIH0sIDEwMCApICk7XG5cbiAgICB2YXIgaW52YWxDdG5yQkJPblNjcm9sbCA9IGZ1bmN0aW9uKGRvbUVsZSl7XG4gICAgICByLnJlZ2lzdGVyQmluZGluZyhkb21FbGUsICdzY3JvbGwnLCBmdW5jdGlvbihlKXtcbiAgICAgICAgci5pbnZhbGlkYXRlQ29udGFpbmVyQ2xpZW50Q29vcmRzQ2FjaGUoKTtcbiAgICAgIH0gKTtcbiAgICB9O1xuXG4gICAgdmFyIGJiQ3RuciA9IHIuZGF0YS5jeS5jb250YWluZXIoKTtcblxuICAgIGZvciggOzsgKXtcblxuICAgICAgaW52YWxDdG5yQkJPblNjcm9sbCggYmJDdG5yICk7XG5cbiAgICAgIGlmKCBiYkN0bnIucGFyZW50Tm9kZSApe1xuICAgICAgICBiYkN0bnIgPSBiYkN0bnIucGFyZW50Tm9kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gc3RvcCByaWdodCBjbGljayBtZW51IGZyb20gYXBwZWFyaW5nIG9uIGN5XG4gICAgci5yZWdpc3RlckJpbmRpbmcoci5kYXRhLmNvbnRhaW5lciwgJ2NvbnRleHRtZW51JywgZnVuY3Rpb24oZSl7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSk7XG5cbiAgICB2YXIgaW5Cb3hTZWxlY3Rpb24gPSBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHIuZGF0YS5zZWxlY3RbNF0gIT09IDA7XG4gICAgfTtcblxuICAgIC8vIFByaW1hcnkga2V5XG4gICAgci5yZWdpc3RlckJpbmRpbmcoci5kYXRhLmNvbnRhaW5lciwgJ21vdXNlZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHIuaG92ZXJEYXRhLmNhcHR1cmUgPSB0cnVlO1xuICAgICAgci5ob3ZlckRhdGEud2hpY2ggPSBlLndoaWNoO1xuXG4gICAgICB2YXIgY3kgPSByLmRhdGEuY3k7XG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcbiAgICAgIHZhciBzZWxlY3QgPSByLmRhdGEuc2VsZWN0O1xuICAgICAgdmFyIG5lYXIgPSByLmZpbmROZWFyZXN0RWxlbWVudChwb3NbMF0sIHBvc1sxXSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgdmFyIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHM7XG5cbiAgICAgIHIuaG92ZXJEYXRhLm1kb3duUG9zID0gcG9zO1xuICAgICAgXG4gICAgICB2YXIgbmVlZHNSZWRyYXcgPSByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXc7XG5cbiAgICAgIHZhciBjaGVja0ZvclRhcGhvbGQgPSBmdW5jdGlvbigpe1xuICAgICAgICByLmhvdmVyRGF0YS50YXBob2xkQ2FuY2VsbGVkID0gZmFsc2U7XG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KCByLmhvdmVyRGF0YS50YXBob2xkVGltZW91dCApO1xuXG4gICAgICAgIHIuaG92ZXJEYXRhLnRhcGhvbGRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuXG4gICAgICAgICAgaWYoIHIuaG92ZXJEYXRhLnRhcGhvbGRDYW5jZWxsZWQgKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGVsZSA9IHIuaG92ZXJEYXRhLmRvd247XG5cbiAgICAgICAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgICAgICAgZWxlLnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RhcGhvbGQnLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgICB9KSApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY3kudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGFwaG9sZCcsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICAgIH0pICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0sIHIudGFwaG9sZER1cmF0aW9uKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFJpZ2h0IGNsaWNrIGJ1dHRvblxuICAgICAgaWYoIGUud2hpY2ggPT0gMyApe1xuXG4gICAgICAgIHIuaG92ZXJEYXRhLmN4dFN0YXJ0ZWQgPSB0cnVlO1xuXG4gICAgICAgIHZhciBjeHRFdnQgPSBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgIHR5cGU6ICdjeHR0YXBzdGFydCcsXG4gICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmKCBuZWFyICl7XG4gICAgICAgICAgbmVhci5hY3RpdmF0ZSgpO1xuICAgICAgICAgIG5lYXIudHJpZ2dlciggY3h0RXZ0ICk7XG5cbiAgICAgICAgICByLmhvdmVyRGF0YS5kb3duID0gbmVhcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjeS50cmlnZ2VyKCBjeHRFdnQgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHIuaG92ZXJEYXRhLmRvd25UaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICAgICAgci5ob3ZlckRhdGEuY3h0RHJhZ2dlZCA9IGZhbHNlO1xuXG4gICAgICAvLyBQcmltYXJ5IGJ1dHRvblxuICAgICAgfSBlbHNlIGlmIChlLndoaWNoID09IDEpIHtcblxuICAgICAgICBpZiggbmVhciApe1xuICAgICAgICAgIG5lYXIuYWN0aXZhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVsZW1lbnQgZHJhZ2dpbmdcbiAgICAgICAge1xuICAgICAgICAgIC8vIElmIHNvbWV0aGluZyBpcyB1bmRlciB0aGUgY3Vyc29yIGFuZCBpdCBpcyBkcmFnZ2FibGUsIHByZXBhcmUgdG8gZ3JhYiBpdFxuICAgICAgICAgIGlmIChuZWFyICE9IG51bGwpIHtcblxuICAgICAgICAgICAgaWYoIHIubm9kZUlzRHJhZ2dhYmxlKG5lYXIpICl7XG5cbiAgICAgICAgICAgICAgdmFyIGdyYWJFdmVudCA9IG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2dyYWInLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBpZiAoIG5lYXIuaXNOb2RlKCkgJiYgIW5lYXIuc2VsZWN0ZWQoKSApe1xuXG4gICAgICAgICAgICAgICAgZHJhZ2dlZEVsZW1lbnRzID0gci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIGFkZE5vZGVUb0RyYWcoIG5lYXIsIHsgYWRkVG9MaXN0OiBkcmFnZ2VkRWxlbWVudHMgfSApO1xuXG4gICAgICAgICAgICAgICAgbmVhci50cmlnZ2VyKGdyYWJFdmVudCk7XG5cbiAgICAgICAgICAgICAgfSBlbHNlIGlmICggbmVhci5pc05vZGUoKSAmJiBuZWFyLnNlbGVjdGVkKCkgKXtcbiAgICAgICAgICAgICAgICBkcmFnZ2VkRWxlbWVudHMgPSByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzID0gWyAgXTtcblxuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZE5vZGVzID0gY3kuJChmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5pc05vZGUoKSAmJiB0aGlzLnNlbGVjdGVkKCk7IH0pO1xuXG4gICAgICAgICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBzZWxlY3RlZE5vZGVzLmxlbmd0aDsgaSsrICl7XG5cbiAgICAgICAgICAgICAgICAgIC8vIE9ubHkgYWRkIHRoaXMgc2VsZWN0ZWQgbm9kZSB0byBkcmFnIGlmIGl0IGlzIGRyYWdnYWJsZSwgZWcuIGhhcyBub256ZXJvIG9wYWNpdHlcbiAgICAgICAgICAgICAgICAgIGlmKCByLm5vZGVJc0RyYWdnYWJsZSggc2VsZWN0ZWROb2Rlc1tpXSApICl7XG4gICAgICAgICAgICAgICAgICAgIGFkZE5vZGVUb0RyYWcoIHNlbGVjdGVkTm9kZXNbaV0sIHsgYWRkVG9MaXN0OiBkcmFnZ2VkRWxlbWVudHMgfSApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG5lYXIudHJpZ2dlciggZ3JhYkV2ZW50ICk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBuZWVkc1JlZHJhd1tDUi5OT0RFXSA9IHRydWU7XG4gICAgICAgICAgICAgIG5lZWRzUmVkcmF3W0NSLkRSQUddID0gdHJ1ZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBuZWFyXG4gICAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ21vdXNlZG93bicsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0YXBzdGFydCcsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd2bW91c2Vkb3duJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICA7XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKG5lYXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgY3lcbiAgICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbW91c2Vkb3duJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RhcHN0YXJ0JyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3Ztb3VzZWRvd24nLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByLmhvdmVyRGF0YS5kb3duID0gbmVhcjtcbiAgICAgICAgICByLmhvdmVyRGF0YS5kb3duVGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNlbGVjdGlvbiBib3hcbiAgICAgICAgaWYgKCBuZWFyID09IG51bGwgfHwgbmVhci5pc0VkZ2UoKSApIHtcbiAgICAgICAgICBzZWxlY3RbNF0gPSAxO1xuICAgICAgICAgIHZhciB0aW1lVW50aWxBY3RpdmUgPSBNYXRoLm1heCggMCwgQ1IucGFuT3JCb3hTZWxlY3REZWxheSAtICgrbmV3IERhdGUoKSAtIHIuaG92ZXJEYXRhLmRvd25UaW1lKSApO1xuXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KCByLmJnQWN0aXZlVGltZW91dCApO1xuXG4gICAgICAgICAgaWYoIGN5LmJveFNlbGVjdGlvbkVuYWJsZWQoKSB8fCAoIG5lYXIgJiYgbmVhci5pc0VkZ2UoKSApICl7XG4gICAgICAgICAgICByLmJnQWN0aXZlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgaWYoIG5lYXIgKXtcbiAgICAgICAgICAgICAgICBuZWFyLnVuYWN0aXZhdGUoKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgci5ob3ZlckRhdGEuZHJhZ2dpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICAgIC8vY2hlY2tGb3JUYXBob2xkKCk7XG5cbiAgICAgICAgICAgICAgbmVlZHNSZWRyYXdbQ1IuU0VMRUNUX0JPWF0gPSB0cnVlO1xuXG4gICAgICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgICAgICB9LCB0aW1lVW50aWxBY3RpdmUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB7XG4gICAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvL3IuaG92ZXJEYXRhLmRyYWdnaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy9jaGVja0ZvclRhcGhvbGQoKTtcblxuICAgICAgICAgICAgbmVlZHNSZWRyYXdbQ1IuU0VMRUNUX0JPWF0gPSB0cnVlO1xuXG4gICAgICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgY2hlY2tGb3JUYXBob2xkKCk7XG5cbiAgICAgIH1cblxuICAgICAgLy8gSW5pdGlhbGl6ZSBzZWxlY3Rpb24gYm94IGNvb3JkaW5hdGVzXG4gICAgICBzZWxlY3RbMF0gPSBzZWxlY3RbMl0gPSBwb3NbMF07XG4gICAgICBzZWxlY3RbMV0gPSBzZWxlY3RbM10gPSBwb3NbMV07XG5cbiAgICB9LCBmYWxzZSk7XG5cbiAgICByLnJlZ2lzdGVyQmluZGluZyh3aW5kb3csICdtb3VzZW1vdmUnLCAkJC51dGlsLnRocm90dGxlKCBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgcHJldmVudERlZmF1bHQgPSBmYWxzZTtcbiAgICAgIHZhciBjYXB0dXJlID0gci5ob3ZlckRhdGEuY2FwdHVyZTtcblxuICAgICAgLy8gc2F2ZSBjeWNsZXMgaWYgbW91c2UgZXZlbnRzIGFyZW4ndCB0byBiZSBjYXB0dXJlZFxuICAgICAgaWYgKCAhY2FwdHVyZSApe1xuICAgICAgICB2YXIgY29udGFpbmVyUGFnZUNvb3JkcyA9IHIuZmluZENvbnRhaW5lckNsaWVudENvb3JkcygpO1xuXG4gICAgICAgIGlmIChlLmNsaWVudFggPiBjb250YWluZXJQYWdlQ29vcmRzWzBdICYmIGUuY2xpZW50WCA8IGNvbnRhaW5lclBhZ2VDb29yZHNbMF0gKyByLmNhbnZhc1dpZHRoXG4gICAgICAgICAgJiYgZS5jbGllbnRZID4gY29udGFpbmVyUGFnZUNvb3Jkc1sxXSAmJiBlLmNsaWVudFkgPCBjb250YWluZXJQYWdlQ29vcmRzWzFdICsgci5jYW52YXNIZWlnaHRcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gaW5zaWRlIGNvbnRhaW5lciBib3VuZHMgc28gT0tcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3lDb250YWluZXIgPSByLmRhdGEuY29udGFpbmVyO1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgIHZhciB0UGFyZW50ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgICAgIHZhciBjb250YWluZXJJc1RhcmdldCA9IGZhbHNlO1xuXG4gICAgICAgIHdoaWxlKCB0UGFyZW50ICl7XG4gICAgICAgICAgaWYoIHRQYXJlbnQgPT09IGN5Q29udGFpbmVyICl7XG4gICAgICAgICAgICBjb250YWluZXJJc1RhcmdldCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0UGFyZW50ID0gdFBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoICFjb250YWluZXJJc1RhcmdldCApeyByZXR1cm47IH0gLy8gaWYgdGFyZ2V0IGlzIG91dGlzZGUgY3kgY29udGFpbmVyLCB0aGVuIHRoaXMgZXZlbnQgaXMgbm90IGZvciB1c1xuICAgICAgfVxuXG4gICAgICB2YXIgY3kgPSByLmRhdGEuY3k7XG4gICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuICAgICAgdmFyIHNlbGVjdCA9IHIuZGF0YS5zZWxlY3Q7XG4gICAgICB2YXIgbmVlZHNSZWRyYXcgPSByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXc7XG5cbiAgICAgIHZhciBuZWFyID0gbnVsbDtcbiAgICAgIGlmKCAhci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzICl7XG4gICAgICAgIG5lYXIgPSByLmZpbmROZWFyZXN0RWxlbWVudChwb3NbMF0sIHBvc1sxXSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgfVxuICAgICAgdmFyIGxhc3QgPSByLmhvdmVyRGF0YS5sYXN0O1xuICAgICAgdmFyIGRvd24gPSByLmhvdmVyRGF0YS5kb3duO1xuXG4gICAgICB2YXIgZGlzcCA9IFtwb3NbMF0gLSBzZWxlY3RbMl0sIHBvc1sxXSAtIHNlbGVjdFszXV07XG5cbiAgICAgIHZhciBkcmFnZ2VkRWxlbWVudHMgPSByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzO1xuXG4gICAgICB2YXIgZHggPSBzZWxlY3RbMl0gLSBzZWxlY3RbMF07XG4gICAgICB2YXIgZHgyID0gZHggKiBkeDtcbiAgICAgIHZhciBkeSA9IHNlbGVjdFszXSAtIHNlbGVjdFsxXTtcbiAgICAgIHZhciBkeTIgPSBkeSAqIGR5O1xuICAgICAgdmFyIGRpc3QyID0gZHgyICsgZHkyO1xuICAgICAgdmFyIHJkaXN0MiA9IGRpc3QyICogem9vbSAqIHpvb207XG5cbiAgICAgIHIuaG92ZXJEYXRhLnRhcGhvbGRDYW5jZWxsZWQgPSB0cnVlO1xuXG4gICAgICB2YXIgdXBkYXRlRHJhZ0RlbHRhID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIGRyYWdEZWx0YSA9IHIuaG92ZXJEYXRhLmRyYWdEZWx0YSA9IHIuaG92ZXJEYXRhLmRyYWdEZWx0YSB8fCBbXTtcblxuICAgICAgICBpZiggZHJhZ0RlbHRhLmxlbmd0aCA9PT0gMCApe1xuICAgICAgICAgIGRyYWdEZWx0YS5wdXNoKCBkaXNwWzBdICk7XG4gICAgICAgICAgZHJhZ0RlbHRhLnB1c2goIGRpc3BbMV0gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkcmFnRGVsdGFbMF0gKz0gZGlzcFswXTtcbiAgICAgICAgICBkcmFnRGVsdGFbMV0gKz0gZGlzcFsxXTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuXG4gICAgICBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XG5cbiAgICAgIC8vIE1vdXNlbW92ZSBldmVudFxuICAgICAge1xuICAgICAgICBpZiAobmVhciAhPSBudWxsKSB7XG4gICAgICAgICAgbmVhclxuICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ21vdXNlbW92ZScsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAndm1vdXNlbW92ZScsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAndGFwZHJhZycsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgO1xuXG4gICAgICAgIH0gZWxzZSBpZiAobmVhciA9PSBudWxsKSB7XG4gICAgICAgICAgY3lcbiAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICdtb3VzZW1vdmUnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3Ztb3VzZW1vdmUnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3RhcGRyYWcnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgIDtcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIC8vIHRyaWdnZXIgY29udGV4dCBkcmFnIGlmIHJtb3VzZSBkb3duXG4gICAgICBpZiggci5ob3ZlckRhdGEud2hpY2ggPT09IDMgKXtcbiAgICAgICAgdmFyIGN4dEV2dCA9IG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgdHlwZTogJ2N4dGRyYWcnLFxuICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiggZG93biApe1xuICAgICAgICAgIGRvd24udHJpZ2dlciggY3h0RXZ0ICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3kudHJpZ2dlciggY3h0RXZ0ICk7XG4gICAgICAgIH1cblxuICAgICAgICByLmhvdmVyRGF0YS5jeHREcmFnZ2VkID0gdHJ1ZTtcblxuICAgICAgICBpZiggIXIuaG92ZXJEYXRhLmN4dE92ZXIgfHwgbmVhciAhPT0gci5ob3ZlckRhdGEuY3h0T3ZlciApe1xuXG4gICAgICAgICAgaWYoIHIuaG92ZXJEYXRhLmN4dE92ZXIgKXtcbiAgICAgICAgICAgIHIuaG92ZXJEYXRhLmN4dE92ZXIudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ2N4dGRyYWdvdXQnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgIH0pICk7XG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdjeHRkcmFnb3V0ICcgKyByLmhvdmVyRGF0YS5jeHRPdmVyLmlkKCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHIuaG92ZXJEYXRhLmN4dE92ZXIgPSBuZWFyO1xuXG4gICAgICAgICAgaWYoIG5lYXIgKXtcbiAgICAgICAgICAgIG5lYXIudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ2N4dGRyYWdvdmVyJyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICB9KSApO1xuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnY3h0ZHJhZ292ZXIgJyArIG5lYXIuaWQoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgd2UgYXJlIGRyYWcgcGFubmluZyB0aGUgZW50aXJlIGdyYXBoXG4gICAgICB9IGVsc2UgaWYgKHIuaG92ZXJEYXRhLmRyYWdnaW5nKSB7XG4gICAgICAgIHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcblxuICAgICAgICBpZiggY3kucGFubmluZ0VuYWJsZWQoKSAmJiBjeS51c2VyUGFubmluZ0VuYWJsZWQoKSApe1xuICAgICAgICAgIHZhciBkZWx0YVA7XG5cbiAgICAgICAgICBpZiggci5ob3ZlckRhdGEuanVzdFN0YXJ0ZWRQYW4gKXtcbiAgICAgICAgICAgIHZhciBtZFBvcyA9IHIuaG92ZXJEYXRhLm1kb3duUG9zO1xuXG4gICAgICAgICAgICBkZWx0YVAgPSB7XG4gICAgICAgICAgICAgIHg6ICggcG9zWzBdIC0gbWRQb3NbMF0gKSAqIHpvb20sXG4gICAgICAgICAgICAgIHk6ICggcG9zWzFdIC0gbWRQb3NbMV0gKSAqIHpvb21cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHIuaG92ZXJEYXRhLmp1c3RTdGFydGVkUGFuID0gZmFsc2U7XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsdGFQID0ge1xuICAgICAgICAgICAgICB4OiBkaXNwWzBdICogem9vbSxcbiAgICAgICAgICAgICAgeTogZGlzcFsxXSAqIHpvb21cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjeS5wYW5CeSggZGVsdGFQICk7XG5cbiAgICAgICAgICByLmhvdmVyRGF0YS5kcmFnZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5lZWRzIHJlcHJvamVjdCBkdWUgdG8gcGFuIGNoYW5naW5nIHZpZXdwb3J0XG4gICAgICAgIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLmNsaWVudFgsIGUuY2xpZW50WSk7XG5cbiAgICAgIC8vIENoZWNrcyBwcmltYXJ5IGJ1dHRvbiBkb3duICYgb3V0IG9mIHRpbWUgJiBtb3VzZSBub3QgbW92ZWQgbXVjaFxuICAgICAgfSBlbHNlIGlmKFxuICAgICAgICAgIHNlbGVjdFs0XSA9PSAxICYmIChkb3duID09IG51bGwgfHwgZG93bi5pc0VkZ2UoKSlcbiAgICAgICAgICAmJiAoICFjeS5ib3hTZWxlY3Rpb25FbmFibGVkKCkgfHwgKCtuZXcgRGF0ZSgpIC0gci5ob3ZlckRhdGEuZG93blRpbWUgPj0gQ1IucGFuT3JCb3hTZWxlY3REZWxheSkgKVxuICAgICAgICAgIC8vJiYgKE1hdGguYWJzKHNlbGVjdFszXSAtIHNlbGVjdFsxXSkgKyBNYXRoLmFicyhzZWxlY3RbMl0gLSBzZWxlY3RbMF0pIDwgNClcbiAgICAgICAgICAmJiAhci5ob3ZlckRhdGEuc2VsZWN0aW5nXG4gICAgICAgICAgJiYgcmRpc3QyID49IHIuZGVza3RvcFRhcFRocmVzaG9sZDJcbiAgICAgICAgICAmJiBjeS5wYW5uaW5nRW5hYmxlZCgpICYmIGN5LnVzZXJQYW5uaW5nRW5hYmxlZCgpXG4gICAgICApe1xuICAgICAgICByLmhvdmVyRGF0YS5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgIHIuaG92ZXJEYXRhLnNlbGVjdGluZyA9IGZhbHNlO1xuICAgICAgICByLmhvdmVyRGF0YS5qdXN0U3RhcnRlZFBhbiA9IHRydWU7XG4gICAgICAgIHNlbGVjdFs0XSA9IDA7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlYWN0aXZhdGUgYmcgb24gYm94IHNlbGVjdGlvblxuICAgICAgICBpZiAoY3kuYm94U2VsZWN0aW9uRW5hYmxlZCgpICYmICFyLmhvdmVyRGF0YS5kcmFnZ2luZyAmJiBNYXRoLnBvdyhzZWxlY3RbMl0gLSBzZWxlY3RbMF0sIDIpICsgTWF0aC5wb3coc2VsZWN0WzNdIC0gc2VsZWN0WzFdLCAyKSA+IDcgJiYgc2VsZWN0WzRdKXtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoIHIuYmdBY3RpdmVUaW1lb3V0ICk7XG4gICAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHIuaG92ZXJEYXRhLnNlbGVjdGluZyA9IHRydWU7XG5cbiAgICAgICAgICBuZWVkc1JlZHJhd1tDUi5TRUxFQ1RfQk9YXSA9IHRydWU7XG4gICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBkb3duICYmIGRvd24uaXNFZGdlKCkgJiYgZG93bi5hY3RpdmUoKSApeyBkb3duLnVuYWN0aXZhdGUoKTsgfVxuXG4gICAgICAgIGlmIChuZWFyICE9IGxhc3QpIHtcblxuICAgICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgICBsYXN0LnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICdtb3VzZW91dCcsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgfSkgKTtcblxuICAgICAgICAgICAgbGFzdC50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAndGFwZHJhZ291dCcsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgfSkgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobmVhcikge1xuICAgICAgICAgICAgbmVhci50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAnbW91c2VvdmVyJyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICB9KSApO1xuXG4gICAgICAgICAgICBuZWFyLnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICd0YXBkcmFnb3ZlcicsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgfSkgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByLmhvdmVyRGF0YS5sYXN0ID0gbmVhcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBkb3duICYmIGRvd24uaXNOb2RlKCkgJiYgci5ub2RlSXNEcmFnZ2FibGUoZG93bikgKXtcblxuICAgICAgICAgIGlmKCByZGlzdDIgPj0gci5kZXNrdG9wVGFwVGhyZXNob2xkMiApeyAvLyB0aGVuIGRyYWdcblxuICAgICAgICAgICAgdmFyIGp1c3RTdGFydGVkRHJhZyA9ICFyLmRyYWdEYXRhLmRpZERyYWc7XG5cbiAgICAgICAgICAgIGlmKCBqdXN0U3RhcnRlZERyYWcgKSB7XG4gICAgICAgICAgICAgIG5lZWRzUmVkcmF3W0NSLk5PREVdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgci5kcmFnRGF0YS5kaWREcmFnID0gdHJ1ZTsgLy8gaW5kaWNhdGUgdGhhdCB3ZSBhY3R1YWxseSBkaWQgZHJhZyB0aGUgbm9kZVxuXG4gICAgICAgICAgICB2YXIgdG9UcmlnZ2VyID0gW107XG5cbiAgICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZHJhZ2dlZEVsZW1lbnRzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICAgIHZhciBkRWxlID0gZHJhZ2dlZEVsZW1lbnRzW2ldO1xuXG4gICAgICAgICAgICAgIC8vIG5vdywgYWRkIHRoZSBlbGVtZW50cyB0byB0aGUgZHJhZyBsYXllciBpZiBub3QgZG9uZSBhbHJlYWR5XG4gICAgICAgICAgICAgIGlmKCAhci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzICl7XG4gICAgICAgICAgICAgICAgYWRkTm9kZVRvRHJhZyggZEVsZSwgeyBpbkRyYWdMYXllcjogdHJ1ZSB9ICk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBMb2NrZWQgbm9kZXMgbm90IGRyYWdnYWJsZSwgYXMgd2VsbCBhcyBub24tdmlzaWJsZSBub2Rlc1xuICAgICAgICAgICAgICBpZiggZEVsZS5pc05vZGUoKSAmJiByLm5vZGVJc0RyYWdnYWJsZShkRWxlKSAmJiBkRWxlLmdyYWJiZWQoKSApe1xuICAgICAgICAgICAgICAgIHZhciBkUG9zID0gZEVsZS5fcHJpdmF0ZS5wb3NpdGlvbjtcblxuICAgICAgICAgICAgICAgIHRvVHJpZ2dlci5wdXNoKCBkRWxlICk7XG5cbiAgICAgICAgICAgICAgICBpZiggJCQuaXMubnVtYmVyKGRpc3BbMF0pICYmICQkLmlzLm51bWJlcihkaXNwWzFdKSApe1xuICAgICAgICAgICAgICAgICAgZFBvcy54ICs9IGRpc3BbMF07XG4gICAgICAgICAgICAgICAgICBkUG9zLnkgKz0gZGlzcFsxXTtcblxuICAgICAgICAgICAgICAgICAgaWYoIGp1c3RTdGFydGVkRHJhZyApe1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHJhZ0RlbHRhID0gci5ob3ZlckRhdGEuZHJhZ0RlbHRhO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKCAkJC5pcy5udW1iZXIoZHJhZ0RlbHRhWzBdKSAmJiAkJC5pcy5udW1iZXIoZHJhZ0RlbHRhWzFdKSApe1xuICAgICAgICAgICAgICAgICAgICAgIGRQb3MueCArPSBkcmFnRGVsdGFbMF07XG4gICAgICAgICAgICAgICAgICAgICAgZFBvcy55ICs9IGRyYWdEZWx0YVsxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyA9IHRydWU7XG5cbiAgICAgICAgICAgIHZhciB0Y29sID0gKG5ldyAkJC5Db2xsZWN0aW9uKGN5LCB0b1RyaWdnZXIpKTtcblxuICAgICAgICAgICAgdGNvbC51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuICAgICAgICAgICAgdGNvbC50cmlnZ2VyKCdwb3NpdGlvbiBkcmFnJyk7XG5cbiAgICAgICAgICAgIG5lZWRzUmVkcmF3W0NSLkRSQUddID0gdHJ1ZTtcbiAgICAgICAgICAgIHIucmVkcmF3KCk7XG5cbiAgICAgICAgICB9IGVsc2UgeyAvLyBvdGhlcndpc2Ugc2F2ZSBkcmFnIGRlbHRhIGZvciB3aGVuIHdlIGFjdHVhbGx5IHN0YXJ0IGRyYWdnaW5nIHNvIHRoZSByZWxhdGl2ZSBncmFiIHBvcyBpcyBjb25zdGFudFxuICAgICAgICAgICAgdXBkYXRlRHJhZ0RlbHRhKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHJldmVudCB0aGUgZHJhZ2dpbmcgZnJvbSB0cmlnZ2VyaW5nIHRleHQgc2VsZWN0aW9uIG9uIHRoZSBwYWdlXG4gICAgICAgIHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgc2VsZWN0WzJdID0gcG9zWzBdOyBzZWxlY3RbM10gPSBwb3NbMV07XG5cbiAgICAgIGlmKCBwcmV2ZW50RGVmYXVsdCApe1xuICAgICAgICBpZihlLnN0b3BQcm9wYWdhdGlvbikgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICBpZihlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSwgMTAwMC8zMCwgeyB0cmFpbGluZzogdHJ1ZSB9KSwgZmFsc2UpO1xuXG4gICAgci5yZWdpc3RlckJpbmRpbmcod2luZG93LCAnbW91c2V1cCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCctLVxcbm1vdXNldXAnLCBlKVxuXG4gICAgICB2YXIgY2FwdHVyZSA9IHIuaG92ZXJEYXRhLmNhcHR1cmU7XG4gICAgICBpZiAoIWNhcHR1cmUpIHsgcmV0dXJuOyB9XG4gICAgICByLmhvdmVyRGF0YS5jYXB0dXJlID0gZmFsc2U7XG5cbiAgICAgIHZhciBjeSA9IHIuZGF0YS5jeTsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLmNsaWVudFgsIGUuY2xpZW50WSk7IHZhciBzZWxlY3QgPSByLmRhdGEuc2VsZWN0O1xuICAgICAgdmFyIG5lYXIgPSByLmZpbmROZWFyZXN0RWxlbWVudChwb3NbMF0sIHBvc1sxXSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgdmFyIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHM7IHZhciBkb3duID0gci5ob3ZlckRhdGEuZG93bjtcbiAgICAgIHZhciBzaGlmdERvd24gPSBlLnNoaWZ0S2V5O1xuICAgICAgdmFyIG5lZWRzUmVkcmF3ID0gci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3O1xuXG4gICAgICBpZiggci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uICl7XG4gICAgICAgIG5lZWRzUmVkcmF3W0NSLlNFTEVDVF9CT1hdID0gdHJ1ZTtcbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgIH1cblxuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkOyAvLyBub3QgYWN0aXZlIGJnIG5vd1xuICAgICAgY2xlYXJUaW1lb3V0KCByLmJnQWN0aXZlVGltZW91dCApO1xuXG4gICAgICBpZiggZG93biApe1xuICAgICAgICBkb3duLnVuYWN0aXZhdGUoKTtcbiAgICAgIH1cblxuICAgICAgaWYoIHIuaG92ZXJEYXRhLndoaWNoID09PSAzICl7XG4gICAgICAgIHZhciBjeHRFdnQgPSBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgIHR5cGU6ICdjeHR0YXBlbmQnLFxuICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiggZG93biApe1xuICAgICAgICAgIGRvd24udHJpZ2dlciggY3h0RXZ0ICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3kudHJpZ2dlciggY3h0RXZ0ICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggIXIuaG92ZXJEYXRhLmN4dERyYWdnZWQgKXtcbiAgICAgICAgICB2YXIgY3h0VGFwID0gbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgIHR5cGU6ICdjeHR0YXAnLFxuICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiggZG93biApe1xuICAgICAgICAgICAgZG93bi50cmlnZ2VyKCBjeHRUYXAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3kudHJpZ2dlciggY3h0VGFwICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgci5ob3ZlckRhdGEuY3h0RHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgICByLmhvdmVyRGF0YS53aGljaCA9IG51bGw7XG5cbiAgICAgIC8vIGlmIG5vdCByaWdodCBtb3VzZVxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBEZXNlbGVjdCBhbGwgZWxlbWVudHMgaWYgbm90aGluZyBpcyBjdXJyZW50bHkgdW5kZXIgdGhlIG1vdXNlIGN1cnNvciBhbmQgd2UgYXJlbid0IGRyYWdnaW5nIHNvbWV0aGluZ1xuICAgICAgICBpZiAoIChkb3duID09IG51bGwpIC8vIG5vdCBtb3VzZWRvd24gb24gbm9kZVxuICAgICAgICAgICYmICFyLmRyYWdEYXRhLmRpZERyYWcgLy8gZGlkbid0IG1vdmUgdGhlIG5vZGUgYXJvdW5kXG4gICAgICAgICAgLy8mJiAhKE1hdGgucG93KHNlbGVjdFsyXSAtIHNlbGVjdFswXSwgMikgKyBNYXRoLnBvdyhzZWxlY3RbM10gLSBzZWxlY3RbMV0sIDIpID4gNyAmJiBzZWxlY3RbNF0pIC8vIG5vdCBib3ggc2VsZWN0aW9uXG4gICAgICAgICAgJiYgIXIuaG92ZXJEYXRhLmRyYWdnZWQgLy8gZGlkbid0IHBhblxuICAgICAgICApIHtcblxuICAgICAgICAgIGN5LiQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkKCk7XG4gICAgICAgICAgfSkudW5zZWxlY3QoKTtcblxuICAgICAgICAgIGlmIChkcmFnZ2VkRWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbmVlZHNSZWRyYXdbQ1IuTk9ERV0gPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHMgPSBkcmFnZ2VkRWxlbWVudHMgPSBbXTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gTW91c2V1cCBldmVudFxuICAgICAgICB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ3RyaWdnZXIgbW91c2V1cCBldCBhbCcpO1xuXG4gICAgICAgICAgaWYgKG5lYXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgbmVhclxuICAgICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdtb3VzZXVwJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RhcGVuZCcsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd2bW91c2V1cCcsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgO1xuICAgICAgICAgIH0gZWxzZSBpZiAobmVhciA9PSBudWxsKSB7XG4gICAgICAgICAgICBjeVxuICAgICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdtb3VzZXVwJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RhcGVuZCcsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd2bW91c2V1cCcsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENsaWNrIGV2ZW50XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygndHJpZ2dlciBjbGljayBldCBhbCcpO1xuXG4gICAgICAgICAgaWYoXG4gICAgICAgICAgICAvL01hdGgucG93KHNlbGVjdFsyXSAtIHNlbGVjdFswXSwgMikgKyBNYXRoLnBvdyhzZWxlY3RbM10gLSBzZWxlY3RbMV0sIDIpID09PSAwXG4gICAgICAgICAgICAhci5kcmFnRGF0YS5kaWREcmFnIC8vIGRpZG4ndCBtb3ZlIGEgbm9kZSBhcm91bmRcbiAgICAgICAgICAgICYmICFyLmhvdmVyRGF0YS5kcmFnZ2VkIC8vIGRpZG4ndCBwYW5cbiAgICAgICAgICApe1xuICAgICAgICAgICAgaWYgKG5lYXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBuZWFyXG4gICAgICAgICAgICAgICAgLnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAnY2xpY2snLFxuICAgICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICAgICAgfSkgKVxuICAgICAgICAgICAgICAgIC50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgICAgdHlwZTogJ3RhcCcsXG4gICAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgICAgICB9KSApXG4gICAgICAgICAgICAgICAgLnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAndmNsaWNrJyxcbiAgICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgICAgIH0pIClcbiAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuZWFyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgY3lcbiAgICAgICAgICAgICAgICAudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdjbGljaycsXG4gICAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgICAgICB9KSApXG4gICAgICAgICAgICAgICAgLnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAndGFwJyxcbiAgICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgICAgIH0pIClcbiAgICAgICAgICAgICAgICAudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICd2Y2xpY2snLFxuICAgICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICAgICAgfSkgKVxuICAgICAgICAgICAgICA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2luZ2xlIHNlbGVjdGlvblxuICAgICAgICBpZiAobmVhciA9PSBkb3duICYmICFyLmRyYWdEYXRhLmRpZERyYWcpIHtcbiAgICAgICAgICBpZiAobmVhciAhPSBudWxsICYmIG5lYXIuX3ByaXZhdGUuc2VsZWN0YWJsZSkge1xuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnc2luZ2xlIHNlbGVjdGlvbicpXG5cbiAgICAgICAgICAgIGlmKCByLmhvdmVyRGF0YS5kcmFnZ2luZyApe1xuICAgICAgICAgICAgICAvLyBpZiBwYW5uaW5nLCBkb24ndCBjaGFuZ2Ugc2VsZWN0aW9uIHN0YXRlXG4gICAgICAgICAgICB9IGVsc2UgaWYoIGN5LnNlbGVjdGlvblR5cGUoKSA9PT0gJ2FkZGl0aXZlJyB8fCBzaGlmdERvd24gKXtcbiAgICAgICAgICAgICAgaWYoIG5lYXIuc2VsZWN0ZWQoKSApe1xuICAgICAgICAgICAgICAgIG5lYXIudW5zZWxlY3QoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZWFyLnNlbGVjdCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiggIXNoaWZ0RG93biApe1xuICAgICAgICAgICAgICAgIGN5LiQoJzpzZWxlY3RlZCcpLnVubWVyZ2UoIG5lYXIgKS51bnNlbGVjdCgpO1xuICAgICAgICAgICAgICAgIG5lYXIuc2VsZWN0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbmVlZHNSZWRyYXdbQ1IuTk9ERV0gPSB0cnVlO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHIuaG92ZXJEYXRhLnNlbGVjdGluZyAmJiBjeS5ib3hTZWxlY3Rpb25FbmFibGVkKCkgJiYgIE1hdGgucG93KHNlbGVjdFsyXSAtIHNlbGVjdFswXSwgMikgKyBNYXRoLnBvdyhzZWxlY3RbM10gLSBzZWxlY3RbMV0sIDIpID4gNyAmJiBzZWxlY3RbNF0gKSB7XG4gICAgICAgICAgdmFyIG5ld2x5U2VsZWN0ZWQgPSBbXTtcbiAgICAgICAgICB2YXIgYm94ID0gci5nZXRBbGxJbkJveCggc2VsZWN0WzBdLCBzZWxlY3RbMV0sIHNlbGVjdFsyXSwgc2VsZWN0WzNdICk7XG5cbiAgICAgICAgICBuZWVkc1JlZHJhd1tDUi5TRUxFQ1RfQk9YXSA9IHRydWU7XG5cbiAgICAgICAgICBpZiggYm94Lmxlbmd0aCA+IDAgKSB7XG4gICAgICAgICAgICBuZWVkc1JlZHJhd1tDUi5OT0RFXSA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBib3gubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgIGlmKCBib3hbaV0uX3ByaXZhdGUuc2VsZWN0YWJsZSApe1xuICAgICAgICAgICAgICBuZXdseVNlbGVjdGVkLnB1c2goIGJveFtpXSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBuZXdseVNlbENvbCA9IG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgbmV3bHlTZWxlY3RlZCApO1xuXG4gICAgICAgICAgaWYoIGN5LnNlbGVjdGlvblR5cGUoKSA9PT0gJ2FkZGl0aXZlJyApe1xuICAgICAgICAgICAgbmV3bHlTZWxDb2wuc2VsZWN0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmKCAhc2hpZnREb3duICl7XG4gICAgICAgICAgICAgIGN5LiQoJzpzZWxlY3RlZCcpLnVubWVyZ2UoIG5ld2x5U2VsQ29sICkudW5zZWxlY3QoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbmV3bHlTZWxDb2wuc2VsZWN0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gYWx3YXlzIG5lZWQgcmVkcmF3IGluIGNhc2UgZWxlcyB1bnNlbGVjdGFibGVcbiAgICAgICAgICByLnJlZHJhdygpO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYW5jZWwgZHJhZyBwYW5cbiAgICAgICAgaWYoIHIuaG92ZXJEYXRhLmRyYWdnaW5nICl7XG4gICAgICAgICAgci5ob3ZlckRhdGEuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICBcbiAgICAgICAgICBuZWVkc1JlZHJhd1tDUi5TRUxFQ1RfQk9YXSA9IHRydWU7XG4gICAgICAgICAgbmVlZHNSZWRyYXdbQ1IuTk9ERV0gPSB0cnVlO1xuICAgICAgICAgIFxuICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNlbGVjdFs0XSkge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdmcmVlIGF0IGVuZCcsIGRyYWdnZWRFbGVtZW50cylcblxuICAgICAgICAgIG5lZWRzUmVkcmF3W0NSLkRSQUddID0gdHJ1ZTtcbiAgICAgICAgICBuZWVkc1JlZHJhd1tDUi5OT0RFXSA9IHRydWU7XG5cbiAgICAgICAgICBmcmVlRHJhZ2dlZEVsZW1lbnRzKCBkcmFnZ2VkRWxlbWVudHMgKTtcblxuICAgICAgICAgIGlmKCBkb3duICl7IGRvd24udHJpZ2dlcignZnJlZScpOyB9XG5cbiAgLy8gICAgICAgIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHMgPSBbXTtcblxuICAgICAgICB9XG5cbiAgICAgIH0gLy8gZWxzZSBub3QgcmlnaHQgbW91c2VcblxuICAgICAgc2VsZWN0WzRdID0gMDsgci5ob3ZlckRhdGEuZG93biA9IG51bGw7XG5cbiAgICAgIC8vci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NSLlNFTEVDVF9CT1hdID0gdHJ1ZTtcblxuLy8gICAgICBjb25zb2xlLmxvZygnbXUnLCBwb3NbMF0sIHBvc1sxXSk7XG4vLyAgICAgIGNvbnNvbGUubG9nKCdzcycsIHNlbGVjdCk7XG5cbiAgICAgIHIuaG92ZXJEYXRhLmN4dFN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyA9IGZhbHNlO1xuICAgICAgci5ob3ZlckRhdGEuc2VsZWN0aW5nID0gZmFsc2U7XG4gICAgICByLmRyYWdEYXRhLmRpZERyYWcgPSBmYWxzZTtcbiAgICAgIHIuaG92ZXJEYXRhLmRyYWdnZWQgPSBmYWxzZTtcbiAgICAgIHIuaG92ZXJEYXRhLmRyYWdEZWx0YSA9IFtdO1xuXG4gICAgfSwgZmFsc2UpO1xuXG4gICAgdmFyIHdoZWVsSGFuZGxlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmKCByLnNjcm9sbGluZ1BhZ2UgKXsgcmV0dXJuOyB9IC8vIHdoaWxlIHNjcm9sbGluZywgaWdub3JlIHdoZWVsLXRvLXpvb21cblxuICAgICAgdmFyIGN5ID0gci5kYXRhLmN5O1xuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLmNsaWVudFgsIGUuY2xpZW50WSk7XG4gICAgICB2YXIgcnBvcyA9IFtwb3NbMF0gKiBjeS56b29tKCkgKyBjeS5wYW4oKS54LFxuICAgICAgICAgICAgICAgICAgICBwb3NbMV0gKiBjeS56b29tKCkgKyBjeS5wYW4oKS55XTtcblxuICAgICAgaWYoIHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyB8fCByLmhvdmVyRGF0YS5kcmFnZ2luZyB8fCByLmhvdmVyRGF0YS5jeHRTdGFydGVkIHx8IGluQm94U2VsZWN0aW9uKCkgKXsgLy8gaWYgcGFuIGRyYWdnaW5nIG9yIGN4dCBkcmFnZ2luZywgd2hlZWwgbW92ZW1lbnRzIG1ha2Ugbm8gem9vbVxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYoIGN5LnBhbm5pbmdFbmFibGVkKCkgJiYgY3kudXNlclBhbm5pbmdFbmFibGVkKCkgJiYgY3kuem9vbWluZ0VuYWJsZWQoKSAmJiBjeS51c2VyWm9vbWluZ0VuYWJsZWQoKSApe1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgci5kYXRhLndoZWVsWm9vbWluZyA9IHRydWU7XG4gICAgICAgIGNsZWFyVGltZW91dCggci5kYXRhLndoZWVsVGltZW91dCApO1xuICAgICAgICByLmRhdGEud2hlZWxUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgIHIuZGF0YS53aGVlbFpvb21pbmcgPSBmYWxzZTtcblxuICAgICAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDUi5OT0RFXSA9IHRydWU7XG4gICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgfSwgMTUwKTtcblxuICAgICAgICB2YXIgZGlmZiA9IGUuZGVsdGFZIC8gLTI1MCB8fCBlLndoZWVsRGVsdGFZIC8gMTAwMCB8fCBlLndoZWVsRGVsdGEgLyAxMDAwO1xuICAgICAgICBkaWZmID0gZGlmZiAqIHIud2hlZWxTZW5zaXRpdml0eTtcblxuICAgICAgICB2YXIgbmVlZHNXaGVlbEZpeCA9IGUuZGVsdGFNb2RlID09PSAxO1xuICAgICAgICBpZiggbmVlZHNXaGVlbEZpeCApeyAvLyBmaXhlcyBzbG93IHdoZWVsIGV2ZW50cyBvbiBmZi9saW51eCBhbmQgZmYvd2luZG93c1xuICAgICAgICAgIGRpZmYgKj0gMzM7XG4gICAgICAgIH1cblxuICAgICAgICBjeS56b29tKHtcbiAgICAgICAgICBsZXZlbDogY3kuem9vbSgpICogTWF0aC5wb3coMTAsIGRpZmYpLFxuICAgICAgICAgIHJlbmRlcmVkUG9zaXRpb246IHsgeDogcnBvc1swXSwgeTogcnBvc1sxXSB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8vIEZ1bmN0aW9ucyB0byBoZWxwIHdpdGggd2hldGhlciBtb3VzZSB3aGVlbCBzaG91bGQgdHJpZ2dlciB6b29taW5nXG4gICAgLy8gLS1cbiAgICByLnJlZ2lzdGVyQmluZGluZyhyLmRhdGEuY29udGFpbmVyLCAnd2hlZWwnLCB3aGVlbEhhbmRsZXIsIHRydWUpO1xuXG4gICAgLy8gZGlzYWJsZSBub25zdGFuZGFyZCB3aGVlbCBldmVudHNcbiAgICAvLyByLnJlZ2lzdGVyQmluZGluZyhyLmRhdGEuY29udGFpbmVyLCAnbW91c2V3aGVlbCcsIHdoZWVsSGFuZGxlciwgdHJ1ZSk7XG4gICAgLy8gci5yZWdpc3RlckJpbmRpbmcoci5kYXRhLmNvbnRhaW5lciwgJ0RPTU1vdXNlU2Nyb2xsJywgd2hlZWxIYW5kbGVyLCB0cnVlKTtcbiAgICAvLyByLnJlZ2lzdGVyQmluZGluZyhyLmRhdGEuY29udGFpbmVyLCAnTW96TW91c2VQaXhlbFNjcm9sbCcsIHdoZWVsSGFuZGxlciwgdHJ1ZSk7IC8vIG9sZGVyIGZpcmVmb3hcblxuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHdpbmRvdywgJ3Njcm9sbCcsIGZ1bmN0aW9uKGUpe1xuICAgICAgci5zY3JvbGxpbmdQYWdlID0gdHJ1ZTtcblxuICAgICAgY2xlYXJUaW1lb3V0KCByLnNjcm9sbGluZ1BhZ2VUaW1lb3V0ICk7XG4gICAgICByLnNjcm9sbGluZ1BhZ2VUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICByLnNjcm9sbGluZ1BhZ2UgPSBmYWxzZTtcbiAgICAgIH0sIDI1MCk7XG4gICAgfSwgdHJ1ZSk7XG5cbiAgICAvLyBGdW5jdGlvbnMgdG8gaGVscCB3aXRoIGhhbmRsaW5nIG1vdXNlb3V0L21vdXNlb3ZlciBvbiB0aGUgQ3l0b3NjYXBlIGNvbnRhaW5lclxuICAgICAgICAgIC8vIEhhbmRsZSBtb3VzZW91dCBvbiBDeXRvc2NhcGUgY29udGFpbmVyXG4gICAgci5yZWdpc3RlckJpbmRpbmcoci5kYXRhLmNvbnRhaW5lciwgJ21vdXNlb3V0JywgZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLmNsaWVudFgsIGUuY2xpZW50WSk7XG5cbiAgICAgIHIuZGF0YS5jeS50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgIHR5cGU6ICdtb3VzZW91dCcsXG4gICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgfSkpO1xuICAgIH0sIGZhbHNlKTtcblxuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuZGF0YS5jb250YWluZXIsICdtb3VzZW92ZXInLCBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcblxuICAgICAgci5kYXRhLmN5LnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgdHlwZTogJ21vdXNlb3ZlcicsXG4gICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgfSkpO1xuICAgIH0sIGZhbHNlKTtcblxuICAgIHZhciBmMXgxLCBmMXkxLCBmMngxLCBmMnkxOyAvLyBzdGFydGluZyBwb2ludHMgZm9yIHBpbmNoLXRvLXpvb21cbiAgICB2YXIgZGlzdGFuY2UxLCBkaXN0YW5jZTFTcTsgLy8gaW5pdGlhbCBkaXN0YW5jZSBiZXR3ZWVuIGZpbmdlciAxIGFuZCBmaW5nZXIgMiBmb3IgcGluY2gtdG8tem9vbVxuICAgIHZhciBjZW50ZXIxLCBtb2RlbENlbnRlcjE7IC8vIGNlbnRlciBwb2ludCBvbiBzdGFydCBwaW5jaCB0byB6b29tXG4gICAgdmFyIG9mZnNldExlZnQsIG9mZnNldFRvcDtcbiAgICB2YXIgY29udGFpbmVyV2lkdGgsIGNvbnRhaW5lckhlaWdodDtcbiAgICB2YXIgdHdvRmluZ2Vyc1N0YXJ0SW5zaWRlO1xuXG4gICAgdmFyIGRpc3RhbmNlID0gZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIpe1xuICAgICAgcmV0dXJuIE1hdGguc3FydCggKHgyLXgxKSooeDIteDEpICsgKHkyLXkxKSooeTIteTEpICk7XG4gICAgfTtcblxuICAgIHZhciBkaXN0YW5jZVNxID0gZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIpe1xuICAgICAgcmV0dXJuICh4Mi14MSkqKHgyLXgxKSArICh5Mi15MSkqKHkyLXkxKTtcbiAgICB9O1xuXG4gICAgci5yZWdpc3RlckJpbmRpbmcoci5kYXRhLmNvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbihlKSB7XG5cbiAgICAgIGNsZWFyVGltZW91dCggdGhpcy50aHJlZUZpbmdlclNlbGVjdFRpbWVvdXQgKTtcblxuICAgICAgaWYoIGUudGFyZ2V0ICE9PSByLmRhdGEubGluayApe1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIHIudG91Y2hEYXRhLmNhcHR1cmUgPSB0cnVlO1xuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuXG4gICAgICB2YXIgY3kgPSByLmRhdGEuY3k7XG4gICAgICB2YXIgbm9kZXMgPSByLmdldENhY2hlZE5vZGVzKCk7XG4gICAgICB2YXIgZWRnZXMgPSByLmdldENhY2hlZEVkZ2VzKCk7XG4gICAgICB2YXIgbm93ID0gci50b3VjaERhdGEubm93O1xuICAgICAgdmFyIGVhcmxpZXIgPSByLnRvdWNoRGF0YS5lYXJsaWVyO1xuICAgICAgdmFyIG5lZWRzUmVkcmF3ID0gci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3O1xuXG4gICAgICBpZiAoZS50b3VjaGVzWzBdKSB7IHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZKTsgbm93WzBdID0gcG9zWzBdOyBub3dbMV0gPSBwb3NbMV07IH1cbiAgICAgIGlmIChlLnRvdWNoZXNbMV0pIHsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMV0uY2xpZW50WCwgZS50b3VjaGVzWzFdLmNsaWVudFkpOyBub3dbMl0gPSBwb3NbMF07IG5vd1szXSA9IHBvc1sxXTsgfVxuICAgICAgaWYgKGUudG91Y2hlc1syXSkgeyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1syXS5jbGllbnRYLCBlLnRvdWNoZXNbMl0uY2xpZW50WSk7IG5vd1s0XSA9IHBvc1swXTsgbm93WzVdID0gcG9zWzFdOyB9XG5cblxuICAgICAgLy8gcmVjb3JkIHN0YXJ0aW5nIHBvaW50cyBmb3IgcGluY2gtdG8tem9vbVxuICAgICAgaWYoIGUudG91Y2hlc1sxXSApe1xuXG4gICAgICAgIC8vIGFueXRoaW5nIGluIHRoZSBzZXQgb2YgZHJhZ2dlZCBlbGVzIHNob3VsZCBiZSByZWxlYXNlZFxuICAgICAgICB2YXIgcmVsZWFzZSA9IGZ1bmN0aW9uKCBlbGVzICl7XG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICBlbGVzW2ldLl9wcml2YXRlLmdyYWJiZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGVsZXNbaV0uX3ByaXZhdGUucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmKCBlbGVzW2ldLmFjdGl2ZSgpICl7IGVsZXNbaV0udW5hY3RpdmF0ZSgpOyB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZWxlYXNlKG5vZGVzKTtcbiAgICAgICAgcmVsZWFzZShlZGdlcyk7XG5cbiAgICAgICAgdmFyIG9mZnNldHMgPSByLmZpbmRDb250YWluZXJDbGllbnRDb29yZHMoKTtcbiAgICAgICAgb2Zmc2V0TGVmdCA9IG9mZnNldHNbMF07XG4gICAgICAgIG9mZnNldFRvcCA9IG9mZnNldHNbMV07XG4gICAgICAgIGNvbnRhaW5lcldpZHRoID0gb2Zmc2V0c1syXTtcbiAgICAgICAgY29udGFpbmVySGVpZ2h0ID0gb2Zmc2V0c1szXTtcblxuICAgICAgICBmMXgxID0gZS50b3VjaGVzWzBdLmNsaWVudFggLSBvZmZzZXRMZWZ0O1xuICAgICAgICBmMXkxID0gZS50b3VjaGVzWzBdLmNsaWVudFkgLSBvZmZzZXRUb3A7XG5cbiAgICAgICAgZjJ4MSA9IGUudG91Y2hlc1sxXS5jbGllbnRYIC0gb2Zmc2V0TGVmdDtcbiAgICAgICAgZjJ5MSA9IGUudG91Y2hlc1sxXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuXG4gICAgICAgIHR3b0ZpbmdlcnNTdGFydEluc2lkZSA9XG4gICAgICAgICAgICAgMCA8PSBmMXgxICYmIGYxeDEgPD0gY29udGFpbmVyV2lkdGhcbiAgICAgICAgICAmJiAwIDw9IGYyeDEgJiYgZjJ4MSA8PSBjb250YWluZXJXaWR0aFxuICAgICAgICAgICYmIDAgPD0gZjF5MSAmJiBmMXkxIDw9IGNvbnRhaW5lckhlaWdodFxuICAgICAgICAgICYmIDAgPD0gZjJ5MSAmJiBmMnkxIDw9IGNvbnRhaW5lckhlaWdodFxuICAgICAgICA7XG5cbiAgICAgICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcblxuICAgICAgICBkaXN0YW5jZTEgPSBkaXN0YW5jZSggZjF4MSwgZjF5MSwgZjJ4MSwgZjJ5MSApO1xuICAgICAgICBkaXN0YW5jZTFTcSA9IGRpc3RhbmNlU3EoIGYxeDEsIGYxeTEsIGYyeDEsIGYyeTEgKTtcbiAgICAgICAgY2VudGVyMSA9IFsgKGYxeDEgKyBmMngxKS8yLCAoZjF5MSArIGYyeTEpLzIgXTtcbiAgICAgICAgbW9kZWxDZW50ZXIxID0gW1xuICAgICAgICAgIChjZW50ZXIxWzBdIC0gcGFuLngpIC8gem9vbSxcbiAgICAgICAgICAoY2VudGVyMVsxXSAtIHBhbi55KSAvIHpvb21cbiAgICAgICAgXTtcblxuICAgICAgICAvLyBjb25zaWRlciBjb250ZXh0IHRhcFxuICAgICAgICB2YXIgY3h0RGlzdFRocmVzaG9sZCA9IDIwMDtcbiAgICAgICAgdmFyIGN4dERpc3RUaHJlc2hvbGRTcSA9IGN4dERpc3RUaHJlc2hvbGQgKiBjeHREaXN0VGhyZXNob2xkO1xuICAgICAgICBpZiggZGlzdGFuY2UxU3EgPCBjeHREaXN0VGhyZXNob2xkU3EgJiYgIWUudG91Y2hlc1syXSApe1xuXG4gICAgICAgICAgdmFyIG5lYXIxID0gci5maW5kTmVhcmVzdEVsZW1lbnQobm93WzBdLCBub3dbMV0sIHRydWUsIHRydWUpO1xuICAgICAgICAgIHZhciBuZWFyMiA9IHIuZmluZE5lYXJlc3RFbGVtZW50KG5vd1syXSwgbm93WzNdLCB0cnVlLCB0cnVlKTtcblxuICAgICAgICAgIC8vY29uc29sZS5sb2coZGlzdGFuY2UxKVxuXG4gICAgICAgICAgaWYoIG5lYXIxICYmIG5lYXIxLmlzTm9kZSgpICl7XG4gICAgICAgICAgICBuZWFyMS5hY3RpdmF0ZSgpLnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICdjeHR0YXBzdGFydCcsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgfSkgKTtcbiAgICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbmVhcjE7XG5cbiAgICAgICAgICB9IGVsc2UgaWYoIG5lYXIyICYmIG5lYXIyLmlzTm9kZSgpICl7XG4gICAgICAgICAgICBuZWFyMi5hY3RpdmF0ZSgpLnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICdjeHR0YXBzdGFydCcsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgfSkgKTtcbiAgICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbmVhcjI7XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3kudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ2N4dHRhcHN0YXJ0JyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICB9KSApO1xuICAgICAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCByLnRvdWNoRGF0YS5zdGFydCApeyByLnRvdWNoRGF0YS5zdGFydC5fcHJpdmF0ZS5ncmFiYmVkID0gZmFsc2U7IH1cbiAgICAgICAgICByLnRvdWNoRGF0YS5jeHQgPSB0cnVlO1xuICAgICAgICAgIHIudG91Y2hEYXRhLmN4dERyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAvL2NvbnNvbGUubG9nKCdjeHR0YXBzdGFydCcpXG5cbiAgICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coY2VudGVyMSk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCd0b3VjaHN0YXJ0IHB0eicpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhvZmZzZXRMZWZ0LCBvZmZzZXRUb3ApO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhmMXgxLCBmMXkxKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coZjJ4MSwgZjJ5MSk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGRpc3RhbmNlMSk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGNlbnRlcjEpO1xuICAgICAgfVxuXG4gICAgICAvLyBjb25zb2xlLmxvZygnYW5vdGhlciB0YXBzdGFydCcpXG5cblxuICAgICAgaWYgKGUudG91Y2hlc1syXSkge1xuXG4gICAgICB9IGVsc2UgaWYgKGUudG91Y2hlc1sxXSkge1xuXG4gICAgICB9IGVsc2UgaWYgKGUudG91Y2hlc1swXSkge1xuICAgICAgICB2YXIgbmVhciA9IHIuZmluZE5lYXJlc3RFbGVtZW50KG5vd1swXSwgbm93WzFdLCB0cnVlLCB0cnVlKTtcblxuICAgICAgICBpZiAobmVhciAhPSBudWxsKSB7XG4gICAgICAgICAgbmVhci5hY3RpdmF0ZSgpO1xuXG4gICAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBuZWFyO1xuXG4gICAgICAgICAgaWYoIG5lYXIuaXNOb2RlKCkgJiYgci5ub2RlSXNEcmFnZ2FibGUobmVhcikgKXtcblxuICAgICAgICAgICAgdmFyIGRyYWdnZWRFbGVzID0gci5kcmFnRGF0YS50b3VjaERyYWdFbGVzID0gW107XG5cbiAgICAgICAgICAgIG5lZWRzUmVkcmF3W0NSLk5PREVdID0gdHJ1ZTtcbiAgICAgICAgICAgIG5lZWRzUmVkcmF3W0NSLkRSQUddID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYoIG5lYXIuc2VsZWN0ZWQoKSApe1xuICAgICAgICAgICAgICAvLyByZXNldCBkcmFnIGVsZW1lbnRzLCBzaW5jZSBuZWFyIHdpbGwgYmUgYWRkZWQgYWdhaW5cblxuICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWROb2RlcyA9IGN5LiQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pc05vZGUoKSAmJiB0aGlzLnNlbGVjdGVkKCk7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGZvciggdmFyIGsgPSAwOyBrIDwgc2VsZWN0ZWROb2Rlcy5sZW5ndGg7IGsrKyApe1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZE5vZGUgPSBzZWxlY3RlZE5vZGVzW2tdO1xuXG4gICAgICAgICAgICAgICAgaWYoIHIubm9kZUlzRHJhZ2dhYmxlKHNlbGVjdGVkTm9kZSkgKXtcbiAgICAgICAgICAgICAgICAgIGFkZE5vZGVUb0RyYWcoIHNlbGVjdGVkTm9kZSwgeyBhZGRUb0xpc3Q6IGRyYWdnZWRFbGVzIH0gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFkZE5vZGVUb0RyYWcoIG5lYXIsIHsgYWRkVG9MaXN0OiBkcmFnZ2VkRWxlcyB9ICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5lYXIudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ2dyYWInLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgIH0pICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmVhclxuICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3RvdWNoc3RhcnQnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3RhcHN0YXJ0JyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICd2bW91c2Rvd24nLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgIDtcbiAgICAgICAgfSBpZiAobmVhciA9PSBudWxsKSB7XG4gICAgICAgICAgY3lcbiAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICd0b3VjaHN0YXJ0JyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICd0YXBzdGFydCcsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAndm1vdXNlZG93bicsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgO1xuXG4gICAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0ge1xuICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIG5lZWRzUmVkcmF3W0NSLlNFTEVDVF9CT1hdID0gdHJ1ZTtcbiAgICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyBUYXAsIHRhcGhvbGRcbiAgICAgICAgLy8gLS0tLS1cblxuICAgICAgICBmb3IgKHZhciBpPTA7IGk8bm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZWFybGllcltpXSA9IG5vd1tpXTtcbiAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uW2ldID0gbm93W2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgci50b3VjaERhdGEuc2luZ2xlVG91Y2hNb3ZlZCA9IGZhbHNlO1xuICAgICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaFN0YXJ0VGltZSA9ICtuZXcgRGF0ZSgpO1xuXG4gICAgICAgIGNsZWFyVGltZW91dCggci50b3VjaERhdGEudGFwaG9sZFRpbWVvdXQgKTtcbiAgICAgICAgci50b3VjaERhdGEudGFwaG9sZFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmKFxuICAgICAgICAgICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkID09PSBmYWxzZVxuICAgICAgICAgICAgICAmJiAhci5waW5jaGluZyAvLyBpZiBwaW5jaGluZywgdGhlbiB0YXBob2xkIHVuc2VsZWN0IHNob3VsZG4ndCB0YWtlIGVmZmVjdFxuXG4gICAgICAgICAgICAgIC8vIFRoaXMgdGltZSBkb3VibGUgY29uc3RyYWludCBwcmV2ZW50cyBtdWx0aXBsZSBxdWljayB0YXBzXG4gICAgICAgICAgICAgIC8vIGZvbGxvd2VkIGJ5IGEgdGFwaG9sZCB0cmlnZ2VyaW5nIG11bHRpcGxlIHRhcGhvbGQgZXZlbnRzXG4gICAgICAgICAgICAgIC8vJiYgRGF0ZS5ub3coKSAtIHIudG91Y2hEYXRhLnNpbmdsZVRvdWNoU3RhcnRUaW1lID4gMjUwXG4gICAgICAgICAgKXtcbiAgICAgICAgICAgIGlmIChyLnRvdWNoRGF0YS5zdGFydCkge1xuICAgICAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydC50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0YXBob2xkJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgICAgfSkgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHIuZGF0YS5jeS50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0YXBob2xkJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgICAgfSkgKTtcblxuICAgICAgICAgICAgICBjeS4kKCc6c2VsZWN0ZWQnKS51bnNlbGVjdCgpO1xuICAgICAgICAgICAgfVxuXG4vLyAgICAgICAgICAgIGNvbnNvbGUubG9nKCd0YXBob2xkJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCByLnRhcGhvbGREdXJhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIC8vci5yZWRyYXcoKTtcblxuICAgIH0sIGZhbHNlKTtcblxuLy8gY29uc29sZS5sb2cgPSBmdW5jdGlvbihtKXsgJCgnI2NvbnNvbGUnKS5hcHBlbmQoJzxkaXY+JyttKyc8L2Rpdj4nKTsgfTtcblxuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHdpbmRvdywgJ3RvdWNobW92ZScsICQkLnV0aWwudGhyb3R0bGUoZnVuY3Rpb24oZSkge1xuXG4gICAgICB2YXIgc2VsZWN0ID0gci5kYXRhLnNlbGVjdDtcbiAgICAgIHZhciBjYXB0dXJlID0gci50b3VjaERhdGEuY2FwdHVyZTsgLy9pZiAoIWNhcHR1cmUpIHsgcmV0dXJuOyB9O1xuICAgICAgaWYoIGNhcHR1cmUgKXsgZS5wcmV2ZW50RGVmYXVsdCgpOyB9XG5cbiAgICAgIHZhciBjeSA9IHIuZGF0YS5jeTtcbiAgICAgIHZhciBub3cgPSByLnRvdWNoRGF0YS5ub3c7IHZhciBlYXJsaWVyID0gci50b3VjaERhdGEuZWFybGllcjtcbiAgICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgICAgXG4gICAgICB2YXIgbmVlZHNSZWRyYXcgPSByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXc7XG5cbiAgICAgIGlmIChlLnRvdWNoZXNbMF0pIHsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkpOyBub3dbMF0gPSBwb3NbMF07IG5vd1sxXSA9IHBvc1sxXTsgfVxuICAgICAgaWYgKGUudG91Y2hlc1sxXSkgeyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1sxXS5jbGllbnRYLCBlLnRvdWNoZXNbMV0uY2xpZW50WSk7IG5vd1syXSA9IHBvc1swXTsgbm93WzNdID0gcG9zWzFdOyB9XG4gICAgICBpZiAoZS50b3VjaGVzWzJdKSB7IHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzJdLmNsaWVudFgsIGUudG91Y2hlc1syXS5jbGllbnRZKTsgbm93WzRdID0gcG9zWzBdOyBub3dbNV0gPSBwb3NbMV07IH1cbiAgICAgIHZhciBkaXNwID0gW107IGZvciAodmFyIGo9MDtqPG5vdy5sZW5ndGg7aisrKSB7IGRpc3Bbal0gPSBub3dbal0gLSBlYXJsaWVyW2pdOyB9XG5cbiAgICAgIHZhciBzdGFydFBvcyA9IHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb247XG5cbiAgICAgIHZhciBkeCA9IG5vd1swXSAtIHN0YXJ0UG9zWzBdO1xuICAgICAgdmFyIGR4MiA9IGR4ICogZHg7XG4gICAgICB2YXIgZHkgPSBub3dbMV0gLSBzdGFydFBvc1sxXTtcbiAgICAgIHZhciBkeTIgPSBkeSAqIGR5O1xuICAgICAgdmFyIGRpc3QyID0gZHgyICsgZHkyO1xuICAgICAgdmFyIHJkaXN0MiA9IGRpc3QyICogem9vbSAqIHpvb207XG5cbiAgICAgIGlmKCBjYXB0dXJlICYmIHIudG91Y2hEYXRhLmN4dCApe1xuICAgICAgICB2YXIgZjF4MiA9IGUudG91Y2hlc1swXS5jbGllbnRYIC0gb2Zmc2V0TGVmdCwgZjF5MiA9IGUudG91Y2hlc1swXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuICAgICAgICB2YXIgZjJ4MiA9IGUudG91Y2hlc1sxXS5jbGllbnRYIC0gb2Zmc2V0TGVmdCwgZjJ5MiA9IGUudG91Y2hlc1sxXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuICAgICAgICAvLyB2YXIgZGlzdGFuY2UyID0gZGlzdGFuY2UoIGYxeDIsIGYxeTIsIGYyeDIsIGYyeTIgKTtcbiAgICAgICAgdmFyIGRpc3RhbmNlMlNxID0gZGlzdGFuY2VTcSggZjF4MiwgZjF5MiwgZjJ4MiwgZjJ5MiApO1xuICAgICAgICB2YXIgZmFjdG9yU3EgPSBkaXN0YW5jZTJTcSAvIGRpc3RhbmNlMVNxO1xuXG4gICAgICAgIHZhciBkaXN0VGhyZXNob2xkID0gMTUwO1xuICAgICAgICB2YXIgZGlzdFRocmVzaG9sZFNxID0gZGlzdFRocmVzaG9sZCAqIGRpc3RUaHJlc2hvbGQ7XG4gICAgICAgIHZhciBmYWN0b3JUaHJlc2hvbGQgPSAxLjU7XG4gICAgICAgIHZhciBmYWN0b3JUaHJlc2hvbGRTcSA9IGZhY3RvclRocmVzaG9sZCAqIGZhY3RvclRocmVzaG9sZDtcblxuICAgICAgICAvL2NvbnNvbGUubG9nKGZhY3RvciwgZGlzdGFuY2UyKVxuXG4gICAgICAgIC8vIGNhbmNlbCBjdHggZ2VzdHVyZXMgaWYgdGhlIGRpc3RhbmNlIGIvdCB0aGUgZmluZ2VycyBpbmNyZWFzZXNcbiAgICAgICAgaWYoIGZhY3RvclNxID49IGZhY3RvclRocmVzaG9sZFNxIHx8IGRpc3RhbmNlMlNxID49IGRpc3RUaHJlc2hvbGRTcSApe1xuICAgICAgICAgIHIudG91Y2hEYXRhLmN4dCA9IGZhbHNlO1xuICAgICAgICAgIGlmKCByLnRvdWNoRGF0YS5zdGFydCApeyByLnRvdWNoRGF0YS5zdGFydC51bmFjdGl2YXRlKCk7IHIudG91Y2hEYXRhLnN0YXJ0ID0gbnVsbDsgfVxuICAgICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZWVkc1JlZHJhd1tDUi5TRUxFQ1RfQk9YXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgY3h0RXZ0ID0gbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgIHR5cGU6ICdjeHR0YXBlbmQnLFxuICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYoIHIudG91Y2hEYXRhLnN0YXJ0ICl7XG4gICAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydC50cmlnZ2VyKCBjeHRFdnQgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3kudHJpZ2dlciggY3h0RXZ0ICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgaWYoIGNhcHR1cmUgJiYgci50b3VjaERhdGEuY3h0ICl7XG4gICAgICAgIHZhciBjeHRFdnQgPSBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgIHR5cGU6ICdjeHRkcmFnJyxcbiAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgbmVlZHNSZWRyYXdbQ1IuU0VMRUNUX0JPWF0gPSB0cnVlO1xuXG4gICAgICAgIGlmKCByLnRvdWNoRGF0YS5zdGFydCApe1xuICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0LnRyaWdnZXIoIGN4dEV2dCApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN5LnRyaWdnZXIoIGN4dEV2dCApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIHIudG91Y2hEYXRhLnN0YXJ0ICl7IHIudG91Y2hEYXRhLnN0YXJ0Ll9wcml2YXRlLmdyYWJiZWQgPSBmYWxzZTsgfVxuICAgICAgICByLnRvdWNoRGF0YS5jeHREcmFnZ2VkID0gdHJ1ZTtcblxuICAgICAgICAvL2NvbnNvbGUubG9nKCdjeHRkcmFnJylcblxuICAgICAgICB2YXIgbmVhciA9IHIuZmluZE5lYXJlc3RFbGVtZW50KG5vd1swXSwgbm93WzFdLCB0cnVlLCB0cnVlKTtcblxuICAgICAgICBpZiggIXIudG91Y2hEYXRhLmN4dE92ZXIgfHwgbmVhciAhPT0gci50b3VjaERhdGEuY3h0T3ZlciApe1xuXG4gICAgICAgICAgaWYoIHIudG91Y2hEYXRhLmN4dE92ZXIgKXtcbiAgICAgICAgICAgIHIudG91Y2hEYXRhLmN4dE92ZXIudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ2N4dGRyYWdvdXQnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgIH0pICk7XG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdjeHRkcmFnb3V0Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgci50b3VjaERhdGEuY3h0T3ZlciA9IG5lYXI7XG5cbiAgICAgICAgICBpZiggbmVhciApe1xuICAgICAgICAgICAgbmVhci50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAnY3h0ZHJhZ292ZXInLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgIH0pICk7XG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdjeHRkcmFnb3ZlcicpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSBpZiggY2FwdHVyZSAmJiBlLnRvdWNoZXNbMl0gJiYgY3kuYm94U2VsZWN0aW9uRW5hYmxlZCgpICl7XG4gICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgY2xlYXJUaW1lb3V0KCB0aGlzLnRocmVlRmluZ2VyU2VsZWN0VGltZW91dCApO1xuICAgICAgICB0aGlzLmxhc3RUaHJlZVRvdWNoID0gK25ldyBEYXRlKCk7XG4gICAgICAgIHIudG91Y2hEYXRhLnNlbGVjdGluZyA9IHRydWU7XG5cbiAgICAgICAgbmVlZHNSZWRyYXdbQ1IuU0VMRUNUX0JPWF0gPSB0cnVlO1xuXG4gICAgICAgIGlmKCAhc2VsZWN0IHx8IHNlbGVjdC5sZW5ndGggPT09IDAgfHwgc2VsZWN0WzBdID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICBzZWxlY3RbMF0gPSAobm93WzBdICsgbm93WzJdICsgbm93WzRdKS8zO1xuICAgICAgICAgIHNlbGVjdFsxXSA9IChub3dbMV0gKyBub3dbM10gKyBub3dbNV0pLzM7XG4gICAgICAgICAgc2VsZWN0WzJdID0gKG5vd1swXSArIG5vd1syXSArIG5vd1s0XSkvMyArIDE7XG4gICAgICAgICAgc2VsZWN0WzNdID0gKG5vd1sxXSArIG5vd1szXSArIG5vd1s1XSkvMyArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZWN0WzJdID0gKG5vd1swXSArIG5vd1syXSArIG5vd1s0XSkvMztcbiAgICAgICAgICBzZWxlY3RbM10gPSAobm93WzFdICsgbm93WzNdICsgbm93WzVdKS8zO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZWN0WzRdID0gMTtcbiAgICAgICAgci50b3VjaERhdGEuc2VsZWN0aW5nID0gdHJ1ZTtcblxuICAgICAgICByLnJlZHJhdygpO1xuXG4gICAgICB9IGVsc2UgaWYgKCBjYXB0dXJlICYmIGUudG91Y2hlc1sxXSAmJiBjeS56b29taW5nRW5hYmxlZCgpICYmIGN5LnBhbm5pbmdFbmFibGVkKCkgJiYgY3kudXNlclpvb21pbmdFbmFibGVkKCkgJiYgY3kudXNlclBhbm5pbmdFbmFibGVkKCkgKSB7IC8vIHR3byBmaW5nZXJzID0+IHBpbmNoIHRvIHpvb21cbiAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICBuZWVkc1JlZHJhd1tDUi5TRUxFQ1RfQk9YXSA9IHRydWU7XG5cbiAgICAgICAgdmFyIGRyYWdnZWRFbGVzID0gci5kcmFnRGF0YS50b3VjaERyYWdFbGVzO1xuICAgICAgICBpZiggZHJhZ2dlZEVsZXMgKXtcbiAgICAgICAgICBuZWVkc1JlZHJhd1tDUi5EUkFHXSA9IHRydWU7XG5cbiAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGRyYWdnZWRFbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICBkcmFnZ2VkRWxlc1tpXS5fcHJpdmF0ZS5ncmFiYmVkID0gZmFsc2U7XG4gICAgICAgICAgICBkcmFnZ2VkRWxlc1tpXS5fcHJpdmF0ZS5yc2NyYXRjaC5pbkRyYWdMYXllciA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCd0b3VjaG1vdmUgcHR6Jyk7XG5cbiAgICAgICAgLy8gKHgyLCB5MikgZm9yIGZpbmdlcnMgMSBhbmQgMlxuICAgICAgICB2YXIgZjF4MiA9IGUudG91Y2hlc1swXS5jbGllbnRYIC0gb2Zmc2V0TGVmdCwgZjF5MiA9IGUudG91Y2hlc1swXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuICAgICAgICB2YXIgZjJ4MiA9IGUudG91Y2hlc1sxXS5jbGllbnRYIC0gb2Zmc2V0TGVmdCwgZjJ5MiA9IGUudG91Y2hlc1sxXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCBmMXgyLCBmMXkyIClcbiAgICAgICAgLy8gY29uc29sZS5sb2coIGYyeDIsIGYyeTIgKVxuXG4gICAgICAgIHZhciBkaXN0YW5jZTIgPSBkaXN0YW5jZSggZjF4MiwgZjF5MiwgZjJ4MiwgZjJ5MiApO1xuICAgICAgICAvLyB2YXIgZGlzdGFuY2UyU3EgPSBkaXN0YW5jZVNxKCBmMXgyLCBmMXkyLCBmMngyLCBmMnkyICk7XG4gICAgICAgIC8vIHZhciBmYWN0b3IgPSBNYXRoLnNxcnQoIGRpc3RhbmNlMlNxICkgLyBNYXRoLnNxcnQoIGRpc3RhbmNlMVNxICk7XG4gICAgICAgIHZhciBmYWN0b3IgPSBkaXN0YW5jZTIgLyBkaXN0YW5jZTE7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coZGlzdGFuY2UyKVxuICAgICAgICAvLyBjb25zb2xlLmxvZyhmYWN0b3IpXG5cbiAgICAgICAgaWYoIGZhY3RvciAhPSAxICYmIHR3b0ZpbmdlcnNTdGFydEluc2lkZSl7XG5cbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhmYWN0b3IpXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coZGlzdGFuY2UyICsgJyAvICcgKyBkaXN0YW5jZTEpO1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCctLScpO1xuXG4gICAgICAgICAgLy8gZGVsdGEgZmluZ2VyMVxuICAgICAgICAgIHZhciBkZjF4ID0gZjF4MiAtIGYxeDE7XG4gICAgICAgICAgdmFyIGRmMXkgPSBmMXkyIC0gZjF5MTtcblxuICAgICAgICAgIC8vIGRlbHRhIGZpbmdlciAyXG4gICAgICAgICAgdmFyIGRmMnggPSBmMngyIC0gZjJ4MTtcbiAgICAgICAgICB2YXIgZGYyeSA9IGYyeTIgLSBmMnkxO1xuXG4gICAgICAgICAgLy8gdHJhbnNsYXRpb24gaXMgdGhlIG5vcm1hbGlzZWQgdmVjdG9yIG9mIHRoZSB0d28gZmluZ2VycyBtb3ZlbWVudFxuICAgICAgICAgIC8vIGkuZS4gc28gcGluY2hpbmcgY2FuY2VscyBvdXQgYW5kIG1vdmluZyB0b2dldGhlciBwYW5zXG4gICAgICAgICAgdmFyIHR4ID0gKGRmMXggKyBkZjJ4KS8yO1xuICAgICAgICAgIHZhciB0eSA9IChkZjF5ICsgZGYyeSkvMjtcblxuICAgICAgICAgIC8vIGFkanVzdCBmYWN0b3IgYnkgdGhlIHNwZWVkIG11bHRpcGxpZXJcbiAgICAgICAgICAvLyB2YXIgc3BlZWQgPSAxLjU7XG4gICAgICAgICAgLy8gaWYoIGZhY3RvciA+IDEgKXtcbiAgICAgICAgICAvLyAgIGZhY3RvciA9IChmYWN0b3IgLSAxKSAqIHNwZWVkICsgMTtcbiAgICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICAgIC8vICAgZmFjdG9yID0gMSAtICgxIC0gZmFjdG9yKSAqIHNwZWVkO1xuICAgICAgICAgIC8vIH1cblxuICAgICAgICAgIC8vIG5vdyBjYWxjdWxhdGUgdGhlIHpvb21cbiAgICAgICAgICB2YXIgem9vbTEgPSBjeS56b29tKCk7XG4gICAgICAgICAgdmFyIHpvb20yID0gem9vbTEgKiBmYWN0b3I7XG4gICAgICAgICAgdmFyIHBhbjEgPSBjeS5wYW4oKTtcblxuICAgICAgICAgIC8vIHRoZSBtb2RlbCBjZW50ZXIgcG9pbnQgY29udmVydGVkIHRvIHRoZSBjdXJyZW50IHJlbmRlcmVkIHBvc1xuICAgICAgICAgIHZhciBjdHJ4ID0gbW9kZWxDZW50ZXIxWzBdICogem9vbTEgKyBwYW4xLng7XG4gICAgICAgICAgdmFyIGN0cnkgPSBtb2RlbENlbnRlcjFbMV0gKiB6b29tMSArIHBhbjEueTtcblxuICAgICAgICAgIHZhciBwYW4yID0ge1xuICAgICAgICAgICAgeDogLXpvb20yL3pvb20xICogKGN0cnggLSBwYW4xLnggLSB0eCkgKyBjdHJ4LFxuICAgICAgICAgICAgeTogLXpvb20yL3pvb20xICogKGN0cnkgLSBwYW4xLnkgLSB0eSkgKyBjdHJ5XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHBhbjIpO1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHpvb20yKTtcblxuICAgICAgICAgIC8vIHJlbW92ZSBkcmFnZ2VkIGVsZXNcbiAgICAgICAgICBpZiggci50b3VjaERhdGEuc3RhcnQgKXtcbiAgICAgICAgICAgIHZhciBkcmFnZ2VkRWxlcyA9IHIuZHJhZ0RhdGEudG91Y2hEcmFnRWxlcztcblxuICAgICAgICAgICAgaWYoIGRyYWdnZWRFbGVzICl7IGZvciggdmFyIGkgPSAwOyBpIDwgZHJhZ2dlZEVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgICAgdmFyIGRFaV9wID0gZHJhZ2dlZEVsZXNbaV0uX3ByaXZhdGU7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBkRWlfcC5ncmFiYmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGRFaV9wLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gZmFsc2U7XG4gICAgICAgICAgICB9IH1cblxuICAgICAgICAgICAgdmFyIHN0YXJ0X3AgPSByLnRvdWNoRGF0YS5zdGFydC5fcHJpdmF0ZTtcbiAgICAgICAgICAgIHN0YXJ0X3AuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICBzdGFydF9wLmdyYWJiZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHN0YXJ0X3AucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSBmYWxzZTtcblxuICAgICAgICAgICAgbmVlZHNSZWRyYXdbQ1IuRFJBR10gPSB0cnVlO1xuXG4gICAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydFxuICAgICAgICAgICAgICAudHJpZ2dlcignZnJlZScpXG4gICAgICAgICAgICAgIC50cmlnZ2VyKCd1bmFjdGl2YXRlJylcbiAgICAgICAgICAgIDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjeS52aWV3cG9ydCh7XG4gICAgICAgICAgICB6b29tOiB6b29tMixcbiAgICAgICAgICAgIHBhbjogcGFuMixcbiAgICAgICAgICAgIGNhbmNlbE9uRmFpbGVkWm9vbTogdHJ1ZVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZGlzdGFuY2UxID0gZGlzdGFuY2UyO1xuICAgICAgICAgIGYxeDEgPSBmMXgyO1xuICAgICAgICAgIGYxeTEgPSBmMXkyO1xuICAgICAgICAgIGYyeDEgPSBmMngyO1xuICAgICAgICAgIGYyeTEgPSBmMnkyO1xuXG4gICAgICAgICAgci5waW5jaGluZyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZS1wcm9qZWN0XG4gICAgICAgIGlmIChlLnRvdWNoZXNbMF0pIHsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkpOyBub3dbMF0gPSBwb3NbMF07IG5vd1sxXSA9IHBvc1sxXTsgfVxuICAgICAgICBpZiAoZS50b3VjaGVzWzFdKSB7IHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzFdLmNsaWVudFgsIGUudG91Y2hlc1sxXS5jbGllbnRZKTsgbm93WzJdID0gcG9zWzBdOyBub3dbM10gPSBwb3NbMV07IH1cbiAgICAgICAgaWYgKGUudG91Y2hlc1syXSkgeyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1syXS5jbGllbnRYLCBlLnRvdWNoZXNbMl0uY2xpZW50WSk7IG5vd1s0XSA9IHBvc1swXTsgbm93WzVdID0gcG9zWzFdOyB9XG5cbiAgICAgIH0gZWxzZSBpZiAoZS50b3VjaGVzWzBdKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHIudG91Y2hEYXRhLnN0YXJ0O1xuICAgICAgICB2YXIgbGFzdCA9IHIudG91Y2hEYXRhLmxhc3Q7XG4gICAgICAgIHZhciBuZWFyID0gbmVhciB8fCByLmZpbmROZWFyZXN0RWxlbWVudChub3dbMF0sIG5vd1sxXSwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYoIHN0YXJ0ICE9IG51bGwgJiYgc3RhcnQuX3ByaXZhdGUuZ3JvdXAgPT0gJ25vZGVzJyAmJiByLm5vZGVJc0RyYWdnYWJsZShzdGFydCkgKXtcblxuICAgICAgICAgIGlmKCByZGlzdDIgPj0gci50b3VjaFRhcFRocmVzaG9sZDIgKXsgLy8gdGhlbiBkcmFnZ2luZyBjYW4gaGFwcGVuXG4gICAgICAgICAgICB2YXIgZHJhZ2dlZEVsZXMgPSByLmRyYWdEYXRhLnRvdWNoRHJhZ0VsZXM7XG5cbiAgICAgICAgICAgIGZvciggdmFyIGsgPSAwOyBrIDwgZHJhZ2dlZEVsZXMubGVuZ3RoOyBrKysgKXtcbiAgICAgICAgICAgICAgdmFyIGRyYWdnZWRFbGUgPSBkcmFnZ2VkRWxlc1trXTtcblxuICAgICAgICAgICAgICBpZiggci5ub2RlSXNEcmFnZ2FibGUoZHJhZ2dlZEVsZSkgJiYgZHJhZ2dlZEVsZS5pc05vZGUoKSAmJiBkcmFnZ2VkRWxlLmdyYWJiZWQoKSApe1xuICAgICAgICAgICAgICAgIHIuZHJhZ0RhdGEuZGlkRHJhZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIGRQb3MgPSBkcmFnZ2VkRWxlLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIHZhciBqdXN0U3RhcnRlZERyYWcgPSAhci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzO1xuXG4gICAgICAgICAgICAgICAgaWYoICQkLmlzLm51bWJlcihkaXNwWzBdKSAmJiAkJC5pcy5udW1iZXIoZGlzcFsxXSkgKXtcbiAgICAgICAgICAgICAgICAgIGRQb3MueCArPSBkaXNwWzBdO1xuICAgICAgICAgICAgICAgICAgZFBvcy55ICs9IGRpc3BbMV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYoIGp1c3RTdGFydGVkRHJhZyApe1xuICAgICAgICAgICAgICAgICAgYWRkTm9kZVRvRHJhZyggZHJhZ2dlZEVsZSwgeyBpbkRyYWdMYXllcjogdHJ1ZSB9ICk7XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIG5lZWRzUmVkcmF3W0NSLk5PREVdID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgdmFyIGRyYWdEZWx0YSA9IHIudG91Y2hEYXRhLmRyYWdEZWx0YTtcblxuICAgICAgICAgICAgICAgICAgaWYoICQkLmlzLm51bWJlcihkcmFnRGVsdGFbMF0pICYmICQkLmlzLm51bWJlcihkcmFnRGVsdGFbMV0pICl7XG4gICAgICAgICAgICAgICAgICAgIGRQb3MueCArPSBkcmFnRGVsdGFbMF07XG4gICAgICAgICAgICAgICAgICAgIGRQb3MueSArPSBkcmFnRGVsdGFbMV07XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRjb2wgPSBuZXcgJCQuQ29sbGVjdGlvbihjeSwgZHJhZ2dlZEVsZSk7XG5cbiAgICAgICAgICAgIHRjb2wudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgICAgICAgICAgIHRjb2wudHJpZ2dlcigncG9zaXRpb24gZHJhZycpO1xuXG4gICAgICAgICAgICByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgPSB0cnVlO1xuXG4gICAgICAgICAgICBuZWVkc1JlZHJhd1tDUi5EUkFHXSA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmKFxuICAgICAgICAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uWzBdID09IGVhcmxpZXJbMF1cbiAgICAgICAgICAgICAgJiYgci50b3VjaERhdGEuc3RhcnRQb3NpdGlvblsxXSA9PSBlYXJsaWVyWzFdXG4gICAgICAgICAgICApe1xuXG4gICAgICAgICAgICAgIG5lZWRzUmVkcmF3W0NSLk5PREVdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgICB9IGVsc2UgeyAvLyBvdGhlcmlzZSBrZWVwIHRyYWNrIG9mIGRyYWcgZGVsdGEgZm9yIGxhdGVyXG4gICAgICAgICAgICB2YXIgZHJhZ0RlbHRhID0gci50b3VjaERhdGEuZHJhZ0RlbHRhID0gci50b3VjaERhdGEuZHJhZ0RlbHRhIHx8IFtdO1xuXG4gICAgICAgICAgICBpZiggZHJhZ0RlbHRhLmxlbmd0aCA9PT0gMCApe1xuICAgICAgICAgICAgICBkcmFnRGVsdGEucHVzaCggZGlzcFswXSApO1xuICAgICAgICAgICAgICBkcmFnRGVsdGEucHVzaCggZGlzcFsxXSApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZHJhZ0RlbHRhWzBdICs9IGRpc3BbMF07XG4gICAgICAgICAgICAgIGRyYWdEZWx0YVsxXSArPSBkaXNwWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRvdWNobW92ZSBldmVudFxuICAgICAgICB7XG5cbiAgICAgICAgICBpZiAoc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhcnQudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3RvdWNobW92ZScsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgfSkgKTtcblxuICAgICAgICAgICAgc3RhcnQudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3RhcGRyYWcnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgIH0pICk7XG5cbiAgICAgICAgICAgIHN0YXJ0LnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICd2bW91c2Vtb3ZlJyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICB9KSApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdGFydCA9PSBudWxsKSB7XG5cbiAgICAgICAgICAgIGlmIChuZWFyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgbmVhci50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0b3VjaG1vdmUnLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgICB9KSApO1xuXG4gICAgICAgICAgICAgIG5lYXIudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGFwZHJhZycsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICAgIH0pICk7XG5cbiAgICAgICAgICAgICAgbmVhci50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd2bW91c2Vtb3ZlJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgICAgfSkgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5lYXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICBjeS50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0b3VjaG1vdmUnLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgICB9KSApO1xuXG4gICAgICAgICAgICAgIGN5LnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RhcGRyYWcnLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgICB9KSApO1xuXG4gICAgICAgICAgICAgIGN5LnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3Ztb3VzZW1vdmUnLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgICB9KSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChuZWFyICE9IGxhc3QpIHtcbiAgICAgICAgICAgIGlmIChsYXN0KSB7IGxhc3QudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwgeyB0eXBlOiAndGFwZHJhZ291dCcsIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfSB9KSk7IH1cbiAgICAgICAgICAgIGlmIChuZWFyKSB7IG5lYXIudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwgeyB0eXBlOiAndGFwZHJhZ292ZXInLCBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH0gfSkpOyB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgci50b3VjaERhdGEubGFzdCA9IG5lYXI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayB0byBjYW5jZWwgdGFwaG9sZFxuICAgICAgICBmb3IgKHZhciBpPTA7aTxub3cubGVuZ3RoO2krKykge1xuICAgICAgICAgIGlmIChub3dbaV1cbiAgICAgICAgICAgICYmIHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb25baV1cbiAgICAgICAgICAgICYmIE1hdGguYWJzKG5vd1tpXSAtIHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb25baV0pID4gNCkge1xuXG4gICAgICAgICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZihcbiAgICAgICAgICAgIGNhcHR1cmVcbiAgICAgICAgICAgICYmICggc3RhcnQgPT0gbnVsbCB8fCBzdGFydC5pc0VkZ2UoKSApXG4gICAgICAgICAgICAmJiBjeS5wYW5uaW5nRW5hYmxlZCgpICYmIGN5LnVzZXJQYW5uaW5nRW5hYmxlZCgpXG4gICAgICAgICl7XG5cbiAgICAgICAgICBpZiggci5zd2lwZVBhbm5pbmcgKXtcbiAgICAgICAgICAgIGN5LnBhbkJ5KHtcbiAgICAgICAgICAgICAgeDogZGlzcFswXSAqIHpvb20sXG4gICAgICAgICAgICAgIHk6IGRpc3BbMV0gKiB6b29tXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIH0gZWxzZSBpZiggcmRpc3QyID49IHIudG91Y2hUYXBUaHJlc2hvbGQyICl7XG4gICAgICAgICAgICByLnN3aXBlUGFubmluZyA9IHRydWU7XG5cbiAgICAgICAgICAgIGN5LnBhbkJ5KHtcbiAgICAgICAgICAgICAgeDogZHggKiB6b29tLFxuICAgICAgICAgICAgICB5OiBkeSAqIHpvb21cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCBzdGFydCApe1xuICAgICAgICAgICAgc3RhcnQudW5hY3RpdmF0ZSgpO1xuXG4gICAgICAgICAgICBpZiggIXIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiApe1xuICAgICAgICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB7XG4gICAgICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBuZWVkc1JlZHJhd1tDUi5TRUxFQ1RfQk9YXSA9IHRydWU7XG5cbiAgICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBSZS1wcm9qZWN0XG4gICAgICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkpO1xuICAgICAgICAgIG5vd1swXSA9IHBvc1swXTsgbm93WzFdID0gcG9zWzFdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGo9MDsgajxub3cubGVuZ3RoOyBqKyspIHsgZWFybGllcltqXSA9IG5vd1tqXTsgfVxuICAgICAgLy9yLnJlZHJhdygpO1xuXG4gICAgfSwgMTAwMC8zMCwgeyB0cmFpbGluZzogdHJ1ZSB9KSwgZmFsc2UpO1xuXG4gICAgci5yZWdpc3RlckJpbmRpbmcod2luZG93LCAndG91Y2hjYW5jZWwnLCBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgc3RhcnQgPSByLnRvdWNoRGF0YS5zdGFydDtcblxuICAgICAgci50b3VjaERhdGEuY2FwdHVyZSA9IGZhbHNlO1xuXG4gICAgICBpZiggc3RhcnQgKXtcbiAgICAgICAgc3RhcnQudW5hY3RpdmF0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgci5yZWdpc3RlckJpbmRpbmcod2luZG93LCAndG91Y2hlbmQnLCBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgc3RhcnQgPSByLnRvdWNoRGF0YS5zdGFydDtcblxuICAgICAgdmFyIGNhcHR1cmUgPSByLnRvdWNoRGF0YS5jYXB0dXJlO1xuXG4gICAgICBpZiggY2FwdHVyZSApe1xuICAgICAgICByLnRvdWNoRGF0YS5jYXB0dXJlID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHZhciBzZWxlY3QgPSByLmRhdGEuc2VsZWN0O1xuXG4gICAgICByLnN3aXBlUGFubmluZyA9IGZhbHNlO1xuICAgICAgci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzID0gZmFsc2U7XG5cbiAgICAgIHZhciBjeSA9IHIuZGF0YS5jeTtcbiAgICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgICAgdmFyIG5vdyA9IHIudG91Y2hEYXRhLm5vdztcbiAgICAgIHZhciBlYXJsaWVyID0gci50b3VjaERhdGEuZWFybGllcjtcbiAgICAgIFxuICAgICAgdmFyIG5lZWRzUmVkcmF3ID0gci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3O1xuXG4gICAgICBpZiAoZS50b3VjaGVzWzBdKSB7IHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZKTsgbm93WzBdID0gcG9zWzBdOyBub3dbMV0gPSBwb3NbMV07IH1cbiAgICAgIGlmIChlLnRvdWNoZXNbMV0pIHsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMV0uY2xpZW50WCwgZS50b3VjaGVzWzFdLmNsaWVudFkpOyBub3dbMl0gPSBwb3NbMF07IG5vd1szXSA9IHBvc1sxXTsgfVxuICAgICAgaWYgKGUudG91Y2hlc1syXSkgeyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1syXS5jbGllbnRYLCBlLnRvdWNoZXNbMl0uY2xpZW50WSk7IG5vd1s0XSA9IHBvc1swXTsgbm93WzVdID0gcG9zWzFdOyB9XG5cbiAgICAgIGlmKCBzdGFydCApe1xuICAgICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdHhUYXBlbmQ7XG4gICAgICBpZiggci50b3VjaERhdGEuY3h0ICl7XG4gICAgICAgIGN0eFRhcGVuZCA9IG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgdHlwZTogJ2N4dHRhcGVuZCcsXG4gICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmKCBzdGFydCApe1xuICAgICAgICAgIHN0YXJ0LnRyaWdnZXIoIGN0eFRhcGVuZCApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN5LnRyaWdnZXIoIGN0eFRhcGVuZCApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9jb25zb2xlLmxvZygnY3h0dGFwZW5kJylcblxuICAgICAgICBpZiggIXIudG91Y2hEYXRhLmN4dERyYWdnZWQgKXtcbiAgICAgICAgICB2YXIgY3R4VGFwID0gbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgIHR5cGU6ICdjeHR0YXAnLFxuICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiggc3RhcnQgKXtcbiAgICAgICAgICAgIHN0YXJ0LnRyaWdnZXIoIGN0eFRhcCApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjeS50cmlnZ2VyKCBjdHhUYXAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvL2NvbnNvbGUubG9nKCdjeHR0YXAnKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoIHIudG91Y2hEYXRhLnN0YXJ0ICl7IHIudG91Y2hEYXRhLnN0YXJ0Ll9wcml2YXRlLmdyYWJiZWQgPSBmYWxzZTsgfVxuICAgICAgICByLnRvdWNoRGF0YS5jeHQgPSBmYWxzZTtcbiAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBudWxsO1xuXG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gbm8gbW9yZSBib3ggc2VsZWN0aW9uIGlmIHdlIGRvbid0IGhhdmUgdGhyZWUgZmluZ2Vyc1xuICAgICAgaWYoICFlLnRvdWNoZXNbMl0gJiYgY3kuYm94U2VsZWN0aW9uRW5hYmxlZCgpICYmIHIudG91Y2hEYXRhLnNlbGVjdGluZyApe1xuICAgICAgICByLnRvdWNoRGF0YS5zZWxlY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KCB0aGlzLnRocmVlRmluZ2VyU2VsZWN0VGltZW91dCApO1xuICAgICAgICAvL3RoaXMudGhyZWVGaW5nZXJTZWxlY3RUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgIHZhciBuZXdseVNlbGVjdGVkID0gW107XG4gICAgICAgICAgdmFyIGJveCA9IHIuZ2V0QWxsSW5Cb3goIHNlbGVjdFswXSwgc2VsZWN0WzFdLCBzZWxlY3RbMl0sIHNlbGVjdFszXSApO1xuXG4gICAgICAgICAgc2VsZWN0WzBdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHNlbGVjdFsxXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBzZWxlY3RbMl0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgc2VsZWN0WzNdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHNlbGVjdFs0XSA9IDA7XG5cbiAgICAgICAgICBuZWVkc1JlZHJhd1tDUi5TRUxFQ1RfQk9YXSA9IHRydWU7XG5cbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhib3gpO1xuICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpPCBib3gubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICBpZiggYm94W2ldLl9wcml2YXRlLnNlbGVjdGFibGUgKXtcbiAgICAgICAgICAgICAgbmV3bHlTZWxlY3RlZC5wdXNoKCBib3hbaV0gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbmV3bHlTZWxDb2wgPSBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIG5ld2x5U2VsZWN0ZWQgKTtcblxuICAgICAgICAgIGlmKCBjeS5zZWxlY3Rpb25UeXBlKCkgPT09ICdzaW5nbGUnICl7XG4gICAgICAgICAgICBjeS4kKCc6c2VsZWN0ZWQnKS51bm1lcmdlKCBuZXdseVNlbENvbCApLnVuc2VsZWN0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV3bHlTZWxDb2wuc2VsZWN0KCk7XG5cbiAgICAgICAgICBpZiggbmV3bHlTZWxDb2wubGVuZ3RoID4gMCApIHtcbiAgICAgICAgICAgIG5lZWRzUmVkcmF3W0NSLk5PREVdID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgLy99LCAxMDApO1xuICAgICAgfVxuXG4gICAgICB2YXIgdXBkYXRlU3RhcnRTdHlsZSA9IGZhbHNlO1xuXG4gICAgICBpZiggc3RhcnQgIT0gbnVsbCApe1xuICAgICAgICBzdGFydC5fcHJpdmF0ZS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdXBkYXRlU3RhcnRTdHlsZSA9IHRydWU7XG4gICAgICAgIHN0YXJ0LnVuYWN0aXZhdGUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGUudG91Y2hlc1syXSkge1xuICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIG5lZWRzUmVkcmF3W0NSLlNFTEVDVF9CT1hdID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZS50b3VjaGVzWzFdKSB7XG5cbiAgICAgIH0gZWxzZSBpZiAoZS50b3VjaGVzWzBdKSB7XG5cbiAgICAgIC8vIExhc3QgdG91Y2ggcmVsZWFzZWRcbiAgICAgIH0gZWxzZSBpZiAoIWUudG91Y2hlc1swXSkge1xuXG4gICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgbmVlZHNSZWRyYXdbQ1IuU0VMRUNUX0JPWF0gPSB0cnVlO1xuICAgICAgICBcbiAgICAgICAgdmFyIGRyYWdnZWRFbGVzID0gci5kcmFnRGF0YS50b3VjaERyYWdFbGVzO1xuXG4gICAgICAgIGlmIChzdGFydCAhPSBudWxsICkge1xuXG4gICAgICAgICAgdmFyIHN0YXJ0V2FzR3JhYmJlZCA9IHN0YXJ0Ll9wcml2YXRlLmdyYWJiZWQ7XG4gICAgICAgICAgXG4gICAgICAgICAgZnJlZURyYWdnZWRFbGVtZW50cyggZHJhZ2dlZEVsZXMgKTtcblxuICAgICAgICAgIG5lZWRzUmVkcmF3W0NSLkRSQUddID0gdHJ1ZTtcbiAgICAgICAgICBuZWVkc1JlZHJhd1tDUi5OT0RFXSA9IHRydWU7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYoIHN0YXJ0V2FzR3JhYmJlZCApe1xuICAgICAgICAgICAgc3RhcnQudHJpZ2dlcignZnJlZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN0YXJ0XG4gICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAndG91Y2hlbmQnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3RhcGVuZCcsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAndm1vdXNldXAnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgIDtcblxuICAgICAgICAgIHN0YXJ0LnVuYWN0aXZhdGUoKTtcblxuICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbnVsbDtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBuZWFyID0gci5maW5kTmVhcmVzdEVsZW1lbnQobm93WzBdLCBub3dbMV0sIHRydWUsIHRydWUpO1xuXG4gICAgICAgICAgaWYgKG5lYXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgbmVhclxuICAgICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0b3VjaGVuZCcsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0YXBlbmQnLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndm1vdXNldXAnLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobmVhciA9PSBudWxsKSB7XG4gICAgICAgICAgICBjeVxuICAgICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0b3VjaGVuZCcsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0YXBlbmQnLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndm1vdXNldXAnLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHggPSByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uWzBdIC0gbm93WzBdO1xuICAgICAgICB2YXIgZHgyID0gZHggKiBkeDtcbiAgICAgICAgdmFyIGR5ID0gci50b3VjaERhdGEuc3RhcnRQb3NpdGlvblsxXSAtIG5vd1sxXTtcbiAgICAgICAgdmFyIGR5MiA9IGR5ICogZHk7XG4gICAgICAgIHZhciBkaXN0MiA9IGR4MiArIGR5MjtcbiAgICAgICAgdmFyIHJkaXN0MiA9IGRpc3QyICogem9vbSAqIHpvb207XG5cbiAgICAgICAgLy8gUHJlcGFyZSB0byBzZWxlY3QgdGhlIGN1cnJlbnRseSB0b3VjaGVkIG5vZGUsIG9ubHkgaWYgaXQgaGFzbid0IGJlZW4gZHJhZ2dlZCBwYXN0IGEgY2VydGFpbiBkaXN0YW5jZVxuICAgICAgICBpZiAoc3RhcnQgIT0gbnVsbFxuICAgICAgICAgICAgJiYgIXIuZHJhZ0RhdGEuZGlkRHJhZyAvLyBkaWRuJ3QgZHJhZyBub2RlcyBhcm91bmRcbiAgICAgICAgICAgICYmIHN0YXJ0Ll9wcml2YXRlLnNlbGVjdGFibGVcbiAgICAgICAgICAgICYmIHJkaXN0MiA8IHIudG91Y2hUYXBUaHJlc2hvbGQyXG4gICAgICAgICAgICAmJiAhci5waW5jaGluZyAvLyBwaW5jaCB0byB6b29tIHNob3VsZCBub3QgYWZmZWN0IHNlbGVjdGlvblxuICAgICAgICApIHtcblxuICAgICAgICAgIGlmKCBjeS5zZWxlY3Rpb25UeXBlKCkgPT09ICdzaW5nbGUnICl7XG4gICAgICAgICAgICBjeS4kKCc6c2VsZWN0ZWQnKS51bm1lcmdlKCBzdGFydCApLnVuc2VsZWN0KCk7XG4gICAgICAgICAgICBzdGFydC5zZWxlY3QoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYoIHN0YXJ0LnNlbGVjdGVkKCkgKXtcbiAgICAgICAgICAgICAgc3RhcnQudW5zZWxlY3QoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0YXJ0LnNlbGVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHVwZGF0ZVN0YXJ0U3R5bGUgPSB0cnVlO1xuXG5cbiAgICAgICAgICBuZWVkc1JlZHJhd1tDUi5OT0RFXSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUYXAgZXZlbnQsIHJvdWdobHkgc2FtZSBhcyBtb3VzZSBjbGljayBldmVudCBmb3IgdG91Y2hcbiAgICAgICAgaWYgKCByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkID09PSBmYWxzZSApIHtcblxuICAgICAgICAgIGlmIChzdGFydCkge1xuICAgICAgICAgICAgc3RhcnRcbiAgICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGFwJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3ZjbGljaycsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjeVxuICAgICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0YXAnLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndmNsaWNrJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICA7XG4gICAgICAgICAgfVxuXG4vLyAgICAgICAgICBjb25zb2xlLmxvZygndGFwJyk7XG4gICAgICAgIH1cblxuICAgICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBub3cubGVuZ3RoOyBqKysgKXsgZWFybGllcltqXSA9IG5vd1tqXTsgfVxuXG4gICAgICByLmRyYWdEYXRhLmRpZERyYWcgPSBmYWxzZTsgLy8gcmVzZXQgZm9yIG5leHQgbW91c2Vkb3duXG5cbiAgICAgIGlmKCBlLnRvdWNoZXMubGVuZ3RoID09PSAwICl7XG4gICAgICAgIHIudG91Y2hEYXRhLmRyYWdEZWx0YSA9IFtdO1xuICAgICAgfVxuXG4gICAgICBpZiggdXBkYXRlU3RhcnRTdHlsZSAmJiBzdGFydCApe1xuICAgICAgICBzdGFydC51cGRhdGVTdHlsZShmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIGlmKCBlLnRvdWNoZXMubGVuZ3RoIDwgMiApe1xuICAgICAgICByLnBpbmNoaW5nID0gZmFsc2U7XG4gICAgICAgIG5lZWRzUmVkcmF3W0NSLk5PREVdID0gdHJ1ZTtcbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgIH1cblxuICAgICAgLy9yLnJlZHJhdygpO1xuXG4gICAgfSwgZmFsc2UpO1xuICB9O1xuXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIENhbnZhc1JlbmRlcmVyID0gJCQoJ3JlbmRlcmVyJywgJ2NhbnZhcycpO1xuICB2YXIgcmVuZGVyZXIgPSBDYW52YXNSZW5kZXJlci5wcm90b3R5cGU7XG4gIHZhciB1c2VQYXRocyA9IENhbnZhc1JlbmRlcmVyLnVzZVBhdGhzKCk7XG5cbiAgLy8gTm9kZSBzaGFwZSBjb250cmFjdDpcbiAgLy9cbiAgLy8gZHJhdzogZHJhd1xuICAvLyBpbnRlcnNlY3RMaW5lOiByZXBvcnQgaW50ZXJzZWN0aW9uIGZyb20geCwgeSwgdG8gbm9kZSBjZW50ZXJcbiAgLy8gY2hlY2tQb2ludDogY2hlY2sgeCwgeSBpbiBub2RlXG5cbiAgdmFyIG5vZGVTaGFwZXMgPSBDYW52YXNSZW5kZXJlci5ub2RlU2hhcGVzID0ge307XG5cbiAgdmFyIHNpbjAgPSBNYXRoLnNpbigwKTtcbiAgdmFyIGNvczAgPSBNYXRoLmNvcygwKTtcblxuICB2YXIgc2luID0ge307XG4gIHZhciBjb3MgPSB7fTtcblxuICB2YXIgZWxsaXBzZVN0ZXBTaXplID0gMC4xO1xuXG4gIGZvciAodmFyIGkgPSAwICogTWF0aC5QSTsgaSA8IDIgKiBNYXRoLlBJOyBpICs9IGVsbGlwc2VTdGVwU2l6ZSApIHtcbiAgICBzaW5baV0gPSBNYXRoLnNpbihpKTtcbiAgICBjb3NbaV0gPSBNYXRoLmNvcyhpKTtcbiAgfVxuXG4gIG5vZGVTaGFwZXNbJ2VsbGlwc2UnXSA9IHtcbiAgICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICBub2RlU2hhcGVzWydlbGxpcHNlJ10uZHJhd1BhdGgoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICB9LFxuICAgIFxuICAgIGRyYXdQYXRoOiBmdW5jdGlvbihjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICBcbiAgICAgIGlmKCB1c2VQYXRocyApe1xuICAgICAgICBpZiggY29udGV4dC5iZWdpblBhdGggKXsgY29udGV4dC5iZWdpblBhdGgoKTsgfVxuXG4gICAgICAgIHZhciB4UG9zLCB5UG9zO1xuICAgICAgICB2YXIgcncgPSB3aWR0aC8yO1xuICAgICAgICB2YXIgcmggPSBoZWlnaHQvMjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgKiBNYXRoLlBJOyBpIDwgMiAqIE1hdGguUEk7IGkgKz0gZWxsaXBzZVN0ZXBTaXplICkge1xuICAgICAgICAgICAgeFBvcyA9IGNlbnRlclggLSAocncgKiBzaW5baV0pICogc2luMCArIChydyAqIGNvc1tpXSkgKiBjb3MwO1xuICAgICAgICAgICAgeVBvcyA9IGNlbnRlclkgKyAocmggKiBjb3NbaV0pICogc2luMCArIChyaCAqIHNpbltpXSkgKiBjb3MwO1xuXG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHhQb3MsIHlQb3MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh4UG9zLCB5UG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGlmKCBjb250ZXh0LmJlZ2luUGF0aCApeyBjb250ZXh0LmJlZ2luUGF0aCgpOyB9XG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKGNlbnRlclgsIGNlbnRlclkpO1xuICAgICAgICBjb250ZXh0LnNjYWxlKHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gICAgICAgIC8vIEF0IG9yaWdpbiwgcmFkaXVzIDEsIDAgdG8gMnBpXG4gICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIDEsIDAsIE1hdGguUEkgKiAyICogMC45OTksIGZhbHNlKTsgLy8gKjAuOTk5IGIvYyBjaHJvbWUgcmVuZGVyaW5nIGJ1ZyBvbiBmdWxsIGNpcmNsZVxuICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuXG4gICAgICAgIGNvbnRleHQuc2NhbGUoMi93aWR0aCwgMi9oZWlnaHQpO1xuICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSgtY2VudGVyWCwgLWNlbnRlclkpO1xuXG4gICAgICB9XG4gICAgICBcbiAgICB9LFxuICAgIFxuICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uKG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZykge1xuICAgICAgdmFyIGludGVyc2VjdCA9ICQkLm1hdGguaW50ZXJzZWN0TGluZUVsbGlwc2UoXG4gICAgICAgIHgsIHksXG4gICAgICAgIG5vZGVYLFxuICAgICAgICBub2RlWSxcbiAgICAgICAgd2lkdGggLyAyICsgcGFkZGluZyxcbiAgICAgICAgaGVpZ2h0IC8gMiArIHBhZGRpbmcpO1xuICAgICAgXG4gICAgICByZXR1cm4gaW50ZXJzZWN0O1xuICAgIH0sXG4gICAgXG4gICAgaW50ZXJzZWN0Qm94OiBmdW5jdGlvbihcbiAgICAgIHgxLCB5MSwgeDIsIHkyLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZLCBwYWRkaW5nKSB7XG4gICAgICBcbiAgICAgIHJldHVybiAkJC5tYXRoLmJveEludGVyc2VjdEVsbGlwc2UoXG4gICAgICAgIHgxLCB5MSwgeDIsIHkyLCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICB9LFxuICAgIFxuICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uKFxuICAgICAgeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgXG4vLyAgICAgIGNvbnNvbGUubG9nKGFyZ3VtZW50cyk7XG4gICAgICBcbiAgICAgIHggLT0gY2VudGVyWDtcbiAgICAgIHkgLT0gY2VudGVyWTtcbiAgICAgIFxuICAgICAgeCAvPSAod2lkdGggLyAyICsgcGFkZGluZyk7XG4gICAgICB5IC89IChoZWlnaHQgLyAyICsgcGFkZGluZyk7XG4gICAgICBcbiAgICAgIHJldHVybiAoTWF0aC5wb3coeCwgMikgKyBNYXRoLnBvdyh5LCAyKSA8PSAxKTtcbiAgICB9XG4gIH07XG4gIFxuICBmdW5jdGlvbiBnZW5lcmF0ZVBvbHlnb24oIG5hbWUsIHBvaW50cyApe1xuICAgIG5vZGVTaGFwZXNbbmFtZV0gPSB7XG4gICAgICBwb2ludHM6IHBvaW50cyxcbiAgICAgIFxuICAgICAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICByZW5kZXJlci5kcmF3UG9seWdvbihjb250ZXh0LFxuICAgICAgICAgIGNlbnRlclgsIGNlbnRlclksXG4gICAgICAgICAgd2lkdGgsIGhlaWdodCxcbiAgICAgICAgICBub2RlU2hhcGVzW25hbWVdLnBvaW50cyk7XG4gICAgICB9LFxuICAgICAgXG4gICAgICBkcmF3UGF0aDogZnVuY3Rpb24oY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICByZW5kZXJlci5kcmF3UG9seWdvblBhdGgoY29udGV4dCxcbiAgICAgICAgICBjZW50ZXJYLCBjZW50ZXJZLFxuICAgICAgICAgIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgICAgbm9kZVNoYXBlc1tuYW1lXS5wb2ludHMpO1xuICAgICAgfSxcbiAgICAgIFxuICAgICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24obm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBwYWRkaW5nKSB7XG4gICAgICAgIHJldHVybiAkJC5tYXRoLnBvbHlnb25JbnRlcnNlY3RMaW5lKFxuICAgICAgICAgICAgeCwgeSxcbiAgICAgICAgICAgIG5vZGVTaGFwZXNbbmFtZV0ucG9pbnRzLFxuICAgICAgICAgICAgbm9kZVgsXG4gICAgICAgICAgICBub2RlWSxcbiAgICAgICAgICAgIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMixcbiAgICAgICAgICAgIHBhZGRpbmcpO1xuICAgICAgfSxcbiAgICAgIFxuICAgICAgaW50ZXJzZWN0Qm94OiBmdW5jdGlvbihcbiAgICAgICAgeDEsIHkxLCB4MiwgeTIsXG4gICAgICAgIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIFxuICAgICAgICBjZW50ZXJZLCBwYWRkaW5nKSB7XG4gICAgICAgIFxuICAgICAgICB2YXIgcG9pbnRzID0gbm9kZVNoYXBlc1tuYW1lXS5wb2ludHM7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gJCQubWF0aC5ib3hJbnRlcnNlY3RQb2x5Z29uKFxuICAgICAgICAgIHgxLCB5MSwgeDIsIHkyLFxuICAgICAgICAgIHBvaW50cywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgXG4gICAgICAgICAgY2VudGVyWSwgWzAsIC0xXSwgcGFkZGluZyk7XG4gICAgICB9LFxuICAgICAgXG4gICAgICBjaGVja1BvaW50OiBmdW5jdGlvbihcbiAgICAgICAgeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuICQkLm1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIG5vZGVTaGFwZXNbbmFtZV0ucG9pbnRzLFxuICAgICAgICAgIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIFswLCAtMV0sIHBhZGRpbmcpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgXG4gIGdlbmVyYXRlUG9seWdvbiggJ3RyaWFuZ2xlJywgJCQubWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoMywgMCkgKTtcbiAgXG4gIGdlbmVyYXRlUG9seWdvbiggJ3NxdWFyZScsICQkLm1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDQsIDApICk7XG4gIG5vZGVTaGFwZXNbJ3JlY3RhbmdsZSddID0gbm9kZVNoYXBlc1snc3F1YXJlJ107XG4gIFxuICBub2RlU2hhcGVzWydyb3VuZHJlY3RhbmdsZSddID0ge1xuICAgIHBvaW50czogJCQubWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNCwgMCksXG4gICAgXG4gICAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgcmVuZGVyZXIuZHJhd1JvdW5kUmVjdGFuZ2xlKGNvbnRleHQsXG4gICAgICAgIGNlbnRlclgsIGNlbnRlclksXG4gICAgICAgIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgIDEwKTtcbiAgICB9LFxuICAgIFxuICAgIGRyYXdQYXRoOiBmdW5jdGlvbihjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICByZW5kZXJlci5kcmF3Um91bmRSZWN0YW5nbGVQYXRoKGNvbnRleHQsXG4gICAgICAgIGNlbnRlclgsIGNlbnRlclksXG4gICAgICAgIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgIDEwKTtcbiAgICB9LFxuICAgIFxuICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uKG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZykge1xuICAgICAgcmV0dXJuICQkLm1hdGgucm91bmRSZWN0YW5nbGVJbnRlcnNlY3RMaW5lKFxuICAgICAgICAgIHgsIHksXG4gICAgICAgICAgbm9kZVgsXG4gICAgICAgICAgbm9kZVksXG4gICAgICAgICAgd2lkdGgsIGhlaWdodCxcbiAgICAgICAgICBwYWRkaW5nKTtcbiAgICB9LFxuICAgIFxuICAgIGludGVyc2VjdEJveDogZnVuY3Rpb24oXG4gICAgICB4MSwgeTEsIHgyLCB5MixcbiAgICAgIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIFxuICAgICAgY2VudGVyWSwgcGFkZGluZykge1xuXG4gICAgICByZXR1cm4gJCQubWF0aC5yb3VuZFJlY3RhbmdsZUludGVyc2VjdEJveChcbiAgICAgICAgeDEsIHkxLCB4MiwgeTIsIFxuICAgICAgICB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZLCBwYWRkaW5nKTtcbiAgICB9LFxuICAgIFxuICAgIC8vIExvb2tzIGxpa2UgdGhlIHdpZHRoIHBhc3NlZCBpbnRvIHRoaXMgZnVuY3Rpb24gaXMgYWN0dWFsbHkgdGhlIHRvdGFsIHdpZHRoIC8gMlxuICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uKFxuICAgICAgeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgXG4gICAgICB2YXIgY29ybmVyUmFkaXVzID0gJCQubWF0aC5nZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaEJveFxuICAgICAgaWYgKCQkLm1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIG5vZGVTaGFwZXNbJ3JvdW5kcmVjdGFuZ2xlJ10ucG9pbnRzLFxuICAgICAgICBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0IC0gMiAqIGNvcm5lclJhZGl1cywgWzAsIC0xXSwgcGFkZGluZykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIHZCb3hcbiAgICAgIGlmICgkJC5tYXRoLnBvaW50SW5zaWRlUG9seWdvbih4LCB5LCBub2RlU2hhcGVzWydyb3VuZHJlY3RhbmdsZSddLnBvaW50cyxcbiAgICAgICAgY2VudGVyWCwgY2VudGVyWSwgd2lkdGggLSAyICogY29ybmVyUmFkaXVzLCBoZWlnaHQsIFswLCAtMV0sIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICB2YXIgY2hlY2tJbkVsbGlwc2UgPSBmdW5jdGlvbih4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nKSB7XG4gICAgICAgIHggLT0gY2VudGVyWDtcbiAgICAgICAgeSAtPSBjZW50ZXJZO1xuICAgICAgICBcbiAgICAgICAgeCAvPSAod2lkdGggLyAyICsgcGFkZGluZyk7XG4gICAgICAgIHkgLz0gKGhlaWdodCAvIDIgKyBwYWRkaW5nKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiAoTWF0aC5wb3coeCwgMikgKyBNYXRoLnBvdyh5LCAyKSA8PSAxKTtcbiAgICAgIH07XG4gICAgICBcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgdG9wIGxlZnQgcXVhcnRlciBjaXJjbGVcbiAgICAgIGlmIChjaGVja0luRWxsaXBzZSh4LCB5LFxuICAgICAgICBjZW50ZXJYIC0gd2lkdGggLyAyICsgY29ybmVyUmFkaXVzLFxuICAgICAgICBjZW50ZXJZIC0gaGVpZ2h0IC8gMiArIGNvcm5lclJhZGl1cyxcbiAgICAgICAgY29ybmVyUmFkaXVzICogMiwgY29ybmVyUmFkaXVzICogMiwgcGFkZGluZykpIHtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKlxuICAgICAgaWYgKHJlbmRlcmVyLmJveEludGVyc2VjdEVsbGlwc2UoeCwgeSwgeCwgeSwgcGFkZGluZywgXG4gICAgICAgIGNvcm5lclJhZGl1cyAqIDIsIGNvcm5lclJhZGl1cyAqIDIsXG4gICAgICAgIGNlbnRlclggLSB3aWR0aCArIGNvcm5lclJhZGl1cyxcbiAgICAgICAgY2VudGVyWSAtIGhlaWdodCArIGNvcm5lclJhZGl1cykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICAqL1xuICAgICAgXG4gICAgICAvLyBDaGVjayB0b3AgcmlnaHQgcXVhcnRlciBjaXJjbGVcbiAgICAgIGlmIChjaGVja0luRWxsaXBzZSh4LCB5LFxuICAgICAgICBjZW50ZXJYICsgd2lkdGggLyAyIC0gY29ybmVyUmFkaXVzLFxuICAgICAgICBjZW50ZXJZIC0gaGVpZ2h0IC8gMiArIGNvcm5lclJhZGl1cyxcbiAgICAgICAgY29ybmVyUmFkaXVzICogMiwgY29ybmVyUmFkaXVzICogMiwgcGFkZGluZykpIHtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDaGVjayBib3R0b20gcmlnaHQgcXVhcnRlciBjaXJjbGVcbiAgICAgIGlmIChjaGVja0luRWxsaXBzZSh4LCB5LFxuICAgICAgICBjZW50ZXJYICsgd2lkdGggLyAyIC0gY29ybmVyUmFkaXVzLFxuICAgICAgICBjZW50ZXJZICsgaGVpZ2h0IC8gMiAtIGNvcm5lclJhZGl1cyxcbiAgICAgICAgY29ybmVyUmFkaXVzICogMiwgY29ybmVyUmFkaXVzICogMiwgcGFkZGluZykpIHtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDaGVjayBib3R0b20gbGVmdCBxdWFydGVyIGNpcmNsZVxuICAgICAgaWYgKGNoZWNrSW5FbGxpcHNlKHgsIHksXG4gICAgICAgIGNlbnRlclggLSB3aWR0aCAvIDIgKyBjb3JuZXJSYWRpdXMsXG4gICAgICAgIGNlbnRlclkgKyBoZWlnaHQgLyAyIC0gY29ybmVyUmFkaXVzLFxuICAgICAgICBjb3JuZXJSYWRpdXMgKiAyLCBjb3JuZXJSYWRpdXMgKiAyLCBwYWRkaW5nKSkge1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG4gIFxuICBnZW5lcmF0ZVBvbHlnb24oICdkaWFtb25kJywgW1xuICAgIDAsIDEsXG4gICAgMSwgMCxcbiAgICAwLCAtMSxcbiAgICAtMSwgMFxuICBdICk7XG4gIFxuICBnZW5lcmF0ZVBvbHlnb24oICdwZW50YWdvbicsICQkLm1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDUsIDApICk7XG4gIFxuICBnZW5lcmF0ZVBvbHlnb24oICdoZXhhZ29uJywgJCQubWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNiwgMCkgKTtcbiAgXG4gIGdlbmVyYXRlUG9seWdvbiggJ2hlcHRhZ29uJywgJCQubWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNywgMCkgKTtcbiAgXG4gIGdlbmVyYXRlUG9seWdvbiggJ29jdGFnb24nLCAkJC5tYXRoLmdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg4LCAwKSApO1xuICAgIFxuICB2YXIgc3RhcjVQb2ludHMgPSBuZXcgQXJyYXkoMjApO1xuICB7XG4gICAgdmFyIG91dGVyUG9pbnRzID0gJCQubWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzKDUsIDApO1xuICAgIHZhciBpbm5lclBvaW50cyA9ICQkLm1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50cyg1LCBNYXRoLlBJIC8gNSk7XG4gICAgXG4gIC8vICBjb25zb2xlLmxvZyhvdXRlclBvaW50cyk7XG4gIC8vICBjb25zb2xlLmxvZyhpbm5lclBvaW50cyk7XG4gICAgXG4gICAgLy8gT3V0ZXIgcmFkaXVzIGlzIDE7IGlubmVyIHJhZGl1cyBvZiBzdGFyIGlzIHNtYWxsZXJcbiAgICB2YXIgaW5uZXJSYWRpdXMgPSAwLjUgKiAoMyAtIE1hdGguc3FydCg1KSk7XG4gICAgaW5uZXJSYWRpdXMgKj0gMS41NztcbiAgICBcbiAgICBmb3IgKHZhciBpPTA7aTxpbm5lclBvaW50cy5sZW5ndGgvMjtpKyspIHtcbiAgICAgIGlubmVyUG9pbnRzW2kqMl0gKj0gaW5uZXJSYWRpdXM7XG4gICAgICBpbm5lclBvaW50c1tpKjIrMV0gKj0gaW5uZXJSYWRpdXM7XG4gICAgfVxuICAgIFxuICAgIGZvciAodmFyIGk9MDtpPDIwLzQ7aSsrKSB7XG4gICAgICBzdGFyNVBvaW50c1tpKjRdID0gb3V0ZXJQb2ludHNbaSoyXTtcbiAgICAgIHN0YXI1UG9pbnRzW2kqNCsxXSA9IG91dGVyUG9pbnRzW2kqMisxXTtcbiAgICAgIFxuICAgICAgc3RhcjVQb2ludHNbaSo0KzJdID0gaW5uZXJQb2ludHNbaSoyXTtcbiAgICAgIHN0YXI1UG9pbnRzW2kqNCszXSA9IGlubmVyUG9pbnRzW2kqMisxXTtcbiAgICB9XG4gICAgXG4gIC8vICBjb25zb2xlLmxvZyhzdGFyNVBvaW50cyk7XG4gIH1cblxuICBzdGFyNVBvaW50cyA9ICQkLm1hdGguZml0UG9seWdvblRvU3F1YXJlKCBzdGFyNVBvaW50cyApO1xuICBcbiAgZ2VuZXJhdGVQb2x5Z29uKCAnc3RhcicsIHN0YXI1UG9pbnRzICk7XG4gIFxuICBnZW5lcmF0ZVBvbHlnb24oICd2ZWUnLCBbXG4gICAgLTEsIC0xLFxuICAgIDAsIC0wLjMzMyxcbiAgICAxLCAtMSxcbiAgICAwLCAxXG4gIF0gKTtcbiAgXG4gIGdlbmVyYXRlUG9seWdvbiggJ3Job21ib2lkJywgW1xuICAgIC0xLCAtMSxcbiAgICAwLjMzMywgLTEsXG4gICAgMSwgMSxcbiAgICAtMC4zMzMsIDFcbiAgXSApO1xuXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgYW5pbWF0ZTogdHJ1ZSwgLy8gd2hldGhlciB0byBzaG93IHRoZSBsYXlvdXQgYXMgaXQncyBydW5uaW5nXG4gICAgbWF4U2ltdWxhdGlvblRpbWU6IDQwMDAsIC8vIG1heCBsZW5ndGggaW4gbXMgdG8gcnVuIHRoZSBsYXlvdXRcbiAgICBmaXQ6IHRydWUsIC8vIG9uIGV2ZXJ5IGxheW91dCByZXBvc2l0aW9uIG9mIG5vZGVzLCBmaXQgdGhlIHZpZXdwb3J0XG4gICAgcGFkZGluZzogMzAsIC8vIHBhZGRpbmcgYXJvdW5kIHRoZSBzaW11bGF0aW9uXG4gICAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCwgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gICAgdW5ncmFiaWZ5V2hpbGVTaW11bGF0aW5nOiBmYWxzZSwgLy8gc28geW91IGNhbid0IGRyYWcgbm9kZXMgZHVyaW5nIGxheW91dFxuXG4gICAgLy8gY2FsbGJhY2tzIG9uIGxheW91dCBldmVudHNcbiAgICByZWFkeTogdW5kZWZpbmVkLCAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeSBcbiAgICBzdG9wOiB1bmRlZmluZWQsIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3BcblxuICAgIC8vIGZvcmNlcyB1c2VkIGJ5IGFyYm9yICh1c2UgYXJib3IgZGVmYXVsdCBvbiB1bmRlZmluZWQpXG4gICAgcmVwdWxzaW9uOiB1bmRlZmluZWQsXG4gICAgc3RpZmZuZXNzOiB1bmRlZmluZWQsXG4gICAgZnJpY3Rpb246IHVuZGVmaW5lZCxcbiAgICBncmF2aXR5OiB0cnVlLFxuICAgIGZwczogdW5kZWZpbmVkLFxuICAgIHByZWNpc2lvbjogdW5kZWZpbmVkLFxuXG4gICAgLy8gc3RhdGljIG51bWJlcnMgb3IgZnVuY3Rpb25zIHRoYXQgZHluYW1pY2FsbHkgcmV0dXJuIHdoYXQgdGhlc2VcbiAgICAvLyB2YWx1ZXMgc2hvdWxkIGJlIGZvciBlYWNoIGVsZW1lbnRcbiAgICAvLyBlLmcuIG5vZGVNYXNzOiBmdW5jdGlvbihuKXsgcmV0dXJuIG4uZGF0YSgnd2VpZ2h0JykgfVxuICAgIG5vZGVNYXNzOiB1bmRlZmluZWQsIFxuICAgIGVkZ2VMZW5ndGg6IHVuZGVmaW5lZCxcblxuICAgIHN0ZXBTaXplOiAwLjEsIC8vIHNtb290aGluZyBvZiBhcmJvciBib3VuZGluZyBib3hcblxuICAgIC8vIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIGlmIHRoZSBzeXN0ZW0gaXMgc3RhYmxlIHRvIGluZGljYXRlXG4gICAgLy8gdGhhdCB0aGUgbGF5b3V0IGNhbiBiZSBzdG9wcGVkXG4gICAgc3RhYmxlRW5lcmd5OiBmdW5jdGlvbiggZW5lcmd5ICl7XG4gICAgICB2YXIgZSA9IGVuZXJneTsgXG4gICAgICByZXR1cm4gKGUubWF4IDw9IDAuNSkgfHwgKGUubWVhbiA8PSAwLjMpO1xuICAgIH0sXG5cbiAgICAvLyBpbmZpbml0ZSBsYXlvdXQgb3B0aW9uc1xuICAgIGluZmluaXRlOiBmYWxzZSAvLyBvdmVycmlkZXMgYWxsIG90aGVyIG9wdGlvbnMgZm9yIGEgZm9yY2VzLWFsbC10aGUtdGltZSBtb2RlXG4gIH07XG4gIFxuICBmdW5jdGlvbiBBcmJvckxheW91dChvcHRpb25zKXtcbiAgICB0aGlzLl9wcml2YXRlID0ge307XG5cbiAgICB0aGlzLl9wcml2YXRlLm9wdGlvbnMgPSAkJC51dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuICB9XG4gICAgXG4gIEFyYm9yTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpe1xuICAgIHZhciBsYXlvdXQgPSB0aGlzO1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5fcHJpdmF0ZS5vcHRpb25zO1xuXG4gICAgJCQudXRpbC5yZXF1aXJlKCdhcmJvcicsIGZ1bmN0aW9uKGFyYm9yKXtcblxuICAgICAgdmFyIGN5ID0gb3B0aW9ucy5jeTtcbiAgICAgIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICAgICAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpLm5vdCgnOnBhcmVudCcpO1xuICAgICAgdmFyIGVkZ2VzID0gZWxlcy5lZGdlcygpO1xuICAgICAgdmFyIGJiID0gJCQudXRpbC5tYWtlQm91bmRpbmdCb3goIG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgICAgICB4MTogMCwgeTE6IDAsIHc6IGN5LndpZHRoKCksIGg6IGN5LmhlaWdodCgpXG4gICAgICB9ICk7XG4gICAgICB2YXIgc2ltVXBkYXRpbmdQb3MgPSBmYWxzZTtcblxuICAgICAgbGF5b3V0LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0c3RhcnQnLCBsYXlvdXQ6IGxheW91dCB9KTtcblxuICAgICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSBmb3Igb2xkIGFuaW1hdGlvbiBvcHRpb25cbiAgICAgIGlmKCBvcHRpb25zLmxpdmVVcGRhdGUgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICBvcHRpb25zLmFuaW1hdGUgPSBvcHRpb25zLmxpdmVVcGRhdGU7XG4gICAgICB9XG5cbiAgICAgIC8vIGFyYm9yIGRvZXNuJ3Qgd29yayB3aXRoIGp1c3QgMSBub2RlIFxuICAgICAgaWYoIGVsZXMubm9kZXMoKS5zaXplKCkgPD0gMSApe1xuICAgICAgICBpZiggb3B0aW9ucy5maXQgKXtcbiAgICAgICAgICBjeS5yZXNldCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlcy5ub2RlcygpLnBvc2l0aW9uKHtcbiAgICAgICAgICB4OiBNYXRoLnJvdW5kKCAoYmIueDEgKyBiYi54MikvMiApLFxuICAgICAgICAgIHk6IE1hdGgucm91bmQoIChiYi55MSArIGJiLnkyKS8yIClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0cmVhZHknLCBvcHRpb25zLnJlYWR5KTtcbiAgICAgICAgbGF5b3V0LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0cmVhZHknLCBsYXlvdXQ6IGxheW91dCB9KTtcblxuICAgICAgICBsYXlvdXQub25lKCdsYXlvdXRzdG9wJywgb3B0aW9ucy5zdG9wKTtcbiAgICAgICAgbGF5b3V0LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0c3RvcCcsIGxheW91dDogbGF5b3V0IH0pO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHN5cyA9IGxheW91dC5fcHJpdmF0ZS5zeXN0ZW0gPSBhcmJvci5QYXJ0aWNsZVN5c3RlbSgpO1xuXG4gICAgICBzeXMucGFyYW1ldGVycyh7XG4gICAgICAgIHJlcHVsc2lvbjogb3B0aW9ucy5yZXB1bHNpb24sXG4gICAgICAgIHN0aWZmbmVzczogb3B0aW9ucy5zdGlmZm5lc3MsIFxuICAgICAgICBmcmljdGlvbjogb3B0aW9ucy5mcmljdGlvbiwgXG4gICAgICAgIGdyYXZpdHk6IG9wdGlvbnMuZ3Jhdml0eSwgXG4gICAgICAgIGZwczogb3B0aW9ucy5mcHMsIFxuICAgICAgICBkdDogb3B0aW9ucy5kdCwgXG4gICAgICAgIHByZWNpc2lvbjogb3B0aW9ucy5wcmVjaXNpb25cbiAgICAgIH0pO1xuXG4gICAgICBpZiggb3B0aW9ucy5hbmltYXRlICYmIG9wdGlvbnMuZml0ICl7XG4gICAgICAgIGN5LmZpdCggYmIsIG9wdGlvbnMucGFkZGluZyApO1xuICAgICAgfVxuICAgICAgXG4gICAgICB2YXIgZG9uZVRpbWUgPSAyNTA7XG4gICAgICB2YXIgZG9uZVRpbWVvdXQ7XG4gICAgICBcbiAgICAgIHZhciByZWFkeSA9IGZhbHNlO1xuICAgICAgXG4gICAgICB2YXIgbGFzdERyYXcgPSArbmV3IERhdGUoKTtcbiAgICAgIHZhciBzeXNSZW5kZXJlciA9IHtcbiAgICAgICAgaW5pdDogZnVuY3Rpb24oc3lzdGVtKXtcbiAgICAgICAgfSxcbiAgICAgICAgcmVkcmF3OiBmdW5jdGlvbigpe1xuICAgICAgICAgIHZhciBlbmVyZ3kgPSBzeXMuZW5lcmd5KCk7XG5cbiAgICAgICAgICAvLyBpZiB3ZSdyZSBzdGFibGUgKGFjY29yZGluZyB0byB0aGUgY2xpZW50KSwgd2UncmUgZG9uZVxuICAgICAgICAgIGlmKCAhb3B0aW9ucy5pbmZpbml0ZSAmJiBvcHRpb25zLnN0YWJsZUVuZXJneSAhPSBudWxsICYmIGVuZXJneSAhPSBudWxsICYmIGVuZXJneS5uID4gMCAmJiBvcHRpb25zLnN0YWJsZUVuZXJneShlbmVyZ3kpICl7XG4gICAgICAgICAgICBsYXlvdXQuc3RvcCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCAhb3B0aW9ucy5pbmZpbml0ZSAmJiBkb25lVGltZSAhPSBJbmZpbml0eSApe1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGRvbmVUaW1lb3V0KTtcbiAgICAgICAgICAgIGRvbmVUaW1lb3V0ID0gc2V0VGltZW91dChkb25lSGFuZGxlciwgZG9uZVRpbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICB2YXIgbW92ZWROb2RlcyA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgICAgICBcbiAgICAgICAgICBzeXMuZWFjaE5vZGUoZnVuY3Rpb24obiwgcG9pbnQpeyBcbiAgICAgICAgICAgIHZhciBkYXRhID0gbi5kYXRhO1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBkYXRhLmVsZW1lbnQ7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKCBub2RlID09IG51bGwgKXtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiggIW5vZGUubG9ja2VkKCkgJiYgIW5vZGUuZ3JhYmJlZCgpICl7XG4gICAgICAgICAgICAgIG5vZGUuc2lsZW50UG9zaXRpb24oe1xuICAgICAgICAgICAgICAgIHg6IGJiLngxICsgcG9pbnQueCxcbiAgICAgICAgICAgICAgICB5OiBiYi55MSArIHBvaW50LnlcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgbW92ZWROb2Rlcy5tZXJnZSggbm9kZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuXG4gICAgICAgICAgaWYoIG9wdGlvbnMuYW5pbWF0ZSAmJiBtb3ZlZE5vZGVzLmxlbmd0aCA+IDAgKXtcbiAgICAgICAgICAgIHNpbVVwZGF0aW5nUG9zID0gdHJ1ZTtcblxuICAgICAgICAgICAgbW92ZWROb2Rlcy5ydHJpZ2dlcigncG9zaXRpb24nKTtcblxuICAgICAgICAgICAgaWYoIG9wdGlvbnMuZml0ICl7XG4gICAgICAgICAgICAgIGN5LmZpdCggb3B0aW9ucy5wYWRkaW5nICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhc3REcmF3ID0gK25ldyBEYXRlKCk7XG4gICAgICAgICAgICBzaW1VcGRhdGluZ1BvcyA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIFxuICAgICAgICAgIGlmKCAhcmVhZHkgKXtcbiAgICAgICAgICAgIHJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGxheW91dC5vbmUoJ2xheW91dHJlYWR5Jywgb3B0aW9ucy5yZWFkeSk7XG4gICAgICAgICAgICBsYXlvdXQudHJpZ2dlcih7IHR5cGU6ICdsYXlvdXRyZWFkeScsIGxheW91dDogbGF5b3V0IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgIH07XG4gICAgICBzeXMucmVuZGVyZXIgPSBzeXNSZW5kZXJlcjtcbiAgICAgIHN5cy5zY3JlZW5TaXplKCBiYi53LCBiYi5oICk7XG4gICAgICBzeXMuc2NyZWVuUGFkZGluZyggb3B0aW9ucy5wYWRkaW5nLCBvcHRpb25zLnBhZGRpbmcsIG9wdGlvbnMucGFkZGluZywgb3B0aW9ucy5wYWRkaW5nICk7XG4gICAgICBzeXMuc2NyZWVuU3RlcCggb3B0aW9ucy5zdGVwU2l6ZSApO1xuXG4gICAgICBmdW5jdGlvbiBjYWxjdWxhdGVWYWx1ZUZvckVsZW1lbnQoZWxlbWVudCwgdmFsdWUpe1xuICAgICAgICBpZiggdmFsdWUgPT0gbnVsbCApe1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSBpZiggdHlwZW9mIHZhbHVlID09IHR5cGVvZiBmdW5jdGlvbigpe30gKXtcbiAgICAgICAgICByZXR1cm4gdmFsdWUuYXBwbHkoZWxlbWVudCwgW2VsZW1lbnQuX3ByaXZhdGUuZGF0YSwge1xuICAgICAgICAgICAgbm9kZXM6IG5vZGVzLmxlbmd0aCxcbiAgICAgICAgICAgIGVkZ2VzOiBlZGdlcy5sZW5ndGgsXG4gICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50XG4gICAgICAgICAgfV0pOyBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGdyYWJIYW5kbGVyO1xuICAgICAgbm9kZXMub24oJ2dyYWIgZnJlZSBwb3NpdGlvbicsIGdyYWJIYW5kbGVyID0gZnVuY3Rpb24oZSl7XG4gICAgICAgIGlmKCBzaW1VcGRhdGluZ1BvcyApeyByZXR1cm47IH1cblxuICAgICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbigpO1xuICAgICAgICB2YXIgYXBvcyA9IHN5cy5mcm9tU2NyZWVuKCBwb3MgKTtcbiAgICAgICAgaWYoICFhcG9zICl7IHJldHVybjsgfVxuXG4gICAgICAgIHZhciBwID0gYXJib3IuUG9pbnQoYXBvcy54LCBhcG9zLnkpO1xuICAgICAgICB2YXIgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZztcblxuICAgICAgICBpZihcbiAgICAgICAgICBiYi54MSArIHBhZGRpbmcgPD0gcG9zLnggJiYgcG9zLnggPD0gYmIueDIgLSBwYWRkaW5nICYmXG4gICAgICAgICAgYmIueTEgKyBwYWRkaW5nIDw9IHBvcy55ICYmIHBvcy55IDw9IGJiLnkyIC0gcGFkZGluZ1xuICAgICAgICApe1xuICAgICAgICAgIHRoaXMuc2NyYXRjaCgpLmFyYm9yLnAgPSBwO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBzd2l0Y2goIGUudHlwZSApe1xuICAgICAgICBjYXNlICdncmFiJzpcbiAgICAgICAgICB0aGlzLnNjcmF0Y2goKS5hcmJvci5maXhlZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2ZyZWUnOlxuICAgICAgICAgIHRoaXMuc2NyYXRjaCgpLmFyYm9yLmZpeGVkID0gZmFsc2U7XG4gICAgICAgICAgLy90aGlzLnNjcmF0Y2goKS5hcmJvci50ZW1wTWFzcyA9IDEwMDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB2YXIgbG9ja0hhbmRsZXI7XG4gICAgICBub2Rlcy5vbignbG9jayB1bmxvY2snLCBsb2NrSGFuZGxlciA9IGZ1bmN0aW9uKGUpe1xuICAgICAgICBub2RlLnNjcmF0Y2goKS5hcmJvci5maXhlZCA9IG5vZGUubG9ja2VkKCk7XG4gICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgdmFyIHJlbW92ZUhhbmRsZXI7XG4gICAgICBlbGVzLm9uKCdyZW1vdmUnLCByZW1vdmVIYW5kbGVyID0gZnVuY3Rpb24oZSl7IHJldHVybjsgLy8gVE9ETyBlbmFibGUgd2hlbiBsYXlvdXQgYWRkL3JlbW92ZSBhcGkgYWRkZWRcbiAgICAgICAgLy8gdmFyIGVsZSA9IHRoaXM7XG4gICAgICAgIC8vIHZhciBhcmJvckVsZSA9IGVsZS5zY3JhdGNoKCkuYXJib3I7XG5cbiAgICAgICAgLy8gaWYoICFhcmJvckVsZSApeyByZXR1cm47IH1cblxuICAgICAgICAvLyBpZiggZWxlLmlzTm9kZSgpICl7XG4gICAgICAgIC8vICAgc3lzLnBydW5lTm9kZSggYXJib3JFbGUgKTtcbiAgICAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgLy8gICBzeXMucHJ1bmVFZGdlKCBhcmJvckVsZSApO1xuICAgICAgICAvLyB9XG4gICAgICB9KTtcblxuICAgICAgdmFyIGFkZEhhbmRsZXI7XG4gICAgICBjeS5vbignYWRkJywgJyonLCBhZGRIYW5kbGVyID0gZnVuY3Rpb24oKXsgcmV0dXJuOyAvLyBUT0RPIGVuYWJsZSB3aGVuIGxheW91dCBhZGQvcmVtb3ZlIGFwaSBhZGRlZFxuICAgICAgICAvLyB2YXIgZWxlID0gdGhpcztcblxuICAgICAgICAvLyBpZiggZWxlLmlzTm9kZSgpICl7XG4gICAgICAgIC8vICAgYWRkTm9kZSggZWxlICk7XG4gICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgIC8vICAgYWRkRWRnZSggZWxlICk7XG4gICAgICAgIC8vIH1cbiAgICAgIH0pO1xuXG4gICAgICB2YXIgcmVzaXplSGFuZGxlcjtcbiAgICAgIGN5Lm9uKCdyZXNpemUnLCByZXNpemVIYW5kbGVyID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoIG9wdGlvbnMuYm91bmRpbmdCb3ggPT0gbnVsbCAmJiBsYXlvdXQuX3ByaXZhdGUuc3lzdGVtICE9IG51bGwgKXtcbiAgICAgICAgICB2YXIgdyA9IGN5LndpZHRoKCk7XG4gICAgICAgICAgdmFyIGggPSBjeS5oZWlnaHQoKTtcblxuICAgICAgICAgIHN5cy5zY3JlZW5TaXplKCB3LCBoICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiBhZGROb2RlKCBub2RlICl7XG4gICAgICAgIGlmKCBub2RlLmlzRnVsbEF1dG9QYXJlbnQoKSApeyByZXR1cm47IH0gLy8gdGhleSBkb24ndCBleGlzdCBpbiB0aGUgc2ltXG5cbiAgICAgICAgdmFyIGlkID0gbm9kZS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgICB2YXIgbWFzcyA9IGNhbGN1bGF0ZVZhbHVlRm9yRWxlbWVudChub2RlLCBvcHRpb25zLm5vZGVNYXNzKTtcbiAgICAgICAgdmFyIGxvY2tlZCA9IG5vZGUuX3ByaXZhdGUubG9ja2VkO1xuICAgICAgICB2YXIgblBvcyA9IG5vZGUucG9zaXRpb24oKTtcbiAgICAgICAgXG4gICAgICAgIHZhciBwb3MgPSBzeXMuZnJvbVNjcmVlbih7XG4gICAgICAgICAgeDogblBvcy54LFxuICAgICAgICAgIHk6IG5Qb3MueVxuICAgICAgICB9KTtcblxuICAgICAgICBub2RlLnNjcmF0Y2goKS5hcmJvciA9IHN5cy5hZGROb2RlKGlkLCB7XG4gICAgICAgICAgZWxlbWVudDogbm9kZSxcbiAgICAgICAgICBtYXNzOiBtYXNzLFxuICAgICAgICAgIGZpeGVkOiBsb2NrZWQsXG4gICAgICAgICAgeDogbG9ja2VkID8gcG9zLnggOiB1bmRlZmluZWQsXG4gICAgICAgICAgeTogbG9ja2VkID8gcG9zLnkgOiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGFkZEVkZ2UoIGVkZ2UgKXtcbiAgICAgICAgdmFyIHNyYyA9IGVkZ2Uuc291cmNlKCkuaWQoKTtcbiAgICAgICAgdmFyIHRndCA9IGVkZ2UudGFyZ2V0KCkuaWQoKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGNhbGN1bGF0ZVZhbHVlRm9yRWxlbWVudChlZGdlLCBvcHRpb25zLmVkZ2VMZW5ndGgpO1xuICAgICAgICBcbiAgICAgICAgZWRnZS5zY3JhdGNoKCkuYXJib3IgPSBzeXMuYWRkRWRnZShzcmMsIHRndCwge1xuICAgICAgICAgIGxlbmd0aDogbGVuZ3RoXG4gICAgICAgIH0pOyBcbiAgICAgIH1cblxuICAgICAgbm9kZXMuZWFjaChmdW5jdGlvbihpLCBub2RlKXtcbiAgICAgICAgYWRkTm9kZSggbm9kZSApO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGVkZ2VzLmVhY2goZnVuY3Rpb24oaSwgZWRnZSl7XG4gICAgICAgIGFkZEVkZ2UoIGVkZ2UgKTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICB2YXIgZ3JhYmJhYmxlTm9kZXMgPSBub2Rlcy5maWx0ZXIoXCI6Z3JhYmJhYmxlXCIpO1xuICAgICAgLy8gZGlzYWJsZSBncmFiYmluZyBpZiBzbyBzZXRcbiAgICAgIGlmKCBvcHRpb25zLnVuZ3JhYmlmeVdoaWxlU2ltdWxhdGluZyApe1xuICAgICAgICBncmFiYmFibGVOb2Rlcy51bmdyYWJpZnkoKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIGRvbmVIYW5kbGVyID0gbGF5b3V0Ll9wcml2YXRlLmRvbmVIYW5kbGVyID0gZnVuY3Rpb24oKXtcbiAgICAgICAgbGF5b3V0Ll9wcml2YXRlLmRvbmVIYW5kbGVyID0gbnVsbDtcblxuICAgICAgICBpZiggIW9wdGlvbnMuYW5pbWF0ZSApe1xuICAgICAgICAgIGlmKCBvcHRpb25zLmZpdCApe1xuICAgICAgICAgICAgY3kucmVzZXQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBub2Rlcy5ydHJpZ2dlcigncG9zaXRpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVuYmluZCBoYW5kbGVyc1xuICAgICAgICBub2Rlcy5vZmYoJ2dyYWIgZnJlZSBwb3NpdGlvbicsIGdyYWJIYW5kbGVyKTtcbiAgICAgICAgbm9kZXMub2ZmKCdsb2NrIHVubG9jaycsIGxvY2tIYW5kbGVyKTtcbiAgICAgICAgZWxlcy5vZmYoJ3JlbW92ZScsIHJlbW92ZUhhbmRsZXIpO1xuICAgICAgICBjeS5vZmYoJ2FkZCcsICcqJywgYWRkSGFuZGxlcik7XG4gICAgICAgIGN5Lm9mZigncmVzaXplJywgcmVzaXplSGFuZGxlcik7XG4gICAgICAgIFxuICAgICAgICAvLyBlbmFibGUgYmFjayBncmFiYmluZyBpZiBzbyBzZXRcbiAgICAgICAgaWYoIG9wdGlvbnMudW5ncmFiaWZ5V2hpbGVTaW11bGF0aW5nICl7XG4gICAgICAgICAgZ3JhYmJhYmxlTm9kZXMuZ3JhYmlmeSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0c3RvcCcsIG9wdGlvbnMuc3RvcCk7XG4gICAgICAgIGxheW91dC50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHN0b3AnLCBsYXlvdXQ6IGxheW91dCB9KTtcbiAgICAgIH07XG4gICAgICBcbiAgICAgIHN5cy5zdGFydCgpO1xuICAgICAgaWYoICFvcHRpb25zLmluZmluaXRlICYmIG9wdGlvbnMubWF4U2ltdWxhdGlvblRpbWUgIT0gbnVsbCAmJiBvcHRpb25zLm1heFNpbXVsYXRpb25UaW1lID4gMCAmJiBvcHRpb25zLm1heFNpbXVsYXRpb25UaW1lICE9PSBJbmZpbml0eSApe1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgbGF5b3V0LnN0b3AoKTtcbiAgICAgICAgfSwgb3B0aW9ucy5tYXhTaW11bGF0aW9uVGltZSk7XG4gICAgICB9XG4gICAgXG4gICAgfSk7IC8vIHJlcXVpcmVcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuXG5cbiAgQXJib3JMYXlvdXQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpe1xuICAgIGlmKCB0aGlzLl9wcml2YXRlLnN5c3RlbSAhPSBudWxsICl7XG4gICAgICB0aGlzLl9wcml2YXRlLnN5c3RlbS5zdG9wKCk7XG4gICAgfVxuXG4gICAgaWYoIHRoaXMuX3ByaXZhdGUuZG9uZUhhbmRsZXIgKXtcbiAgICAgIHRoaXMuX3ByaXZhdGUuZG9uZUhhbmRsZXIoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcbiAgXG4gICQkKCdsYXlvdXQnLCAnYXJib3InLCBBcmJvckxheW91dCk7XG4gIFxuICBcbn0pKGN5dG9zY2FwZSk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgZml0OiB0cnVlLCAvLyB3aGV0aGVyIHRvIGZpdCB0aGUgdmlld3BvcnQgdG8gdGhlIGdyYXBoXG4gICAgZGlyZWN0ZWQ6IGZhbHNlLCAvLyB3aGV0aGVyIHRoZSB0cmVlIGlzIGRpcmVjdGVkIGRvd253YXJkcyAob3IgZWRnZXMgY2FuIHBvaW50IGluIGFueSBkaXJlY3Rpb24gaWYgZmFsc2UpXG4gICAgcGFkZGluZzogMzAsIC8vIHBhZGRpbmcgb24gZml0XG4gICAgY2lyY2xlOiBmYWxzZSwgLy8gcHV0IGRlcHRocyBpbiBjb25jZW50cmljIGNpcmNsZXMgaWYgdHJ1ZSwgcHV0IGRlcHRocyB0b3AgZG93biBpZiBmYWxzZVxuICAgIHNwYWNpbmdGYWN0b3I6IDEuNzUsIC8vIHBvc2l0aXZlIHNwYWNpbmcgZmFjdG9yLCBsYXJnZXIgPT4gbW9yZSBzcGFjZSBiZXR3ZWVuIG5vZGVzIChOLkIuIG4vYSBpZiBjYXVzZXMgb3ZlcmxhcClcbiAgICBib3VuZGluZ0JveDogdW5kZWZpbmVkLCAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgICBhdm9pZE92ZXJsYXA6IHRydWUsIC8vIHByZXZlbnRzIG5vZGUgb3ZlcmxhcCwgbWF5IG92ZXJmbG93IGJvdW5kaW5nQm94IGlmIG5vdCBlbm91Z2ggc3BhY2VcbiAgICByb290czogdW5kZWZpbmVkLCAvLyB0aGUgcm9vdHMgb2YgdGhlIHRyZWVzXG4gICAgbWF4aW1hbEFkanVzdG1lbnRzOiAwLCAvLyBob3cgbWFueSB0aW1lcyB0byB0cnkgdG8gcG9zaXRpb24gdGhlIG5vZGVzIGluIGEgbWF4aW1hbCB3YXkgKGkuZS4gbm8gYmFja3RyYWNraW5nKVxuICAgIGFuaW1hdGU6IGZhbHNlLCAvLyB3aGV0aGVyIHRvIHRyYW5zaXRpb24gdGhlIG5vZGUgcG9zaXRpb25zXG4gICAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCwgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgICByZWFkeTogdW5kZWZpbmVkLCAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICAgIHN0b3A6IHVuZGVmaW5lZCAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG4gIH07XG4gIFxuICBmdW5jdGlvbiBCcmVhZHRoRmlyc3RMYXlvdXQoIG9wdGlvbnMgKXtcbiAgICB0aGlzLm9wdGlvbnMgPSAkJC51dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuICB9XG4gIFxuICBCcmVhZHRoRmlyc3RMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHBhcmFtcyA9IHRoaXMub3B0aW9ucztcbiAgICB2YXIgb3B0aW9ucyA9IHBhcmFtcztcbiAgICBcbiAgICB2YXIgY3kgPSBwYXJhbXMuY3k7XG4gICAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gICAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpLm5vdCgnOnBhcmVudCcpO1xuICAgIHZhciBncmFwaCA9IGVsZXM7XG4gICAgXG4gICAgdmFyIGJiID0gJCQudXRpbC5tYWtlQm91bmRpbmdCb3goIG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgICAgeDE6IDAsIHkxOiAwLCB3OiBjeS53aWR0aCgpLCBoOiBjeS5oZWlnaHQoKVxuICAgIH0gKTtcblxuICAgIHZhciByb290cztcbiAgICBpZiggJCQuaXMuZWxlbWVudE9yQ29sbGVjdGlvbihvcHRpb25zLnJvb3RzKSApe1xuICAgICAgcm9vdHMgPSBvcHRpb25zLnJvb3RzO1xuICAgIH0gZWxzZSBpZiggJCQuaXMuYXJyYXkob3B0aW9ucy5yb290cykgKXtcbiAgICAgIHZhciByb290c0FycmF5ID0gW107XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5yb290cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgaWQgPSBvcHRpb25zLnJvb3RzW2ldO1xuICAgICAgICB2YXIgZWxlID0gY3kuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG4gICAgICAgIHJvb3RzQXJyYXkucHVzaCggZWxlICk7XG4gICAgICB9XG5cbiAgICAgIHJvb3RzID0gbmV3ICQkLkNvbGxlY3Rpb24oIGN5LCByb290c0FycmF5ICk7XG4gICAgfSBlbHNlIGlmKCAkJC5pcy5zdHJpbmcob3B0aW9ucy5yb290cykgKXtcbiAgICAgIHJvb3RzID0gY3kuJCggb3B0aW9ucy5yb290cyApO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKCBvcHRpb25zLmRpcmVjdGVkICl7XG4gICAgICAgIHJvb3RzID0gbm9kZXMucm9vdHMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjb21wb25lbnRzID0gW107XG4gICAgICAgIHZhciB1bmhhbmRsZWROb2RlcyA9IG5vZGVzO1xuXG4gICAgICAgIHdoaWxlKCB1bmhhbmRsZWROb2Rlcy5sZW5ndGggPiAwICl7XG4gICAgICAgICAgdmFyIGN1cnJDb21wID0gY3kuY29sbGVjdGlvbigpO1xuXG4gICAgICAgICAgZWxlcy5iZnMoe1xuICAgICAgICAgICAgcm9vdHM6IHVuaGFuZGxlZE5vZGVzWzBdLFxuICAgICAgICAgICAgdmlzaXQ6IGZ1bmN0aW9uKGksIGRlcHRoLCBub2RlLCBlZGdlLCBwTm9kZSl7XG4gICAgICAgICAgICAgIGN1cnJDb21wID0gY3VyckNvbXAuYWRkKCBub2RlICk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGlyZWN0ZWQ6IGZhbHNlXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB1bmhhbmRsZWROb2RlcyA9IHVuaGFuZGxlZE5vZGVzLm5vdCggY3VyckNvbXAgKTtcbiAgICAgICAgICBjb21wb25lbnRzLnB1c2goIGN1cnJDb21wICk7XG4gICAgICAgIH1cblxuICAgICAgICByb290cyA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjb21wb25lbnRzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGNvbXAgPSBjb21wb25lbnRzW2ldO1xuICAgICAgICAgIHZhciBtYXhEZWdyZWUgPSBjb21wLm1heERlZ3JlZSggZmFsc2UgKTtcbiAgICAgICAgICB2YXIgY29tcFJvb3RzID0gY29tcC5maWx0ZXIoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlZ3JlZShmYWxzZSkgPT09IG1heERlZ3JlZTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJvb3RzID0gcm9vdHMuYWRkKCBjb21wUm9vdHMgKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgIH1cbiAgICB9XG5cblxuICAgIHZhciBkZXB0aHMgPSBbXTtcbiAgICB2YXIgZm91bmRCeUJmcyA9IHt9O1xuICAgIHZhciBpZDJkZXB0aCA9IHt9O1xuICAgIHZhciBwcmV2Tm9kZSA9IHt9O1xuICAgIHZhciBwcmV2RWRnZSA9IHt9O1xuICAgIHZhciBzdWNjZXNzb3JzID0ge307XG5cbiAgICAvLyBmaW5kIHRoZSBkZXB0aHMgb2YgdGhlIG5vZGVzXG4gICAgZ3JhcGguYmZzKHtcbiAgICAgIHJvb3RzOiByb290cyxcbiAgICAgIGRpcmVjdGVkOiBvcHRpb25zLmRpcmVjdGVkLFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKGksIGRlcHRoLCBub2RlLCBlZGdlLCBwTm9kZSl7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgICAgICB2YXIgaWQgPSBlbGUuaWQoKTtcblxuICAgICAgICBpZiggIWRlcHRoc1tkZXB0aF0gKXtcbiAgICAgICAgICBkZXB0aHNbZGVwdGhdID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBkZXB0aHNbZGVwdGhdLnB1c2goIGVsZSApO1xuICAgICAgICBmb3VuZEJ5QmZzWyBpZCBdID0gdHJ1ZTtcbiAgICAgICAgaWQyZGVwdGhbIGlkIF0gPSBkZXB0aDtcbiAgICAgICAgcHJldk5vZGVbIGlkIF0gPSBwTm9kZTtcbiAgICAgICAgcHJldkVkZ2VbIGlkIF0gPSBlZGdlO1xuXG4gICAgICAgIGlmKCBwTm9kZSApe1xuICAgICAgICAgIHZhciBwcmV2SWQgPSBwTm9kZS5pZCgpO1xuICAgICAgICAgIHZhciBzdWNjID0gc3VjY2Vzc29yc1sgcHJldklkIF0gPSBzdWNjZXNzb3JzWyBwcmV2SWQgXSB8fCBbXTtcbiAgICAgICAgICBcbiAgICAgICAgICBzdWNjLnB1c2goIG5vZGUgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gY2hlY2sgZm9yIG5vZGVzIG5vdCBmb3VuZCBieSBiZnNcbiAgICB2YXIgb3JwaGFuTm9kZXMgPSBbXTtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gbm9kZXNbaV07XG5cbiAgICAgIGlmKCBmb3VuZEJ5QmZzWyBlbGUuaWQoKSBdICl7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3JwaGFuTm9kZXMucHVzaCggZWxlICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYXNzaWduIG9ycGhhbiBub2RlcyBhIGRlcHRoIGZyb20gdGhlaXIgbmVpZ2hib3Job29kXG4gICAgdmFyIG1heENoZWNrcyA9IG9ycGhhbk5vZGVzLmxlbmd0aCAqIDM7XG4gICAgdmFyIGNoZWNrcyA9IDA7XG4gICAgd2hpbGUoIG9ycGhhbk5vZGVzLmxlbmd0aCAhPT0gMCAmJiBjaGVja3MgPCBtYXhDaGVja3MgKXtcbiAgICAgIHZhciBub2RlID0gb3JwaGFuTm9kZXMuc2hpZnQoKTtcbiAgICAgIHZhciBuZWlnaGJvcnMgPSBub2RlLm5laWdoYm9yaG9vZCgpLm5vZGVzKCk7XG4gICAgICB2YXIgYXNzaWduZWREZXB0aCA9IGZhbHNlO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5laWdoYm9ycy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZGVwdGggPSBpZDJkZXB0aFsgbmVpZ2hib3JzW2ldLmlkKCkgXTtcblxuICAgICAgICBpZiggZGVwdGggIT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgIGRlcHRoc1tkZXB0aF0ucHVzaCggbm9kZSApO1xuICAgICAgICAgIGFzc2lnbmVkRGVwdGggPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKCAhYXNzaWduZWREZXB0aCApe1xuICAgICAgICBvcnBoYW5Ob2Rlcy5wdXNoKCBub2RlICk7XG4gICAgICB9XG5cbiAgICAgIGNoZWNrcysrO1xuICAgIH1cblxuICAgIC8vIGFzc2lnbiBvcnBoYW4gbm9kZXMgdGhhdCBhcmUgc3RpbGwgbGVmdCB0byB0aGUgZGVwdGggb2YgdGhlaXIgc3ViZ3JhcGhcbiAgICB3aGlsZSggb3JwaGFuTm9kZXMubGVuZ3RoICE9PSAwICl7XG4gICAgICB2YXIgbm9kZSA9IG9ycGhhbk5vZGVzLnNoaWZ0KCk7XG4gICAgICAvL3ZhciBzdWJncmFwaCA9IGdyYXBoLmJmcyggbm9kZSApLnBhdGg7XG4gICAgICB2YXIgYXNzaWduZWREZXB0aCA9IGZhbHNlO1xuXG4gICAgICAvLyBmb3IoIHZhciBpID0gMDsgaSA8IHN1YmdyYXBoLmxlbmd0aDsgaSsrICl7XG4gICAgICAvLyAgIHZhciBkZXB0aCA9IGlkMmRlcHRoWyBzdWJncmFwaFtpXS5pZCgpIF07XG5cbiAgICAgIC8vICAgaWYoIGRlcHRoICE9PSB1bmRlZmluZWQgKXtcbiAgICAgIC8vICAgICBkZXB0aHNbZGVwdGhdLnB1c2goIG5vZGUgKTtcbiAgICAgIC8vICAgICBhc3NpZ25lZERlcHRoID0gdHJ1ZTtcbiAgICAgIC8vICAgICBicmVhaztcbiAgICAgIC8vICAgfVxuICAgICAgLy8gfVxuXG4gICAgICBpZiggIWFzc2lnbmVkRGVwdGggKXsgLy8gd29yc3QgY2FzZSBpZiB0aGUgZ3JhcGggcmVhbGx5IGlzbid0IHRyZWUgZnJpZW5kbHksIHRoZW4ganVzdCBkdW1wIGl0IGluIDBcbiAgICAgICAgaWYoIGRlcHRocy5sZW5ndGggPT09IDAgKXtcbiAgICAgICAgICBkZXB0aHMucHVzaChbXSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGRlcHRoc1swXS5wdXNoKCBub2RlICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYXNzaWduIHRoZSBub2RlcyBhIGRlcHRoIGFuZCBpbmRleFxuICAgIHZhciBhc3NpZ25EZXB0aHNUb0VsZXMgPSBmdW5jdGlvbigpe1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBkZXB0aHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZXMgPSBkZXB0aHNbaV07XG5cbiAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBlbGVzLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IGVsZXNbal07XG5cbiAgICAgICAgICBlbGUuX3ByaXZhdGUuc2NyYXRjaC5icmVhZHRoZmlyc3QgPSB7XG4gICAgICAgICAgICBkZXB0aDogaSxcbiAgICAgICAgICAgIGluZGV4OiBqXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgYXNzaWduRGVwdGhzVG9FbGVzKCk7XG5cblxuICAgIHZhciBpbnRlcnNlY3RzRGVwdGggPSBmdW5jdGlvbiggbm9kZSApeyAvLyByZXR1cm5zIHRydWUgaWYgaGFzIGVkZ2VzIHBvaW50aW5nIGluIGZyb20gYSBoaWdoZXIgZGVwdGhcbiAgICAgIHZhciBlZGdlcyA9IG5vZGUuY29ubmVjdGVkRWRnZXMoZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YSgndGFyZ2V0JykgPT09IG5vZGUuaWQoKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHRoaXNJbmZvID0gbm9kZS5fcHJpdmF0ZS5zY3JhdGNoLmJyZWFkdGhmaXJzdDtcbiAgICAgIHZhciBoaWdoZXN0RGVwdGhPZk90aGVyID0gMDtcbiAgICAgIHZhciBoaWdoZXN0T3RoZXI7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG4gICAgICAgIHZhciBvdGhlck5vZGUgPSBlZGdlLnNvdXJjZSgpWzBdO1xuICAgICAgICB2YXIgb3RoZXJJbmZvID0gb3RoZXJOb2RlLl9wcml2YXRlLnNjcmF0Y2guYnJlYWR0aGZpcnN0O1xuXG4gICAgICAgIGlmKCB0aGlzSW5mby5kZXB0aCA8PSBvdGhlckluZm8uZGVwdGggJiYgaGlnaGVzdERlcHRoT2ZPdGhlciA8IG90aGVySW5mby5kZXB0aCApe1xuICAgICAgICAgIGhpZ2hlc3REZXB0aE9mT3RoZXIgPSBvdGhlckluZm8uZGVwdGg7XG4gICAgICAgICAgaGlnaGVzdE90aGVyID0gb3RoZXJOb2RlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoaWdoZXN0T3RoZXI7XG4gICAgfTtcblxuICAgICAvLyBtYWtlIG1heGltYWwgaWYgc28gc2V0IGJ5IGFkanVzdGluZyBkZXB0aHNcbiAgICBmb3IoIHZhciBhZGogPSAwOyBhZGogPCBvcHRpb25zLm1heGltYWxBZGp1c3RtZW50czsgYWRqKysgKXtcblxuICAgICAgdmFyIG5EZXB0aHMgPSBkZXB0aHMubGVuZ3RoO1xuICAgICAgdmFyIGVsZXNUb01vdmUgPSBbXTtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbkRlcHRoczsgaSsrICl7XG4gICAgICAgIHZhciBkZXB0aCA9IGRlcHRoc1tpXTtcblxuICAgICAgICB2YXIgbkRlcHRoID0gZGVwdGgubGVuZ3RoO1xuICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IG5EZXB0aDsgaisrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IGRlcHRoW2pdO1xuICAgICAgICAgIHZhciBpbmZvID0gZWxlLl9wcml2YXRlLnNjcmF0Y2guYnJlYWR0aGZpcnN0O1xuICAgICAgICAgIHZhciBpbnRFbGUgPSBpbnRlcnNlY3RzRGVwdGgoZWxlKTtcblxuICAgICAgICAgIGlmKCBpbnRFbGUgKXtcbiAgICAgICAgICAgIGluZm8uaW50RWxlID0gaW50RWxlO1xuICAgICAgICAgICAgZWxlc1RvTW92ZS5wdXNoKCBlbGUgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzVG9Nb3ZlLmxlbmd0aDsgaSsrICl7IFxuICAgICAgICB2YXIgZWxlID0gZWxlc1RvTW92ZVtpXTtcbiAgICAgICAgdmFyIGluZm8gPSBlbGUuX3ByaXZhdGUuc2NyYXRjaC5icmVhZHRoZmlyc3Q7XG4gICAgICAgIHZhciBpbnRFbGUgPSBpbmZvLmludEVsZTtcbiAgICAgICAgdmFyIGludEluZm8gPSBpbnRFbGUuX3ByaXZhdGUuc2NyYXRjaC5icmVhZHRoZmlyc3Q7XG5cbiAgICAgICAgZGVwdGhzWyBpbmZvLmRlcHRoIF0uc3BsaWNlKCBpbmZvLmluZGV4LCAxICk7IC8vIHJlbW92ZSBmcm9tIG9sZCBkZXB0aCAmIGluZGV4XG5cbiAgICAgICAgLy8gYWRkIHRvIGVuZCBvZiBuZXcgZGVwdGhcbiAgICAgICAgdmFyIG5ld0RlcHRoID0gaW50SW5mby5kZXB0aCArIDE7XG4gICAgICAgIHdoaWxlKCBuZXdEZXB0aCA+IGRlcHRocy5sZW5ndGggLSAxICl7XG4gICAgICAgICAgZGVwdGhzLnB1c2goW10pO1xuICAgICAgICB9XG4gICAgICAgIGRlcHRoc1sgbmV3RGVwdGggXS5wdXNoKCBlbGUgKTtcblxuICAgICAgICBpbmZvLmRlcHRoID0gbmV3RGVwdGg7XG4gICAgICAgIGluZm8uaW5kZXggPSBkZXB0aHNbbmV3RGVwdGhdLmxlbmd0aCAtIDE7XG4gICAgICB9XG5cbiAgICAgIGFzc2lnbkRlcHRoc1RvRWxlcygpO1xuICAgIH1cblxuICAgIC8vIGZpbmQgbWluIGRpc3RhbmNlIHdlIG5lZWQgdG8gbGVhdmUgYmV0d2VlbiBub2Rlc1xuICAgIHZhciBtaW5EaXN0YW5jZSA9IDA7XG4gICAgaWYoIG9wdGlvbnMuYXZvaWRPdmVybGFwICl7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciB3ID0gbm9kZXNbaV0ub3V0ZXJXaWR0aCgpO1xuICAgICAgICB2YXIgaCA9IG5vZGVzW2ldLm91dGVySGVpZ2h0KCk7XG4gICAgICAgIFxuICAgICAgICBtaW5EaXN0YW5jZSA9IE1hdGgubWF4KG1pbkRpc3RhbmNlLCB3LCBoKTtcbiAgICAgIH1cbiAgICAgIG1pbkRpc3RhbmNlICo9IG9wdGlvbnMuc3BhY2luZ0ZhY3RvcjsgLy8ganVzdCB0byBoYXZlIHNvbWUgbmljZSBzcGFjaW5nXG4gICAgfVxuXG4gICAgLy8gZ2V0IHRoZSB3ZWlnaHRlZCBwZXJjZW50IGZvciBhbiBlbGVtZW50IGJhc2VkIG9uIGl0cyBjb25uZWN0aXZpdHkgdG8gb3RoZXIgbGV2ZWxzXG4gICAgdmFyIGNhY2hlZFdlaWdodGVkUGVyY2VudCA9IHt9O1xuICAgIHZhciBnZXRXZWlnaHRlZFBlcmNlbnQgPSBmdW5jdGlvbiggZWxlICl7XG4gICAgICBpZiggY2FjaGVkV2VpZ2h0ZWRQZXJjZW50WyBlbGUuaWQoKSBdICl7XG4gICAgICAgIHJldHVybiBjYWNoZWRXZWlnaHRlZFBlcmNlbnRbIGVsZS5pZCgpIF07XG4gICAgICB9XG5cbiAgICAgIHZhciBlbGVEZXB0aCA9IGVsZS5fcHJpdmF0ZS5zY3JhdGNoLmJyZWFkdGhmaXJzdC5kZXB0aDtcbiAgICAgIHZhciBuZWlnaGJvcnMgPSBlbGUubmVpZ2hib3Job29kKCkubm9kZXMoKS5ub3QoJzpwYXJlbnQnKTtcbiAgICAgIHZhciBwZXJjZW50ID0gMDtcbiAgICAgIHZhciBzYW1wbGVzID0gMDtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBuZWlnaGJvcnMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIG5laWdoYm9yID0gbmVpZ2hib3JzW2ldO1xuICAgICAgICB2YXIgYmYgPSBuZWlnaGJvci5fcHJpdmF0ZS5zY3JhdGNoLmJyZWFkdGhmaXJzdDtcbiAgICAgICAgdmFyIGluZGV4ID0gYmYuaW5kZXg7XG4gICAgICAgIHZhciBkZXB0aCA9IGJmLmRlcHRoO1xuICAgICAgICB2YXIgbkRlcHRoID0gZGVwdGhzW2RlcHRoXS5sZW5ndGg7XG5cbiAgICAgICAgaWYoIGVsZURlcHRoID4gZGVwdGggfHwgZWxlRGVwdGggPT09IDAgKXsgLy8gb25seSBnZXQgaW5mbHVlbmNlZCBieSBlbGVtZW50cyBhYm92ZVxuICAgICAgICAgIHBlcmNlbnQgKz0gaW5kZXggLyBuRGVwdGg7XG4gICAgICAgICAgc2FtcGxlcysrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNhbXBsZXMgPSBNYXRoLm1heCgxLCBzYW1wbGVzKTtcbiAgICAgIHBlcmNlbnQgPSBwZXJjZW50IC8gc2FtcGxlcztcblxuICAgICAgaWYoIHNhbXBsZXMgPT09IDAgKXsgLy8gc28gbG9uZSBub2RlcyBoYXZlIGEgXCJkb24ndCBjYXJlXCIgc3RhdGUgaW4gc29ydGluZ1xuICAgICAgICBwZXJjZW50ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBjYWNoZWRXZWlnaHRlZFBlcmNlbnRbIGVsZS5pZCgpIF0gPSBwZXJjZW50O1xuICAgICAgcmV0dXJuIHBlcmNlbnQ7XG4gICAgfTtcblxuXG4gICAgLy8gcmVhcnJhbmdlIHRoZSBpbmRpY2VzIGluIGVhY2ggZGVwdGggbGV2ZWwgYmFzZWQgb24gY29ubmVjdGl2aXR5XG5cbiAgICB2YXIgc29ydEZuID0gZnVuY3Rpb24oYSwgYil7XG4gICAgICB2YXIgYXBjdCA9IGdldFdlaWdodGVkUGVyY2VudCggYSApO1xuICAgICAgdmFyIGJwY3QgPSBnZXRXZWlnaHRlZFBlcmNlbnQoIGIgKTtcblxuICAgICAgcmV0dXJuIGFwY3QgLSBicGN0O1xuICAgIH07XG5cbiAgICBmb3IoIHZhciB0aW1lcyA9IDA7IHRpbWVzIDwgMzsgdGltZXMrKyApeyAvLyBkbyBpdCBhIGZldyB0aW1lcyBiL2MgdGhlIGRlcHRocyBhcmUgZHluYW1pYyBhbmQgd2Ugd2FudCBhIG1vcmUgc3RhYmxlIHJlc3VsdFxuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGRlcHRocy5sZW5ndGg7IGkrKyApe1xuICAgICAgICBkZXB0aHNbaV0gPSBkZXB0aHNbaV0uc29ydCggc29ydEZuICk7XG4gICAgICB9XG4gICAgICBhc3NpZ25EZXB0aHNUb0VsZXMoKTsgLy8gYW5kIHVwZGF0ZVxuXG4gICAgfVxuXG4gICAgdmFyIGJpZ2dlc3REZXB0aFNpemUgPSAwO1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZGVwdGhzLmxlbmd0aDsgaSsrICl7XG4gICAgICBiaWdnZXN0RGVwdGhTaXplID0gTWF0aC5tYXgoIGRlcHRoc1tpXS5sZW5ndGgsIGJpZ2dlc3REZXB0aFNpemUgKTtcbiAgICB9XG5cbiAgICB2YXIgY2VudGVyID0ge1xuICAgICAgeDogYmIueDEgKyBiYi53LzIsXG4gICAgICB5OiBiYi54MSArIGJiLmgvMlxuICAgIH07XG4gICBcbiAgICB2YXIgZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiggZWxlLCBpc0JvdHRvbURlcHRoICl7XG4gICAgICB2YXIgaW5mbyA9IGVsZS5fcHJpdmF0ZS5zY3JhdGNoLmJyZWFkdGhmaXJzdDtcbiAgICAgIHZhciBkZXB0aCA9IGluZm8uZGVwdGg7XG4gICAgICB2YXIgaW5kZXggPSBpbmZvLmluZGV4O1xuICAgICAgdmFyIGRlcHRoU2l6ZSA9IGRlcHRoc1tkZXB0aF0ubGVuZ3RoO1xuXG4gICAgICB2YXIgZGlzdGFuY2VYID0gTWF0aC5tYXgoIGJiLncgLyAoZGVwdGhTaXplICsgMSksIG1pbkRpc3RhbmNlICk7XG4gICAgICB2YXIgZGlzdGFuY2VZID0gTWF0aC5tYXgoIGJiLmggLyAoZGVwdGhzLmxlbmd0aCArIDEpLCBtaW5EaXN0YW5jZSApO1xuICAgICAgdmFyIHJhZGl1c1N0ZXBTaXplID0gTWF0aC5taW4oIGJiLncgLyAyIC8gZGVwdGhzLmxlbmd0aCwgYmIuaCAvIDIgLyBkZXB0aHMubGVuZ3RoICk7XG4gICAgICByYWRpdXNTdGVwU2l6ZSA9IE1hdGgubWF4KCByYWRpdXNTdGVwU2l6ZSwgbWluRGlzdGFuY2UgKTtcblxuICAgICAgaWYoICFvcHRpb25zLmNpcmNsZSApe1xuICAgICAgICBcbiAgICAgICAgdmFyIGVwb3MgPSB7XG4gICAgICAgICAgeDogY2VudGVyLnggKyAoaW5kZXggKyAxIC0gKGRlcHRoU2l6ZSArIDEpLzIpICogZGlzdGFuY2VYLFxuICAgICAgICAgIHk6IChkZXB0aCArIDEpICogZGlzdGFuY2VZXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYoIGlzQm90dG9tRGVwdGggKXtcbiAgICAgICAgICByZXR1cm4gZXBvcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhciBzdWNjcyA9IHN1Y2Nlc3NvcnNbIGVsZS5pZCgpIF07XG4gICAgICAgIC8vIGlmKCBzdWNjcyApe1xuICAgICAgICAvLyAgIGVwb3MueCA9IDA7XG4gICAgICAgIC8vIFxuICAgICAgICAvLyAgIGZvciggdmFyIGkgPSAwIDsgaSA8IHN1Y2NzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIC8vICAgICB2YXIgc3BvcyA9IHBvc1sgc3VjY3NbaV0uaWQoKSBdO1xuICAgICAgICAvLyAgICAgXG4gICAgICAgIC8vICAgICBlcG9zLnggKz0gc3Bvcy54O1xuICAgICAgICAvLyAgIH1cbiAgICAgICAgLy8gXG4gICAgICAgIC8vICAgZXBvcy54IC89IHN1Y2NzLmxlbmd0aDtcbiAgICAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgLy8gICAvL2RlYnVnZ2VyO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgcmV0dXJuIGVwb3M7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmKCBvcHRpb25zLmNpcmNsZSApe1xuICAgICAgICAgIHZhciByYWRpdXMgPSByYWRpdXNTdGVwU2l6ZSAqIGRlcHRoICsgcmFkaXVzU3RlcFNpemUgLSAoZGVwdGhzLmxlbmd0aCA+IDAgJiYgZGVwdGhzWzBdLmxlbmd0aCA8PSAzID8gcmFkaXVzU3RlcFNpemUvMiA6IDApO1xuICAgICAgICAgIHZhciB0aGV0YSA9IDIgKiBNYXRoLlBJIC8gZGVwdGhzW2RlcHRoXS5sZW5ndGggKiBpbmRleDtcblxuICAgICAgICAgIGlmKCBkZXB0aCA9PT0gMCAmJiBkZXB0aHNbMF0ubGVuZ3RoID09PSAxICl7XG4gICAgICAgICAgICByYWRpdXMgPSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBjZW50ZXIueCArIHJhZGl1cyAqIE1hdGguY29zKHRoZXRhKSxcbiAgICAgICAgICAgIHk6IGNlbnRlci55ICsgcmFkaXVzICogTWF0aC5zaW4odGhldGEpXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBjZW50ZXIueCArIChpbmRleCArIDEgLSAoZGVwdGhTaXplICsgMSkvMikgKiBkaXN0YW5jZVgsXG4gICAgICAgICAgICB5OiAoZGVwdGggKyAxKSAqIGRpc3RhbmNlWVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgIH07XG5cbiAgICAvLyBnZXQgcG9zaXRpb25zIGluIHJldmVyc2UgZGVwdGggb3JkZXJcbiAgICB2YXIgcG9zID0ge307XG4gICAgZm9yKCB2YXIgaSA9IGRlcHRocy5sZW5ndGggLSAxOyBpID49MDsgaS0tICl7XG4gICAgICB2YXIgZGVwdGggPSBkZXB0aHNbaV07XG5cbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgZGVwdGgubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgdmFyIG5vZGUgPSBkZXB0aFtqXTtcblxuICAgICAgICBwb3NbIG5vZGUuaWQoKSBdID0gZ2V0UG9zaXRpb24oIG5vZGUsIGkgPT09IGRlcHRocy5sZW5ndGggLSAxICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbm9kZXMubGF5b3V0UG9zaXRpb25zKHRoaXMsIG9wdGlvbnMsIGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gcG9zWyB0aGlzLmlkKCkgXTtcbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcbiAgXG4gICQkKCdsYXlvdXQnLCAnYnJlYWR0aGZpcnN0JywgQnJlYWR0aEZpcnN0TGF5b3V0KTtcbiAgXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgZml0OiB0cnVlLCAvLyB3aGV0aGVyIHRvIGZpdCB0aGUgdmlld3BvcnQgdG8gdGhlIGdyYXBoXG4gICAgcGFkZGluZzogMzAsIC8vIHRoZSBwYWRkaW5nIG9uIGZpdFxuICAgIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICAgIGF2b2lkT3ZlcmxhcDogdHJ1ZSwgLy8gcHJldmVudHMgbm9kZSBvdmVybGFwLCBtYXkgb3ZlcmZsb3cgYm91bmRpbmdCb3ggYW5kIHJhZGl1cyBpZiBub3QgZW5vdWdoIHNwYWNlXG4gICAgcmFkaXVzOiB1bmRlZmluZWQsIC8vIHRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZVxuICAgIHN0YXJ0QW5nbGU6IDMvMiAqIE1hdGguUEksIC8vIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3Qgbm9kZVxuICAgIGNvdW50ZXJjbG9ja3dpc2U6IGZhbHNlLCAvLyB3aGV0aGVyIHRoZSBsYXlvdXQgc2hvdWxkIGdvIGNvdW50ZXJjbG9ja3dpc2UgKHRydWUpIG9yIGNsb2Nrd2lzZSAoZmFsc2UpXG4gICAgc29ydDogdW5kZWZpbmVkLCAvLyBhIHNvcnRpbmcgZnVuY3Rpb24gdG8gb3JkZXIgdGhlIG5vZGVzOyBlLmcuIGZ1bmN0aW9uKGEsIGIpeyByZXR1cm4gYS5kYXRhKCd3ZWlnaHQnKSAtIGIuZGF0YSgnd2VpZ2h0JykgfVxuICAgIGFuaW1hdGU6IGZhbHNlLCAvLyB3aGV0aGVyIHRvIHRyYW5zaXRpb24gdGhlIG5vZGUgcG9zaXRpb25zXG4gICAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCwgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgICByZWFkeTogdW5kZWZpbmVkLCAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICAgIHN0b3A6IHVuZGVmaW5lZCAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG4gIH07XG4gIFxuICBmdW5jdGlvbiBDaXJjbGVMYXlvdXQoIG9wdGlvbnMgKXtcbiAgICB0aGlzLm9wdGlvbnMgPSAkJC51dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuICB9XG4gIFxuICBDaXJjbGVMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHBhcmFtcyA9IHRoaXMub3B0aW9ucztcbiAgICB2YXIgb3B0aW9ucyA9IHBhcmFtcztcbiAgICBcbiAgICB2YXIgY3kgPSBwYXJhbXMuY3k7XG4gICAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gICAgICBcbiAgICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCkubm90KCc6cGFyZW50Jyk7XG5cbiAgICBpZiggb3B0aW9ucy5zb3J0ICl7XG4gICAgICBub2RlcyA9IG5vZGVzLnNvcnQoIG9wdGlvbnMuc29ydCApO1xuICAgIH1cbiAgICBcbiAgICB2YXIgYmIgPSAkJC51dGlsLm1ha2VCb3VuZGluZ0JveCggb3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgICB4MTogMCwgeTE6IDAsIHc6IGN5LndpZHRoKCksIGg6IGN5LmhlaWdodCgpXG4gICAgfSApO1xuXG4gICAgdmFyIGNlbnRlciA9IHtcbiAgICAgIHg6IGJiLngxICsgYmIudy8yLFxuICAgICAgeTogYmIueTEgKyBiYi5oLzJcbiAgICB9O1xuICAgIFxuICAgIHZhciB0aGV0YSA9IG9wdGlvbnMuc3RhcnRBbmdsZTtcbiAgICB2YXIgZFRoZXRhID0gMiAqIE1hdGguUEkgLyBub2Rlcy5sZW5ndGg7XG4gICAgdmFyIHI7XG5cbiAgICB2YXIgbWluRGlzdGFuY2UgPSAwO1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciB3ID0gbm9kZXNbaV0ub3V0ZXJXaWR0aCgpO1xuICAgICAgdmFyIGggPSBub2Rlc1tpXS5vdXRlckhlaWdodCgpO1xuICAgICAgXG4gICAgICBtaW5EaXN0YW5jZSA9IE1hdGgubWF4KG1pbkRpc3RhbmNlLCB3LCBoKTtcbiAgICB9XG5cbiAgICBpZiggJCQuaXMubnVtYmVyKG9wdGlvbnMucmFkaXVzKSApe1xuICAgICAgciA9IG9wdGlvbnMucmFkaXVzO1xuICAgIH0gZWxzZSBpZiggbm9kZXMubGVuZ3RoIDw9IDEgKXtcbiAgICAgIHIgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICByID0gTWF0aC5taW4oIGJiLmgsIGJiLncgKS8yIC0gbWluRGlzdGFuY2U7XG4gICAgfVxuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSByYWRpdXNcbiAgICBpZiggbm9kZXMubGVuZ3RoID4gMSAmJiBvcHRpb25zLmF2b2lkT3ZlcmxhcCApeyAvLyBidXQgb25seSBpZiBtb3JlIHRoYW4gb25lIG5vZGUgKGNhbid0IG92ZXJsYXApXG4gICAgICBtaW5EaXN0YW5jZSAqPSAxLjc1OyAvLyBqdXN0IHRvIGhhdmUgc29tZSBuaWNlIHNwYWNpbmdcblxuICAgICAgdmFyIGRUaGV0YSA9IDIgKiBNYXRoLlBJIC8gbm9kZXMubGVuZ3RoO1xuICAgICAgdmFyIGRjb3MgPSBNYXRoLmNvcyhkVGhldGEpIC0gTWF0aC5jb3MoMCk7XG4gICAgICB2YXIgZHNpbiA9IE1hdGguc2luKGRUaGV0YSkgLSBNYXRoLnNpbigwKTtcbiAgICAgIHZhciByTWluID0gTWF0aC5zcXJ0KCBtaW5EaXN0YW5jZSAqIG1pbkRpc3RhbmNlIC8gKCBkY29zKmRjb3MgKyBkc2luKmRzaW4gKSApOyAvLyBzLnQuIG5vIG5vZGVzIG92ZXJsYXBwaW5nXG4gICAgICByID0gTWF0aC5tYXgoIHJNaW4sIHIgKTtcbiAgICB9XG5cbiAgICB2YXIgZ2V0UG9zID0gZnVuY3Rpb24oIGksIGVsZSApe1xuICAgICAgdmFyIHJ4ID0gciAqIE1hdGguY29zKCB0aGV0YSApO1xuICAgICAgdmFyIHJ5ID0gciAqIE1hdGguc2luKCB0aGV0YSApO1xuICAgICAgdmFyIHBvcyA9IHtcbiAgICAgICAgeDogY2VudGVyLnggKyByeCxcbiAgICAgICAgeTogY2VudGVyLnkgKyByeVxuICAgICAgfTtcblxuICAgICAgdGhldGEgPSBvcHRpb25zLmNvdW50ZXJjbG9ja3dpc2UgPyB0aGV0YSAtIGRUaGV0YSA6IHRoZXRhICsgZFRoZXRhO1xuICAgICAgcmV0dXJuIHBvcztcbiAgICB9O1xuICAgIFxuICAgIG5vZGVzLmxheW91dFBvc2l0aW9ucyggdGhpcywgb3B0aW9ucywgZ2V0UG9zICk7XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcbiAgXG4gICQkKCdsYXlvdXQnLCAnY2lyY2xlJywgQ2lyY2xlTGF5b3V0KTtcbiAgXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgLy8gZGVmYXVsdCBsYXlvdXQgb3B0aW9uc1xuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgYW5pbWF0ZTogdHJ1ZSwgLy8gd2hldGhlciB0byBzaG93IHRoZSBsYXlvdXQgYXMgaXQncyBydW5uaW5nXG4gICAgcmVmcmVzaDogMSwgLy8gbnVtYmVyIG9mIHRpY2tzIHBlciBmcmFtZTsgaGlnaGVyIGlzIGZhc3RlciBidXQgbW9yZSBqZXJreVxuICAgIG1heFNpbXVsYXRpb25UaW1lOiA0MDAwLCAvLyBtYXggbGVuZ3RoIGluIG1zIHRvIHJ1biB0aGUgbGF5b3V0XG4gICAgdW5ncmFiaWZ5V2hpbGVTaW11bGF0aW5nOiBmYWxzZSwgLy8gc28geW91IGNhbid0IGRyYWcgbm9kZXMgZHVyaW5nIGxheW91dFxuICAgIGZpdDogdHJ1ZSwgLy8gb24gZXZlcnkgbGF5b3V0IHJlcG9zaXRpb24gb2Ygbm9kZXMsIGZpdCB0aGUgdmlld3BvcnRcbiAgICBwYWRkaW5nOiAzMCwgLy8gcGFkZGluZyBhcm91bmQgdGhlIHNpbXVsYXRpb25cbiAgICBib3VuZGluZ0JveDogdW5kZWZpbmVkLCAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cblxuICAgIC8vIGxheW91dCBldmVudCBjYWxsYmFja3NcbiAgICByZWFkeTogZnVuY3Rpb24oKXt9LCAvLyBvbiBsYXlvdXRyZWFkeVxuICAgIHN0b3A6IGZ1bmN0aW9uKCl7fSwgLy8gb24gbGF5b3V0c3RvcFxuXG4gICAgLy8gcG9zaXRpb25pbmcgb3B0aW9uc1xuICAgIHJhbmRvbWl6ZTogZmFsc2UsIC8vIHVzZSByYW5kb20gbm9kZSBwb3NpdGlvbnMgYXQgYmVnaW5uaW5nIG9mIGxheW91dFxuICAgIGF2b2lkT3ZlcmxhcDogdHJ1ZSwgLy8gaWYgdHJ1ZSwgcHJldmVudHMgb3ZlcmxhcCBvZiBub2RlIGJvdW5kaW5nIGJveGVzXG4gICAgaGFuZGxlRGlzY29ubmVjdGVkOiB0cnVlLCAvLyBpZiB0cnVlLCBhdm9pZHMgZGlzY29ubmVjdGVkIGNvbXBvbmVudHMgZnJvbSBvdmVybGFwcGluZ1xuICAgIG5vZGVTcGFjaW5nOiBmdW5jdGlvbiggbm9kZSApeyByZXR1cm4gMTA7IH0sIC8vIGV4dHJhIHNwYWNpbmcgYXJvdW5kIG5vZGVzXG4gICAgZmxvdzogdW5kZWZpbmVkLCAvLyB1c2UgREFHL3RyZWUgZmxvdyBsYXlvdXQgaWYgc3BlY2lmaWVkLCBlLmcuIHsgYXhpczogJ3knLCBtaW5TZXBhcmF0aW9uOiAzMCB9XG4gICAgYWxpZ25tZW50OiB1bmRlZmluZWQsIC8vIHJlbGF0aXZlIGFsaWdubWVudCBjb25zdHJhaW50cyBvbiBub2RlcywgZS5nLiBmdW5jdGlvbiggbm9kZSApeyByZXR1cm4geyB4OiAwLCB5OiAxIH0gfVxuXG4gICAgLy8gZGlmZmVyZW50IG1ldGhvZHMgb2Ygc3BlY2lmeWluZyBlZGdlIGxlbmd0aFxuICAgIC8vIGVhY2ggY2FuIGJlIGEgY29uc3RhbnQgbnVtZXJpY2FsIHZhbHVlIG9yIGEgZnVuY3Rpb24gbGlrZSBgZnVuY3Rpb24oIGVkZ2UgKXsgcmV0dXJuIDI7IH1gXG4gICAgZWRnZUxlbmd0aDogdW5kZWZpbmVkLCAvLyBzZXRzIGVkZ2UgbGVuZ3RoIGRpcmVjdGx5IGluIHNpbXVsYXRpb25cbiAgICBlZGdlU3ltRGlmZkxlbmd0aDogdW5kZWZpbmVkLCAvLyBzeW1tZXRyaWMgZGlmZiBlZGdlIGxlbmd0aCBpbiBzaW11bGF0aW9uXG4gICAgZWRnZUphY2NhcmRMZW5ndGg6IHVuZGVmaW5lZCwgLy8gamFjY2FyZCBlZGdlIGxlbmd0aCBpbiBzaW11bGF0aW9uXG5cbiAgICAvLyBpdGVyYXRpb25zIG9mIGNvbGEgYWxnb3JpdGhtOyB1c2VzIGRlZmF1bHQgdmFsdWVzIG9uIHVuZGVmaW5lZFxuICAgIHVuY29uc3RySXRlcjogdW5kZWZpbmVkLCAvLyB1bmNvbnN0cmFpbmVkIGluaXRpYWwgbGF5b3V0IGl0ZXJhdGlvbnNcbiAgICB1c2VyQ29uc3RJdGVyOiB1bmRlZmluZWQsIC8vIGluaXRpYWwgbGF5b3V0IGl0ZXJhdGlvbnMgd2l0aCB1c2VyLXNwZWNpZmllZCBjb25zdHJhaW50c1xuICAgIGFsbENvbnN0SXRlcjogdW5kZWZpbmVkLCAvLyBpbml0aWFsIGxheW91dCBpdGVyYXRpb25zIHdpdGggYWxsIGNvbnN0cmFpbnRzIGluY2x1ZGluZyBub24tb3ZlcmxhcFxuXG4gICAgLy8gaW5maW5pdGUgbGF5b3V0IG9wdGlvbnNcbiAgICBpbmZpbml0ZTogZmFsc2UgLy8gb3ZlcnJpZGVzIGFsbCBvdGhlciBvcHRpb25zIGZvciBhIGZvcmNlcy1hbGwtdGhlLXRpbWUgbW9kZVxuICB9O1xuXG4gIC8vIGNvbnN0cnVjdG9yXG4gIC8vIG9wdGlvbnMgOiBvYmplY3QgY29udGFpbmluZyBsYXlvdXQgb3B0aW9uc1xuICBmdW5jdGlvbiBDb2xhTGF5b3V0KCBvcHRpb25zICl7XG4gICAgdGhpcy5vcHRpb25zID0gJCQudXRpbC5leHRlbmQodHJ1ZSwge30sIGRlZmF1bHRzLCBvcHRpb25zKTsgXG4gIH1cblxuICAvLyBydW5zIHRoZSBsYXlvdXRcbiAgQ29sYUxheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgbGF5b3V0ID0gdGhpcztcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBcbiAgICBsYXlvdXQubWFudWFsbHlTdG9wcGVkID0gZmFsc2U7XG5cbiAgICAkJC51dGlsLnJlcXVpcmUoJ2NvbGEnLCBmdW5jdGlvbihjb2xhKXtcblxuICAgICAgdmFyIGN5ID0gb3B0aW9ucy5jeTsgLy8gY3kgaXMgYXV0b21hdGljYWxseSBwb3B1bGF0ZWQgZm9yIHVzIGluIHRoZSBjb25zdHJ1Y3RvclxuICAgICAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gICAgICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCk7XG4gICAgICB2YXIgZWRnZXMgPSBlbGVzLmVkZ2VzKCk7XG4gICAgICB2YXIgcmVhZHkgPSBmYWxzZTtcbiAgICAgIFxuICAgICAgdmFyIGJiID0gJCQudXRpbC5tYWtlQm91bmRpbmdCb3goIG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgICAgICB4MTogMCwgeTE6IDAsIHc6IGN5LndpZHRoKCksIGg6IGN5LmhlaWdodCgpXG4gICAgICB9ICk7XG5cbiAgICAgIHZhciBnZXRPcHRWYWwgPSBmdW5jdGlvbiggdmFsLCBlbGUgKXtcbiAgICAgICAgaWYoICQkLmlzLmZuKHZhbCkgKXtcbiAgICAgICAgICB2YXIgZm4gPSB2YWw7XG4gICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KCBlbGUsIFsgZWxlIF0gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgdXBkYXRlTm9kZVBvc2l0aW9ucyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciB4ID0geyBtaW46IEluZmluaXR5LCBtYXg6IC1JbmZpbml0eSB9O1xuICAgICAgICB2YXIgeSA9IHsgbWluOiBJbmZpbml0eSwgbWF4OiAtSW5maW5pdHkgfTtcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICB2YXIgc2NyYXRjaCA9IG5vZGUuX3ByaXZhdGUuc2NyYXRjaC5jb2xhO1xuXG4gICAgICAgICAgeC5taW4gPSBNYXRoLm1pbiggeC5taW4sIHNjcmF0Y2gueCB8fCAwICk7XG4gICAgICAgICAgeC5tYXggPSBNYXRoLm1heCggeC5tYXgsIHNjcmF0Y2gueCB8fCAwICk7XG5cbiAgICAgICAgICB5Lm1pbiA9IE1hdGgubWluKCB5Lm1pbiwgc2NyYXRjaC55IHx8IDAgKTtcbiAgICAgICAgICB5Lm1heCA9IE1hdGgubWF4KCB5Lm1heCwgc2NyYXRjaC55IHx8IDAgKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyB1cGRhdGUgbm9kZSBkaW1zXG4gICAgICAgICAgaWYoICFzY3JhdGNoLnVwZGF0ZWREaW1zICl7XG4gICAgICAgICAgICB2YXIgbmJiID0gbm9kZS5ib3VuZGluZ0JveCgpO1xuICAgICAgICAgICAgdmFyIHBhZGRpbmcgPSBnZXRPcHRWYWwoIG9wdGlvbnMubm9kZVNwYWNpbmcsIG5vZGUgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc2NyYXRjaC53aWR0aCA9IG5iYi53ICsgMipwYWRkaW5nO1xuICAgICAgICAgICAgc2NyYXRjaC5oZWlnaHQgPSBuYmIuaCArIDIqcGFkZGluZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBub2Rlcy5wb3NpdGlvbnMoZnVuY3Rpb24oaSwgbm9kZSl7XG4gICAgICAgICAgdmFyIHNjcmF0Y2ggPSBub2RlLl9wcml2YXRlLnNjcmF0Y2guY29sYTtcbiAgICAgICAgICB2YXIgcmV0UG9zO1xuXG4gICAgICAgICAgaWYoICFub2RlLmdyYWJiZWQoKSAmJiAhbm9kZS5pc1BhcmVudCgpICl7XG4gICAgICAgICAgICByZXRQb3MgPSB7XG4gICAgICAgICAgICAgIHg6IGJiLngxICsgc2NyYXRjaC54IC0geC5taW4sXG4gICAgICAgICAgICAgIHk6IGJiLnkxICsgc2NyYXRjaC55IC0geS5taW5cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmKCAhJCQuaXMubnVtYmVyKHJldFBvcy54KSB8fCAhJCQuaXMubnVtYmVyKHJldFBvcy55KSApe1xuICAgICAgICAgICAgICByZXRQb3MgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJldFBvcztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbm9kZXMudXBkYXRlQ29tcG91bmRCb3VuZHMoKTsgLy8gYmVjYXVzZSB0aGUgd2F5IHRoaXMgbGF5b3V0IHNldHMgcG9zaXRpb25zIGlzIGJ1Z2d5IGZvciBzb21lIHJlYXNvbjsgcmVmICM4NzhcblxuICAgICAgICBpZiggIXJlYWR5ICl7XG4gICAgICAgICAgb25SZWFkeSgpO1xuICAgICAgICAgIHJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBvcHRpb25zLmZpdCApe1xuICAgICAgICAgIGN5LmZpdCggb3B0aW9ucy5wYWRkaW5nICk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBvbkRvbmUgPSBmdW5jdGlvbigpe1xuICAgICAgICBpZiggb3B0aW9ucy51bmdyYWJpZnlXaGlsZVNpbXVsYXRpbmcgKXtcbiAgICAgICAgICBncmFiYmFibGVOb2Rlcy5ncmFiaWZ5KCk7XG4gICAgICAgIH1cblxuICAgICAgICBub2Rlcy5vZmYoJ2dyYWIgZnJlZSBwb3NpdGlvbicsIGdyYWJIYW5kbGVyKTtcbiAgICAgICAgbm9kZXMub2ZmKCdsb2NrIHVubG9jaycsIGxvY2tIYW5kbGVyKTtcblxuICAgICAgICAvLyB0cmlnZ2VyIGxheW91dHN0b3Agd2hlbiB0aGUgbGF5b3V0IHN0b3BzIChlLmcuIGZpbmlzaGVzKVxuICAgICAgICBsYXlvdXQub25lKCdsYXlvdXRzdG9wJywgb3B0aW9ucy5zdG9wKTtcbiAgICAgICAgbGF5b3V0LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0c3RvcCcsIGxheW91dDogbGF5b3V0IH0pO1xuICAgICAgfTtcblxuICAgICAgdmFyIG9uUmVhZHkgPSBmdW5jdGlvbigpe1xuICAgICAgICAvLyB0cmlnZ2VyIGxheW91dHJlYWR5IHdoZW4gZWFjaCBub2RlIGhhcyBoYWQgaXRzIHBvc2l0aW9uIHNldCBhdCBsZWFzdCBvbmNlXG4gICAgICAgIGxheW91dC5vbmUoJ2xheW91dHJlYWR5Jywgb3B0aW9ucy5yZWFkeSk7XG4gICAgICAgIGxheW91dC50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHJlYWR5JywgbGF5b3V0OiBsYXlvdXQgfSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgdGlja3NQZXJGcmFtZSA9IG9wdGlvbnMucmVmcmVzaDtcbiAgICAgIHZhciB0aWNrU2tpcCA9IDE7IC8vIGZyYW1lcyB1bnRpbCBhIHRpY2s7IHVzZWQgdG8gc2xvdyBkb3duIHNpbSBmb3IgZGVidWdnaW5nXG5cbiAgICAgIGlmKCBvcHRpb25zLnJlZnJlc2ggPCAwICl7XG4gICAgICAgIHRpY2tTa2lwID0gTWF0aC5hYnMoIG9wdGlvbnMucmVmcmVzaCApO1xuICAgICAgICB0aWNrc1BlckZyYW1lID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpY2tzUGVyRnJhbWUgPSBNYXRoLm1heCggMSwgdGlja3NQZXJGcmFtZSApOyAvLyBhdCBsZWFzdCAxXG4gICAgICB9XG5cbiAgICAgIHZhciBhZGFwdG9yID0gbGF5b3V0LmFkYXB0b3IgPSBjb2xhLmFkYXB0b3Ioe1xuICAgICAgICB0cmlnZ2VyOiBmdW5jdGlvbiggZSApeyAvLyBvbiBzaW0gZXZlbnQgICAgICBcbiAgICAgICAgICB2YXIgVElDSyA9IGNvbGEuRXZlbnRUeXBlID8gY29sYS5FdmVudFR5cGUudGljayA6IG51bGw7XG4gICAgICAgICAgdmFyIEVORCA9IGNvbGEuRXZlbnRUeXBlID8gY29sYS5FdmVudFR5cGUuZW5kIDogbnVsbDtcbiAgICAgICAgICBcbiAgICAgICAgICBzd2l0Y2goIGUudHlwZSApe1xuICAgICAgICAgICAgY2FzZSAndGljayc6XG4gICAgICAgICAgICBjYXNlIFRJQ0s6XG4gICAgICAgICAgICAgIGlmKCBvcHRpb25zLmFuaW1hdGUgKXtcbiAgICAgICAgICAgICAgICB1cGRhdGVOb2RlUG9zaXRpb25zKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICBjYXNlIEVORDpcbiAgICAgICAgICAgICAgdXBkYXRlTm9kZVBvc2l0aW9ucygpO1xuICAgICAgICAgICAgICBpZiggIW9wdGlvbnMuaW5maW5pdGUgKXsgb25Eb25lKCk7IH0gICAgICAgICAgIFxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAga2ljazogZnVuY3Rpb24oKXsgLy8ga2ljayBvZmYgdGhlIHNpbXVsYXRpb25cbiAgICAgICAgICB2YXIgc2tpcCA9IDA7XG5cbiAgICAgICAgICB2YXIgaW5mdGljayA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBpZiggbGF5b3V0Lm1hbnVhbGx5U3RvcHBlZCApe1xuICAgICAgICAgICAgICBvbkRvbmUoKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgcmV0ID0gYWRhcHRvci50aWNrKCk7XG5cbiAgICAgICAgICAgIGlmKCByZXQgJiYgb3B0aW9ucy5pbmZpbml0ZSApeyAvLyByZXN1bWUgbGF5b3V0IGlmIGRvbmVcbiAgICAgICAgICAgICAgYWRhcHRvci5yZXN1bWUoKTsgLy8gcmVzdW1lID0+IG5ldyBraWNrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiByZXQ7IC8vIGFsbG93IHJlZ3VsYXIgZmluaXNoIGIvYyBvZiBuZXcga2lja1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB2YXIgbXVsdGl0aWNrID0gZnVuY3Rpb24oKXsgLy8gbXVsdGlwbGUgdGlja3MgaW4gYSByb3dcbiAgICAgICAgICAgIHZhciByZXQ7XG5cbiAgICAgICAgICAgIC8vIHNraXAgdGlja3MgdG8gc2xvdyBkb3duIGxheW91dCBmb3IgZGVidWdnaW5nXG4gICAgICAgICAgICAvLyB2YXIgdGhpc1NraXAgPSBza2lwO1xuICAgICAgICAgICAgLy8gc2tpcCA9IChza2lwICsgMSkgJSB0aWNrU2tpcDtcbiAgICAgICAgICAgIC8vIGlmKCB0aGlzU2tpcCAhPT0gMCApe1xuICAgICAgICAgICAgLy8gICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGlja3NQZXJGcmFtZSAmJiAhcmV0OyBpKysgKXtcbiAgICAgICAgICAgICAgcmV0ID0gcmV0IHx8IGluZnRpY2soKTsgLy8gcGljayB1cCB0cnVlIHJldCB2YWxzID0+IHNpbSBkb25lXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmKCBvcHRpb25zLmFuaW1hdGUgKXtcbiAgICAgICAgICAgIHZhciBmcmFtZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIGlmKCBtdWx0aXRpY2soKSApeyByZXR1cm47IH1cblxuICAgICAgICAgICAgICAkJC51dGlsLnJlcXVlc3RBbmltYXRpb25GcmFtZSggZnJhbWUgKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICQkLnV0aWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBmcmFtZSApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSggIWluZnRpY2soKSApe31cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb246IGZ1bmN0aW9uKCB0eXBlLCBsaXN0ZW5lciApe30sIC8vIGR1bW15OyBub3QgbmVlZGVkXG5cbiAgICAgICAgZHJhZzogZnVuY3Rpb24oKXt9IC8vIG5vdCBuZWVkZWQgZm9yIG91ciBjYXNlXG4gICAgICB9KTtcbiAgICAgIGxheW91dC5hZGFwdG9yID0gYWRhcHRvcjtcblxuICAgICAgLy8gaWYgc2V0IG5vIGdyYWJiaW5nIGR1cmluZyBsYXlvdXRcbiAgICAgIHZhciBncmFiYmFibGVOb2RlcyA9IG5vZGVzLmZpbHRlcignOmdyYWJiYWJsZScpO1xuICAgICAgaWYoIG9wdGlvbnMudW5ncmFiaWZ5V2hpbGVTaW11bGF0aW5nICl7XG4gICAgICAgIGdyYWJiYWJsZU5vZGVzLnVuZ3JhYmlmeSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBoYW5kbGUgbm9kZSBkcmFnZ2luZ1xuICAgICAgdmFyIGdyYWJIYW5kbGVyO1xuICAgICAgbm9kZXMub24oJ2dyYWIgZnJlZSBwb3NpdGlvbicsIGdyYWJIYW5kbGVyID0gZnVuY3Rpb24oZSl7XG4gICAgICAgIHZhciBub2RlID0gdGhpcztcbiAgICAgICAgdmFyIHNjckNvbGEgPSBub2RlLl9wcml2YXRlLnNjcmF0Y2guY29sYTtcbiAgICAgICAgdmFyIHBvcyA9IG5vZGUuX3ByaXZhdGUucG9zaXRpb247XG5cbiAgICAgICAgaWYoIG5vZGUuZ3JhYmJlZCgpICl7XG4gICAgICAgICAgc2NyQ29sYS54ID0gcG9zLnggLSBiYi54MTtcbiAgICAgICAgICBzY3JDb2xhLnkgPSBwb3MueSAtIGJiLnkxO1xuXG4gICAgICAgICAgYWRhcHRvci5kcmFnc3RhcnQoIHNjckNvbGEgKTtcbiAgICAgICAgfSBlbHNlIGlmKCAkJC5pcy5udW1iZXIoc2NyQ29sYS54KSAmJiAkJC5pcy5udW1iZXIoc2NyQ29sYS55KSApe1xuICAgICAgICAgIHBvcy54ID0gc2NyQ29sYS54ICsgYmIueDE7XG4gICAgICAgICAgcG9zLnkgPSBzY3JDb2xhLnkgKyBiYi55MTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCggZS50eXBlICl7XG4gICAgICAgICAgY2FzZSAnZ3JhYic6XG4gICAgICAgICAgICBhZGFwdG9yLmRyYWdzdGFydCggc2NyQ29sYSApO1xuICAgICAgICAgICAgYWRhcHRvci5yZXN1bWUoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2ZyZWUnOlxuICAgICAgICAgICAgYWRhcHRvci5kcmFnZW5kKCBzY3JDb2xhICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgbG9ja0hhbmRsZXI7XG4gICAgICBub2Rlcy5vbignbG9jayB1bmxvY2snLCBsb2NrSGFuZGxlciA9IGZ1bmN0aW9uKGUpe1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXM7XG4gICAgICAgIHZhciBzY3JDb2xhID0gbm9kZS5fcHJpdmF0ZS5zY3JhdGNoLmNvbGE7XG4gICAgICBcbiAgICAgICAgaWYoIG5vZGUubG9ja2VkKCkgKXtcbiAgICAgICAgICBhZGFwdG9yLmRyYWdzdGFydCggc2NyQ29sYSApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkYXB0b3IuZHJhZ2VuZCggc2NyQ29sYSApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdmFyIG5vbnBhcmVudE5vZGVzID0gbm9kZXMuc3RkRmlsdGVyKGZ1bmN0aW9uKCBub2RlICl7XG4gICAgICAgIHJldHVybiAhbm9kZS5pc1BhcmVudCgpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGFkZCBub2RlcyB0byBjb2xhXG4gICAgICBhZGFwdG9yLm5vZGVzKCBub25wYXJlbnROb2Rlcy5tYXAoZnVuY3Rpb24oIG5vZGUsIGkgKXtcbiAgICAgICAgdmFyIHBhZGRpbmcgPSBnZXRPcHRWYWwoIG9wdGlvbnMubm9kZVNwYWNpbmcsIG5vZGUgKTtcbiAgICAgICAgdmFyIHBvcyA9IG5vZGUucG9zaXRpb24oKTtcbiAgICAgICAgdmFyIG5iYiA9IG5vZGUuYm91bmRpbmdCb3goKTtcblxuICAgICAgICB2YXIgc3RydWN0ID0gbm9kZS5fcHJpdmF0ZS5zY3JhdGNoLmNvbGEgPSB7XG4gICAgICAgICAgeDogb3B0aW9ucy5yYW5kb21pemUgfHwgcG9zLnggPT09IHVuZGVmaW5lZCA/IE1hdGgucm91bmQoIE1hdGgucmFuZG9tKCkgKiBiYi53ICkgOiBwb3MueCxcbiAgICAgICAgICB5OiBvcHRpb25zLnJhbmRvbWl6ZSB8fCBwb3MueSA9PT0gdW5kZWZpbmVkID8gTWF0aC5yb3VuZCggTWF0aC5yYW5kb20oKSAqIGJiLmggKSA6IHBvcy55LFxuICAgICAgICAgIHdpZHRoOiBuYmIudyArIDIqcGFkZGluZyxcbiAgICAgICAgICBoZWlnaHQ6IG5iYi5oICsgMipwYWRkaW5nLFxuICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHN0cnVjdDtcbiAgICAgIH0pICk7XG5cbiAgICAgIGlmKCBvcHRpb25zLmFsaWdubWVudCApeyAvLyB0aGVuIHNldCBhbGlnbm1lbnQgY29uc3RyYWludHNcblxuICAgICAgICB2YXIgb2Zmc2V0c1ggPSBbXTtcbiAgICAgICAgdmFyIG9mZnNldHNZID0gW107XG5cbiAgICAgICAgbm9ucGFyZW50Tm9kZXMuZm9yRWFjaChmdW5jdGlvbiggbm9kZSApe1xuICAgICAgICAgIHZhciBhbGlnbiA9IGdldE9wdFZhbCggb3B0aW9ucy5hbGlnbm1lbnQsIG5vZGUgKTtcbiAgICAgICAgICB2YXIgc2NyQ29sYSA9IG5vZGUuX3ByaXZhdGUuc2NyYXRjaC5jb2xhO1xuICAgICAgICAgIHZhciBpbmRleCA9IHNjckNvbGEuaW5kZXg7XG5cbiAgICAgICAgICBpZiggIWFsaWduICl7IHJldHVybjsgfVxuXG4gICAgICAgICAgaWYoIGFsaWduLnggIT0gbnVsbCApe1xuICAgICAgICAgICAgb2Zmc2V0c1gucHVzaCh7XG4gICAgICAgICAgICAgIG5vZGU6IGluZGV4LFxuICAgICAgICAgICAgICBvZmZzZXQ6IGFsaWduLnhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCBhbGlnbi55ICE9IG51bGwgKXtcbiAgICAgICAgICAgIG9mZnNldHNZLnB1c2goe1xuICAgICAgICAgICAgICBub2RlOiBpbmRleCxcbiAgICAgICAgICAgICAgb2Zmc2V0OiBhbGlnbi55XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGFkZCBhbGlnbm1lbnQgY29uc3RyYWludHMgb24gbm9kZXNcbiAgICAgICAgdmFyIGNvbnN0cmFpbnRzID0gW107XG5cbiAgICAgICAgaWYoIG9mZnNldHNYLmxlbmd0aCA+IDAgKXtcbiAgICAgICAgICBjb25zdHJhaW50cy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdhbGlnbm1lbnQnLFxuICAgICAgICAgICAgYXhpczogJ3gnLFxuICAgICAgICAgICAgb2Zmc2V0czogb2Zmc2V0c1hcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBvZmZzZXRzWS5sZW5ndGggPiAwICl7XG4gICAgICAgICAgY29uc3RyYWludHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnYWxpZ25tZW50JyxcbiAgICAgICAgICAgIGF4aXM6ICd5JyxcbiAgICAgICAgICAgIG9mZnNldHM6IG9mZnNldHNZXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGFkYXB0b3IuY29uc3RyYWludHMoIGNvbnN0cmFpbnRzICk7XG5cbiAgICAgIH1cblxuICAgICAgLy8gYWRkIGNvbXBvdW5kIG5vZGVzIHRvIGNvbGFcbiAgICAgIGFkYXB0b3IuZ3JvdXBzKCBub2Rlcy5zdGRGaWx0ZXIoZnVuY3Rpb24oIG5vZGUgKXtcbiAgICAgICAgcmV0dXJuIG5vZGUuaXNQYXJlbnQoKTtcbiAgICAgIH0pLm1hcChmdW5jdGlvbiggbm9kZSwgaSApeyAvLyBhZGQgYmFzaWMgZ3JvdXAgaW5jbCBsZWFmIG5vZGVzXG4gICAgICAgIHZhciBzdHlsZSA9IG5vZGUuX3ByaXZhdGUuc3R5bGU7XG4gICAgICAgIFxuICAgICAgICB2YXIgb3B0UGFkZGluZyA9IGdldE9wdFZhbCggb3B0aW9ucy5ub2RlU3BhY2luZywgbm9kZSApO1xuICAgICAgICBcbiAgICAgICAgdmFyIHBsZWZ0ID0gc3R5bGVbJ3BhZGRpbmctbGVmdCddLnB4VmFsdWUgKyBvcHRQYWRkaW5nO1xuICAgICAgICB2YXIgcHJpZ2h0ID0gc3R5bGVbJ3BhZGRpbmctcmlnaHQnXS5weFZhbHVlICsgb3B0UGFkZGluZztcbiAgICAgICAgdmFyIHB0b3AgPSBzdHlsZVsncGFkZGluZy10b3AnXS5weFZhbHVlICsgb3B0UGFkZGluZztcbiAgICAgICAgdmFyIHBib3R0b20gPSBzdHlsZVsncGFkZGluZy1ib3R0b20nXS5weFZhbHVlICsgb3B0UGFkZGluZztcbiAgICAgICAgXG4gICAgICAgIG5vZGUuX3ByaXZhdGUuc2NyYXRjaC5jb2xhID0ge1xuICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgIFxuICAgICAgICAgIHBhZGRpbmc6IE1hdGgubWF4KCBwbGVmdCwgcHJpZ2h0LCBwdG9wLCBwYm90dG9tICksXG5cbiAgICAgICAgICBsZWF2ZXM6IG5vZGUuZGVzY2VuZGFudHMoKS5zdGRGaWx0ZXIoZnVuY3Rpb24oIGNoaWxkICl7XG4gICAgICAgICAgICByZXR1cm4gIWNoaWxkLmlzUGFyZW50KCk7XG4gICAgICAgICAgfSkubWFwKGZ1bmN0aW9uKCBjaGlsZCApe1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkWzBdLl9wcml2YXRlLnNjcmF0Y2guY29sYS5pbmRleDtcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uKCBub2RlICl7IC8vIGFkZCBzdWJncm91cHNcbiAgICAgICAgbm9kZS5fcHJpdmF0ZS5zY3JhdGNoLmNvbGEuZ3JvdXBzID0gbm9kZS5kZXNjZW5kYW50cygpLnN0ZEZpbHRlcihmdW5jdGlvbiggY2hpbGQgKXtcbiAgICAgICAgICByZXR1cm4gY2hpbGQuaXNQYXJlbnQoKTtcbiAgICAgICAgfSkubWFwKGZ1bmN0aW9uKCBjaGlsZCApe1xuICAgICAgICAgIHJldHVybiBjaGlsZC5fcHJpdmF0ZS5zY3JhdGNoLmNvbGEuaW5kZXg7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBub2RlLl9wcml2YXRlLnNjcmF0Y2guY29sYTtcbiAgICAgIH0pICk7XG5cbiAgICAgIC8vIGdldCB0aGUgZWRnZSBsZW5ndGggc2V0dGluZyBtZWNoYW5pc21cbiAgICAgIHZhciBsZW5ndGg7XG4gICAgICB2YXIgbGVuZ3RoRm5OYW1lO1xuICAgICAgaWYoIG9wdGlvbnMuZWRnZUxlbmd0aCAhPSBudWxsICl7XG4gICAgICAgIGxlbmd0aCA9IG9wdGlvbnMuZWRnZUxlbmd0aDtcbiAgICAgICAgbGVuZ3RoRm5OYW1lID0gJ2xpbmtEaXN0YW5jZSc7XG4gICAgICB9IGVsc2UgaWYoIG9wdGlvbnMuZWRnZVN5bURpZmZMZW5ndGggIT0gbnVsbCApe1xuICAgICAgICBsZW5ndGggPSBvcHRpb25zLmVkZ2VTeW1EaWZmTGVuZ3RoO1xuICAgICAgICBsZW5ndGhGbk5hbWUgPSAnc3ltbWV0cmljRGlmZkxpbmtMZW5ndGhzJztcbiAgICAgIH0gZWxzZSBpZiggb3B0aW9ucy5lZGdlSmFjY2FyZExlbmd0aCAhPSBudWxsICl7XG4gICAgICAgIGxlbmd0aCA9IG9wdGlvbnMuZWRnZUphY2NhcmRMZW5ndGg7XG4gICAgICAgIGxlbmd0aEZuTmFtZSA9ICdqYWNjYXJkTGlua0xlbmd0aHMnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVuZ3RoID0gMTAwO1xuICAgICAgICBsZW5ndGhGbk5hbWUgPSAnbGlua0Rpc3RhbmNlJztcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbmd0aEdldHRlciA9IGZ1bmN0aW9uKCBsaW5rICl7XG4gICAgICAgIHJldHVybiBsaW5rLmNhbGNMZW5ndGg7XG4gICAgICB9O1xuXG4gICAgICAvLyBhZGQgdGhlIGVkZ2VzIHRvIGNvbGFcbiAgICAgIGFkYXB0b3IubGlua3MoIGVkZ2VzLnN0ZEZpbHRlcihmdW5jdGlvbiggZWRnZSApe1xuICAgICAgICByZXR1cm4gIWVkZ2Uuc291cmNlKCkuaXNQYXJlbnQoKSAmJiAhZWRnZS50YXJnZXQoKS5pc1BhcmVudCgpO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uKCBlZGdlLCBpICl7XG4gICAgICAgIHZhciBjID0gZWRnZS5fcHJpdmF0ZS5zY3JhdGNoLmNvbGEgPSB7XG4gICAgICAgICAgc291cmNlOiBlZGdlLnNvdXJjZSgpWzBdLl9wcml2YXRlLnNjcmF0Y2guY29sYS5pbmRleCxcbiAgICAgICAgICB0YXJnZXQ6IGVkZ2UudGFyZ2V0KClbMF0uX3ByaXZhdGUuc2NyYXRjaC5jb2xhLmluZGV4XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYoIGxlbmd0aCAhPSBudWxsICl7XG4gICAgICAgICAgYy5jYWxjTGVuZ3RoID0gZ2V0T3B0VmFsKCBsZW5ndGgsIGVkZ2UgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjO1xuICAgICAgfSkgKTtcblxuICAgICAgYWRhcHRvci5zaXplKFsgYmIudywgYmIuaCBdKTtcblxuICAgICAgaWYoIGxlbmd0aCAhPSBudWxsICl7XG4gICAgICAgIGFkYXB0b3JbIGxlbmd0aEZuTmFtZSBdKCBsZW5ndGhHZXR0ZXIgKTtcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IHRoZSBmbG93IG9mIGNvbGFcbiAgICAgIGlmKCBvcHRpb25zLmZsb3cgKXtcbiAgICAgICAgdmFyIGZsb3c7XG4gICAgICAgIHZhciBkZWZBeGlzID0gJ3knO1xuICAgICAgICB2YXIgZGVmTWluU2VwID0gNTA7XG5cbiAgICAgICAgaWYoICQkLmlzLnN0cmluZyhvcHRpb25zLmZsb3cpICl7XG4gICAgICAgICAgZmxvdyA9IHtcbiAgICAgICAgICAgIGF4aXM6IG9wdGlvbnMuZmxvdyxcbiAgICAgICAgICAgIG1pblNlcGFyYXRpb246IGRlZk1pblNlcFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiggJCQuaXMubnVtYmVyKG9wdGlvbnMuZmxvdykgKXtcbiAgICAgICAgICBmbG93ID0ge1xuICAgICAgICAgICAgYXhpczogZGVmQXhpcyxcbiAgICAgICAgICAgIG1pblNlcGFyYXRpb246IG9wdGlvbnMuZmxvd1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiggJCQuaXMucGxhaW5PYmplY3Qob3B0aW9ucy5mbG93KSApe1xuICAgICAgICAgIGZsb3cgPSBvcHRpb25zLmZsb3c7XG5cbiAgICAgICAgICBmbG93LmF4aXMgPSBmbG93LmF4aXMgfHwgZGVmQXhpcztcbiAgICAgICAgICBmbG93Lm1pblNlcGFyYXRpb24gPSBmbG93Lm1pblNlcGFyYXRpb24gIT0gbnVsbCA/IGZsb3cubWluU2VwYXJhdGlvbiA6IGRlZk1pblNlcDtcbiAgICAgICAgfSBlbHNlIHsgLy8gZS5nLiBvcHRpb25zLmZsb3c6IHRydWVcbiAgICAgICAgICBmbG93ID0ge1xuICAgICAgICAgICAgYXhpczogZGVmQXhpcyxcbiAgICAgICAgICAgIG1pblNlcGFyYXRpb246IGRlZk1pblNlcFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBhZGFwdG9yLmZsb3dMYXlvdXQoIGZsb3cuYXhpcyAsIGZsb3cubWluU2VwYXJhdGlvbiApO1xuICAgICAgfVxuXG4gICAgICBsYXlvdXQudHJpZ2dlcih7IHR5cGU6ICdsYXlvdXRzdGFydCcsIGxheW91dDogbGF5b3V0IH0pO1xuXG4gICAgICBhZGFwdG9yXG4gICAgICAgIC5hdm9pZE92ZXJsYXBzKCBvcHRpb25zLmF2b2lkT3ZlcmxhcCApXG4gICAgICAgIC5oYW5kbGVEaXNjb25uZWN0ZWQoIG9wdGlvbnMuaGFuZGxlRGlzY29ubmVjdGVkIClcbiAgICAgICAgLnN0YXJ0KCBvcHRpb25zLnVuY29uc3RySXRlciwgb3B0aW9ucy51c2VyQ29uc3RJdGVyLCBvcHRpb25zLmFsbENvbnN0SXRlcilcbiAgICAgIDtcblxuICAgICAgaWYoICFvcHRpb25zLmluZmluaXRlICl7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICBpZiggIWxheW91dC5tYW51YWxseVN0b3BwZWQgKXtcbiAgICAgICAgICAgIGFkYXB0b3Iuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgb3B0aW9ucy5tYXhTaW11bGF0aW9uVGltZSk7XG4gICAgICB9XG5cbiAgICB9KTsgLy8gcmVxdWlyZVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG5cbiAgLy8gY2FsbGVkIG9uIGNvbnRpbnVvdXMgbGF5b3V0cyB0byBzdG9wIHRoZW0gYmVmb3JlIHRoZXkgZmluaXNoXG4gIENvbGFMYXlvdXQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpe1xuICAgIGlmKCB0aGlzLmFkYXB0b3IgKXtcbiAgICAgIHRoaXMubWFudWFsbHlTdG9wcGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuYWRhcHRvci5zdG9wKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG5cbiAgLy8gcmVnaXN0ZXIgdGhlIGxheW91dFxuICAkJCgnbGF5b3V0JywgJ2NvbGEnLCBDb2xhTGF5b3V0KTtcblxufSkoY3l0b3NjYXBlKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICBmaXQ6IHRydWUsIC8vIHdoZXRoZXIgdG8gZml0IHRoZSB2aWV3cG9ydCB0byB0aGUgZ3JhcGhcbiAgICBwYWRkaW5nOiAzMCwgLy8gdGhlIHBhZGRpbmcgb24gZml0XG4gICAgc3RhcnRBbmdsZTogMy8yICogTWF0aC5QSSwgLy8gdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBub2RlXG4gICAgY291bnRlcmNsb2Nrd2lzZTogZmFsc2UsIC8vIHdoZXRoZXIgdGhlIGxheW91dCBzaG91bGQgZ28gY291bnRlcmNsb2Nrd2lzZS9hbnRpY2xvY2t3aXNlICh0cnVlKSBvciBjbG9ja3dpc2UgKGZhbHNlKVxuICAgIG1pbk5vZGVTcGFjaW5nOiAxMCwgLy8gbWluIHNwYWNpbmcgYmV0d2VlbiBvdXRzaWRlIG9mIG5vZGVzICh1c2VkIGZvciByYWRpdXMgYWRqdXN0bWVudClcbiAgICBib3VuZGluZ0JveDogdW5kZWZpbmVkLCAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgICBhdm9pZE92ZXJsYXA6IHRydWUsIC8vIHByZXZlbnRzIG5vZGUgb3ZlcmxhcCwgbWF5IG92ZXJmbG93IGJvdW5kaW5nQm94IGlmIG5vdCBlbm91Z2ggc3BhY2VcbiAgICBoZWlnaHQ6IHVuZGVmaW5lZCwgLy8gaGVpZ2h0IG9mIGxheW91dCBhcmVhIChvdmVycmlkZXMgY29udGFpbmVyIGhlaWdodClcbiAgICB3aWR0aDogdW5kZWZpbmVkLCAvLyB3aWR0aCBvZiBsYXlvdXQgYXJlYSAob3ZlcnJpZGVzIGNvbnRhaW5lciB3aWR0aClcbiAgICBjb25jZW50cmljOiBmdW5jdGlvbihub2RlKXsgLy8gcmV0dXJucyBudW1lcmljIHZhbHVlIGZvciBlYWNoIG5vZGUsIHBsYWNpbmcgaGlnaGVyIG5vZGVzIGluIGxldmVscyB0b3dhcmRzIHRoZSBjZW50cmVcbiAgICAgIHJldHVybiBub2RlLmRlZ3JlZSgpO1xuICAgIH0sXG4gICAgbGV2ZWxXaWR0aDogZnVuY3Rpb24obm9kZXMpeyAvLyB0aGUgdmFyaWF0aW9uIG9mIGNvbmNlbnRyaWMgdmFsdWVzIGluIGVhY2ggbGV2ZWxcbiAgICAgIHJldHVybiBub2Rlcy5tYXhEZWdyZWUoKSAvIDQ7XG4gICAgfSxcbiAgICBhbmltYXRlOiBmYWxzZSwgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsIC8vIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcyBpZiBlbmFibGVkXG4gICAgcmVhZHk6IHVuZGVmaW5lZCwgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgICBzdG9wOiB1bmRlZmluZWQgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxuICB9O1xuICBcbiAgZnVuY3Rpb24gQ29uY2VudHJpY0xheW91dCggb3B0aW9ucyApe1xuICAgIHRoaXMub3B0aW9ucyA9ICQkLnV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG4gIH1cbiAgXG4gIENvbmNlbnRyaWNMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHBhcmFtcyA9IHRoaXMub3B0aW9ucztcbiAgICB2YXIgb3B0aW9ucyA9IHBhcmFtcztcbiAgICBcbiAgICB2YXIgY3kgPSBwYXJhbXMuY3k7XG4gICAgXG4gICAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gICAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpLm5vdCgnOnBhcmVudCcpO1xuICAgIFxuICAgIHZhciBiYiA9ICQkLnV0aWwubWFrZUJvdW5kaW5nQm94KCBvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICAgIHgxOiAwLCB5MTogMCwgdzogY3kud2lkdGgoKSwgaDogY3kuaGVpZ2h0KClcbiAgICB9ICk7XG5cbiAgICB2YXIgY2VudGVyID0ge1xuICAgICAgeDogYmIueDEgKyBiYi53LzIsXG4gICAgICB5OiBiYi55MSArIGJiLmgvMlxuICAgIH07XG4gICAgXG4gICAgdmFyIG5vZGVWYWx1ZXMgPSBbXTsgLy8geyBub2RlLCB2YWx1ZSB9XG4gICAgdmFyIHRoZXRhID0gb3B0aW9ucy5zdGFydEFuZ2xlO1xuICAgIHZhciBtYXhOb2RlU2l6ZSA9IDA7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgXG4gICAgICAvLyBjYWxjdWxhdGUgdGhlIG5vZGUgdmFsdWVcbiAgICAgIHZhbHVlID0gb3B0aW9ucy5jb25jZW50cmljLmFwcGx5KG5vZGUsIFsgbm9kZSBdKTtcbiAgICAgIG5vZGVWYWx1ZXMucHVzaCh7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgbm9kZTogbm9kZVxuICAgICAgfSk7XG5cbiAgICAgIC8vIGZvciBzdHlsZSBtYXBwaW5nXG4gICAgICBub2RlLl9wcml2YXRlLnNjcmF0Y2guY29uY2VudHJpYyA9IHZhbHVlO1xuICAgIH1cblxuICAgIC8vIGluIGNhc2Ugd2UgdXNlZCB0aGUgYGNvbmNlbnRyaWNgIGluIHN0eWxlXG4gICAgbm9kZXMudXBkYXRlU3R5bGUoKTtcblxuICAgIC8vIGNhbGN1bGF0ZSBtYXggc2l6ZSBub3cgYmFzZWQgb24gcG90ZW50aWFsbHkgdXBkYXRlZCBtYXBwZXJzXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcblxuICAgICAgbWF4Tm9kZVNpemUgPSBNYXRoLm1heCggbWF4Tm9kZVNpemUsIG5vZGUub3V0ZXJXaWR0aCgpLCBub2RlLm91dGVySGVpZ2h0KCkgKTtcbiAgICB9XG5cbiAgICAvLyBzb3J0IG5vZGUgdmFsdWVzIGluIGRlc2NyZWFzaW5nIG9yZGVyXG4gICAgbm9kZVZhbHVlcy5zb3J0KGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgcmV0dXJuIGIudmFsdWUgLSBhLnZhbHVlO1xuICAgIH0pO1xuXG4gICAgdmFyIGxldmVsV2lkdGggPSBvcHRpb25zLmxldmVsV2lkdGgoIG5vZGVzICk7XG5cbiAgICAvLyBwdXQgdGhlIHZhbHVlcyBpbnRvIGxldmVsc1xuICAgIHZhciBsZXZlbHMgPSBbIFtdIF07XG4gICAgdmFyIGN1cnJlbnRMZXZlbCA9IGxldmVsc1swXTtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVWYWx1ZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciB2YWwgPSBub2RlVmFsdWVzW2ldO1xuXG4gICAgICBpZiggY3VycmVudExldmVsLmxlbmd0aCA+IDAgKXtcbiAgICAgICAgdmFyIGRpZmYgPSBNYXRoLmFicyggY3VycmVudExldmVsWzBdLnZhbHVlIC0gdmFsLnZhbHVlICk7XG5cbiAgICAgICAgaWYoIGRpZmYgPj0gbGV2ZWxXaWR0aCApe1xuICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IFtdO1xuICAgICAgICAgIGxldmVscy5wdXNoKCBjdXJyZW50TGV2ZWwgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjdXJyZW50TGV2ZWwucHVzaCggdmFsICk7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIHBvc2l0aW9ucyBmcm9tIGxldmVsc1xuXG4gICAgdmFyIHBvcyA9IHt9OyAvLyBpZCA9PiBwb3NpdGlvblxuICAgIHZhciByID0gMDtcbiAgICB2YXIgbWluRGlzdCA9IG1heE5vZGVTaXplICsgb3B0aW9ucy5taW5Ob2RlU3BhY2luZzsgLy8gbWluIGRpc3QgYmV0d2VlbiBub2Rlc1xuXG4gICAgaWYoICFvcHRpb25zLmF2b2lkT3ZlcmxhcCApeyAvLyB0aGVuIHN0cmljdGx5IGNvbnN0cmFpbiB0byBiYlxuICAgICAgdmFyIGZpcnN0THZsSGFzTXVsdGkgPSBsZXZlbHMubGVuZ3RoID4gMCAmJiBsZXZlbHNbMF0ubGVuZ3RoID4gMTtcbiAgICAgIHZhciBtYXhSID0gKCBNYXRoLm1pbihiYi53LCBiYi5oKSAvIDIgLSBtaW5EaXN0ICk7XG4gICAgICB2YXIgclN0ZXAgPSBtYXhSIC8gKCBsZXZlbHMubGVuZ3RoICsgZmlyc3RMdmxIYXNNdWx0aSA/IDEgOiAwICk7XG5cbiAgICAgIG1pbkRpc3QgPSBNYXRoLm1pbiggbWluRGlzdCwgclN0ZXAgKTtcbiAgICB9XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGxldmVsID0gbGV2ZWxzW2ldO1xuICAgICAgdmFyIGRUaGV0YSA9IDIgKiBNYXRoLlBJIC8gbGV2ZWwubGVuZ3RoO1xuXG4gICAgICAvLyBjYWxjdWxhdGUgdGhlIHJhZGl1c1xuICAgICAgaWYoIGxldmVsLmxlbmd0aCA+IDEgJiYgb3B0aW9ucy5hdm9pZE92ZXJsYXAgKXsgLy8gYnV0IG9ubHkgaWYgbW9yZSB0aGFuIG9uZSBub2RlIChjYW4ndCBvdmVybGFwKVxuICAgICAgICB2YXIgZGNvcyA9IE1hdGguY29zKGRUaGV0YSkgLSBNYXRoLmNvcygwKTtcbiAgICAgICAgdmFyIGRzaW4gPSBNYXRoLnNpbihkVGhldGEpIC0gTWF0aC5zaW4oMCk7XG4gICAgICAgIHZhciByTWluID0gTWF0aC5zcXJ0KCBtaW5EaXN0ICogbWluRGlzdCAvICggZGNvcypkY29zICsgZHNpbipkc2luICkgKTsgLy8gcy50LiBubyBub2RlcyBvdmVybGFwcGluZ1xuICAgICAgICByID0gTWF0aC5tYXgoIHJNaW4sIHIgKTtcbiAgICAgIH1cblxuICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBsZXZlbC5sZW5ndGg7IGorKyApe1xuICAgICAgICB2YXIgdmFsID0gbGV2ZWxbal07XG4gICAgICAgIHZhciB0aGV0YSA9IG9wdGlvbnMuc3RhcnRBbmdsZSArIChvcHRpb25zLmNvdW50ZXJjbG9ja3dpc2UgPyAtMSA6IDEpICogZFRoZXRhICogajtcblxuICAgICAgICB2YXIgcCA9IHtcbiAgICAgICAgICB4OiBjZW50ZXIueCArIHIgKiBNYXRoLmNvcyh0aGV0YSksXG4gICAgICAgICAgeTogY2VudGVyLnkgKyByICogTWF0aC5zaW4odGhldGEpXG4gICAgICAgIH07XG5cbiAgICAgICAgcG9zWyB2YWwubm9kZS5pZCgpIF0gPSBwO1xuICAgICAgfVxuXG4gICAgICByICs9IG1pbkRpc3Q7XG4gICAgICBcbiAgICB9IFxuXG4gICAgLy8gcG9zaXRpb24gdGhlIG5vZGVzXG4gICAgbm9kZXMubGF5b3V0UG9zaXRpb25zKHRoaXMsIG9wdGlvbnMsIGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgaWQgPSB0aGlzLmlkKCk7XG5cbiAgICAgIHJldHVybiBwb3NbaWRdO1xuICAgIH0pO1xuICBcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcbiAgXG4gICQkKCdsYXlvdXQnLCAnY29uY2VudHJpYycsIENvbmNlbnRyaWNMYXlvdXQpO1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuLypcbiAgVGhlIENvU0UgbGF5b3V0IHdhcyB3cml0dGVuIGJ5IEdlcmFyZG8gSHVjay5cblxuICBNb2RpZmljYXRpb25zIHRyYWNrZWQgb24gR2l0aHViLlxuKi9cblxuOyhmdW5jdGlvbigkJCkgeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIERFQlVHO1xuXG4gIC8qKlxuICAgKiBAYnJpZWYgOiAgZGVmYXVsdCBsYXlvdXQgb3B0aW9uc1xuICAgKi9cbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIC8vIENhbGxlZCBvbiBgbGF5b3V0cmVhZHlgXG4gICAgcmVhZHkgICAgICAgICAgICAgICA6IGZ1bmN0aW9uKCkge30sXG5cbiAgICAvLyBDYWxsZWQgb24gYGxheW91dHN0b3BgXG4gICAgc3RvcCAgICAgICAgICAgICAgICA6IGZ1bmN0aW9uKCkge30sXG5cbiAgICAvLyBXaGV0aGVyIHRvIGFuaW1hdGUgd2hpbGUgcnVubmluZyB0aGUgbGF5b3V0XG4gICAgYW5pbWF0ZSAgICAgICAgICAgICA6IHRydWUsXG5cbiAgICAvLyBOdW1iZXIgb2YgaXRlcmF0aW9ucyBiZXR3ZWVuIGNvbnNlY3V0aXZlIHNjcmVlbiBwb3NpdGlvbnMgdXBkYXRlICgwIC0+IG9ubHkgdXBkYXRlZCBvbiB0aGUgZW5kKVxuICAgIHJlZnJlc2ggICAgICAgICAgICAgOiA0LFxuICAgIFxuICAgIC8vIFdoZXRoZXIgdG8gZml0IHRoZSBuZXR3b3JrIHZpZXcgYWZ0ZXIgd2hlbiBkb25lXG4gICAgZml0ICAgICAgICAgICAgICAgICA6IHRydWUsIFxuXG4gICAgLy8gUGFkZGluZyBvbiBmaXRcbiAgICBwYWRkaW5nICAgICAgICAgICAgIDogMzAsIFxuXG4gICAgLy8gQ29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gICAgYm91bmRpbmdCb3ggICAgICAgICA6IHVuZGVmaW5lZCxcblxuICAgIC8vIFdoZXRoZXIgdG8gcmFuZG9taXplIG5vZGUgcG9zaXRpb25zIG9uIHRoZSBiZWdpbm5pbmdcbiAgICByYW5kb21pemUgICAgICAgICAgIDogdHJ1ZSxcbiAgICBcbiAgICAvLyBXaGV0aGVyIHRvIHVzZSB0aGUgSlMgY29uc29sZSB0byBwcmludCBkZWJ1ZyBtZXNzYWdlc1xuICAgIGRlYnVnICAgICAgICAgICAgICAgOiBmYWxzZSxcblxuICAgIC8vIE5vZGUgcmVwdWxzaW9uIChub24gb3ZlcmxhcHBpbmcpIG11bHRpcGxpZXJcbiAgICBub2RlUmVwdWxzaW9uICAgICAgIDogNDAwMDAwLFxuICAgIFxuICAgIC8vIE5vZGUgcmVwdWxzaW9uIChvdmVybGFwcGluZykgbXVsdGlwbGllclxuICAgIG5vZGVPdmVybGFwICAgICAgICAgOiAxMCxcbiAgICBcbiAgICAvLyBJZGVhbCBlZGdlIChub24gbmVzdGVkKSBsZW5ndGhcbiAgICBpZGVhbEVkZ2VMZW5ndGggICAgIDogMTAsXG4gICAgXG4gICAgLy8gRGl2aXNvciB0byBjb21wdXRlIGVkZ2UgZm9yY2VzXG4gICAgZWRnZUVsYXN0aWNpdHkgICAgICA6IDEwMCxcbiAgICBcbiAgICAvLyBOZXN0aW5nIGZhY3RvciAobXVsdGlwbGllcikgdG8gY29tcHV0ZSBpZGVhbCBlZGdlIGxlbmd0aCBmb3IgbmVzdGVkIGVkZ2VzXG4gICAgbmVzdGluZ0ZhY3RvciAgICAgICA6IDUsIFxuICAgIFxuICAgIC8vIEdyYXZpdHkgZm9yY2UgKGNvbnN0YW50KVxuICAgIGdyYXZpdHkgICAgICAgICAgICAgOiAyNTAsIFxuICAgIFxuICAgIC8vIE1heGltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcGVyZm9ybVxuICAgIG51bUl0ZXIgICAgICAgICAgICAgOiAxMDAsXG4gICAgXG4gICAgLy8gSW5pdGlhbCB0ZW1wZXJhdHVyZSAobWF4aW11bSBub2RlIGRpc3BsYWNlbWVudClcbiAgICBpbml0aWFsVGVtcCAgICAgICAgIDogMjAwLFxuICAgIFxuICAgIC8vIENvb2xpbmcgZmFjdG9yIChob3cgdGhlIHRlbXBlcmF0dXJlIGlzIHJlZHVjZWQgYmV0d2VlbiBjb25zZWN1dGl2ZSBpdGVyYXRpb25zXG4gICAgY29vbGluZ0ZhY3RvciAgICAgICA6IDAuOTUsIFxuICAgIFxuICAgIC8vIExvd2VyIHRlbXBlcmF0dXJlIHRocmVzaG9sZCAoYmVsb3cgdGhpcyBwb2ludCB0aGUgbGF5b3V0IHdpbGwgZW5kKVxuICAgIG1pblRlbXAgICAgICAgICAgICAgOiAxLjBcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAYnJpZWYgICAgICAgOiBjb25zdHJ1Y3RvclxuICAgKiBAYXJnIG9wdGlvbnMgOiBvYmplY3QgY29udGFpbmluZyBsYXlvdXQgb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gQ29zZUxheW91dChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gJCQudXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zKTsgXG4gIH1cblxuXG4gIC8qKlxuICAgKiBAYnJpZWYgOiBydW5zIHRoZSBsYXlvdXRcbiAgICovXG4gIENvc2VMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIHZhciBjeSAgICAgID0gb3B0aW9ucy5jeTtcbiAgICB2YXIgbGF5b3V0ICA9IHRoaXM7XG5cbiAgICBsYXlvdXQuc3RvcHBlZCA9IGZhbHNlO1xuXG4gICAgbGF5b3V0LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0c3RhcnQnLCBsYXlvdXQ6IGxheW91dCB9KTtcblxuICAgIC8vIFNldCBERUJVRyAtIEdsb2JhbCB2YXJpYWJsZVxuICAgIGlmICh0cnVlID09PSBvcHRpb25zLmRlYnVnKSB7XG4gICAgICBERUJVRyA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIERFQlVHID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gR2V0IHN0YXJ0IHRpbWVcbiAgICB2YXIgc3RhcnRUaW1lID0gbmV3IERhdGUoKTtcblxuICAgIC8vIEluaXRpYWxpemUgbGF5b3V0IGluZm9cbiAgICB2YXIgbGF5b3V0SW5mbyA9IGNyZWF0ZUxheW91dEluZm8oY3ksIGxheW91dCwgb3B0aW9ucyk7XG4gICAgXG4gICAgLy8gU2hvdyBMYXlvdXRJbmZvIGNvbnRlbnRzIGlmIGRlYnVnZ2luZ1xuICAgIGlmIChERUJVRykge1xuICAgICAgcHJpbnRMYXlvdXRJbmZvKGxheW91dEluZm8pO1xuICAgIH1cblxuICAgIC8vIElmIHJlcXVpcmVkLCByYW5kb21pemUgbm9kZSBwb3NpdGlvbnNcbiAgICBpZiAodHJ1ZSA9PT0gb3B0aW9ucy5yYW5kb21pemUpIHtcbiAgICAgIHJhbmRvbWl6ZVBvc2l0aW9ucyhsYXlvdXRJbmZvLCBjeSk7XG4gICAgfVxuXG4gICAgdXBkYXRlUG9zaXRpb25zKGxheW91dEluZm8sIGN5LCBvcHRpb25zKTtcblxuICAgIHZhciBtYWluTG9vcCA9IGZ1bmN0aW9uKGkpe1xuICAgICAgaWYoIGxheW91dC5zdG9wcGVkICl7XG4gICAgICAgIC8vIGxvZ0RlYnVnKFwiTGF5b3V0IG1hbnVhbGx5IHN0b3BwZWQuIFN0b3BwaW5nIGNvbXB1dGF0aW9uIGluIHN0ZXAgXCIgKyBpKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBEbyBvbmUgc3RlcCBpbiB0aGUgcGhpc2ljYWwgc2ltdWxhdGlvblxuICAgICAgc3RlcChsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucywgaSk7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSB0ZW1wZXJhdHVyZVxuICAgICAgbGF5b3V0SW5mby50ZW1wZXJhdHVyZSA9IGxheW91dEluZm8udGVtcGVyYXR1cmUgKiBvcHRpb25zLmNvb2xpbmdGYWN0b3I7XG4gICAgICAvLyBsb2dEZWJ1ZyhcIk5ldyB0ZW1wZXJhdHVyZTogXCIgKyBsYXlvdXRJbmZvLnRlbXBlcmF0dXJlKTtcblxuICAgICAgaWYgKGxheW91dEluZm8udGVtcGVyYXR1cmUgPCBvcHRpb25zLm1pblRlbXApIHtcbiAgICAgICAgLy8gbG9nRGVidWcoXCJUZW1wZXJhdHVyZSBkcm9wIGJlbG93IG1pbmltdW0gdGhyZXNob2xkLiBTdG9wcGluZyBjb21wdXRhdGlvbiBpbiBzdGVwIFwiICsgaSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIHZhciBkb25lID0gZnVuY3Rpb24oKXtcbiAgICAgIHJlZnJlc2hQb3NpdGlvbnMobGF5b3V0SW5mbywgY3ksIG9wdGlvbnMpO1xuXG4gICAgICAvLyBGaXQgdGhlIGdyYXBoIGlmIG5lY2Vzc2FyeVxuICAgICAgaWYgKHRydWUgPT09IG9wdGlvbnMuZml0KSB7XG4gICAgICAgIGN5LmZpdCggb3B0aW9ucy5wYWRkaW5nICk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEdldCBlbmQgdGltZVxuICAgICAgdmFyIGVuZFRpbWUgPSBuZXcgRGF0ZSgpO1xuXG4gICAgICBjb25zb2xlLmluZm8oJ0xheW91dCB0b29rICcgKyAoZW5kVGltZSAtIHN0YXJ0VGltZSkgKyAnIG1zJyk7XG5cbiAgICAgIC8vIExheW91dCBoYXMgZmluaXNoZWRcbiAgICAgIGxheW91dC5vbmUoJ2xheW91dHN0b3AnLCBvcHRpb25zLnN0b3ApO1xuICAgICAgbGF5b3V0LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0c3RvcCcsIGxheW91dDogbGF5b3V0IH0pO1xuICAgIH07XG5cbiAgICBpZiggb3B0aW9ucy5hbmltYXRlICl7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgZnJhbWUgPSBmdW5jdGlvbigpe1xuXG4gICAgICAgIHZhciBmID0gMDtcbiAgICAgICAgdmFyIGxvb3BSZXQ7XG4gICAgICAgIHdoaWxlKCBmIDwgb3B0aW9ucy5yZWZyZXNoICYmIGkgPCBvcHRpb25zLm51bUl0ZXIgKXtcbiAgICAgICAgICB2YXIgbG9vcFJldCA9IG1haW5Mb29wKGkpO1xuICAgICAgICAgIGlmKCBsb29wUmV0ID09PSBmYWxzZSApeyBicmVhazsgfVxuXG4gICAgICAgICAgZisrO1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZnJlc2hQb3NpdGlvbnMobGF5b3V0SW5mbywgY3ksIG9wdGlvbnMpO1xuICAgICAgICBpZiggb3B0aW9ucy5maXQgKXtcbiAgICAgICAgICBjeS5maXQoIG9wdGlvbnMucGFkZGluZyApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBsb29wUmV0ICE9PSBmYWxzZSAmJiBpICsgMSA8IG9wdGlvbnMubnVtSXRlciApIHtcbiAgICAgICAgICAkJC51dGlsLnJlcXVlc3RBbmltYXRpb25GcmFtZSggZnJhbWUgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgICQkLnV0aWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBmcmFtZSApO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnMubnVtSXRlcjsgaSsrKSB7XG4gICAgICAgIGlmKCBtYWluTG9vcChpKSA9PT0gZmFsc2UgKXsgYnJlYWs7IH1cbiAgICAgIH1cblxuICAgICAgZG9uZSgpO1xuICAgIH1cbiAgIFxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBicmllZiA6IGNhbGxlZCBvbiBjb250aW51b3VzIGxheW91dHMgdG8gc3RvcCB0aGVtIGJlZm9yZSB0aGV5IGZpbmlzaFxuICAgKi9cbiAgQ29zZUxheW91dC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5zdG9wcGVkID0gdHJ1ZTtcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBicmllZiAgICAgOiBDcmVhdGVzIGFuIG9iamVjdCB3aGljaCBpcyBjb250YWlucyBhbGwgdGhlIGRhdGFcbiAgICogICAgICAgICAgICAgIHVzZWQgaW4gdGhlIGxheW91dCBwcm9jZXNzXG4gICAqIEBhcmcgY3kgICAgOiBjeXRvc2NhcGUuanMgb2JqZWN0XG4gICAqIEByZXR1cm4gICAgOiBsYXlvdXRJbmZvIG9iamVjdCBpbml0aWFsaXplZFxuICAgKi9cbiAgdmFyIGNyZWF0ZUxheW91dEluZm8gPSBmdW5jdGlvbihjeSwgbGF5b3V0LCBvcHRpb25zKSB7XG4gICAgLy8gU2hvcnRjdXRcbiAgICB2YXIgZWRnZXMgPSBvcHRpb25zLmVsZXMuZWRnZXMoKTtcbiAgICB2YXIgbm9kZXMgPSBvcHRpb25zLmVsZXMubm9kZXMoKTtcblxuICAgIHZhciBsYXlvdXRJbmZvICAgPSB7XG4gICAgICBsYXlvdXQgICAgICAgOiBsYXlvdXQsXG4gICAgICBsYXlvdXROb2RlcyAgOiBbXSwgXG4gICAgICBpZFRvSW5kZXggICAgOiB7fSxcbiAgICAgIG5vZGVTaXplICAgICA6IG5vZGVzLnNpemUoKSxcbiAgICAgIGdyYXBoU2V0ICAgICA6IFtdLFxuICAgICAgaW5kZXhUb0dyYXBoIDogW10sIFxuICAgICAgbGF5b3V0RWRnZXMgIDogW10sXG4gICAgICBlZGdlU2l6ZSAgICAgOiBlZGdlcy5zaXplKCksXG4gICAgICB0ZW1wZXJhdHVyZSAgOiBvcHRpb25zLmluaXRpYWxUZW1wLFxuICAgICAgY2xpZW50V2lkdGggIDogY3kud2lkdGgoKSxcbiAgICAgIGNsaWVudEhlaWdodCA6IGN5LndpZHRoKCksXG4gICAgICBib3VuZGluZ0JveCAgOiAkJC51dGlsLm1ha2VCb3VuZGluZ0JveCggb3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgICAgICAgICAgICAgICAgICAgIHgxOiAwLCB5MTogMCwgdzogY3kud2lkdGgoKSwgaDogY3kuaGVpZ2h0KClcbiAgICAgICAgICAgICAgICAgICAgIH0gKVxuICAgIH07IFxuICAgIFxuICAgIC8vIEl0ZXJhdGUgb3ZlciBhbGwgbm9kZXMsIGNyZWF0aW5nIGxheW91dCBub2Rlc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ub2RlU2l6ZTsgaSsrKSB7XG4gICAgICB2YXIgdGVtcE5vZGUgICAgICAgID0ge307XG4gICAgICB0ZW1wTm9kZS5pZCAgICAgICAgID0gbm9kZXNbaV0uZGF0YSgnaWQnKTtcbiAgICAgIHRlbXBOb2RlLnBhcmVudElkICAgPSBub2Rlc1tpXS5kYXRhKCdwYXJlbnQnKTsgICAgICBcbiAgICAgIHRlbXBOb2RlLmNoaWxkcmVuICAgPSBbXTtcbiAgICAgIHRlbXBOb2RlLnBvc2l0aW9uWCAgPSBub2Rlc1tpXS5wb3NpdGlvbigneCcpO1xuICAgICAgdGVtcE5vZGUucG9zaXRpb25ZICA9IG5vZGVzW2ldLnBvc2l0aW9uKCd5Jyk7XG4gICAgICB0ZW1wTm9kZS5vZmZzZXRYICAgID0gMDsgICAgICBcbiAgICAgIHRlbXBOb2RlLm9mZnNldFkgICAgPSAwO1xuICAgICAgdGVtcE5vZGUuaGVpZ2h0ICAgICA9IG5vZGVzW2ldLmhlaWdodCgpO1xuICAgICAgdGVtcE5vZGUud2lkdGggICAgICA9IG5vZGVzW2ldLndpZHRoKCk7XG4gICAgICB0ZW1wTm9kZS5tYXhYICAgICAgID0gdGVtcE5vZGUucG9zaXRpb25YICsgdGVtcE5vZGUud2lkdGggIC8gMjtcbiAgICAgIHRlbXBOb2RlLm1pblggICAgICAgPSB0ZW1wTm9kZS5wb3NpdGlvblggLSB0ZW1wTm9kZS53aWR0aCAgLyAyO1xuICAgICAgdGVtcE5vZGUubWF4WSAgICAgICA9IHRlbXBOb2RlLnBvc2l0aW9uWSArIHRlbXBOb2RlLmhlaWdodCAvIDI7XG4gICAgICB0ZW1wTm9kZS5taW5ZICAgICAgID0gdGVtcE5vZGUucG9zaXRpb25ZIC0gdGVtcE5vZGUuaGVpZ2h0IC8gMjtcbiAgICAgIHRlbXBOb2RlLnBhZExlZnQgICAgPSBub2Rlc1tpXS5fcHJpdmF0ZS5zdHlsZVsncGFkZGluZy1sZWZ0J10ucHhWYWx1ZTtcbiAgICAgIHRlbXBOb2RlLnBhZFJpZ2h0ICAgPSBub2Rlc1tpXS5fcHJpdmF0ZS5zdHlsZVsncGFkZGluZy1yaWdodCddLnB4VmFsdWU7XG4gICAgICB0ZW1wTm9kZS5wYWRUb3AgICAgID0gbm9kZXNbaV0uX3ByaXZhdGUuc3R5bGVbJ3BhZGRpbmctdG9wJ10ucHhWYWx1ZTtcbiAgICAgIHRlbXBOb2RlLnBhZEJvdHRvbSAgPSBub2Rlc1tpXS5fcHJpdmF0ZS5zdHlsZVsncGFkZGluZy1ib3R0b20nXS5weFZhbHVlO1xuICAgICAgXG4gICAgICAvLyBBZGQgbmV3IG5vZGVcbiAgICAgIGxheW91dEluZm8ubGF5b3V0Tm9kZXMucHVzaCh0ZW1wTm9kZSk7XG4gICAgICAvLyBBZGQgZW50cnkgdG8gaWQtaW5kZXggbWFwXG4gICAgICBsYXlvdXRJbmZvLmlkVG9JbmRleFt0ZW1wTm9kZS5pZF0gPSBpO1xuICAgIH1cblxuICAgIC8vIElubGluZSBpbXBsZW1lbnRhdGlvbiBvZiBhIHF1ZXVlLCB1c2VkIGZvciB0cmF2ZXJzaW5nIHRoZSBncmFwaCBpbiBCRlMgb3JkZXJcbiAgICB2YXIgcXVldWUgPSBbXTtcbiAgICB2YXIgc3RhcnQgPSAwOyAgIC8vIFBvaW50cyB0byB0aGUgc3RhcnQgdGhlIHF1ZXVlXG4gICAgdmFyIGVuZCAgID0gLTE7ICAvLyBQb2ludHMgdG8gdGhlIGVuZCBvZiB0aGUgcXVldWVcblxuICAgIHZhciB0ZW1wR3JhcGggPSBbXTtcblxuICAgIC8vIFNlY29uZCBwYXNzIHRvIGFkZCBjaGlsZCBpbmZvcm1hdGlvbiBhbmQgXG4gICAgLy8gaW5pdGlhbGl6ZSBxdWV1ZSBmb3IgaGllcmFyY2hpY2FsIHRyYXZlcnNhbFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ub2RlU2l6ZTsgaSsrKSB7XG4gICAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbaV07XG4gICAgICB2YXIgcF9pZCA9IG4ucGFyZW50SWQ7XG4gICAgICAvLyBDaGVjayBpZiBub2RlIG4gaGFzIGEgcGFyZW50IG5vZGVcbiAgICAgIGlmIChudWxsICE9IHBfaWQpIHtcbiAgICAgIC8vIEFkZCBub2RlIElkIHRvIHBhcmVudCdzIGxpc3Qgb2YgY2hpbGRyZW5cbiAgICAgIGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbcF9pZF1dLmNoaWxkcmVuLnB1c2gobi5pZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgYSBub2RlIGRvZXNuJ3QgaGF2ZSBhIHBhcmVudCwgdGhlbiBpdCdzIGluIHRoZSByb290IGdyYXBoXG4gICAgICBxdWV1ZVsrK2VuZF0gPSBuLmlkO1xuICAgICAgdGVtcEdyYXBoLnB1c2gobi5pZCk7ICAgIFxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBBZGQgcm9vdCBncmFwaCB0byBncmFwaFNldFxuICAgIGxheW91dEluZm8uZ3JhcGhTZXQucHVzaCh0ZW1wR3JhcGgpO1xuXG4gICAgLy8gVHJhdmVyc2UgdGhlIGdyYXBoLCBsZXZlbCBieSBsZXZlbCwgXG4gICAgd2hpbGUgKHN0YXJ0IDw9IGVuZCkge1xuICAgICAgLy8gR2V0IHRoZSBub2RlIHRvIHZpc2l0IGFuZCByZW1vdmUgaXQgZnJvbSBxdWV1ZVxuICAgICAgdmFyIG5vZGVfaWQgID0gcXVldWVbc3RhcnQrK107XG4gICAgICB2YXIgbm9kZV9peCAgPSBsYXlvdXRJbmZvLmlkVG9JbmRleFtub2RlX2lkXTtcbiAgICAgIHZhciBub2RlICAgICA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbm9kZV9peF07XG4gICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIEFkZCBjaGlsZHJlbiBub2RlcyBhcyBhIG5ldyBncmFwaCB0byBncmFwaCBzZXRcbiAgICAgIGxheW91dEluZm8uZ3JhcGhTZXQucHVzaChjaGlsZHJlbik7XG4gICAgICAvLyBBZGQgY2hpbGRyZW4gdG8gcXVlIHF1ZXVlIHRvIGJlIHZpc2l0ZWRcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcXVldWVbKytlbmRdID0gY2hpbGRyZW5baV07XG4gICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGluZGV4VG9HcmFwaCBtYXBcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8uZ3JhcGhTZXQubGVuZ3RoOyBpKyspIHsgICAgICBcbiAgICAgIHZhciBncmFwaCA9IGxheW91dEluZm8uZ3JhcGhTZXRbaV07XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdyYXBoLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgaW5kZXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFtncmFwaFtqXV07XG4gICAgICBsYXlvdXRJbmZvLmluZGV4VG9HcmFwaFtpbmRleF0gPSBpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBJdGVyYXRlIG92ZXIgYWxsIGVkZ2VzLCBjcmVhdGluZyBMYXlvdXQgRWRnZXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8uZWRnZVNpemU7IGkrKykge1xuICAgICAgdmFyIGUgPSBlZGdlc1tpXTtcbiAgICAgIHZhciB0ZW1wRWRnZSA9IHt9OyAgICAgIFxuICAgICAgdGVtcEVkZ2UuaWQgICAgICAgPSBlLmRhdGEoJ2lkJyk7XG4gICAgICB0ZW1wRWRnZS5zb3VyY2VJZCA9IGUuZGF0YSgnc291cmNlJyk7XG4gICAgICB0ZW1wRWRnZS50YXJnZXRJZCA9IGUuZGF0YSgndGFyZ2V0Jyk7XG5cbiAgICAgIC8vIENvbXB1dGUgaWRlYWwgbGVuZ3RoXG4gICAgICB2YXIgaWRlYWxMZW5ndGggPSBvcHRpb25zLmlkZWFsRWRnZUxlbmd0aDtcblxuICAgICAgLy8gQ2hlY2sgaWYgaXQncyBhbiBpbnRlciBncmFwaCBlZGdlXG4gICAgICB2YXIgc291cmNlSXggICAgPSBsYXlvdXRJbmZvLmlkVG9JbmRleFt0ZW1wRWRnZS5zb3VyY2VJZF07XG4gICAgICB2YXIgdGFyZ2V0SXggICAgPSBsYXlvdXRJbmZvLmlkVG9JbmRleFt0ZW1wRWRnZS50YXJnZXRJZF07XG4gICAgICB2YXIgc291cmNlR3JhcGggPSBsYXlvdXRJbmZvLmluZGV4VG9HcmFwaFtzb3VyY2VJeF07XG4gICAgICB2YXIgdGFyZ2V0R3JhcGggPSBsYXlvdXRJbmZvLmluZGV4VG9HcmFwaFt0YXJnZXRJeF07XG5cbiAgICAgIGlmIChzb3VyY2VHcmFwaCAhPSB0YXJnZXRHcmFwaCkge1xuICAgICAgLy8gRmluZCBsb3dlc3QgY29tbW9uIGdyYXBoIGFuY2VzdG9yXG4gICAgICB2YXIgbGNhID0gZmluZExDQSh0ZW1wRWRnZS5zb3VyY2VJZCwgdGVtcEVkZ2UudGFyZ2V0SWQsIGxheW91dEluZm8pO1xuXG4gICAgICAvLyBDb21wdXRlIHN1bSBvZiBub2RlIGRlcHRocywgcmVsYXRpdmUgdG8gbGNhIGdyYXBoXG4gICAgICB2YXIgbGNhR3JhcGggPSBsYXlvdXRJbmZvLmdyYXBoU2V0W2xjYV07XG4gICAgICB2YXIgZGVwdGggICAgPSAwO1xuXG4gICAgICAvLyBTb3VyY2UgZGVwdGhcbiAgICAgIHZhciB0ZW1wTm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbc291cmNlSXhdO1xuICAgICAgd2hpbGUgKC0xID09PSAkLmluQXJyYXkodGVtcE5vZGUuaWQsIGxjYUdyYXBoKSkge1xuICAgICAgICB0ZW1wTm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbdGVtcE5vZGUucGFyZW50SWRdXTtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgIH1cblxuICAgICAgLy8gVGFyZ2V0IGRlcHRoXG4gICAgICB0ZW1wTm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbdGFyZ2V0SXhdO1xuICAgICAgd2hpbGUgKC0xID09PSAkLmluQXJyYXkodGVtcE5vZGUuaWQsIGxjYUdyYXBoKSkge1xuICAgICAgICB0ZW1wTm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbdGVtcE5vZGUucGFyZW50SWRdXTtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgIH1cblxuICAgICAgLy8gbG9nRGVidWcoJ0xDQSBvZiBub2RlcyAnICsgdGVtcEVkZ2Uuc291cmNlSWQgKyAnIGFuZCAnICsgdGVtcEVkZ2UudGFyZ2V0SWQgKyAgXG4gICAgICAgIC8vICBcIi4gSW5kZXg6IFwiICsgbGNhICsgXCIgQ29udGVudHM6IFwiICsgbGNhR3JhcGgudG9TdHJpbmcoKSArIFxuICAgICAgICAvLyAgXCIuIERlcHRoOiBcIiArIGRlcHRoKTtcblxuICAgICAgLy8gVXBkYXRlIGlkZWFsTGVuZ3RoXG4gICAgICBpZGVhbExlbmd0aCAqPSBkZXB0aCAqIG9wdGlvbnMubmVzdGluZ0ZhY3RvcjtcbiAgICAgIH1cblxuICAgICAgdGVtcEVkZ2UuaWRlYWxMZW5ndGggPSBpZGVhbExlbmd0aDtcblxuICAgICAgbGF5b3V0SW5mby5sYXlvdXRFZGdlcy5wdXNoKHRlbXBFZGdlKTtcbiAgICB9XG5cbiAgICAvLyBGaW5hbGx5LCByZXR1cm4gbGF5b3V0SW5mbyBvYmplY3RcbiAgICByZXR1cm4gbGF5b3V0SW5mbztcbiAgfTtcblxuICBcbiAgLyoqXG4gICAqIEBicmllZiA6IFRoaXMgZnVuY3Rpb24gZmluZHMgdGhlIGluZGV4IG9mIHRoZSBsb3dlc3QgY29tbW9uIFxuICAgKiAgICAgICAgICBncmFwaCBhbmNlc3RvciBiZXR3ZWVuIDIgbm9kZXMgaW4gdGhlIHN1YnRyZWUgXG4gICAqICAgICAgICAgIChmcm9tIHRoZSBncmFwaCBoaWVyYXJjaHkgaW5kdWNlZCB0cmVlKSB3aG9zZVxuICAgKiAgICAgICAgICByb290IGlzIGdyYXBoSXhcbiAgICpcbiAgICogQGFyZyBub2RlMTogbm9kZTEncyBJRFxuICAgKiBAYXJnIG5vZGUyOiBub2RlMidzIElEXG4gICAqIEBhcmcgbGF5b3V0SW5mbzogbGF5b3V0SW5mbyBvYmplY3RcbiAgICpcbiAgICovXG4gIHZhciBmaW5kTENBID0gZnVuY3Rpb24obm9kZTEsIG5vZGUyLCBsYXlvdXRJbmZvKSB7XG4gICAgLy8gRmluZCB0aGVpciBjb21tb24gYW5jZXN0ZXIsIHN0YXJ0aW5nIGZyb20gdGhlIHJvb3QgZ3JhcGhcbiAgICB2YXIgcmVzID0gZmluZExDQV9hdXgobm9kZTEsIG5vZGUyLCAwLCBsYXlvdXRJbmZvKTtcbiAgICBpZiAoMiA+IHJlcy5jb3VudCkge1xuICAgICAgLy8gSWYgYXV4IGZ1bmN0aW9uIGNvdWxkbid0IGZpbmQgdGhlIGNvbW1vbiBhbmNlc3RlciwgXG4gICAgICAvLyB0aGVuIGl0IGlzIHRoZSByb290IGdyYXBoXG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlcy5ncmFwaDtcbiAgICB9XG4gIH07XG5cblxuICAvKipcbiAgICogQGJyaWVmICAgICAgICAgIDogQXV4aWxpYXJ5IGZ1bmN0aW9uIHVzZWQgZm9yIExDQSBjb21wdXRhdGlvblxuICAgKiBcbiAgICogQGFyZyBub2RlMSAgICAgIDogbm9kZTEncyBJRFxuICAgKiBAYXJnIG5vZGUyICAgICAgOiBub2RlMidzIElEXG4gICAqIEBhcmcgZ3JhcGhJeCAgICA6IHN1YmdyYXBoIGluZGV4XG4gICAqIEBhcmcgbGF5b3V0SW5mbyA6IGxheW91dEluZm8gb2JqZWN0XG4gICAqXG4gICAqIEByZXR1cm4gICAgICAgICA6IG9iamVjdCBvZiB0aGUgZm9ybSB7Y291bnQ6IFgsIGdyYXBoOiBZfSwgd2hlcmU6XG4gICAqICAgICAgICAgICAgICAgICAgIFggaXMgdGhlIG51bWJlciBvZiBhbmNlc3RlcnMgKG1heDogMikgZm91bmQgaW4gXG4gICAqICAgICAgICAgICAgICAgICAgIGdyYXBoSXggKGFuZCBpdCdzIHN1YmdyYXBocyksXG4gICAqICAgICAgICAgICAgICAgICAgIFkgaXMgdGhlIGdyYXBoIGluZGV4IG9mIHRoZSBsb3dlc3QgZ3JhcGggY29udGFpbmluZyBcbiAgICogICAgICAgICAgICAgICAgICAgYWxsIFggbm9kZXNcbiAgICovXG4gIHZhciBmaW5kTENBX2F1eCA9IGZ1bmN0aW9uKG5vZGUxLCBub2RlMiwgZ3JhcGhJeCwgbGF5b3V0SW5mbykge1xuICAgIHZhciBncmFwaCA9IGxheW91dEluZm8uZ3JhcGhTZXRbZ3JhcGhJeF07XG4gICAgLy8gSWYgYm90aCBub2RlcyBiZWxvbmdzIHRvIGdyYXBoSXhcbiAgICBpZiAoLTEgPCAkLmluQXJyYXkobm9kZTEsIGdyYXBoKSAmJiAtMSA8ICQuaW5BcnJheShub2RlMiwgZ3JhcGgpKSB7XG4gICAgICByZXR1cm4ge2NvdW50OjIsIGdyYXBoOmdyYXBoSXh9O1xuICAgIH1cblxuICAgIC8vIE1ha2UgcmVjdXJzaXZlIGNhbGxzIGZvciBhbGwgc3ViZ3JhcGhzXG4gICAgdmFyIGMgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JhcGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBub2RlSWQgICA9IGdyYXBoW2ldO1xuICAgICAgdmFyIG5vZGVJeCAgID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbbm9kZUlkXTtcbiAgICAgIHZhciBjaGlsZHJlbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbm9kZUl4XS5jaGlsZHJlbjtcblxuICAgICAgLy8gSWYgdGhlIG5vZGUgaGFzIG5vIGNoaWxkLCBza2lwIGl0XG4gICAgICBpZiAoMCA9PT0gY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNoaWxkR3JhcGhJeCA9IGxheW91dEluZm8uaW5kZXhUb0dyYXBoW2xheW91dEluZm8uaWRUb0luZGV4W2NoaWxkcmVuWzBdXV07XG4gICAgICB2YXIgcmVzdWx0ID0gZmluZExDQV9hdXgobm9kZTEsIG5vZGUyLCBjaGlsZEdyYXBoSXgsIGxheW91dEluZm8pO1xuICAgICAgaWYgKDAgPT09IHJlc3VsdC5jb3VudCkge1xuICAgICAgLy8gTmVpdGhlciBub2RlMSBub3Igbm9kZTIgYXJlIHByZXNlbnQgaW4gdGhpcyBzdWJncmFwaFxuICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKDEgPT09IHJlc3VsdC5jb3VudCkge1xuICAgICAgLy8gT25lIG9mIChub2RlMSwgbm9kZTIpIGlzIHByZXNlbnQgaW4gdGhpcyBzdWJncmFwaFxuICAgICAgYysrO1xuICAgICAgaWYgKDIgPT09IGMpIHtcbiAgICAgICAgLy8gV2UndmUgYWxyZWFkeSBmb3VuZCBib3RoIG5vZGVzLCBubyBuZWVkIHRvIGtlZXAgc2VhcmNoaW5nXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgIC8vIEJvdGggbm9kZXMgYXJlIHByZXNlbnQgaW4gdGhpcyBzdWJncmFwaFxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gICAgICBcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHtjb3VudDpjLCBncmFwaDpncmFwaEl4fTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAYnJpZWY6IHByaW50c0xheW91dEluZm8gaW50byBqcyBjb25zb2xlXG4gICAqICAgICAgICAgT25seSB1c2VkIGZvciBkZWJidWdpbmcgXG4gICAqL1xuICB2YXIgcHJpbnRMYXlvdXRJbmZvID0gZnVuY3Rpb24obGF5b3V0SW5mbykge1xuICAgIGlmICghREVCVUcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc29sZS5kZWJ1ZyhcImxheW91dE5vZGVzOlwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgICAgdmFyIG4gPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2ldO1xuICAgICAgdmFyIHMgPSBcbiAgICAgIFwiXFxuaW5kZXg6IFwiICAgICArIGkgKyBcbiAgICAgIFwiXFxuSWQ6IFwiICAgICAgICArIG4uaWQgKyBcbiAgICAgIFwiXFxuQ2hpbGRyZW46IFwiICArIG4uY2hpbGRyZW4udG9TdHJpbmcoKSArICBcbiAgICAgIFwiXFxucGFyZW50SWQ6IFwiICArIG4ucGFyZW50SWQgICsgXG4gICAgICBcIlxcbnBvc2l0aW9uWDogXCIgKyBuLnBvc2l0aW9uWCArIFxuICAgICAgXCJcXG5wb3NpdGlvblk6IFwiICsgbi5wb3NpdGlvblkgK1xuICAgICAgXCJcXG5PZmZzZXRYOiBcIiArIG4ub2Zmc2V0WCArIFxuICAgICAgXCJcXG5PZmZzZXRZOiBcIiArIG4ub2Zmc2V0WSArIFxuICAgICAgXCJcXG5wYWRMZWZ0OiBcIiArIG4ucGFkTGVmdCArIFxuICAgICAgXCJcXG5wYWRSaWdodDogXCIgKyBuLnBhZFJpZ2h0ICsgXG4gICAgICBcIlxcbnBhZFRvcDogXCIgKyBuLnBhZFRvcCArIFxuICAgICAgXCJcXG5wYWRCb3R0b206IFwiICsgbi5wYWRCb3R0b207XG5cbiAgICAgIGNvbnNvbGUuZGVidWcocyk7ICAgIFxuICAgIH0gIFxuICAgIFxuICAgIGNvbnNvbGUuZGVidWcoJ2lkVG9JbmRleCcpO1xuICAgIGZvciAodmFyIGkgaW4gbGF5b3V0SW5mby5pZFRvSW5kZXgpIHtcbiAgICAgIGNvbnNvbGUuZGVidWcoXCJJZDogXCIgKyBpICsgXCJcXG5JbmRleDogXCIgKyBsYXlvdXRJbmZvLmlkVG9JbmRleFtpXSk7XG4gICAgfVxuXG4gICAgY29uc29sZS5kZWJ1ZygnR3JhcGggU2V0Jyk7XG4gICAgdmFyIHNldCA9IGxheW91dEluZm8uZ3JhcGhTZXQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpICsrKSB7XG4gICAgICBjb25zb2xlLmRlYnVnKFwiU2V0IDogXCIgKyBpICsgXCI6IFwiICsgc2V0W2ldLnRvU3RyaW5nKCkpO1xuICAgIH0gXG5cbiAgICB2YXIgcyA9ICdJbmRleFRvR3JhcGgnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5pbmRleFRvR3JhcGgubGVuZ3RoOyBpICsrKSB7XG4gICAgICBzICs9IFwiXFxuSW5kZXggOiBcIiArIGkgKyBcIiBHcmFwaDogXCIrIGxheW91dEluZm8uaW5kZXhUb0dyYXBoW2ldO1xuICAgIH1cbiAgICBjb25zb2xlLmRlYnVnKHMpO1xuXG4gICAgcyA9ICdMYXlvdXQgRWRnZXMnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5sYXlvdXRFZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGUgPSBsYXlvdXRJbmZvLmxheW91dEVkZ2VzW2ldO1xuICAgICAgcyArPSBcIlxcbkVkZ2UgSW5kZXg6IFwiICsgaSArIFwiIElEOiBcIiArIGUuaWQgKyBcbiAgICAgIFwiIFNvdWNlSUQ6IFwiICsgZS5zb3VyY2VJZCArIFwiIFRhcmdldElkOiBcIiArIGUudGFyZ2V0SWQgKyBcbiAgICAgIFwiIElkZWFsIExlbmd0aDogXCIgKyBlLmlkZWFsTGVuZ3RoO1xuICAgIH1cbiAgICBjb25zb2xlLmRlYnVnKHMpO1xuXG4gICAgcyA9ICBcIm5vZGVTaXplOiBcIiArIGxheW91dEluZm8ubm9kZVNpemU7XG4gICAgcyArPSBcIlxcbmVkZ2VTaXplOiBcIiArIGxheW91dEluZm8uZWRnZVNpemU7XG4gICAgcyArPSBcIlxcbnRlbXBlcmF0dXJlOiBcIiArIGxheW91dEluZm8udGVtcGVyYXR1cmU7XG4gICAgY29uc29sZS5kZWJ1ZyhzKTtcblxuICAgIHJldHVybjtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAYnJpZWYgOiBSYW5kb21pemVzIHRoZSBwb3NpdGlvbiBvZiBhbGwgbm9kZXNcbiAgICovXG4gIHZhciByYW5kb21pemVQb3NpdGlvbnMgPSBmdW5jdGlvbihsYXlvdXRJbmZvLCBjeSkge1xuICAgIHZhciB3aWR0aCAgICAgPSBsYXlvdXRJbmZvLmNsaWVudFdpZHRoO1xuICAgIHZhciBoZWlnaHQgICAgPSBsYXlvdXRJbmZvLmNsaWVudEhlaWdodDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ub2RlU2l6ZTsgaSsrKSB7XG4gICAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbaV07XG4gICAgICAvLyBObyBuZWVkIHRvIHJhbmRvbWl6ZSBjb21wb3VuZCBub2Rlc1xuICAgICAgaWYgKHRydWUgfHwgMCA9PT0gbi5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgbi5wb3NpdGlvblggPSBNYXRoLnJhbmRvbSgpICogd2lkdGg7XG4gICAgICAgIG4ucG9zaXRpb25ZID0gTWF0aC5yYW5kb20oKSAqIGhlaWdodDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgXG4gIC8qKlxuICAgKiBAYnJpZWYgICAgICAgICAgOiBVcGRhdGVzIHRoZSBwb3NpdGlvbnMgb2Ygbm9kZXMgaW4gdGhlIG5ldHdvcmtcbiAgICogQGFyZyBsYXlvdXRJbmZvIDogTGF5b3V0SW5mbyBvYmplY3RcbiAgICogQGFyZyBjeSAgICAgICAgIDogQ3l0b3NjYXBlIG9iamVjdFxuICAgKiBAYXJnIG9wdGlvbnMgICAgOiBMYXlvdXQgb3B0aW9uc1xuICAgKi9cbiAgdmFyIHJlZnJlc2hQb3NpdGlvbnMgPSBmdW5jdGlvbihsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucykgeyAgXG4gICAgLy8gdmFyIHMgPSAnUmVmcmVzaGluZyBwb3NpdGlvbnMnO1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgdmFyIGxheW91dCA9IGxheW91dEluZm8ubGF5b3V0O1xuICAgIHZhciBub2RlcyA9IG9wdGlvbnMuZWxlcy5ub2RlcygpO1xuICAgIHZhciBiYiA9IGxheW91dEluZm8uYm91bmRpbmdCb3g7XG4gICAgdmFyIGNvc2VCQiA9IHsgeDE6IEluZmluaXR5LCB4MjogLUluZmluaXR5LCB5MTogSW5maW5pdHksIHkyOiAtSW5maW5pdHkgfTtcbiAgICBcbiAgICBpZiggb3B0aW9ucy5ib3VuZGluZ0JveCApe1xuICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiggbm9kZSApe1xuICAgICAgICB2YXIgbG5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W25vZGUuZGF0YSgnaWQnKV1dO1xuXG4gICAgICAgIGNvc2VCQi54MSA9IE1hdGgubWluKCBjb3NlQkIueDEsIGxub2RlLnBvc2l0aW9uWCApO1xuICAgICAgICBjb3NlQkIueDIgPSBNYXRoLm1heCggY29zZUJCLngyLCBsbm9kZS5wb3NpdGlvblggKTtcblxuICAgICAgICBjb3NlQkIueTEgPSBNYXRoLm1pbiggY29zZUJCLnkxLCBsbm9kZS5wb3NpdGlvblkgKTtcbiAgICAgICAgY29zZUJCLnkyID0gTWF0aC5tYXgoIGNvc2VCQi55MiwgbG5vZGUucG9zaXRpb25ZICk7XG4gICAgICB9KTtcblxuICAgICAgY29zZUJCLncgPSBjb3NlQkIueDIgLSBjb3NlQkIueDE7XG4gICAgICBjb3NlQkIuaCA9IGNvc2VCQi55MiAtIGNvc2VCQi55MTtcbiAgICB9XG5cbiAgICBub2Rlcy5wb3NpdGlvbnMoZnVuY3Rpb24oaSwgZWxlKSB7XG4gICAgICB2YXIgbG5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W2VsZS5kYXRhKCdpZCcpXV07XG4gICAgICAvLyBzID0gXCJOb2RlOiBcIiArIGxub2RlLmlkICsgXCIuIFJlZnJlc2hlZCBwb3NpdGlvbjogKFwiICsgXG4gICAgICAvLyBsbm9kZS5wb3NpdGlvblggKyBcIiwgXCIgKyBsbm9kZS5wb3NpdGlvblkgKyBcIikuXCI7XG4gICAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAgICAgaWYoIG9wdGlvbnMuYm91bmRpbmdCb3ggKXsgLy8gdGhlbiBhZGQgZXh0cmEgYm91bmRpbmcgYm94IGNvbnN0cmFpbnRcbiAgICAgICAgdmFyIHBjdFggPSAobG5vZGUucG9zaXRpb25YIC0gY29zZUJCLngxKSAvIGNvc2VCQi53O1xuICAgICAgICB2YXIgcGN0WSA9IChsbm9kZS5wb3NpdGlvblkgLSBjb3NlQkIueTEpIC8gY29zZUJCLmg7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBiYi54MSArIHBjdFggKiBiYi53LFxuICAgICAgICAgIHk6IGJiLnkxICsgcGN0WSAqIGJiLmhcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogbG5vZGUucG9zaXRpb25YLFxuICAgICAgICAgIHk6IGxub2RlLnBvc2l0aW9uWVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gVHJpZ2dlciBsYXlvdXRSZWFkeSBvbmx5IG9uIGZpcnN0IGNhbGxcbiAgICBpZiAodHJ1ZSAhPT0gbGF5b3V0SW5mby5yZWFkeSkge1xuICAgICAgLy8gcyA9ICdUcmlnZ2VyaW5nIGxheW91dHJlYWR5JztcbiAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgICAgbGF5b3V0SW5mby5yZWFkeSA9IHRydWU7XG4gICAgICBsYXlvdXQub25lKCdsYXlvdXRyZWFkeScsIG9wdGlvbnMucmVhZHkpO1xuICAgICAgbGF5b3V0LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0cmVhZHknLCBsYXlvdXQ6IHRoaXMgfSk7XG4gICAgfVxuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBicmllZiAgICAgICAgICA6IFBlcmZvcm1zIG9uZSBpdGVyYXRpb24gb2YgdGhlIHBoeXNpY2FsIHNpbXVsYXRpb25cbiAgICogQGFyZyBsYXlvdXRJbmZvIDogTGF5b3V0SW5mbyBvYmplY3QgYWxyZWFkeSBpbml0aWFsaXplZFxuICAgKiBAYXJnIGN5ICAgICAgICAgOiBDeXRvc2NhcGUgb2JqZWN0XG4gICAqIEBhcmcgb3B0aW9ucyAgICA6IExheW91dCBvcHRpb25zXG4gICAqL1xuICB2YXIgc3RlcCA9IGZ1bmN0aW9uKGxheW91dEluZm8sIGN5LCBvcHRpb25zLCBzdGVwKSB7ICBcbiAgICAvLyB2YXIgcyA9IFwiXFxuXFxuIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1wiO1xuICAgIC8vIHMgKz0gXCJcXG5TVEVQOiBcIiArIHN0ZXA7XG4gICAgLy8gcyArPSBcIlxcbiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcXG5cIjtcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAgIC8vIENhbGN1bGF0ZSBub2RlIHJlcHVsc2lvbnNcbiAgICBjYWxjdWxhdGVOb2RlRm9yY2VzKGxheW91dEluZm8sIGN5LCBvcHRpb25zKTtcbiAgICAvLyBDYWxjdWxhdGUgZWRnZSBmb3JjZXNcbiAgICBjYWxjdWxhdGVFZGdlRm9yY2VzKGxheW91dEluZm8sIGN5LCBvcHRpb25zKTtcbiAgICAvLyBDYWxjdWxhdGUgZ3Jhdml0eSBmb3JjZXNcbiAgICBjYWxjdWxhdGVHcmF2aXR5Rm9yY2VzKGxheW91dEluZm8sIGN5LCBvcHRpb25zKTtcbiAgICAvLyBQcm9wYWdhdGUgZm9yY2VzIGZyb20gcGFyZW50IHRvIGNoaWxkXG4gICAgcHJvcGFnYXRlRm9yY2VzKGxheW91dEluZm8sIGN5LCBvcHRpb25zKTtcbiAgICAvLyBVcGRhdGUgcG9zaXRpb25zIGJhc2VkIG9uIGNhbGN1bGF0ZWQgZm9yY2VzXG4gICAgdXBkYXRlUG9zaXRpb25zKGxheW91dEluZm8sIGN5LCBvcHRpb25zKTtcbiAgfTtcblxuICBcbiAgLyoqXG4gICAqIEBicmllZiA6IENvbXB1dGVzIHRoZSBub2RlIHJlcHVsc2lvbiBmb3JjZXNcbiAgICovXG4gIHZhciBjYWxjdWxhdGVOb2RlRm9yY2VzID0gZnVuY3Rpb24obGF5b3V0SW5mbywgY3ksIG9wdGlvbnMpIHtcbiAgICAvLyBHbyB0aHJvdWdoIGVhY2ggb2YgdGhlIGdyYXBocyBpbiBncmFwaFNldFxuICAgIC8vIE5vZGVzIG9ubHkgcmVwZWwgZWFjaCBvdGhlciBpZiB0aGV5IGJlbG9uZyB0byB0aGUgc2FtZSBncmFwaFxuICAgIC8vIHZhciBzID0gJ2NhbGN1bGF0ZU5vZGVGb3JjZXMnO1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ncmFwaFNldC5sZW5ndGg7IGkgKyspIHtcbiAgICAgIHZhciBncmFwaCAgICA9IGxheW91dEluZm8uZ3JhcGhTZXRbaV07XG4gICAgICB2YXIgbnVtTm9kZXMgPSBncmFwaC5sZW5ndGg7XG5cbiAgICAgIC8vIHMgPSBcIlNldDogXCIgKyBncmFwaC50b1N0cmluZygpO1xuICAgICAgLy8gbG9nRGVidWcocyk7XG5cbiAgICAgIC8vIE5vdyBnZXQgYWxsIHRoZSBwYWlycyBvZiBub2RlcyBcbiAgICAgIC8vIE9ubHkgZ2V0IGVhY2ggcGFpciBvbmNlLCAoQSwgQikgPSAoQiwgQSlcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtTm9kZXM7IGorKykge1xuICAgICAgdmFyIG5vZGUxID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtncmFwaFtqXV1dO1xuICAgICAgZm9yICh2YXIgayA9IGogKyAxOyBrIDwgbnVtTm9kZXM7IGsrKykge1xuICAgICAgICB2YXIgbm9kZTIgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W2dyYXBoW2tdXV07XG4gICAgICAgIG5vZGVSZXB1bHNpb24obm9kZTEsIG5vZGUyLCBsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucyk7XG4gICAgICB9IFxuICAgICAgfVxuICAgIH0gXG4gIH07XG5cblxuICAvKipcbiAgICogQGJyaWVmIDogQ29tcHV0ZSB0aGUgbm9kZSByZXB1bHNpb24gZm9yY2VzIGJldHdlZW4gYSBwYWlyIG9mIG5vZGVzXG4gICAqL1xuICB2YXIgbm9kZVJlcHVsc2lvbiA9IGZ1bmN0aW9uKG5vZGUxLCBub2RlMiwgbGF5b3V0SW5mbywgY3ksIG9wdGlvbnMpIHtcbiAgICAvLyB2YXIgcyA9IFwiTm9kZSByZXB1bHNpb24uIE5vZGUxOiBcIiArIG5vZGUxLmlkICsgXCIgTm9kZTI6IFwiICsgbm9kZTIuaWQ7XG5cbiAgICAvLyBHZXQgZGlyZWN0aW9uIG9mIGxpbmUgY29ubmVjdGluZyBib3RoIG5vZGUgY2VudGVyc1xuICAgIHZhciBkaXJlY3Rpb25YID0gbm9kZTIucG9zaXRpb25YIC0gbm9kZTEucG9zaXRpb25YO1xuICAgIHZhciBkaXJlY3Rpb25ZID0gbm9kZTIucG9zaXRpb25ZIC0gbm9kZTEucG9zaXRpb25ZO1xuICAgIC8vIHMgKz0gXCJcXG5kaXJlY3Rpb25YOiBcIiArIGRpcmVjdGlvblggKyBcIiwgZGlyZWN0aW9uWTogXCIgKyBkaXJlY3Rpb25ZO1xuXG4gICAgLy8gSWYgYm90aCBjZW50ZXJzIGFyZSB0aGUgc2FtZSwgYXBwbHkgYSByYW5kb20gZm9yY2VcbiAgICBpZiAoMCA9PT0gZGlyZWN0aW9uWCAmJiAwID09PSBkaXJlY3Rpb25ZKSB7XG4gICAgICAvLyBzICs9IFwiXFxuTm9kZXMgaGF2ZSB0aGUgc2FtZSBwb3NpdGlvbi5cIjtcbiAgICAgIHJldHVybjsgLy8gVE9ET1xuICAgIH1cblxuICAgIHZhciBvdmVybGFwID0gbm9kZXNPdmVybGFwKG5vZGUxLCBub2RlMiwgZGlyZWN0aW9uWCwgZGlyZWN0aW9uWSk7XG4gICAgXG4gICAgaWYgKG92ZXJsYXAgPiAwKSB7XG4gICAgICAvLyBzICs9IFwiXFxuTm9kZXMgRE8gb3ZlcmxhcC5cIjtcbiAgICAgIC8vIHMgKz0gXCJcXG5PdmVybGFwOiBcIiArIG92ZXJsYXA7XG4gICAgICAvLyBJZiBub2RlcyBvdmVybGFwLCByZXB1bHNpb24gZm9yY2UgaXMgcHJvcG9ydGlvbmFsIFxuICAgICAgLy8gdG8gdGhlIG92ZXJsYXBcbiAgICAgIHZhciBmb3JjZSAgICA9IG9wdGlvbnMubm9kZU92ZXJsYXAgKiBvdmVybGFwO1xuXG4gICAgICAvLyBDb21wdXRlIHRoZSBtb2R1bGUgYW5kIGNvbXBvbmVudHMgb2YgdGhlIGZvcmNlIHZlY3RvclxuICAgICAgdmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KGRpcmVjdGlvblggKiBkaXJlY3Rpb25YICsgZGlyZWN0aW9uWSAqIGRpcmVjdGlvblkpO1xuICAgICAgLy8gcyArPSBcIlxcbkRpc3RhbmNlOiBcIiArIGRpc3RhbmNlO1xuICAgICAgdmFyIGZvcmNlWCAgID0gZm9yY2UgKiBkaXJlY3Rpb25YIC8gZGlzdGFuY2U7XG4gICAgICB2YXIgZm9yY2VZICAgPSBmb3JjZSAqIGRpcmVjdGlvblkgLyBkaXN0YW5jZTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzICs9IFwiXFxuTm9kZXMgZG8gTk9UIG92ZXJsYXAuXCI7XG4gICAgICAvLyBJZiB0aGVyZSdzIG5vIG92ZXJsYXAsIGZvcmNlIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgXG4gICAgICAvLyB0byBzcXVhcmVkIGRpc3RhbmNlXG5cbiAgICAgIC8vIEdldCBjbGlwcGluZyBwb2ludHMgZm9yIGJvdGggbm9kZXNcbiAgICAgIHZhciBwb2ludDEgPSBmaW5kQ2xpcHBpbmdQb2ludChub2RlMSwgZGlyZWN0aW9uWCwgZGlyZWN0aW9uWSk7XG4gICAgICB2YXIgcG9pbnQyID0gZmluZENsaXBwaW5nUG9pbnQobm9kZTIsIC0xICogZGlyZWN0aW9uWCwgLTEgKiBkaXJlY3Rpb25ZKTtcblxuICAgICAgLy8gVXNlIGNsaXBwaW5nIHBvaW50cyB0byBjb21wdXRlIGRpc3RhbmNlXG4gICAgICB2YXIgZGlzdGFuY2VYICAgPSBwb2ludDIueCAtIHBvaW50MS54O1xuICAgICAgdmFyIGRpc3RhbmNlWSAgID0gcG9pbnQyLnkgLSBwb2ludDEueTtcbiAgICAgIHZhciBkaXN0YW5jZVNxciA9IGRpc3RhbmNlWCAqIGRpc3RhbmNlWCArIGRpc3RhbmNlWSAqIGRpc3RhbmNlWTtcbiAgICAgIHZhciBkaXN0YW5jZSAgICA9IE1hdGguc3FydChkaXN0YW5jZVNxcik7XG4gICAgICAvLyBzICs9IFwiXFxuRGlzdGFuY2U6IFwiICsgZGlzdGFuY2U7XG5cbiAgICAgIC8vIENvbXB1dGUgdGhlIG1vZHVsZSBhbmQgY29tcG9uZW50cyBvZiB0aGUgZm9yY2UgdmVjdG9yXG4gICAgICB2YXIgZm9yY2UgID0gb3B0aW9ucy5ub2RlUmVwdWxzaW9uIC8gZGlzdGFuY2VTcXI7XG4gICAgICB2YXIgZm9yY2VYID0gZm9yY2UgKiBkaXN0YW5jZVggLyBkaXN0YW5jZTtcbiAgICAgIHZhciBmb3JjZVkgPSBmb3JjZSAqIGRpc3RhbmNlWSAvIGRpc3RhbmNlO1xuICAgIH1cblxuICAgIC8vIEFwcGx5IGZvcmNlXG4gICAgbm9kZTEub2Zmc2V0WCAtPSBmb3JjZVg7XG4gICAgbm9kZTEub2Zmc2V0WSAtPSBmb3JjZVk7XG4gICAgbm9kZTIub2Zmc2V0WCArPSBmb3JjZVg7XG4gICAgbm9kZTIub2Zmc2V0WSArPSBmb3JjZVk7XG5cbiAgICAvLyBzICs9IFwiXFxuRm9yY2VYOiBcIiArIGZvcmNlWCArIFwiIEZvcmNlWTogXCIgKyBmb3JjZVk7XG4gICAgLy8gbG9nRGVidWcocyk7XG5cbiAgICByZXR1cm47XG4gIH07XG5cblxuICAvKipcbiAgICogQGJyaWVmIDogRmluZHMgdGhlIHBvaW50IGluIHdoaWNoIGFuIGVkZ2UgKGRpcmVjdGlvbiBkWCwgZFkpIGludGVyc2VjdHMgXG4gICAqICAgICAgICAgIHRoZSByZWN0YW5ndWxhciBib3VuZGluZyBib3ggb2YgaXQncyBzb3VyY2UvdGFyZ2V0IG5vZGUgXG4gICAqL1xuICB2YXIgZmluZENsaXBwaW5nUG9pbnQgPSBmdW5jdGlvbihub2RlLCBkWCwgZFkpIHtcblxuICAgIC8vIFNob3JjdXRzXG4gICAgdmFyIFggPSBub2RlLnBvc2l0aW9uWDtcbiAgICB2YXIgWSA9IG5vZGUucG9zaXRpb25ZO1xuICAgIHZhciBIID0gbm9kZS5oZWlnaHQ7XG4gICAgdmFyIFcgPSBub2RlLndpZHRoO1xuICAgIHZhciBkaXJTbG9wZSAgICAgPSBkWSAvIGRYO1xuICAgIHZhciBub2RlU2xvcGUgICAgPSBIIC8gVztcblxuICAgIC8vIHZhciBzID0gJ0NvbXB1dGluZyBjbGlwcGluZyBwb2ludCBvZiBub2RlICcgKyBub2RlLmlkICsgXG4gICAgLy8gICBcIiAuIEhlaWdodDogIFwiICsgSCArIFwiLCBXaWR0aDogXCIgKyBXICsgXG4gICAgLy8gICBcIlxcbkRpcmVjdGlvbiBcIiArIGRYICsgXCIsIFwiICsgZFk7IFxuICAgIC8vIFxuICAgIC8vIENvbXB1dGUgaW50ZXJzZWN0aW9uXG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIGRvIHtcbiAgICAgIC8vIENhc2U6IFZlcnRpY2FsIGRpcmVjdGlvbiAodXApXG4gICAgICBpZiAoMCA9PT0gZFggJiYgMCA8IGRZKSB7XG4gICAgICAgIHJlcy54ID0gWDtcbiAgICAgICAgLy8gcyArPSBcIlxcblVwIGRpcmVjdGlvblwiO1xuICAgICAgICByZXMueSA9IFkgKyBIIC8gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIENhc2U6IFZlcnRpY2FsIGRpcmVjdGlvbiAoZG93bilcbiAgICAgIGlmICgwID09PSBkWCAmJiAwID4gZFkpIHtcbiAgICAgICAgcmVzLnggPSBYO1xuICAgICAgICByZXMueSA9IFkgKyBIIC8gMjtcbiAgICAgICAgLy8gcyArPSBcIlxcbkRvd24gZGlyZWN0aW9uXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSAgICAgIFxuXG4gICAgICAvLyBDYXNlOiBJbnRlcnNlY3RzIHRoZSByaWdodCBib3JkZXJcbiAgICAgIGlmICgwIDwgZFggJiYgXG4gICAgICAtMSAqIG5vZGVTbG9wZSA8PSBkaXJTbG9wZSAmJiBcbiAgICAgIGRpclNsb3BlIDw9IG5vZGVTbG9wZSkge1xuICAgICAgICByZXMueCA9IFggKyBXIC8gMjtcbiAgICAgICAgcmVzLnkgPSBZICsgKFcgKiBkWSAvIDIgLyBkWCk7XG4gICAgICAgIC8vIHMgKz0gXCJcXG5SaWdodGJvcmRlclwiO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gQ2FzZTogSW50ZXJzZWN0cyB0aGUgbGVmdCBib3JkZXJcbiAgICAgIGlmICgwID4gZFggJiYgXG4gICAgICAtMSAqIG5vZGVTbG9wZSA8PSBkaXJTbG9wZSAmJiBcbiAgICAgIGRpclNsb3BlIDw9IG5vZGVTbG9wZSkge1xuICAgICAgICByZXMueCA9IFggLSBXIC8gMjtcbiAgICAgICAgcmVzLnkgPSBZIC0gKFcgKiBkWSAvIDIgLyBkWCk7XG4gICAgICAgIC8vIHMgKz0gXCJcXG5MZWZ0Ym9yZGVyXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyBDYXNlOiBJbnRlcnNlY3RzIHRoZSB0b3AgYm9yZGVyXG4gICAgICBpZiAoMCA8IGRZICYmIFxuICAgICAgKCBkaXJTbG9wZSA8PSAtMSAqIG5vZGVTbG9wZSB8fFxuICAgICAgICBkaXJTbG9wZSA+PSBub2RlU2xvcGUgKSkge1xuICAgICAgICByZXMueCA9IFggKyAoSCAqIGRYIC8gMiAvIGRZKTtcbiAgICAgICAgcmVzLnkgPSBZICsgSCAvIDI7XG4gICAgICAgIC8vIHMgKz0gXCJcXG5Ub3AgYm9yZGVyXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyBDYXNlOiBJbnRlcnNlY3RzIHRoZSBib3R0b20gYm9yZGVyXG4gICAgICBpZiAoMCA+IGRZICYmIFxuICAgICAgKCBkaXJTbG9wZSA8PSAtMSAqIG5vZGVTbG9wZSB8fFxuICAgICAgICBkaXJTbG9wZSA+PSBub2RlU2xvcGUgKSkge1xuICAgICAgICByZXMueCA9IFggLSAoSCAqIGRYIC8gMiAvIGRZKTtcbiAgICAgICAgcmVzLnkgPSBZIC0gSCAvIDI7XG4gICAgICAgIC8vIHMgKz0gXCJcXG5Cb3R0b20gYm9yZGVyXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgfSB3aGlsZSAoZmFsc2UpO1xuXG4gICAgLy8gcyArPSBcIlxcbkNsaXBwaW5nIHBvaW50IGZvdW5kIGF0IFwiICsgcmVzLnggKyBcIiwgXCIgKyByZXMueTtcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBicmllZiAgOiBEZXRlcm1pbmVzIHdoZXRoZXIgdHdvIG5vZGVzIG92ZXJsYXAgb3Igbm90XG4gICAqIEByZXR1cm4gOiBBbW91bnQgb2Ygb3ZlcmxhcHBpbmcgKDAgPT4gbm8gb3ZlcmxhcClcbiAgICovXG4gIHZhciBub2Rlc092ZXJsYXAgPSBmdW5jdGlvbihub2RlMSwgbm9kZTIsIGRYLCBkWSkge1xuXG4gICAgaWYgKGRYID4gMCkge1xuICAgICAgdmFyIG92ZXJsYXBYID0gbm9kZTEubWF4WCAtIG5vZGUyLm1pblg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvdmVybGFwWCA9IG5vZGUyLm1heFggLSBub2RlMS5taW5YO1xuICAgIH1cblxuICAgIGlmIChkWSA+IDApIHtcbiAgICAgIHZhciBvdmVybGFwWSA9IG5vZGUxLm1heFkgLSBub2RlMi5taW5ZO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb3ZlcmxhcFkgPSBub2RlMi5tYXhZIC0gbm9kZTEubWluWTtcbiAgICB9XG5cbiAgICBpZiAob3ZlcmxhcFggPj0gMCAmJiBvdmVybGFwWSA+PSAwKSB7XG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KG92ZXJsYXBYICogb3ZlcmxhcFggKyBvdmVybGFwWSAqIG92ZXJsYXBZKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9O1xuICAgIFxuICBcbiAgLyoqXG4gICAqIEBicmllZiA6IENhbGN1bGF0ZXMgYWxsIGVkZ2UgZm9yY2VzXG4gICAqL1xuICB2YXIgY2FsY3VsYXRlRWRnZUZvcmNlcyA9IGZ1bmN0aW9uKGxheW91dEluZm8sIGN5LCBvcHRpb25zKSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIGFsbCBlZGdlc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5lZGdlU2l6ZTsgaSsrKSB7XG4gICAgICAvLyBHZXQgZWRnZSwgc291cmNlICYgdGFyZ2V0IG5vZGVzXG4gICAgICB2YXIgZWRnZSAgICAgPSBsYXlvdXRJbmZvLmxheW91dEVkZ2VzW2ldO1xuICAgICAgdmFyIHNvdXJjZUl4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbZWRnZS5zb3VyY2VJZF07XG4gICAgICB2YXIgc291cmNlICAgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW3NvdXJjZUl4XTtcbiAgICAgIHZhciB0YXJnZXRJeCA9IGxheW91dEluZm8uaWRUb0luZGV4W2VkZ2UudGFyZ2V0SWRdO1xuICAgICAgdmFyIHRhcmdldCAgID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1t0YXJnZXRJeF07XG5cbiAgICAgIC8vIEdldCBkaXJlY3Rpb24gb2YgbGluZSBjb25uZWN0aW5nIGJvdGggbm9kZSBjZW50ZXJzXG4gICAgICB2YXIgZGlyZWN0aW9uWCA9IHRhcmdldC5wb3NpdGlvblggLSBzb3VyY2UucG9zaXRpb25YO1xuICAgICAgdmFyIGRpcmVjdGlvblkgPSB0YXJnZXQucG9zaXRpb25ZIC0gc291cmNlLnBvc2l0aW9uWTtcbiAgICAgIFxuICAgICAgLy8gSWYgYm90aCBjZW50ZXJzIGFyZSB0aGUgc2FtZSwgZG8gbm90aGluZy5cbiAgICAgIC8vIEEgcmFuZG9tIGZvcmNlIGhhcyBhbHJlYWR5IGJlZW4gYXBwbGllZCBhcyBub2RlIHJlcHVsc2lvblxuICAgICAgaWYgKDAgPT09IGRpcmVjdGlvblggJiYgMCA9PT0gZGlyZWN0aW9uWSkge1xuICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBHZXQgY2xpcHBpbmcgcG9pbnRzIGZvciBib3RoIG5vZGVzXG4gICAgICB2YXIgcG9pbnQxID0gZmluZENsaXBwaW5nUG9pbnQoc291cmNlLCBkaXJlY3Rpb25YLCBkaXJlY3Rpb25ZKTtcbiAgICAgIHZhciBwb2ludDIgPSBmaW5kQ2xpcHBpbmdQb2ludCh0YXJnZXQsIC0xICogZGlyZWN0aW9uWCwgLTEgKiBkaXJlY3Rpb25ZKTtcblxuXG4gICAgICB2YXIgbHggPSBwb2ludDIueCAtIHBvaW50MS54O1xuICAgICAgdmFyIGx5ID0gcG9pbnQyLnkgLSBwb2ludDEueTtcbiAgICAgIHZhciBsICA9IE1hdGguc3FydChseCAqIGx4ICsgbHkgKiBseSk7XG5cbiAgICAgIHZhciBmb3JjZSAgPSBNYXRoLnBvdyhlZGdlLmlkZWFsTGVuZ3RoIC0gbCwgMikgLyBvcHRpb25zLmVkZ2VFbGFzdGljaXR5OyBcblxuICAgICAgaWYgKDAgIT09IGwpIHtcbiAgICAgICAgdmFyIGZvcmNlWCA9IGZvcmNlICogbHggLyBsO1xuICAgICAgICB2YXIgZm9yY2VZID0gZm9yY2UgKiBseSAvIGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZm9yY2VYID0gMDtcbiAgICAgICAgdmFyIGZvcmNlWSA9IDA7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCB0aGlzIGZvcmNlIHRvIHRhcmdldCBhbmQgc291cmNlIG5vZGVzXG4gICAgICBzb3VyY2Uub2Zmc2V0WCArPSBmb3JjZVg7XG4gICAgICBzb3VyY2Uub2Zmc2V0WSArPSBmb3JjZVk7XG4gICAgICB0YXJnZXQub2Zmc2V0WCAtPSBmb3JjZVg7XG4gICAgICB0YXJnZXQub2Zmc2V0WSAtPSBmb3JjZVk7XG5cbiAgICAgIC8vIHZhciBzID0gJ0VkZ2UgZm9yY2UgYmV0d2VlbiBub2RlcyAnICsgc291cmNlLmlkICsgJyBhbmQgJyArIHRhcmdldC5pZDtcbiAgICAgIC8vIHMgKz0gXCJcXG5EaXN0YW5jZTogXCIgKyBsICsgXCIgRm9yY2U6IChcIiArIGZvcmNlWCArIFwiLCBcIiArIGZvcmNlWSArIFwiKVwiO1xuICAgICAgLy8gbG9nRGVidWcocyk7XG4gICAgfVxuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBicmllZiA6IENvbXB1dGVzIGdyYXZpdHkgZm9yY2VzIGZvciBhbGwgbm9kZXNcbiAgICovXG4gIHZhciBjYWxjdWxhdGVHcmF2aXR5Rm9yY2VzID0gZnVuY3Rpb24obGF5b3V0SW5mbywgY3ksIG9wdGlvbnMpIHtcbiAgICAvLyB2YXIgcyA9ICdjYWxjdWxhdGVHcmF2aXR5Rm9yY2VzJztcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8uZ3JhcGhTZXQubGVuZ3RoOyBpICsrKSB7XG4gICAgICB2YXIgZ3JhcGggICAgPSBsYXlvdXRJbmZvLmdyYXBoU2V0W2ldO1xuICAgICAgdmFyIG51bU5vZGVzID0gZ3JhcGgubGVuZ3RoO1xuXG4gICAgICAvLyBzID0gXCJTZXQ6IFwiICsgZ3JhcGgudG9TdHJpbmcoKTtcbiAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgICAgICAgIFxuICAgICAgLy8gQ29tcHV0ZSBncmFwaCBjZW50ZXJcbiAgICAgIGlmICgwID09PSBpKSB7XG4gICAgICAgIHZhciBjZW50ZXJYICAgPSBsYXlvdXRJbmZvLmNsaWVudEhlaWdodCAvIDI7XG4gICAgICAgIHZhciBjZW50ZXJZICAgPSBsYXlvdXRJbmZvLmNsaWVudFdpZHRoICAvIDI7ICAgIFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gR2V0IFBhcmVudCBub2RlIGZvciB0aGlzIGdyYXBoLCBhbmQgdXNlIGl0cyBwb3NpdGlvbiBhcyBjZW50ZXJcbiAgICAgICAgdmFyIHRlbXAgICAgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W2dyYXBoWzBdXV07XG4gICAgICAgIHZhciBwYXJlbnQgID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFt0ZW1wLnBhcmVudElkXV07XG4gICAgICAgIHZhciBjZW50ZXJYID0gcGFyZW50LnBvc2l0aW9uWDtcbiAgICAgICAgdmFyIGNlbnRlclkgPSBwYXJlbnQucG9zaXRpb25ZO1xuICAgICAgfVxuICAgICAgLy8gcyA9IFwiQ2VudGVyIGZvdW5kIGF0OiBcIiArIGNlbnRlclggKyBcIiwgXCIgKyBjZW50ZXJZO1xuICAgICAgLy8gbG9nRGVidWcocyk7XG5cbiAgICAgIC8vIEFwcGx5IGZvcmNlIHRvIGFsbCBub2RlcyBpbiBncmFwaFxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1Ob2RlczsgaisrKSB7XG4gICAgICAgIHZhciBub2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtncmFwaFtqXV1dO1xuICAgICAgICAvLyBzID0gXCJOb2RlOiBcIiArIG5vZGUuaWQ7XG4gICAgICAgIHZhciBkeCA9IGNlbnRlclggLSBub2RlLnBvc2l0aW9uWDtcbiAgICAgICAgdmFyIGR5ID0gY2VudGVyWSAtIG5vZGUucG9zaXRpb25ZO1xuICAgICAgICB2YXIgZCAgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICBpZiAoZCA+IDEuMCkgeyAvLyBUT0RPOiBVc2UgZ2xvYmFsIHZhcmlhYmxlIGZvciBkaXN0YW5jZSB0aHJlc2hvbGRcbiAgICAgICAgICB2YXIgZnggPSBvcHRpb25zLmdyYXZpdHkgKiBkeCAvIGQ7XG4gICAgICAgICAgdmFyIGZ5ID0gb3B0aW9ucy5ncmF2aXR5ICogZHkgLyBkO1xuICAgICAgICAgIG5vZGUub2Zmc2V0WCArPSBmeDtcbiAgICAgICAgICBub2RlLm9mZnNldFkgKz0gZnk7XG4gICAgICAgICAgLy8gcyArPSBcIjogQXBwbGllZCBmb3JjZTogXCIgKyBmeCArIFwiLCBcIiArIGZ5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHMgKz0gXCI6IHNreXBwZWQgc2luY2UgaXQncyB0b28gY2xvc2UgdG8gY2VudGVyXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG9nRGVidWcocyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBicmllZiAgICAgICAgICA6IFRoaXMgZnVuY3Rpb24gcHJvcGFnYXRlcyB0aGUgZXhpc3Rpbmcgb2Zmc2V0cyBmcm9tIFxuICAgKiAgICAgICAgICAgICAgICAgICBwYXJlbnQgbm9kZXMgdG8gaXRzIGRlc2NlbmRlbnRzLlxuICAgKiBAYXJnIGxheW91dEluZm8gOiBsYXlvdXRJbmZvIE9iamVjdFxuICAgKiBAYXJnIGN5ICAgICAgICAgOiBjeXRvc2NhcGUgT2JqZWN0XG4gICAqIEBhcmcgb3B0aW9ucyAgICA6IExheW91dCBvcHRpb25zXG4gICAqL1xuICB2YXIgcHJvcGFnYXRlRm9yY2VzID0gZnVuY3Rpb24obGF5b3V0SW5mbywgY3ksIG9wdGlvbnMpIHsgIFxuICAgIC8vIElubGluZSBpbXBsZW1lbnRhdGlvbiBvZiBhIHF1ZXVlLCB1c2VkIGZvciB0cmF2ZXJzaW5nIHRoZSBncmFwaCBpbiBCRlMgb3JkZXJcbiAgICB2YXIgcXVldWUgPSBbXTtcbiAgICB2YXIgc3RhcnQgPSAwOyAgIC8vIFBvaW50cyB0byB0aGUgc3RhcnQgdGhlIHF1ZXVlXG4gICAgdmFyIGVuZCAgID0gLTE7ICAvLyBQb2ludHMgdG8gdGhlIGVuZCBvZiB0aGUgcXVldWVcblxuICAgIC8vIGxvZ0RlYnVnKCdwcm9wYWdhdGVGb3JjZXMnKTtcblxuICAgIC8vIFN0YXJ0IGJ5IHZpc2l0aW5nIHRoZSBub2RlcyBpbiB0aGUgcm9vdCBncmFwaFxuICAgIHF1ZXVlLnB1c2guYXBwbHkocXVldWUsIGxheW91dEluZm8uZ3JhcGhTZXRbMF0pO1xuICAgIGVuZCArPSBsYXlvdXRJbmZvLmdyYXBoU2V0WzBdLmxlbmd0aDtcblxuICAgIC8vIFRyYXZlcnNlIHRoZSBncmFwaCwgbGV2ZWwgYnkgbGV2ZWwsIFxuICAgIHdoaWxlIChzdGFydCA8PSBlbmQpIHtcbiAgICAgIC8vIEdldCB0aGUgbm9kZSB0byB2aXNpdCBhbmQgcmVtb3ZlIGl0IGZyb20gcXVldWVcbiAgICAgIHZhciBub2RlSWQgICAgPSBxdWV1ZVtzdGFydCsrXTtcbiAgICAgIHZhciBub2RlSW5kZXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFtub2RlSWRdO1xuICAgICAgdmFyIG5vZGUgICAgICA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbm9kZUluZGV4XTtcbiAgICAgIHZhciBjaGlsZHJlbiAgPSBub2RlLmNoaWxkcmVuO1xuXG4gICAgICAvLyBXZSBvbmx5IG5lZWQgdG8gcHJvY2VzcyB0aGUgbm9kZSBpZiBpdCdzIGNvbXBvdW5kXG4gICAgICBpZiAoMCA8IGNoaWxkcmVuLmxlbmd0aCkgeyAgICBcbiAgICAgIHZhciBvZmZYID0gbm9kZS5vZmZzZXRYO1xuICAgICAgdmFyIG9mZlkgPSBub2RlLm9mZnNldFk7XG5cbiAgICAgIC8vIHZhciBzID0gXCJQcm9wYWdhdGluZyBvZmZzZXQgZnJvbSBwYXJlbnQgbm9kZSA6IFwiICsgbm9kZS5pZCArIFxuICAgICAgLy8gICBcIi4gT2Zmc2V0WDogXCIgKyBvZmZYICsgXCIuIE9mZnNldFk6IFwiICsgb2ZmWTtcbiAgICAgIC8vIHMgKz0gXCJcXG4gQ2hpbGRyZW46IFwiICsgY2hpbGRyZW4udG9TdHJpbmcoKTtcbiAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgICAgXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZE5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W2NoaWxkcmVuW2ldXV07XG4gICAgICAgIC8vIFByb3BhZ2F0ZSBvZmZzZXRcbiAgICAgICAgY2hpbGROb2RlLm9mZnNldFggKz0gb2ZmWDtcbiAgICAgICAgY2hpbGROb2RlLm9mZnNldFkgKz0gb2ZmWTtcbiAgICAgICAgLy8gQWRkIGNoaWxkcmVuIHRvIHF1ZXVlIHRvIGJlIHZpc2l0ZWRcbiAgICAgICAgcXVldWVbKytlbmRdID0gY2hpbGRyZW5baV07XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFJlc2V0IHBhcmVudCBvZmZzZXRzXG4gICAgICBub2RlLm9mZnNldFggPSAwO1xuICAgICAgbm9kZS5vZmZzZXRZID0gMDtcbiAgICAgIH1cbiAgICAgIFxuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAYnJpZWYgOiBVcGRhdGVzIHRoZSBsYXlvdXQgbW9kZWwgcG9zaXRpb25zLCBiYXNlZCBvbiBcbiAgICogICAgICAgICAgdGhlIGFjY3VtdWxhdGVkIGZvcmNlc1xuICAgKi9cbiAgdmFyIHVwZGF0ZVBvc2l0aW9ucyA9IGZ1bmN0aW9uKGxheW91dEluZm8sIGN5LCBvcHRpb25zKSB7XG4gICAgLy8gdmFyIHMgPSAnVXBkYXRpbmcgcG9zaXRpb25zJztcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAgIC8vIFJlc2V0IGJvdW5kYXJpZXMgZm9yIGNvbXBvdW5kIG5vZGVzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKyspIHtcbiAgICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tpXTtcbiAgICAgIGlmICgwIDwgbi5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgLy8gbG9nRGVidWcoXCJSZXNldHRpbmcgYm91bmRhcmllcyBvZiBjb21wb3VuZCBub2RlOiBcIiArIG4uaWQpO1xuICAgICAgICBuLm1heFggPSB1bmRlZmluZWQ7XG4gICAgICAgIG4ubWluWCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbi5tYXhZID0gdW5kZWZpbmVkO1xuICAgICAgICBuLm1pblkgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKyspIHtcbiAgICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tpXTtcbiAgICAgIGlmICgwIDwgbi5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgLy8gTm8gbmVlZCB0byBzZXQgY29tcG91bmQgbm9kZSBwb3NpdGlvblxuICAgICAgICAvLyBsb2dEZWJ1ZyhcIlNraXBwaW5nIHBvc2l0aW9uIHVwZGF0ZSBvZiBub2RlOiBcIiArIG4uaWQpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIHMgPSBcIk5vZGU6IFwiICsgbi5pZCArIFwiIFByZXZpb3VzIHBvc2l0aW9uOiAoXCIgKyBcbiAgICAgIC8vIG4ucG9zaXRpb25YICsgXCIsIFwiICsgbi5wb3NpdGlvblkgKyBcIikuXCI7IFxuXG4gICAgICAvLyBMaW1pdCBkaXNwbGFjZW1lbnQgaW4gb3JkZXIgdG8gaW1wcm92ZSBzdGFiaWxpdHlcbiAgICAgIHZhciB0ZW1wRm9yY2UgPSBsaW1pdEZvcmNlKG4ub2Zmc2V0WCwgbi5vZmZzZXRZLCBsYXlvdXRJbmZvLnRlbXBlcmF0dXJlKTtcbiAgICAgIG4ucG9zaXRpb25YICs9IHRlbXBGb3JjZS54OyBcbiAgICAgIG4ucG9zaXRpb25ZICs9IHRlbXBGb3JjZS55O1xuICAgICAgbi5vZmZzZXRYID0gMDtcbiAgICAgIG4ub2Zmc2V0WSA9IDA7XG4gICAgICBuLm1pblggICAgPSBuLnBvc2l0aW9uWCAtIG4ud2lkdGg7IFxuICAgICAgbi5tYXhYICAgID0gbi5wb3NpdGlvblggKyBuLndpZHRoOyBcbiAgICAgIG4ubWluWSAgICA9IG4ucG9zaXRpb25ZIC0gbi5oZWlnaHQ7IFxuICAgICAgbi5tYXhZICAgID0gbi5wb3NpdGlvblkgKyBuLmhlaWdodDsgXG4gICAgICAvLyBzICs9IFwiIE5ldyBQb3NpdGlvbjogKFwiICsgbi5wb3NpdGlvblggKyBcIiwgXCIgKyBuLnBvc2l0aW9uWSArIFwiKS5cIjtcbiAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgICAvLyBVcGRhdGUgYW5jZXN0cnkgYm91ZGFyaWVzXG4gICAgICB1cGRhdGVBbmNlc3RyeUJvdW5kYXJpZXMobiwgbGF5b3V0SW5mbyk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHNpemUsIHBvc2l0aW9uIG9mIGNvbXB1bmQgbm9kZXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgICAgdmFyIG4gPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2ldO1xuICAgICAgaWYgKDAgPCBuLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICBuLnBvc2l0aW9uWCA9IChuLm1heFggKyBuLm1pblgpIC8gMjtcbiAgICAgICAgbi5wb3NpdGlvblkgPSAobi5tYXhZICsgbi5taW5ZKSAvIDI7XG4gICAgICAgIG4ud2lkdGggICAgID0gbi5tYXhYIC0gbi5taW5YO1xuICAgICAgICBuLmhlaWdodCAgICA9IG4ubWF4WSAtIG4ubWluWTtcbiAgICAgICAgLy8gcyA9IFwiVXBkYXRpbmcgcG9zaXRpb24sIHNpemUgb2YgY29tcG91bmQgbm9kZSBcIiArIG4uaWQ7XG4gICAgICAgIC8vIHMgKz0gXCJcXG5Qb3NpdGlvblg6IFwiICsgbi5wb3NpdGlvblggKyBcIiwgUG9zaXRpb25ZOiBcIiArIG4ucG9zaXRpb25ZO1xuICAgICAgICAvLyBzICs9IFwiXFxuV2lkdGg6IFwiICsgbi53aWR0aCArIFwiLCBIZWlnaHQ6IFwiICsgbi5oZWlnaHQ7XG4gICAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgICAgfVxuICAgIH0gIFxuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBicmllZiA6IExpbWl0cyBhIGZvcmNlIChmb3JjZVgsIGZvcmNlWSkgdG8gYmUgbm90IFxuICAgKiAgICAgICAgICBncmVhdGVyIChpbiBtb2R1bG8pIHRoYW4gbWF4LiBcbiAgIDggICAgICAgICAgUHJlc2VydmVzIGZvcmNlIGRpcmVjdGlvbi4gXG4gICAqL1xuICB2YXIgbGltaXRGb3JjZSA9IGZ1bmN0aW9uKGZvcmNlWCwgZm9yY2VZLCBtYXgpIHtcbiAgICAvLyB2YXIgcyA9IFwiTGltaXRpbmcgZm9yY2U6IChcIiArIGZvcmNlWCArIFwiLCBcIiArIGZvcmNlWSArIFwiKS4gTWF4OiBcIiArIG1heDtcbiAgICB2YXIgZm9yY2UgPSBNYXRoLnNxcnQoZm9yY2VYICogZm9yY2VYICsgZm9yY2VZICogZm9yY2VZKTtcblxuICAgIGlmIChmb3JjZSA+IG1heCkge1xuICAgICAgdmFyIHJlcyA9IHtcbiAgICAgIHggOiBtYXggKiBmb3JjZVggLyBmb3JjZSxcbiAgICAgIHkgOiBtYXggKiBmb3JjZVkgLyBmb3JjZVxuICAgICAgfTsgICAgICBcblxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmVzID0ge1xuICAgICAgeCA6IGZvcmNlWCxcbiAgICAgIHkgOiBmb3JjZVlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gcyArPSBcIi5cXG5SZXN1bHQ6IChcIiArIHJlcy54ICsgXCIsIFwiICsgcmVzLnkgKyBcIilcIjtcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cblxuICAvKipcbiAgICogQGJyaWVmIDogRnVuY3Rpb24gdXNlZCBmb3Iga2VlcGluZyB0cmFjayBvZiBjb21wb3VuZCBub2RlIFxuICAgKiAgICAgICAgICBzaXplcywgc2luY2UgdGhleSBzaG91bGQgYm91bmQgYWxsIHRoZWlyIHN1Ym5vZGVzLlxuICAgKi9cbiAgdmFyIHVwZGF0ZUFuY2VzdHJ5Qm91bmRhcmllcyA9IGZ1bmN0aW9uKG5vZGUsIGxheW91dEluZm8pIHtcbiAgICAvLyB2YXIgcyA9IFwiUHJvcGFnYXRpbmcgbmV3IHBvc2l0aW9uL3NpemUgb2Ygbm9kZSBcIiArIG5vZGUuaWQ7XG4gICAgdmFyIHBhcmVudElkID0gbm9kZS5wYXJlbnRJZDtcbiAgICBpZiAobnVsbCA9PSBwYXJlbnRJZCkge1xuICAgICAgLy8gSWYgdGhlcmUncyBubyBwYXJlbnQsIHdlIGFyZSBkb25lXG4gICAgICAvLyBzICs9IFwiLiBObyBwYXJlbnQgbm9kZS5cIjtcbiAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEdldCBQYXJlbnQgTm9kZVxuICAgIHZhciBwID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtwYXJlbnRJZF1dO1xuICAgIHZhciBmbGFnID0gZmFsc2U7XG5cbiAgICAvLyBNYXhYXG4gICAgaWYgKG51bGwgPT0gcC5tYXhYIHx8IG5vZGUubWF4WCArIHAucGFkUmlnaHQgPiBwLm1heFgpIHtcbiAgICAgIHAubWF4WCA9IG5vZGUubWF4WCArIHAucGFkUmlnaHQ7XG4gICAgICBmbGFnID0gdHJ1ZTtcbiAgICAgIC8vIHMgKz0gXCJcXG5OZXcgbWF4WCBmb3IgcGFyZW50IG5vZGUgXCIgKyBwLmlkICsgXCI6IFwiICsgcC5tYXhYO1xuICAgIH1cblxuICAgIC8vIE1pblhcbiAgICBpZiAobnVsbCA9PSBwLm1pblggfHwgbm9kZS5taW5YIC0gcC5wYWRMZWZ0IDwgcC5taW5YKSB7XG4gICAgICBwLm1pblggPSBub2RlLm1pblggLSBwLnBhZExlZnQ7XG4gICAgICBmbGFnID0gdHJ1ZTtcbiAgICAgIC8vIHMgKz0gXCJcXG5OZXcgbWluWCBmb3IgcGFyZW50IG5vZGUgXCIgKyBwLmlkICsgXCI6IFwiICsgcC5taW5YO1xuICAgIH1cblxuICAgIC8vIE1heFlcbiAgICBpZiAobnVsbCA9PSBwLm1heFkgfHwgbm9kZS5tYXhZICsgcC5wYWRCb3R0b20gPiBwLm1heFkpIHtcbiAgICAgIHAubWF4WSA9IG5vZGUubWF4WSArIHAucGFkQm90dG9tO1xuICAgICAgZmxhZyA9IHRydWU7XG4gICAgICAvLyBzICs9IFwiXFxuTmV3IG1heFkgZm9yIHBhcmVudCBub2RlIFwiICsgcC5pZCArIFwiOiBcIiArIHAubWF4WTtcbiAgICB9XG5cbiAgICAvLyBNaW5ZXG4gICAgaWYgKG51bGwgPT0gcC5taW5ZIHx8IG5vZGUubWluWSAtIHAucGFkVG9wIDwgcC5taW5ZKSB7XG4gICAgICBwLm1pblkgPSBub2RlLm1pblkgLSBwLnBhZFRvcDtcbiAgICAgIGZsYWcgPSB0cnVlO1xuICAgICAgLy8gcyArPSBcIlxcbk5ldyBtaW5ZIGZvciBwYXJlbnQgbm9kZSBcIiArIHAuaWQgKyBcIjogXCIgKyBwLm1pblk7XG4gICAgfVxuXG4gICAgLy8gSWYgdXBkYXRlZCBib3VuZGFyaWVzLCBwcm9wYWdhdGUgY2hhbmdlcyB1cHdhcmRcbiAgICBpZiAoZmxhZykge1xuICAgICAgLy8gbG9nRGVidWcocyk7XG4gICAgICByZXR1cm4gdXBkYXRlQW5jZXN0cnlCb3VuZGFyaWVzKHAsIGxheW91dEluZm8pO1xuICAgIH0gXG5cbiAgICAvLyBzICs9IFwiLiBObyBjaGFuZ2VzIGluIGJvdW5kYXJpZXMvcG9zaXRpb24gb2YgcGFyZW50IG5vZGUgXCIgKyBwLmlkOyAgXG4gICAgLy8gbG9nRGVidWcocyk7XG4gICAgcmV0dXJuO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBicmllZiA6IExvZ3MgYSBkZWJ1ZyBtZXNzYWdlIGluIEpTIGNvbnNvbGUsIGlmIERFQlVHIGlzIE9OXG4gICAqL1xuICAvLyB2YXIgbG9nRGVidWcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gIC8vICAgaWYgKERFQlVHKSB7XG4gIC8vICAgICBjb25zb2xlLmRlYnVnKHRleHQpO1xuICAvLyAgIH1cbiAgLy8gfTtcblxuXG4gIC8vIHJlZ2lzdGVyIHRoZSBsYXlvdXRcbiAgJCQoJ2xheW91dCcsICdjb3NlJywgQ29zZUxheW91dCk7XG5cbn0pKGN5dG9zY2FwZSk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgLy8gZGVmYXVsdCBsYXlvdXQgb3B0aW9uc1xuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgLy8gZGFncmUgYWxnbyBvcHRpb25zLCB1c2VzIGRlZmF1bHQgdmFsdWUgb24gdW5kZWZpbmVkXG4gICAgbm9kZVNlcDogdW5kZWZpbmVkLCAvLyB0aGUgc2VwYXJhdGlvbiBiZXR3ZWVuIGFkamFjZW50IG5vZGVzIGluIHRoZSBzYW1lIHJhbmtcbiAgICBlZGdlU2VwOiB1bmRlZmluZWQsIC8vIHRoZSBzZXBhcmF0aW9uIGJldHdlZW4gYWRqYWNlbnQgZWRnZXMgaW4gdGhlIHNhbWUgcmFua1xuICAgIHJhbmtTZXA6IHVuZGVmaW5lZCwgLy8gdGhlIHNlcGFyYXRpb24gYmV0d2VlbiBhZGphY2VudCBub2RlcyBpbiB0aGUgc2FtZSByYW5rXG4gICAgcmFua0RpcjogdW5kZWZpbmVkLCAvLyAnVEInIGZvciB0b3AgdG8gYm90dG9tIGZsb3csICdMUicgZm9yIGxlZnQgdG8gcmlnaHRcbiAgICBtaW5MZW46IGZ1bmN0aW9uKCBlZGdlICl7IHJldHVybiAxOyB9LCAvLyBudW1iZXIgb2YgcmFua3MgdG8ga2VlcCBiZXR3ZWVuIHRoZSBzb3VyY2UgYW5kIHRhcmdldCBvZiB0aGUgZWRnZVxuICAgIGVkZ2VXZWlnaHQ6IGZ1bmN0aW9uKCBlZGdlICl7IHJldHVybiAxOyB9LCAvLyBoaWdoZXIgd2VpZ2h0IGVkZ2VzIGFyZSBnZW5lcmFsbHkgbWFkZSBzaG9ydGVyIGFuZCBzdHJhaWdodGVyIHRoYW4gbG93ZXIgd2VpZ2h0IGVkZ2VzXG4gICAgXG4gICAgLy8gZ2VuZXJhbCBsYXlvdXQgb3B0aW9uc1xuICAgIGZpdDogdHJ1ZSwgLy8gd2hldGhlciB0byBmaXQgdG8gdmlld3BvcnRcbiAgICBwYWRkaW5nOiAzMCwgLy8gZml0IHBhZGRpbmdcbiAgICBhbmltYXRlOiBmYWxzZSwgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsIC8vIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcyBpZiBlbmFibGVkXG4gICAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCwgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gICAgcmVhZHk6IGZ1bmN0aW9uKCl7fSwgLy8gb24gbGF5b3V0cmVhZHlcbiAgICBzdG9wOiBmdW5jdGlvbigpe30gLy8gb24gbGF5b3V0c3RvcFxuICB9O1xuXG4gIC8vIGNvbnN0cnVjdG9yXG4gIC8vIG9wdGlvbnMgOiBvYmplY3QgY29udGFpbmluZyBsYXlvdXQgb3B0aW9uc1xuICBmdW5jdGlvbiBEYWdyZUxheW91dCggb3B0aW9ucyApe1xuICAgIHRoaXMub3B0aW9ucyA9ICQkLnV0aWwuZXh0ZW5kKHRydWUsIHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7IFxuICB9XG5cbiAgLy8gcnVucyB0aGUgbGF5b3V0XG4gIERhZ3JlTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpe1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIHZhciBsYXlvdXQgPSB0aGlzO1xuXG4gICAgJCQudXRpbC5yZXF1aXJlKCdkYWdyZScsIGZ1bmN0aW9uKGRhZ3JlKXtcblxuICAgICAgdmFyIGN5ID0gb3B0aW9ucy5jeTsgLy8gY3kgaXMgYXV0b21hdGljYWxseSBwb3B1bGF0ZWQgZm9yIHVzIGluIHRoZSBjb25zdHJ1Y3RvclxuICAgICAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG5cbiAgICAgIHZhciBnZXRWYWwgPSBmdW5jdGlvbiggZWxlLCB2YWwgKXtcbiAgICAgICAgcmV0dXJuICQkLmlzLmZuKHZhbCkgPyB2YWwuYXBwbHkoIGVsZSwgWyBlbGUgXSApIDogdmFsO1xuICAgICAgfTtcblxuICAgICAgdmFyIGJiID0gJCQudXRpbC5tYWtlQm91bmRpbmdCb3goIG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgICAgICB4MTogMCwgeTE6IDAsIHc6IGN5LndpZHRoKCksIGg6IGN5LmhlaWdodCgpXG4gICAgICB9ICk7XG5cbiAgICAgIHZhciBnID0gbmV3IGRhZ3JlLmdyYXBobGliLkdyYXBoKHtcbiAgICAgICAgbXVsdGlncmFwaDogdHJ1ZSxcbiAgICAgICAgY29tcG91bmQ6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgZ09iaiA9IHt9O1xuICAgICAgdmFyIHNldEdPYmogPSBmdW5jdGlvbiggbmFtZSwgdmFsICl7XG4gICAgICAgIGlmKCB2YWwgIT0gbnVsbCApe1xuICAgICAgICAgIGdPYmpbIG5hbWUgXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgc2V0R09iaiggJ25vZGVzZXAnLCBvcHRpb25zLm5vZGVTZXAgKTtcbiAgICAgIHNldEdPYmooICdlZGdlc2VwJywgb3B0aW9ucy5lZGdlU2VwICk7XG4gICAgICBzZXRHT2JqKCAncmFua3NlcCcsIG9wdGlvbnMucmFua1NlcCApO1xuICAgICAgc2V0R09iaiggJ3JhbmtkaXInLCBvcHRpb25zLnJhbmtEaXIgKTtcblxuICAgICAgZy5zZXRHcmFwaCggZ09iaiApO1xuXG4gICAgICBnLnNldERlZmF1bHRFZGdlTGFiZWwoZnVuY3Rpb24oKSB7IHJldHVybiB7fTsgfSk7XG4gICAgICBnLnNldERlZmF1bHROb2RlTGFiZWwoZnVuY3Rpb24oKSB7IHJldHVybiB7fTsgfSk7XG5cbiAgICAgIC8vIGFkZCBub2RlcyB0byBkYWdyZVxuICAgICAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpO1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuXG4gICAgICAgIGcuc2V0Tm9kZSggbm9kZS5pZCgpLCB7XG4gICAgICAgICAgd2lkdGg6IG5vZGUud2lkdGgoKSxcbiAgICAgICAgICBoZWlnaHQ6IG5vZGUuaGVpZ2h0KCksXG4gICAgICAgICAgbmFtZTogbm9kZS5pZCgpXG4gICAgICAgIH0gKTtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZyggZy5ub2RlKG5vZGUuaWQoKSkgKTtcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IGNvbXBvdW5kIHBhcmVudHNcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcblxuICAgICAgICBpZiggbm9kZS5pc0NoaWxkKCkgKXtcbiAgICAgICAgICBnLnNldFBhcmVudCggbm9kZS5pZCgpLCBub2RlLnBhcmVudCgpLmlkKCkgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBhZGQgZWRnZXMgdG8gZGFncmVcbiAgICAgIHZhciBlZGdlcyA9IGVsZXMuZWRnZXMoKS5zdGRGaWx0ZXIoZnVuY3Rpb24oIGVkZ2UgKXtcbiAgICAgICAgcmV0dXJuICFlZGdlLnNvdXJjZSgpLmlzUGFyZW50KCkgJiYgIWVkZ2UudGFyZ2V0KCkuaXNQYXJlbnQoKTsgLy8gZGFncmUgY2FuJ3QgaGFuZGxlIGVkZ2VzIG9uIGNvbXBvdW5kIG5vZGVzXG4gICAgICB9KTtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tpXTtcblxuICAgICAgICBnLnNldEVkZ2UoIGVkZ2Uuc291cmNlKCkuaWQoKSwgZWRnZS50YXJnZXQoKS5pZCgpLCB7XG4gICAgICAgICAgbWlubGVuOiBnZXRWYWwoIGVkZ2UsIG9wdGlvbnMubWluTGVuICksXG4gICAgICAgICAgd2VpZ2h0OiBnZXRWYWwoIGVkZ2UsIG9wdGlvbnMuZWRnZVdlaWdodCApLFxuICAgICAgICAgIG5hbWU6IGVkZ2UuaWQoKVxuICAgICAgICB9LCBlZGdlLmlkKCkgKTtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZyggZy5lZGdlKGVkZ2Uuc291cmNlKCkuaWQoKSwgZWRnZS50YXJnZXQoKS5pZCgpLCBlZGdlLmlkKCkpICk7XG4gICAgICB9XG5cbiAgICAgIGRhZ3JlLmxheW91dCggZyApO1xuXG4gICAgICB2YXIgZ05vZGVJZHMgPSBnLm5vZGVzKCk7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGdOb2RlSWRzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBpZCA9IGdOb2RlSWRzW2ldO1xuICAgICAgICB2YXIgbiA9IGcubm9kZSggaWQgKTtcblxuICAgICAgICBjeS5nZXRFbGVtZW50QnlJZChpZCkuc2NyYXRjaCgpLmRhZ3JlID0gbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGRhZ3JlQkI7XG5cbiAgICAgIGlmKCBvcHRpb25zLmJvdW5kaW5nQm94ICl7XG4gICAgICAgIGRhZ3JlQkIgPSB7IHgxOiBJbmZpbml0eSwgeDI6IC1JbmZpbml0eSwgeTE6IEluZmluaXR5LCB5MjogLUluZmluaXR5IH07XG4gICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24oIG5vZGUgKXtcbiAgICAgICAgICB2YXIgZE1vZGVsID0gbm9kZS5zY3JhdGNoKCkuZGFncmU7XG5cbiAgICAgICAgICBkYWdyZUJCLngxID0gTWF0aC5taW4oIGRhZ3JlQkIueDEsIGRNb2RlbC54ICk7XG4gICAgICAgICAgZGFncmVCQi54MiA9IE1hdGgubWF4KCBkYWdyZUJCLngyLCBkTW9kZWwueCApO1xuXG4gICAgICAgICAgZGFncmVCQi55MSA9IE1hdGgubWluKCBkYWdyZUJCLnkxLCBkTW9kZWwueSApO1xuICAgICAgICAgIGRhZ3JlQkIueTIgPSBNYXRoLm1heCggZGFncmVCQi55MiwgZE1vZGVsLnkgKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGFncmVCQi53ID0gZGFncmVCQi54MiAtIGRhZ3JlQkIueDE7XG4gICAgICAgIGRhZ3JlQkIuaCA9IGRhZ3JlQkIueTIgLSBkYWdyZUJCLnkxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGFncmVCQiA9IGJiO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29uc3RyYWluUG9zID0gZnVuY3Rpb24oIHAgKXtcbiAgICAgICAgaWYoIG9wdGlvbnMuYm91bmRpbmdCb3ggKXtcbiAgICAgICAgICB2YXIgeFBjdCA9IChwLnggLSBkYWdyZUJCLngxKSAvIGRhZ3JlQkIudztcbiAgICAgICAgICB2YXIgeVBjdCA9IChwLnkgLSBkYWdyZUJCLnkxKSAvIGRhZ3JlQkIuaDtcblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBiYi54MSArIHhQY3QgKiBiYi53LFxuICAgICAgICAgICAgeTogYmIueTEgKyB5UGN0ICogYmIuaFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIG5vZGVzLmxheW91dFBvc2l0aW9ucyhsYXlvdXQsIG9wdGlvbnMsIGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBkTW9kZWwgPSB0aGlzLnNjcmF0Y2goKS5kYWdyZTtcblxuICAgICAgICByZXR1cm4gY29uc3RyYWluUG9zKHtcbiAgICAgICAgICB4OiBkTW9kZWwueCxcbiAgICAgICAgICB5OiBkTW9kZWwueVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgfSk7IC8vIHJlcXVpcmVcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuXG4gIC8vIHJlZ2lzdGVyIHRoZSBsYXlvdXRcbiAgJCQoJ2xheW91dCcsICdkYWdyZScsIERhZ3JlTGF5b3V0KTtcblxufSkoY3l0b3NjYXBlKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICBmaXQ6IHRydWUsIC8vIHdoZXRoZXIgdG8gZml0IHRoZSB2aWV3cG9ydCB0byB0aGUgZ3JhcGhcbiAgICBwYWRkaW5nOiAzMCwgLy8gcGFkZGluZyB1c2VkIG9uIGZpdFxuICAgIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICAgIGF2b2lkT3ZlcmxhcDogdHJ1ZSwgLy8gcHJldmVudHMgbm9kZSBvdmVybGFwLCBtYXkgb3ZlcmZsb3cgYm91bmRpbmdCb3ggaWYgbm90IGVub3VnaCBzcGFjZVxuICAgIHJvd3M6IHVuZGVmaW5lZCwgLy8gZm9yY2UgbnVtIG9mIHJvd3MgaW4gdGhlIGdyaWRcbiAgICBjb2x1bW5zOiB1bmRlZmluZWQsIC8vIGZvcmNlIG51bSBvZiBjb2xzIGluIHRoZSBncmlkXG4gICAgcG9zaXRpb246IGZ1bmN0aW9uKCBub2RlICl7fSwgLy8gcmV0dXJucyB7IHJvdywgY29sIH0gZm9yIGVsZW1lbnRcbiAgICBzb3J0OiB1bmRlZmluZWQsIC8vIGEgc29ydGluZyBmdW5jdGlvbiB0byBvcmRlciB0aGUgbm9kZXM7IGUuZy4gZnVuY3Rpb24oYSwgYil7IHJldHVybiBhLmRhdGEoJ3dlaWdodCcpIC0gYi5kYXRhKCd3ZWlnaHQnKSB9XG4gICAgYW5pbWF0ZTogZmFsc2UsIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgICBhbmltYXRpb25EdXJhdGlvbjogNTAwLCAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICAgIHJlYWR5OiB1bmRlZmluZWQsIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gICAgc3RvcDogdW5kZWZpbmVkIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3BcbiAgfTtcbiAgXG4gIGZ1bmN0aW9uIEdyaWRMYXlvdXQoIG9wdGlvbnMgKXtcbiAgICB0aGlzLm9wdGlvbnMgPSAkJC51dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuICB9XG4gIFxuICBHcmlkTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpe1xuICAgIHZhciBwYXJhbXMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdmFyIG9wdGlvbnMgPSBwYXJhbXM7XG4gICAgXG4gICAgdmFyIGN5ID0gcGFyYW1zLmN5O1xuICAgIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICAgIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKS5ub3QoJzpwYXJlbnQnKTtcblxuICAgIGlmKCBvcHRpb25zLnNvcnQgKXtcbiAgICAgIG5vZGVzID0gbm9kZXMuc29ydCggb3B0aW9ucy5zb3J0ICk7XG4gICAgfVxuICAgIFxuICAgIHZhciBiYiA9ICQkLnV0aWwubWFrZUJvdW5kaW5nQm94KCBvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICAgIHgxOiAwLCB5MTogMCwgdzogY3kud2lkdGgoKSwgaDogY3kuaGVpZ2h0KClcbiAgICB9ICk7XG5cbiAgICBpZiggYmIuaCA9PT0gMCB8fCBiYi53ID09PSAwKXtcbiAgICAgIG5vZGVzLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4geyB4OiBiYi54MSwgeTogYmIueTEgfTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgfSBlbHNlIHtcbiAgICAgIFxuICAgICAgLy8gd2lkdGgvaGVpZ2h0ICogc3BsaXRzXjIgPSBjZWxscyB3aGVyZSBzcGxpdHMgaXMgbnVtYmVyIG9mIHRpbWVzIHRvIHNwbGl0IHdpZHRoXG4gICAgICB2YXIgY2VsbHMgPSBub2Rlcy5zaXplKCk7XG4gICAgICB2YXIgc3BsaXRzID0gTWF0aC5zcXJ0KCBjZWxscyAqIGJiLmgvYmIudyApO1xuICAgICAgdmFyIHJvd3MgPSBNYXRoLnJvdW5kKCBzcGxpdHMgKTtcbiAgICAgIHZhciBjb2xzID0gTWF0aC5yb3VuZCggYmIudy9iYi5oICogc3BsaXRzICk7XG5cbiAgICAgIHZhciBzbWFsbCA9IGZ1bmN0aW9uKHZhbCl7XG4gICAgICAgIGlmKCB2YWwgPT0gbnVsbCApe1xuICAgICAgICAgIHJldHVybiBNYXRoLm1pbihyb3dzLCBjb2xzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbWluID0gTWF0aC5taW4ocm93cywgY29scyk7XG4gICAgICAgICAgaWYoIG1pbiA9PSByb3dzICl7XG4gICAgICAgICAgICByb3dzID0gdmFsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2xzID0gdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgdmFyIGxhcmdlID0gZnVuY3Rpb24odmFsKXtcbiAgICAgICAgaWYoIHZhbCA9PSBudWxsICl7XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHJvd3MsIGNvbHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBtYXggPSBNYXRoLm1heChyb3dzLCBjb2xzKTtcbiAgICAgICAgICBpZiggbWF4ID09IHJvd3MgKXtcbiAgICAgICAgICAgIHJvd3MgPSB2YWw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbHMgPSB2YWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBpZiByb3dzIG9yIGNvbHVtbnMgd2VyZSBzZXQgaW4gb3B0aW9ucywgdXNlIHRob3NlIHZhbHVlc1xuICAgICAgaWYoIG9wdGlvbnMucm93cyAhPSBudWxsICYmIG9wdGlvbnMuY29sdW1ucyAhPSBudWxsICl7XG4gICAgICAgIHJvd3MgPSBvcHRpb25zLnJvd3M7XG4gICAgICAgIGNvbHMgPSBvcHRpb25zLmNvbHVtbnM7XG4gICAgICB9IGVsc2UgaWYoIG9wdGlvbnMucm93cyAhPSBudWxsICYmIG9wdGlvbnMuY29sdW1ucyA9PSBudWxsICl7XG4gICAgICAgIHJvd3MgPSBvcHRpb25zLnJvd3M7XG4gICAgICAgIGNvbHMgPSBNYXRoLmNlaWwoIGNlbGxzIC8gcm93cyApO1xuICAgICAgfSBlbHNlIGlmKCBvcHRpb25zLnJvd3MgPT0gbnVsbCAmJiBvcHRpb25zLmNvbHVtbnMgIT0gbnVsbCApe1xuICAgICAgICBjb2xzID0gb3B0aW9ucy5jb2x1bW5zO1xuICAgICAgICByb3dzID0gTWF0aC5jZWlsKCBjZWxscyAvIGNvbHMgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gb3RoZXJ3aXNlIHVzZSB0aGUgYXV0b21hdGljIHZhbHVlcyBhbmQgYWRqdXN0IGFjY29yZGluZ2x5XG4gICAgICBcbiAgICAgIC8vIGlmIHJvdW5kaW5nIHdhcyB1cCwgc2VlIGlmIHdlIGNhbiByZWR1Y2Ugcm93cyBvciBjb2x1bW5zXG4gICAgICBlbHNlIGlmKCBjb2xzICogcm93cyA+IGNlbGxzICl7XG4gICAgICAgIHZhciBzbSA9IHNtYWxsKCk7XG4gICAgICAgIHZhciBsZyA9IGxhcmdlKCk7XG4gICAgICAgIFxuICAgICAgICAvLyByZWR1Y2luZyB0aGUgc21hbGwgc2lkZSB0YWtlcyBhd2F5IHRoZSBtb3N0IGNlbGxzLCBzbyB0cnkgaXQgZmlyc3RcbiAgICAgICAgaWYoIChzbSAtIDEpICogbGcgPj0gY2VsbHMgKXtcbiAgICAgICAgICBzbWFsbChzbSAtIDEpO1xuICAgICAgICB9IGVsc2UgaWYoIChsZyAtIDEpICogc20gPj0gY2VsbHMgKXtcbiAgICAgICAgICBsYXJnZShsZyAtIDEpO1xuICAgICAgICB9IFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgXG4gICAgICAgIC8vIGlmIHJvdW5kaW5nIHdhcyB0b28gbG93LCBhZGQgcm93cyBvciBjb2x1bW5zXG4gICAgICAgIHdoaWxlKCBjb2xzICogcm93cyA8IGNlbGxzICl7XG4gICAgICAgICAgdmFyIHNtID0gc21hbGwoKTtcbiAgICAgICAgICB2YXIgbGcgPSBsYXJnZSgpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIHRyeSB0byBhZGQgdG8gbGFyZ2VyIHNpZGUgZmlyc3QgKGFkZHMgbGVzcyBpbiBtdWx0aXBsaWNhdGlvbilcbiAgICAgICAgICBpZiggKGxnICsgMSkgKiBzbSA+PSBjZWxscyApe1xuICAgICAgICAgICAgbGFyZ2UobGcgKyAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc21hbGwoc20gKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIGNlbGxXaWR0aCA9IGJiLncgLyBjb2xzO1xuICAgICAgdmFyIGNlbGxIZWlnaHQgPSBiYi5oIC8gcm93cztcblxuICAgICAgaWYoIG9wdGlvbnMuYXZvaWRPdmVybGFwICl7XG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgIHZhciB3ID0gbm9kZS5vdXRlcldpZHRoKCk7XG4gICAgICAgICAgdmFyIGggPSBub2RlLm91dGVySGVpZ2h0KCk7XG5cbiAgICAgICAgICBjZWxsV2lkdGggPSBNYXRoLm1heCggY2VsbFdpZHRoLCB3ICk7XG4gICAgICAgICAgY2VsbEhlaWdodCA9IE1hdGgubWF4KCBjZWxsSGVpZ2h0LCBoICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIGNlbGxVc2VkID0ge307IC8vIGUuZy4gJ2MtMC0yJyA9PiB0cnVlXG4gICAgICBcbiAgICAgIHZhciB1c2VkID0gZnVuY3Rpb24ocm93LCBjb2wpe1xuICAgICAgICByZXR1cm4gY2VsbFVzZWRbJ2MtJyArIHJvdyArICctJyArIGNvbF0gPyB0cnVlIDogZmFsc2U7XG4gICAgICB9O1xuICAgICAgXG4gICAgICB2YXIgdXNlID0gZnVuY3Rpb24ocm93LCBjb2wpe1xuICAgICAgICBjZWxsVXNlZFsnYy0nICsgcm93ICsgJy0nICsgY29sXSA9IHRydWU7XG4gICAgICB9O1xuXG4gICAgICAvLyB0byBrZWVwIHRyYWNrIG9mIGN1cnJlbnQgY2VsbCBwb3NpdGlvblxuICAgICAgdmFyIHJvdyA9IDA7XG4gICAgICB2YXIgY29sID0gMDtcbiAgICAgIHZhciBtb3ZlVG9OZXh0Q2VsbCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGNvbCsrO1xuICAgICAgICBpZiggY29sID49IGNvbHMgKXtcbiAgICAgICAgICBjb2wgPSAwO1xuICAgICAgICAgIHJvdysrO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBnZXQgYSBjYWNoZSBvZiBhbGwgdGhlIG1hbnVhbCBwb3NpdGlvbnNcbiAgICAgIHZhciBpZDJtYW5Qb3MgPSB7fTtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgdmFyIHJjUG9zID0gb3B0aW9ucy5wb3NpdGlvbiggbm9kZSApO1xuXG4gICAgICAgIGlmKCByY1BvcyAmJiAocmNQb3Mucm93ICE9PSB1bmRlZmluZWQgfHwgcmNQb3MuY29sICE9PSB1bmRlZmluZWQpICl7IC8vIG11c3QgaGF2ZSBhdCBsZWFzdCByb3cgb3IgY29sIGRlZidkXG4gICAgICAgICAgdmFyIHBvcyA9IHtcbiAgICAgICAgICAgIHJvdzogcmNQb3Mucm93LFxuICAgICAgICAgICAgY29sOiByY1Bvcy5jb2xcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYoIHBvcy5jb2wgPT09IHVuZGVmaW5lZCApeyAvLyBmaW5kIHVudXNlZCBjb2xcbiAgICAgICAgICAgIHBvcy5jb2wgPSAwO1xuXG4gICAgICAgICAgICB3aGlsZSggdXNlZChwb3Mucm93LCBwb3MuY29sKSApe1xuICAgICAgICAgICAgICBwb3MuY29sKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmKCBwb3Mucm93ID09PSB1bmRlZmluZWQgKXsgLy8gZmluZCB1bnVzZWQgcm93XG4gICAgICAgICAgICBwb3Mucm93ID0gMDtcblxuICAgICAgICAgICAgd2hpbGUoIHVzZWQocG9zLnJvdywgcG9zLmNvbCkgKXtcbiAgICAgICAgICAgICAgcG9zLnJvdysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlkMm1hblBvc1sgbm9kZS5pZCgpIF0gPSBwb3M7XG4gICAgICAgICAgdXNlKCBwb3Mucm93LCBwb3MuY29sICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGdldFBvcyA9IGZ1bmN0aW9uKGksIGVsZW1lbnQpe1xuICAgICAgICB2YXIgeCwgeTtcblxuICAgICAgICBpZiggZWxlbWVudC5sb2NrZWQoKSB8fCBlbGVtZW50LmlzRnVsbEF1dG9QYXJlbnQoKSApe1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNlZSBpZiB3ZSBoYXZlIGEgbWFudWFsIHBvc2l0aW9uIHNldFxuICAgICAgICB2YXIgcmNQb3MgPSBpZDJtYW5Qb3NbIGVsZW1lbnQuaWQoKSBdO1xuICAgICAgICBpZiggcmNQb3MgKXtcbiAgICAgICAgICB4ID0gcmNQb3MuY29sICogY2VsbFdpZHRoICsgY2VsbFdpZHRoLzIgKyBiYi54MTtcbiAgICAgICAgICB5ID0gcmNQb3Mucm93ICogY2VsbEhlaWdodCArIGNlbGxIZWlnaHQvMiArIGJiLnkxO1xuICAgICAgICBcbiAgICAgICAgfSBlbHNlIHsgLy8gb3RoZXJ3aXNlIHNldCBhdXRvbWF0aWNhbGx5XG4gICAgICAgIFxuICAgICAgICAgIHdoaWxlKCB1c2VkKHJvdywgY29sKSApe1xuICAgICAgICAgICAgbW92ZVRvTmV4dENlbGwoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB4ID0gY29sICogY2VsbFdpZHRoICsgY2VsbFdpZHRoLzIgKyBiYi54MTtcbiAgICAgICAgICB5ID0gcm93ICogY2VsbEhlaWdodCArIGNlbGxIZWlnaHQvMiArIGJiLnkxO1xuICAgICAgICAgIHVzZSggcm93LCBjb2wgKTtcbiAgICAgICAgICBcbiAgICAgICAgICBtb3ZlVG9OZXh0Q2VsbCgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4geyB4OiB4LCB5OiB5IH07XG4gICAgICAgIFxuICAgICAgfTtcblxuICAgICAgbm9kZXMubGF5b3V0UG9zaXRpb25zKCB0aGlzLCBvcHRpb25zLCBnZXRQb3MgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICBcbiAgfTtcbiAgXG4gICQkKCdsYXlvdXQnLCAnZ3JpZCcsIEdyaWRMYXlvdXQpO1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICAvLyBkZWZhdWx0IGxheW91dCBvcHRpb25zXG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICByZWFkeTogZnVuY3Rpb24oKXt9LCAvLyBvbiBsYXlvdXRyZWFkeVxuICAgIHN0b3A6IGZ1bmN0aW9uKCl7fSAvLyBvbiBsYXlvdXRzdG9wXG4gIH07XG5cbiAgLy8gY29uc3RydWN0b3JcbiAgLy8gb3B0aW9ucyA6IG9iamVjdCBjb250YWluaW5nIGxheW91dCBvcHRpb25zXG4gIGZ1bmN0aW9uIE51bGxMYXlvdXQoIG9wdGlvbnMgKXtcbiAgICB0aGlzLm9wdGlvbnMgPSAkJC51dGlsLmV4dGVuZCh0cnVlLCB7fSwgZGVmYXVsdHMsIG9wdGlvbnMpOyBcbiAgfVxuXG4gIC8vIHJ1bnMgdGhlIGxheW91dFxuICBOdWxsTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpe1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzOyAvLyBlbGVtZW50cyB0byBjb25zaWRlciBpbiB0aGUgbGF5b3V0XG4gICAgdmFyIGxheW91dCA9IHRoaXM7XG5cbiAgICAvLyBjeSBpcyBhdXRvbWF0aWNhbGx5IHBvcHVsYXRlZCBmb3IgdXMgaW4gdGhlIGNvbnN0cnVjdG9yXG4gICAgdmFyIGN5ID0gb3B0aW9ucy5jeTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cbiAgICBsYXlvdXQudHJpZ2dlcignbGF5b3V0c3RhcnQnKTtcblxuICAgIC8vIHB1dHMgYWxsIG5vZGVzIGF0ICgwLCAwKVxuICAgIGVsZXMubm9kZXMoKS5wb3NpdGlvbnMoZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyB0cmlnZ2VyIGxheW91dHJlYWR5IHdoZW4gZWFjaCBub2RlIGhhcyBoYWQgaXRzIHBvc2l0aW9uIHNldCBhdCBsZWFzdCBvbmNlXG4gICAgbGF5b3V0Lm9uZSgnbGF5b3V0cmVhZHknLCBvcHRpb25zLnJlYWR5KTtcbiAgICBsYXlvdXQudHJpZ2dlcignbGF5b3V0cmVhZHknKTtcblxuICAgIC8vIHRyaWdnZXIgbGF5b3V0c3RvcCB3aGVuIHRoZSBsYXlvdXQgc3RvcHMgKGUuZy4gZmluaXNoZXMpXG4gICAgbGF5b3V0Lm9uZSgnbGF5b3V0c3RvcCcsIG9wdGlvbnMuc3RvcCk7XG4gICAgbGF5b3V0LnRyaWdnZXIoJ2xheW91dHN0b3AnKTtcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuXG4gIC8vIGNhbGxlZCBvbiBjb250aW51b3VzIGxheW91dHMgdG8gc3RvcCB0aGVtIGJlZm9yZSB0aGV5IGZpbmlzaFxuICBOdWxsTGF5b3V0LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcblxuICAvLyByZWdpc3RlciB0aGUgbGF5b3V0XG4gICQkKCdsYXlvdXQnLCAnbnVsbCcsIE51bGxMYXlvdXQpO1xuXG59KShjeXRvc2NhcGUpO1xuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICBwb3NpdGlvbnM6IHVuZGVmaW5lZCwgLy8gbWFwIG9mIChub2RlIGlkKSA9PiAocG9zaXRpb24gb2JqKTsgb3IgZnVuY3Rpb24obm9kZSl7IHJldHVybiBzb21Qb3M7IH1cbiAgICB6b29tOiB1bmRlZmluZWQsIC8vIHRoZSB6b29tIGxldmVsIHRvIHNldCAocHJvYiB3YW50IGZpdCA9IGZhbHNlIGlmIHNldClcbiAgICBwYW46IHVuZGVmaW5lZCwgLy8gdGhlIHBhbiBsZXZlbCB0byBzZXQgKHByb2Igd2FudCBmaXQgPSBmYWxzZSBpZiBzZXQpXG4gICAgZml0OiB0cnVlLCAvLyB3aGV0aGVyIHRvIGZpdCB0byB2aWV3cG9ydFxuICAgIHBhZGRpbmc6IDMwLCAvLyBwYWRkaW5nIG9uIGZpdFxuICAgIGFuaW1hdGU6IGZhbHNlLCAvLyB3aGV0aGVyIHRvIHRyYW5zaXRpb24gdGhlIG5vZGUgcG9zaXRpb25zXG4gICAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCwgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgICByZWFkeTogdW5kZWZpbmVkLCAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICAgIHN0b3A6IHVuZGVmaW5lZCAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG4gIH07XG4gIFxuICBmdW5jdGlvbiBQcmVzZXRMYXlvdXQoIG9wdGlvbnMgKXtcbiAgICB0aGlzLm9wdGlvbnMgPSAkJC51dGlsLmV4dGVuZCh0cnVlLCB7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuICB9XG4gIFxuICBQcmVzZXRMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG5cbiAgICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCk7XG4gICAgdmFyIHBvc0lzRm4gPSAkJC5pcy5mbiggb3B0aW9ucy5wb3NpdGlvbnMgKTtcblxuICAgIGZ1bmN0aW9uIGdldFBvc2l0aW9uKG5vZGUpe1xuICAgICAgaWYoIG9wdGlvbnMucG9zaXRpb25zID09IG51bGwgKXtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmKCBwb3NJc0ZuICl7XG4gICAgICAgIHJldHVybiBvcHRpb25zLnBvc2l0aW9ucy5hcHBseSggbm9kZSwgWyBub2RlIF0gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIHBvcyA9IG9wdGlvbnMucG9zaXRpb25zW25vZGUuX3ByaXZhdGUuZGF0YS5pZF07XG5cbiAgICAgIGlmKCBwb3MgPT0gbnVsbCApe1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgXG4gICAgbm9kZXMubGF5b3V0UG9zaXRpb25zKHRoaXMsIG9wdGlvbnMsIGZ1bmN0aW9uKGksIG5vZGUpe1xuICAgICAgdmFyIHBvc2l0aW9uID0gZ2V0UG9zaXRpb24obm9kZSk7XG4gICAgICBcbiAgICAgIGlmKCBub2RlLmxvY2tlZCgpIHx8IHBvc2l0aW9uID09IG51bGwgKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgfSk7XG4gICAgICAgIFxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuICBcbiAgJCQoJ2xheW91dCcsICdwcmVzZXQnLCBQcmVzZXRMYXlvdXQpO1xuICBcbn0pKGN5dG9zY2FwZSk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgZml0OiB0cnVlLCAvLyB3aGV0aGVyIHRvIGZpdCB0byB2aWV3cG9ydFxuICAgIHBhZGRpbmc6IDMwLCAvLyBmaXQgcGFkZGluZ1xuICAgIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICAgIGFuaW1hdGU6IGZhbHNlLCAvLyB3aGV0aGVyIHRvIHRyYW5zaXRpb24gdGhlIG5vZGUgcG9zaXRpb25zXG4gICAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCwgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgICByZWFkeTogdW5kZWZpbmVkLCAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICAgIHN0b3A6IHVuZGVmaW5lZCAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG4gIH07XG4gIFxuICBmdW5jdGlvbiBSYW5kb21MYXlvdXQoIG9wdGlvbnMgKXtcbiAgICB0aGlzLm9wdGlvbnMgPSAkJC51dGlsLmV4dGVuZCh0cnVlLCB7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuICB9XG4gIFxuICBSYW5kb21MYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdmFyIGN5ID0gb3B0aW9ucy5jeTtcbiAgICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCkubm90KCc6cGFyZW50Jyk7XG4gICAgXG4gICAgdmFyIGJiID0gJCQudXRpbC5tYWtlQm91bmRpbmdCb3goIG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgICAgeDE6IDAsIHkxOiAwLCB3OiBjeS53aWR0aCgpLCBoOiBjeS5oZWlnaHQoKVxuICAgIH0gKTtcblxuICAgIHZhciBnZXRQb3MgPSBmdW5jdGlvbiggaSwgbm9kZSApe1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogYmIueDEgKyBNYXRoLnJvdW5kKCBNYXRoLnJhbmRvbSgpICogYmIudyApLFxuICAgICAgICB5OiBiYi55MSArIE1hdGgucm91bmQoIE1hdGgucmFuZG9tKCkgKiBiYi5oIClcbiAgICAgIH07XG4gICAgfTtcblxuICAgIG5vZGVzLmxheW91dFBvc2l0aW9ucyggdGhpcywgb3B0aW9ucywgZ2V0UG9zICk7XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcbiAgXG4gIC8vIHJlZ2lzdGVyIHRoZSBsYXlvdXRcbiAgJCQoXG4gICAgJ2xheW91dCcsIC8vIHdlJ3JlIHJlZ2lzdGVyaW5nIGEgbGF5b3V0XG4gICAgJ3JhbmRvbScsIC8vIHRoZSBsYXlvdXQgbmFtZVxuICAgIFJhbmRvbUxheW91dCAvLyB0aGUgbGF5b3V0IHByb3RvdHlwZVxuICApO1xuICBcbn0pKGN5dG9zY2FwZSk7XG5cbjsoIGZ1bmN0aW9uKCAkJCApeyAndXNlIHN0cmljdCc7XG5cbiAgLypcbiAgICogVGhpcyBsYXlvdXQgY29tYmluZXMgc2V2ZXJhbCBhbGdvcml0aG1zOlxuICAgKlxuICAgKiAtIEl0IGdlbmVyYXRlcyBhbiBpbml0aWFsIHBvc2l0aW9uIG9mIHRoZSBub2RlcyBieSB1c2luZyB0aGVcbiAgICogICBGcnVjaHRlcm1hbi1SZWluZ29sZCBhbGdvcml0aG0gKGRvaToxMC4xMDAyL3NwZS40MzgwMjExMTAyKVxuICAgKlxuICAgKiAtIEZpbmFsbHkgaXQgZWxpbWluYXRlcyBvdmVybGFwcyBieSB1c2luZyB0aGUgbWV0aG9kIGRlc2NyaWJlZCBieVxuICAgKiAgIEdhbnNuZXIgYW5kIE5vcnRoIChkb2k6MTAuMTAwNy8zLTU0MC0zNzYyMy0yXzI4KVxuICAgKi9cblxuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgYW5pbWF0ZTogdHJ1ZSwgLy8gd2hldGhlciB0byBzaG93IHRoZSBsYXlvdXQgYXMgaXQncyBydW5uaW5nXG4gICAgcmVhZHk6IHVuZGVmaW5lZCwgLy8gQ2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgICBzdG9wOiB1bmRlZmluZWQsIC8vIENhbGxiYWNrIG9uIGxheW91dHN0b3BcbiAgICBmaXQ6IHRydWUsIC8vIFJlc2V0IHZpZXdwb3J0IHRvIGZpdCBkZWZhdWx0IHNpbXVsYXRpb25Cb3VuZHNcbiAgICBtaW5EaXN0OiAyMCwgLy8gTWluaW11bSBkaXN0YW5jZSBiZXR3ZWVuIG5vZGVzXG4gICAgcGFkZGluZzogMjAsIC8vIFBhZGRpbmdcbiAgICBleHBhbmRpbmdGYWN0b3I6IC0xLjAsIC8vIElmIHRoZSBuZXR3b3JrIGRvZXMgbm90IHNhdGlzZnkgdGhlIG1pbkRpc3RcbiAgICAvLyBjcml0ZXJpdW0gdGhlbiBpdCBleHBhbmRzIHRoZSBuZXR3b3JrIG9mIHRoaXMgYW1vdW50XG4gICAgLy8gSWYgaXQgaXMgc2V0IHRvIC0xLjAgdGhlIGFtb3VudCBvZiBleHBhbnNpb24gaXMgYXV0b21hdGljYWxseVxuICAgIC8vIGNhbGN1bGF0ZWQgYmFzZWQgb24gdGhlIG1pbkRpc3QsIHRoZSBhc3BlY3QgcmF0aW8gYW5kIHRoZVxuICAgIC8vIG51bWJlciBvZiBub2Rlc1xuICAgIG1heEZydWNodGVybWFuUmVpbmdvbGRJdGVyYXRpb25zOiA1MCwgLy8gTWF4aW11bSBudW1iZXIgb2YgaW5pdGlhbCBmb3JjZS1kaXJlY3RlZCBpdGVyYXRpb25zXG4gICAgbWF4RXhwYW5kSXRlcmF0aW9uczogNCwgLy8gTWF4aW11bSBudW1iZXIgb2YgZXhwYW5kaW5nIGl0ZXJhdGlvbnNcbiAgICBib3VuZGluZ0JveDogdW5kZWZpbmVkIC8vIENvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICB9O1xuXG4gIGZ1bmN0aW9uIFNwcmVhZExheW91dCggb3B0aW9ucyApIHtcbiAgICB0aGlzLm9wdGlvbnMgPSAkJC51dGlsLmV4dGVuZCgge30sIGRlZmF1bHRzLCBvcHRpb25zICk7XG4gIH1cblxuICBmdW5jdGlvbiBjZWxsQ2VudHJvaWQoIGNlbGwgKSB7XG4gICAgdmFyIGhlcyA9IGNlbGwuaGFsZmVkZ2VzO1xuICAgIHZhciBhcmVhID0gMCxcbiAgICAgIHggPSAwLFxuICAgICAgeSA9IDA7XG4gICAgdmFyIHAxLCBwMiwgZjtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgaGVzLmxlbmd0aDsgKytpICkge1xuICAgICAgcDEgPSBoZXNbIGkgXS5nZXRFbmRwb2ludCgpO1xuICAgICAgcDIgPSBoZXNbIGkgXS5nZXRTdGFydHBvaW50KCk7XG5cbiAgICAgIGFyZWEgKz0gcDEueCAqIHAyLnk7XG4gICAgICBhcmVhIC09IHAxLnkgKiBwMi54O1xuXG4gICAgICBmID0gcDEueCAqIHAyLnkgLSBwMi54ICogcDEueTtcbiAgICAgIHggKz0gKCBwMS54ICsgcDIueCApICogZjtcbiAgICAgIHkgKz0gKCBwMS55ICsgcDIueSApICogZjtcbiAgICB9XG5cbiAgICBhcmVhIC89IDI7XG4gICAgZiA9IGFyZWEgKiA2O1xuICAgIHJldHVybiB7XG4gICAgICB4OiB4IC8gZixcbiAgICAgIHk6IHkgLyBmXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNpdGVzRGlzdGFuY2UoIGxzLCBycyApIHtcbiAgICB2YXIgZHggPSBscy54IC0gcnMueDtcbiAgICB2YXIgZHkgPSBscy55IC0gcnMueTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KCBkeCAqIGR4ICsgZHkgKiBkeSApO1xuICB9XG5cbiAgU3ByZWFkTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBsYXlvdXQgPSB0aGlzO1xuICAgIC8vIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgICQkLnV0aWwucmVxdWlyZXMoWydmb29ncmFwaCcsICdWb3Jvbm9pJ10sIGZ1bmN0aW9uKGZvb2dyYXBoLCBWb3Jvbm9pKXtcblxuICAgICAgdmFyIGN5ID0gb3B0aW9ucy5jeTtcbiAgICAgIC8vIHZhciBhbGxOb2RlcyA9IGN5Lm5vZGVzKCk7XG4gICAgICB2YXIgbm9kZXMgPSBjeS5ub2RlcygpO1xuICAgICAgLy92YXIgYWxsRWRnZXMgPSBjeS5lZGdlcygpO1xuICAgICAgdmFyIGVkZ2VzID0gY3kuZWRnZXMoKTtcbiAgICAgIHZhciBjV2lkdGggPSBjeS53aWR0aCgpO1xuICAgICAgdmFyIGNIZWlnaHQgPSBjeS5oZWlnaHQoKTtcbiAgICAgIHZhciBzaW11bGF0aW9uQm91bmRzID0gb3B0aW9ucy5ib3VuZGluZ0JveCA/ICQkLnV0aWwubWFrZUJvdW5kaW5nQm94KCBvcHRpb25zLmJvdW5kaW5nQm94ICkgOiBudWxsO1xuICAgICAgdmFyIHBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmc7XG4gICAgICB2YXIgc2ltQkJGYWN0b3IgPSBNYXRoLm1heCggMSwgTWF0aC5sb2cobm9kZXMubGVuZ3RoKSAqIDAuOCApO1xuICAgICAgXG4gICAgICBpZiggbm9kZXMubGVuZ3RoIDwgMTAwICl7XG4gICAgICAgIHNpbUJCRmFjdG9yIC89IDI7XG4gICAgICB9XG5cbiAgICAgIGxheW91dC50cmlnZ2VyKCB7XG4gICAgICAgIHR5cGU6ICdsYXlvdXRzdGFydCcsXG4gICAgICAgIGxheW91dDogbGF5b3V0XG4gICAgICB9ICk7XG5cbiAgICAgIHZhciBzaW1CQiA9IHtcbiAgICAgICAgeDE6IDAsXG4gICAgICAgIHkxOiAwLFxuICAgICAgICB4MjogY1dpZHRoICogc2ltQkJGYWN0b3IsXG4gICAgICAgIHkyOiBjSGVpZ2h0ICogc2ltQkJGYWN0b3JcbiAgICAgIH07XG5cbiAgICAgIGlmKCBzaW11bGF0aW9uQm91bmRzICkge1xuICAgICAgICBzaW1CQi54MSA9IHNpbXVsYXRpb25Cb3VuZHMueDE7XG4gICAgICAgIHNpbUJCLnkxID0gc2ltdWxhdGlvbkJvdW5kcy55MTtcbiAgICAgICAgc2ltQkIueDIgPSBzaW11bGF0aW9uQm91bmRzLngyO1xuICAgICAgICBzaW1CQi55MiA9IHNpbXVsYXRpb25Cb3VuZHMueTI7XG4gICAgICB9XG5cbiAgICAgIHNpbUJCLngxICs9IHBhZGRpbmc7XG4gICAgICBzaW1CQi55MSArPSBwYWRkaW5nO1xuICAgICAgc2ltQkIueDIgLT0gcGFkZGluZztcbiAgICAgIHNpbUJCLnkyIC09IHBhZGRpbmc7XG5cbiAgICAgIHZhciB3aWR0aCA9IHNpbUJCLngyIC0gc2ltQkIueDE7XG4gICAgICB2YXIgaGVpZ2h0ID0gc2ltQkIueTIgLSBzaW1CQi55MTtcblxuICAgICAgLy8gR2V0IHN0YXJ0IHRpbWVcbiAgICAgIHZhciBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgICAvLyBsYXlvdXQgZG9lc24ndCB3b3JrIHdpdGgganVzdCAxIG5vZGVcbiAgICAgIGlmKCBub2Rlcy5zaXplKCkgPD0gMSApIHtcbiAgICAgICAgbm9kZXMucG9zaXRpb25zKCB7XG4gICAgICAgICAgeDogTWF0aC5yb3VuZCggKCBzaW1CQi54MSArIHNpbUJCLngyICkgLyAyICksXG4gICAgICAgICAgeTogTWF0aC5yb3VuZCggKCBzaW1CQi55MSArIHNpbUJCLnkyICkgLyAyIClcbiAgICAgICAgfSApO1xuXG4gICAgICAgIGlmKCBvcHRpb25zLmZpdCApIHtcbiAgICAgICAgICBjeS5maXQoIG9wdGlvbnMucGFkZGluZyApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IGVuZCB0aW1lXG4gICAgICAgIHZhciBlbmRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc29sZS5pbmZvKCBcIkxheW91dCBvbiBcIiArIG5vZGVzLnNpemUoKSArIFwiIG5vZGVzIHRvb2sgXCIgKyAoIGVuZFRpbWUgLSBzdGFydFRpbWUgKSArIFwiIG1zXCIgKTtcblxuICAgICAgICBsYXlvdXQub25lKCBcImxheW91dHJlYWR5XCIsIG9wdGlvbnMucmVhZHkgKTtcbiAgICAgICAgbGF5b3V0LnRyaWdnZXIoIFwibGF5b3V0cmVhZHlcIiApO1xuXG4gICAgICAgIGxheW91dC5vbmUoIFwibGF5b3V0c3RvcFwiLCBvcHRpb25zLnN0b3AgKTtcbiAgICAgICAgbGF5b3V0LnRyaWdnZXIoIFwibGF5b3V0c3RvcFwiICk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBGaXJzdCBJIG5lZWQgdG8gY3JlYXRlIHRoZSBkYXRhIHN0cnVjdHVyZSB0byBwYXNzIHRvIHRoZSB3b3JrZXJcbiAgICAgIHZhciBwRGF0YSA9IHtcbiAgICAgICAgJ3dpZHRoJzogd2lkdGgsXG4gICAgICAgICdoZWlnaHQnOiBoZWlnaHQsXG4gICAgICAgICdtaW5EaXN0Jzogb3B0aW9ucy5taW5EaXN0LFxuICAgICAgICAnZXhwRmFjdCc6IG9wdGlvbnMuZXhwYW5kaW5nRmFjdG9yLFxuICAgICAgICAnZXhwSXQnOiAwLFxuICAgICAgICAnbWF4RXhwSXQnOiBvcHRpb25zLm1heEV4cGFuZEl0ZXJhdGlvbnMsXG4gICAgICAgICd2ZXJ0aWNlcyc6IFtdLFxuICAgICAgICAnZWRnZXMnOiBbXSxcbiAgICAgICAgJ3N0YXJ0VGltZSc6IHN0YXJ0VGltZSxcbiAgICAgICAgJ21heEZydWNodGVybWFuUmVpbmdvbGRJdGVyYXRpb25zJzogb3B0aW9ucy5tYXhGcnVjaHRlcm1hblJlaW5nb2xkSXRlcmF0aW9uc1xuICAgICAgfTtcblxuICAgICAgbm9kZXMuZWFjaChcbiAgICAgICAgZnVuY3Rpb24oIGksIG5vZGUgKSB7XG4gICAgICAgICAgdmFyIG5vZGVJZCA9IHRoaXMuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgICAgICBwRGF0YVsgJ3ZlcnRpY2VzJyBdLnB1c2goIHtcbiAgICAgICAgICAgIGlkOiBub2RlSWQsXG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICAgIH0gKTtcbiAgICAgICAgfSApO1xuXG4gICAgICBlZGdlcy5lYWNoKFxuICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgc3JjTm9kZUlkID0gdGhpcy5zb3VyY2UoKS5pZCgpO1xuICAgICAgICAgIHZhciB0Z3ROb2RlSWQgPSB0aGlzLnRhcmdldCgpLmlkKCk7XG4gICAgICAgICAgcERhdGFbICdlZGdlcycgXS5wdXNoKCB7XG4gICAgICAgICAgICBzcmM6IHNyY05vZGVJZCxcbiAgICAgICAgICAgIHRndDogdGd0Tm9kZUlkXG4gICAgICAgICAgfSApO1xuICAgICAgICB9ICk7XG5cbiAgICAgIC8vRGVjbGVyYXRpb25cbiAgICAgIHZhciB0MSA9ICQkLlRocmVhZCgpO1xuICAgICAgLy8gQW5kIHRvIGFkZCB0aGUgcmVxdWlyZWQgc2NyaXB0c1xuICAgICAgLy9FWFRFUk5BTCAxXG4gICAgICB0MS5yZXF1aXJlKCBmb29ncmFwaCwgJ2Zvb2dyYXBoJyApO1xuICAgICAgLy9FWFRFUk5BTCAyXG4gICAgICB0MS5yZXF1aXJlKCBWb3Jvbm9pICk7XG5cbiAgICAgIC8vTG9jYWwgZnVuY3Rpb25cbiAgICAgIHQxLnJlcXVpcmUoIHNpdGVzRGlzdGFuY2UgKTtcbiAgICAgIHQxLnJlcXVpcmUoIGNlbGxDZW50cm9pZCApO1xuXG4gICAgICBmdW5jdGlvbiBzZXRQb3NpdGlvbnMoIHBEYXRhICl7IC8vY29uc29sZS5sb2coJ3NldCBwb3NucycpXG4gICAgICAgIC8vIEZpcnN0IHdlIHJldHJpZXZlIHRoZSBpbXBvcnRhbnQgZGF0YVxuICAgICAgICAvLyB2YXIgZXhwYW5kSXRlcmF0aW9uID0gcERhdGFbICdleHBJdCcgXTtcbiAgICAgICAgdmFyIGRhdGFWZXJ0aWNlcyA9IHBEYXRhWyAndmVydGljZXMnIF07XG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IFtdO1xuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGRhdGFWZXJ0aWNlcy5sZW5ndGg7ICsraSApIHtcbiAgICAgICAgICB2YXIgZHYgPSBkYXRhVmVydGljZXNbIGkgXTtcbiAgICAgICAgICB2ZXJ0aWNlc1sgZHYuaWQgXSA9IHtcbiAgICAgICAgICAgIHg6IGR2LngsXG4gICAgICAgICAgICB5OiBkdi55XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICAgKiBGSU5BTExZOlxuICAgICAgICAgKlxuICAgICAgICAgKiBXZSBwb3NpdGlvbiB0aGUgbm9kZXMgYmFzZWQgb24gdGhlIGNhbGN1bGF0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBub2Rlcy5wb3NpdGlvbnMoXG4gICAgICAgICAgZnVuY3Rpb24oIGksIG5vZGUgKSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBub2RlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICAgICAgICAvLyB2YXIgcG9zID0gbm9kZS5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAgICAgICAgIHZhciB2ZXJ0ZXggPSB2ZXJ0aWNlc1sgaWQgXTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgeDogTWF0aC5yb3VuZCggc2ltQkIueDEgKyB2ZXJ0ZXgueCApLFxuICAgICAgICAgICAgICB5OiBNYXRoLnJvdW5kKCBzaW1CQi55MSArIHZlcnRleC55IClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSApO1xuXG4gICAgICAgIGlmKCBvcHRpb25zLmZpdCApIHtcbiAgICAgICAgICBjeS5maXQoIG9wdGlvbnMucGFkZGluZyApO1xuICAgICAgICB9XG5cbiAgICAgICAgY3kubm9kZXMoKS5ydHJpZ2dlciggXCJwb3NpdGlvblwiICk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkaWRMYXlvdXRSZWFkeSA9IGZhbHNlO1xuICAgICAgdDEub24oJ21lc3NhZ2UnLCBmdW5jdGlvbihlKXtcbiAgICAgICAgdmFyIHBEYXRhID0gZS5tZXNzYWdlOyAvL2NvbnNvbGUubG9nKCdtZXNzYWdlJywgZSlcblxuICAgICAgICBpZiggIW9wdGlvbnMuYW5pbWF0ZSApe1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldFBvc2l0aW9ucyggcERhdGEgKTtcblxuICAgICAgICBpZiggIWRpZExheW91dFJlYWR5ICl7XG4gICAgICAgICAgbGF5b3V0LnRyaWdnZXIoIFwibGF5b3V0cmVhZHlcIiApO1xuXG4gICAgICAgICAgZGlkTGF5b3V0UmVhZHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgbGF5b3V0Lm9uZSggXCJsYXlvdXRyZWFkeVwiLCBvcHRpb25zLnJlYWR5ICk7XG5cbiAgICAgIHQxLnBhc3MoIHBEYXRhICkucnVuKCBmdW5jdGlvbiggcERhdGEgKSB7XG4gICAgICAgIFxuICAgICAgICBmb29ncmFwaCA9IGV2YWwoJ2Zvb2dyYXBoJyk7XG4gICAgICAgIFZvcm9ub2kgPSBldmFsKCdWb3Jvbm9pJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBJIG5lZWQgdG8gcmV0cmlldmUgdGhlIGltcG9ydGFudCBkYXRhXG4gICAgICAgIHZhciBsV2lkdGggPSBwRGF0YVsgJ3dpZHRoJyBdO1xuICAgICAgICB2YXIgbEhlaWdodCA9IHBEYXRhWyAnaGVpZ2h0JyBdO1xuICAgICAgICB2YXIgbE1pbkRpc3QgPSBwRGF0YVsgJ21pbkRpc3QnIF07XG4gICAgICAgIHZhciBsRXhwRmFjdCA9IHBEYXRhWyAnZXhwRmFjdCcgXTtcbiAgICAgICAgdmFyIGxNYXhFeHBJdCA9IHBEYXRhWyAnbWF4RXhwSXQnIF07XG4gICAgICAgIHZhciBsTWF4RnJ1Y2h0ZXJtYW5SZWluZ29sZEl0ZXJhdGlvbnMgPSBwRGF0YVsgJ21heEZydWNodGVybWFuUmVpbmdvbGRJdGVyYXRpb25zJyBdO1xuXG4gICAgICAgIC8vIFByZXBhcmUgdGhlIGRhdGEgdG8gb3V0cHV0XG4gICAgICAgIHZhciBzYXZlUG9zaXRpb25zID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICBwRGF0YVsgJ3dpZHRoJyBdID0gbFdpZHRoO1xuICAgICAgICAgIHBEYXRhWyAnaGVpZ2h0JyBdID0gbEhlaWdodDtcbiAgICAgICAgICBwRGF0YVsgJ2V4cEl0JyBdID0gZXhwYW5kSXRlcmF0aW9uO1xuICAgICAgICAgIHBEYXRhWyAnZXhwRmFjdCcgXSA9IGxFeHBGYWN0O1xuXG4gICAgICAgICAgcERhdGFbICd2ZXJ0aWNlcycgXSA9IFtdO1xuICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZnYubGVuZ3RoOyArK2kgKSB7XG4gICAgICAgICAgICBwRGF0YVsgJ3ZlcnRpY2VzJyBdLnB1c2goIHtcbiAgICAgICAgICAgICAgaWQ6IGZ2WyBpIF0ubGFiZWwsXG4gICAgICAgICAgICAgIHg6IGZ2WyBpIF0ueCxcbiAgICAgICAgICAgICAgeTogZnZbIGkgXS55XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBtZXNzYWdlUG9zaXRpb25zID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICBicm9hZGNhc3QoIHBEYXRhICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLypcbiAgICAgICAgICogRklSU1QgU1RFUDogQXBwbGljYXRpb24gb2YgdGhlIEZydWNodGVybWFuLVJlaW5nb2xkIGFsZ29yaXRobVxuICAgICAgICAgKlxuICAgICAgICAgKiBXZSB1c2UgdGhlIHZlcnNpb24gaW1wbGVtZW50ZWQgYnkgdGhlIGZvb2dyYXBoIGxpYnJhcnlcbiAgICAgICAgICpcbiAgICAgICAgICogUmVmLjogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9mb29ncmFwaC9cbiAgICAgICAgICovXG5cbiAgICAgICAgLy8gV2UgbmVlZCB0byBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgYSBncmFwaCBjb21wYXRpYmxlIHdpdGggdGhlIGxpYnJhcnlcbiAgICAgICAgdmFyIGZyZyA9IG5ldyBmb29ncmFwaC5HcmFwaCggXCJGUmdyYXBoXCIsIGZhbHNlICk7XG5cbiAgICAgICAgdmFyIGZyZ05vZGVzID0ge307XG5cbiAgICAgICAgLy8gVGhlbiB3ZSBoYXZlIHRvIGFkZCB0aGUgdmVydGljZXNcbiAgICAgICAgdmFyIGRhdGFWZXJ0aWNlcyA9IHBEYXRhWyAndmVydGljZXMnIF07XG4gICAgICAgIGZvciggdmFyIG5pID0gMDsgbmkgPCBkYXRhVmVydGljZXMubGVuZ3RoOyArK25pICkge1xuICAgICAgICAgIHZhciBpZCA9IGRhdGFWZXJ0aWNlc1sgbmkgXVsgJ2lkJyBdO1xuICAgICAgICAgIHZhciB2ID0gbmV3IGZvb2dyYXBoLlZlcnRleCggaWQsIE1hdGgucm91bmQoIE1hdGgucmFuZG9tKCkgKiBsSGVpZ2h0ICksIE1hdGgucm91bmQoIE1hdGgucmFuZG9tKCkgKiBsSGVpZ2h0ICkgKTtcbiAgICAgICAgICBmcmdOb2Rlc1sgaWQgXSA9IHY7XG4gICAgICAgICAgZnJnLmluc2VydFZlcnRleCggdiApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRhdGFFZGdlcyA9IHBEYXRhWyAnZWRnZXMnIF07XG4gICAgICAgIGZvciggdmFyIGVpID0gMDsgZWkgPCBkYXRhRWRnZXMubGVuZ3RoOyArK2VpICkge1xuICAgICAgICAgIHZhciBzcmNOb2RlSWQgPSBkYXRhRWRnZXNbIGVpIF1bICdzcmMnIF07XG4gICAgICAgICAgdmFyIHRndE5vZGVJZCA9IGRhdGFFZGdlc1sgZWkgXVsgJ3RndCcgXTtcbiAgICAgICAgICBmcmcuaW5zZXJ0RWRnZSggXCJcIiwgMSwgZnJnTm9kZXNbIHNyY05vZGVJZCBdLCBmcmdOb2Rlc1sgdGd0Tm9kZUlkIF0gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmdiA9IGZyZy52ZXJ0aWNlcztcblxuICAgICAgICAvLyBUaGVuIHdlIGFwcGx5IHRoZSBsYXlvdXRcbiAgICAgICAgdmFyIGl0ZXJhdGlvbnMgPSBsTWF4RnJ1Y2h0ZXJtYW5SZWluZ29sZEl0ZXJhdGlvbnM7XG4gICAgICAgIHZhciBmckxheW91dE1hbmFnZXIgPSBuZXcgZm9vZ3JhcGguRm9yY2VEaXJlY3RlZFZlcnRleExheW91dCggbFdpZHRoLCBsSGVpZ2h0LCBpdGVyYXRpb25zLCBmYWxzZSwgbE1pbkRpc3QgKTtcblxuICAgICAgICBmckxheW91dE1hbmFnZXIuY2FsbGJhY2sgPSBmdW5jdGlvbigpe1xuICAgICAgICAgIHNhdmVQb3NpdGlvbnMoKTtcbiAgICAgICAgICBtZXNzYWdlUG9zaXRpb25zKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnJMYXlvdXRNYW5hZ2VyLmxheW91dCggZnJnICk7XG5cbiAgICAgICAgc2F2ZVBvc2l0aW9ucygpO1xuICAgICAgICBtZXNzYWdlUG9zaXRpb25zKCk7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogU0VDT05EIFNURVA6IFRpZGluZyB1cCBvZiB0aGUgZ3JhcGguXG4gICAgICAgICAqXG4gICAgICAgICAqIFdlIHVzZSB0aGUgbWV0aG9kIGRlc2NyaWJlZCBieSBHYW5zbmVyIGFuZCBOb3J0aCwgYmFzZWQgb24gVm9yb25vaVxuICAgICAgICAgKiBkaWFncmFtcy5cbiAgICAgICAgICpcbiAgICAgICAgICogUmVmOiBkb2k6MTAuMTAwNy8zLTU0MC0zNzYyMy0yXzI4XG4gICAgICAgICAqL1xuXG4gICAgICAgIC8vIFdlIGNhbGN1bGF0ZSB0aGUgVm9yb25vaSBkaWFncmFtIGRvciB0aGUgcG9zaXRpb24gb2YgdGhlIG5vZGVzXG4gICAgICAgIHZhciB2b3Jvbm9pID0gbmV3IFZvcm9ub2koKTtcbiAgICAgICAgdmFyIGJib3ggPSB7XG4gICAgICAgICAgeGw6IDAsXG4gICAgICAgICAgeHI6IGxXaWR0aCxcbiAgICAgICAgICB5dDogMCxcbiAgICAgICAgICB5YjogbEhlaWdodFxuICAgICAgICB9O1xuICAgICAgICB2YXIgdlNpdGVzID0gW107XG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZnYubGVuZ3RoOyArK2kgKSB7XG4gICAgICAgICAgdlNpdGVzWyBmdlsgaSBdLmxhYmVsIF0gPSBmdlsgaSBdO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tNaW5EaXN0KCBlZSApIHtcbiAgICAgICAgICB2YXIgaW5mcmFjdGlvbnMgPSAwO1xuICAgICAgICAgIC8vIFRoZW4gd2UgY2hlY2sgaWYgdGhlIG1pbmltdW0gZGlzdGFuY2UgaXMgc2F0aXNmaWVkXG4gICAgICAgICAgZm9yKCB2YXIgZWVpID0gMDsgZWVpIDwgZWUubGVuZ3RoOyArK2VlaSApIHtcbiAgICAgICAgICAgIHZhciBlID0gZWVbIGVlaSBdO1xuICAgICAgICAgICAgaWYoICggZS5sU2l0ZSAhPSBudWxsICkgJiYgKCBlLnJTaXRlICE9IG51bGwgKSAmJiBzaXRlc0Rpc3RhbmNlKCBlLmxTaXRlLCBlLnJTaXRlICkgPCBsTWluRGlzdCApIHtcbiAgICAgICAgICAgICAgKytpbmZyYWN0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGluZnJhY3Rpb25zO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRpYWdyYW0gPSB2b3Jvbm9pLmNvbXB1dGUoIGZ2LCBiYm94ICk7XG5cbiAgICAgICAgLy8gVGhlbiB3ZSByZXBvc2l0aW9uIHRoZSBub2RlcyBhdCB0aGUgY2VudHJvaWQgb2YgdGhlaXIgVm9yb25vaSBjZWxsc1xuICAgICAgICB2YXIgY2VsbHMgPSBkaWFncmFtLmNlbGxzO1xuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNlbGxzLmxlbmd0aDsgKytpICkge1xuICAgICAgICAgIHZhciBjZWxsID0gY2VsbHNbIGkgXTtcbiAgICAgICAgICB2YXIgc2l0ZSA9IGNlbGwuc2l0ZTtcbiAgICAgICAgICB2YXIgY2VudHJvaWQgPSBjZWxsQ2VudHJvaWQoIGNlbGwgKTtcbiAgICAgICAgICB2YXIgY3VycnYgPSB2U2l0ZXNbIHNpdGUubGFiZWwgXTtcbiAgICAgICAgICBjdXJydi54ID0gY2VudHJvaWQueDtcbiAgICAgICAgICBjdXJydi55ID0gY2VudHJvaWQueTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBsRXhwRmFjdCA8IDAuMCApIHtcbiAgICAgICAgICAvLyBDYWxjdWxhdGVzIHRoZSBleHBhbmRpbmcgZmFjdG9yXG4gICAgICAgICAgbEV4cEZhY3QgPSBNYXRoLm1heCggMC4wNSwgTWF0aC5taW4oIDAuMTAsIGxNaW5EaXN0IC8gTWF0aC5zcXJ0KCAoIGxXaWR0aCAqIGxIZWlnaHQgKSAvIGZ2Lmxlbmd0aCApICogMC41ICkgKTtcbiAgICAgICAgICAvL2NvbnNvbGUuaW5mbyhcIkV4cGFuZGluZyBmYWN0b3IgaXMgXCIgKyAob3B0aW9ucy5leHBhbmRpbmdGYWN0b3IgKiAxMDAuMCkgKyBcIiVcIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJldkluZnJhY3Rpb25zID0gY2hlY2tNaW5EaXN0KCBkaWFncmFtLmVkZ2VzICk7XG4gICAgICAgIC8vY29uc29sZS5pbmZvKFwiSW5pdGlhbCBpbmZyYWN0aW9ucyBcIiArIHByZXZJbmZyYWN0aW9ucyk7XG5cbiAgICAgICAgdmFyIGJTdG9wID0gKCBwcmV2SW5mcmFjdGlvbnMgPD0gMCApO1xuXG4gICAgICAgIHZhciB2b3Jvbm9pSXRlcmF0aW9uID0gMDtcbiAgICAgICAgdmFyIGV4cGFuZEl0ZXJhdGlvbiA9IDA7XG5cbiAgICAgICAgLy8gdmFyIGluaXRXaWR0aCA9IGxXaWR0aDtcblxuICAgICAgICB3aGlsZSggIWJTdG9wICkge1xuICAgICAgICAgICsrdm9yb25vaUl0ZXJhdGlvbjtcbiAgICAgICAgICBmb3IoIHZhciBpdCA9IDA7IGl0IDw9IDQ7ICsraXQgKSB7XG4gICAgICAgICAgICB2b3Jvbm9pLnJlY3ljbGUoIGRpYWdyYW0gKTtcbiAgICAgICAgICAgIGRpYWdyYW0gPSB2b3Jvbm9pLmNvbXB1dGUoIGZ2LCBiYm94ICk7XG5cbiAgICAgICAgICAgIC8vIFRoZW4gd2UgcmVwb3NpdGlvbiB0aGUgbm9kZXMgYXQgdGhlIGNlbnRyb2lkIG9mIHRoZWlyIFZvcm9ub2kgY2VsbHNcbiAgICAgICAgICAgIGNlbGxzID0gZGlhZ3JhbS5jZWxscztcbiAgICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY2VsbHMubGVuZ3RoOyArK2kgKSB7XG4gICAgICAgICAgICAgIHZhciBjZWxsID0gY2VsbHNbIGkgXTtcbiAgICAgICAgICAgICAgdmFyIHNpdGUgPSBjZWxsLnNpdGU7XG4gICAgICAgICAgICAgIHZhciBjZW50cm9pZCA9IGNlbGxDZW50cm9pZCggY2VsbCApO1xuICAgICAgICAgICAgICB2YXIgY3VycnYgPSB2U2l0ZXNbIHNpdGUubGFiZWwgXTtcbiAgICAgICAgICAgICAgY3VycnYueCA9IGNlbnRyb2lkLng7XG4gICAgICAgICAgICAgIGN1cnJ2LnkgPSBjZW50cm9pZC55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjdXJySW5mcmFjdGlvbnMgPSBjaGVja01pbkRpc3QoIGRpYWdyYW0uZWRnZXMgKTtcbiAgICAgICAgICAvL2NvbnNvbGUuaW5mbyhcIkN1cnJlbnQgaW5mcmFjdGlvbnMgXCIgKyBjdXJySW5mcmFjdGlvbnMpO1xuXG4gICAgICAgICAgaWYoIGN1cnJJbmZyYWN0aW9ucyA8PSAwICkge1xuICAgICAgICAgICAgYlN0b3AgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiggY3VyckluZnJhY3Rpb25zID49IHByZXZJbmZyYWN0aW9ucyB8fCB2b3Jvbm9pSXRlcmF0aW9uID49IDQgKSB7XG4gICAgICAgICAgICAgIGlmKCBleHBhbmRJdGVyYXRpb24gPj0gbE1heEV4cEl0ICkge1xuICAgICAgICAgICAgICAgIGJTdG9wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsV2lkdGggKz0gbFdpZHRoICogbEV4cEZhY3Q7XG4gICAgICAgICAgICAgICAgbEhlaWdodCArPSBsSGVpZ2h0ICogbEV4cEZhY3Q7XG4gICAgICAgICAgICAgICAgYmJveCA9IHtcbiAgICAgICAgICAgICAgICAgIHhsOiAwLFxuICAgICAgICAgICAgICAgICAgeHI6IGxXaWR0aCxcbiAgICAgICAgICAgICAgICAgIHl0OiAwLFxuICAgICAgICAgICAgICAgICAgeWI6IGxIZWlnaHRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICsrZXhwYW5kSXRlcmF0aW9uO1xuICAgICAgICAgICAgICAgIHZvcm9ub2lJdGVyYXRpb24gPSAwO1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5pbmZvKFwiRXhwYW5kZWQgdG8gKFwiK3dpZHRoK1wiLFwiK2hlaWdodCtcIilcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcHJldkluZnJhY3Rpb25zID0gY3VyckluZnJhY3Rpb25zO1xuXG4gICAgICAgICAgc2F2ZVBvc2l0aW9ucygpO1xuICAgICAgICAgIG1lc3NhZ2VQb3NpdGlvbnMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNhdmVQb3NpdGlvbnMoKTtcbiAgICAgICAgcmV0dXJuIHBEYXRhO1xuXG4gICAgICB9ICkudGhlbiggZnVuY3Rpb24oIHBEYXRhICkge1xuICAgICAgICAvLyB2YXIgZXhwYW5kSXRlcmF0aW9uID0gcERhdGFbICdleHBJdCcgXTtcbiAgICAgICAgdmFyIGRhdGFWZXJ0aWNlcyA9IHBEYXRhWyAndmVydGljZXMnIF07XG5cbiAgICAgICAgc2V0UG9zaXRpb25zKCBwRGF0YSApO1xuXG4gICAgICAgIC8vIEdldCBlbmQgdGltZVxuICAgICAgICB2YXIgc3RhcnRUaW1lID0gcERhdGFbICdzdGFydFRpbWUnIF07XG4gICAgICAgIHZhciBlbmRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc29sZS5pbmZvKCBcIkxheW91dCBvbiBcIiArIGRhdGFWZXJ0aWNlcy5sZW5ndGggKyBcIiBub2RlcyB0b29rIFwiICsgKCBlbmRUaW1lIC0gc3RhcnRUaW1lICkgKyBcIiBtc1wiICk7XG5cbiAgICAgICAgbGF5b3V0Lm9uZSggXCJsYXlvdXRzdG9wXCIsIG9wdGlvbnMuc3RvcCApO1xuXG4gICAgICAgIGlmKCAhb3B0aW9ucy5hbmltYXRlICl7XG4gICAgICAgICAgbGF5b3V0LnRyaWdnZXIoIFwibGF5b3V0cmVhZHlcIiApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGF5b3V0LnRyaWdnZXIoIFwibGF5b3V0c3RvcFwiICk7XG5cbiAgICAgICAgdDEuc3RvcCgpO1xuICAgICAgfSApO1xuXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTsgLy8gcnVuXG5cbiAgU3ByZWFkTGF5b3V0LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKSB7fTtcblxuICAkJCggJ2xheW91dCcsICdzcHJlYWQnLCBTcHJlYWRMYXlvdXQgKTtcblxuXG59ICkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIGFuaW1hdGU6IHRydWUsIC8vIHdoZXRoZXIgdG8gc2hvdyB0aGUgbGF5b3V0IGFzIGl0J3MgcnVubmluZ1xuICAgIG1heFNpbXVsYXRpb25UaW1lOiA0MDAwLCAvLyBtYXggbGVuZ3RoIGluIG1zIHRvIHJ1biB0aGUgbGF5b3V0XG4gICAgdW5ncmFiaWZ5V2hpbGVTaW11bGF0aW5nOiBmYWxzZSwgLy8gc28geW91IGNhbid0IGRyYWcgbm9kZXMgZHVyaW5nIGxheW91dFxuICAgIGZpdDogdHJ1ZSwgLy8gd2hldGhlciB0byBmaXQgdGhlIHZpZXdwb3J0IHRvIHRoZSBncmFwaFxuICAgIHBhZGRpbmc6IDMwLCAvLyBwYWRkaW5nIG9uIGZpdFxuICAgIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICAgIHJhbmRvbTogZmFsc2UsIC8vIHdoZXRoZXIgdG8gdXNlIHJhbmRvbSBpbml0aWFsIHBvc2l0aW9uc1xuICAgIGluZmluaXRlOiBmYWxzZSwgLy8gb3ZlcnJpZGVzIGFsbCBvdGhlciBvcHRpb25zIGZvciBhIGZvcmNlcy1hbGwtdGhlLXRpbWUgbW9kZVxuICAgIHJlYWR5OiB1bmRlZmluZWQsIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gICAgc3RvcDogdW5kZWZpbmVkLCAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG5cbiAgICAvLyBzcHJpbmd5IGZvcmNlc1xuICAgIHN0aWZmbmVzczogNDAwLFxuICAgIHJlcHVsc2lvbjogNDAwLFxuICAgIGRhbXBpbmc6IDAuNVxuICB9O1xuXG4gIGZ1bmN0aW9uIFNwcmluZ3lMYXlvdXQoIG9wdGlvbnMgKXtcbiAgICB0aGlzLm9wdGlvbnMgPSAkJC51dGlsLmV4dGVuZCh0cnVlLCB7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuICB9XG4gIFxuICBTcHJpbmd5TGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpe1xuICAgIHZhciBsYXlvdXQgPSB0aGlzO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgICQkLnV0aWwucmVxdWlyZSgnU3ByaW5neScsIGZ1bmN0aW9uKFNwcmluZ3kpe1xuXG4gICAgICB2YXIgc2ltVXBkYXRpbmdQb3MgPSBmYWxzZTtcblxuICAgICAgdmFyIGN5ID0gb3B0aW9ucy5jeTtcbiAgICAgIGxheW91dC50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHN0YXJ0JywgbGF5b3V0OiBsYXlvdXQgfSk7XG4gICAgICBcbiAgICAgIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICAgICAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpLm5vdCgnOnBhcmVudCcpO1xuICAgICAgdmFyIGVkZ2VzID0gZWxlcy5lZGdlcygpO1xuICAgXG4gICAgICB2YXIgYmIgPSAkJC51dGlsLm1ha2VCb3VuZGluZ0JveCggb3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgICAgIHgxOiAwLCB5MTogMCwgdzogY3kud2lkdGgoKSwgaDogY3kuaGVpZ2h0KClcbiAgICAgIH0gKTtcbiAgICAgIFxuICAgICAgLy8gbWFrZSBhIG5ldyBncmFwaFxuICAgICAgdmFyIGdyYXBoID0gbmV3IFNwcmluZ3kuR3JhcGgoKTtcblxuICAgICAgLy8gbWFrZSBzb21lIG5vZGVzXG4gICAgICBub2Rlcy5lYWNoKGZ1bmN0aW9uKGksIG5vZGUpe1xuICAgICAgICBub2RlLnNjcmF0Y2goJ3NwcmluZ3knLCB7XG4gICAgICAgICAgbW9kZWw6IGdyYXBoLm5ld05vZGUoe1xuICAgICAgICAgICAgZWxlbWVudDogbm9kZVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGNvbm5lY3QgdGhlbSB3aXRoIGVkZ2VzXG4gICAgICBlZGdlcy5lYWNoKGZ1bmN0aW9uKGksIGVkZ2Upe1xuICAgICAgICB2YXIgZmRTcmMgPSBlZGdlLnNvdXJjZSgpLnNjcmF0Y2goJ3NwcmluZ3knKS5tb2RlbDtcbiAgICAgICAgdmFyIGZkVGd0ID0gZWRnZS50YXJnZXQoKS5zY3JhdGNoKCdzcHJpbmd5JykubW9kZWw7XG4gICAgICAgIFxuICAgICAgICBlZGdlLnNjcmF0Y2goJ3NwcmluZ3knLCB7XG4gICAgICAgICAgbW9kZWw6IGdyYXBoLm5ld0VkZ2UoZmRTcmMsIGZkVGd0LCB7XG4gICAgICAgICAgICBlbGVtZW50OiBlZGdlXG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgdmFyIHNpbSA9IHdpbmRvdy5zaW0gPSBuZXcgU3ByaW5neS5MYXlvdXQuRm9yY2VEaXJlY3RlZChncmFwaCwgb3B0aW9ucy5zdGlmZm5lc3MsIG9wdGlvbnMucmVwdWxzaW9uLCBvcHRpb25zLmRhbXBpbmcpO1xuXG4gICAgICBpZiggb3B0aW9ucy5pbmZpbml0ZSApe1xuICAgICAgICBzaW0ubWluRW5lcmd5VGhyZXNob2xkID0gLUluZmluaXR5O1xuICAgICAgfVxuXG4gICAgICB2YXIgY3VycmVudEJCID0gc2ltLmdldEJvdW5kaW5nQm94KCk7XG4gICAgICAvLyB2YXIgdGFyZ2V0QkIgPSB7Ym90dG9tbGVmdDogbmV3IFNwcmluZ3kuVmVjdG9yKC0yLCAtMiksIHRvcHJpZ2h0OiBuZXcgU3ByaW5neS5WZWN0b3IoMiwgMil9O1xuICAgICAgXG4gICAgICAvLyBjb252ZXJ0IHRvL2Zyb20gc2NyZWVuIGNvb3JkaW5hdGVzXG4gICAgICB2YXIgdG9TY3JlZW4gPSBmdW5jdGlvbihwKSB7XG4gICAgICAgIGN1cnJlbnRCQiA9IHNpbS5nZXRCb3VuZGluZ0JveCgpO1xuXG4gICAgICAgIHZhciBzaXplID0gY3VycmVudEJCLnRvcHJpZ2h0LnN1YnRyYWN0KGN1cnJlbnRCQi5ib3R0b21sZWZ0KTtcbiAgICAgICAgdmFyIHN4ID0gcC5zdWJ0cmFjdChjdXJyZW50QkIuYm90dG9tbGVmdCkuZGl2aWRlKHNpemUueCkueCAqIGJiLncgKyBiYi54MTtcbiAgICAgICAgdmFyIHN5ID0gcC5zdWJ0cmFjdChjdXJyZW50QkIuYm90dG9tbGVmdCkuZGl2aWRlKHNpemUueSkueSAqIGJiLmggKyBiYi54MTtcblxuICAgICAgICByZXR1cm4gbmV3IFNwcmluZ3kuVmVjdG9yKHN4LCBzeSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgZnJvbVNjcmVlbiA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgY3VycmVudEJCID0gc2ltLmdldEJvdW5kaW5nQm94KCk7XG5cbiAgICAgICAgdmFyIHNpemUgPSBjdXJyZW50QkIudG9wcmlnaHQuc3VidHJhY3QoY3VycmVudEJCLmJvdHRvbWxlZnQpO1xuICAgICAgICB2YXIgcHggPSAoKHMueCAtIGJiLngxKSAvIGJiLncpICogc2l6ZS54ICsgY3VycmVudEJCLmJvdHRvbWxlZnQueDtcbiAgICAgICAgdmFyIHB5ID0gKChzLnkgLSBiYi55MSkgLyBiYi5oKSAqIHNpemUueSArIGN1cnJlbnRCQi5ib3R0b21sZWZ0Lnk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBTcHJpbmd5LlZlY3RvcihweCwgcHkpO1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgdmFyIG1vdmVkTm9kZXMgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICBcbiAgICAgIHZhciBudW1Ob2RlcyA9IGN5Lm5vZGVzKCkuc2l6ZSgpO1xuICAgICAgdmFyIGRyYXduTm9kZXMgPSAxO1xuICAgICAgdmFyIGZkUmVuZGVyZXIgPSBuZXcgU3ByaW5neS5SZW5kZXJlcihzaW0sXG4gICAgICAgIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICAgIGlmKCBzZWxmLnN0b3BwZWQgKXsgcmV0dXJuOyB9IC8vIGJlY2F1c2Ugc3ByaW5neSBpcyBhIGJ1Z2d5IGxheW91dFxuICAgICAgICAgIFxuICAgICAgICAgIGlmKCBtb3ZlZE5vZGVzLmxlbmd0aCA+IDAgJiYgb3B0aW9ucy5hbmltYXRlICl7XG4gICAgICAgICAgICBzaW1VcGRhdGluZ1BvcyA9IHRydWU7XG5cbiAgICAgICAgICAgIG1vdmVkTm9kZXMucnRyaWdnZXIoJ3Bvc2l0aW9uJyk7XG5cbiAgICAgICAgICAgIGlmKCBvcHRpb25zLmZpdCApe1xuICAgICAgICAgICAgICBjeS5maXQoIG9wdGlvbnMucGFkZGluZyApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtb3ZlZE5vZGVzID0gY3kuY29sbGVjdGlvbigpO1xuXG4gICAgICAgICAgICBzaW1VcGRhdGluZ1BvcyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBmdW5jdGlvbiBkcmF3RWRnZShlZGdlLCBwMSwgcDIpIHtcbiAgICAgICAgICAvLyBkcmF3IGFuIGVkZ2VcbiAgICAgICAgfSxcblxuICAgICAgICBmdW5jdGlvbiBkcmF3Tm9kZShub2RlLCBwKSB7XG4gICAgICAgICAgaWYoIHNlbGYuc3RvcHBlZCApeyByZXR1cm47IH0gLy8gYmVjYXVzZSBzcHJpbmd5IGlzIGEgYnVnZ3kgbGF5b3V0XG5cbiAgICAgICAgICB2YXIgdiA9IHRvU2NyZWVuKHApO1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gbm9kZS5kYXRhLmVsZW1lbnQ7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYoICFlbGVtZW50LmxvY2tlZCgpICYmICFlbGVtZW50LmdyYWJiZWQoKSApe1xuICAgICAgICAgICAgICBlbGVtZW50Ll9wcml2YXRlLnBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgIHg6IHYueCxcbiAgICAgICAgICAgICAgICB5OiB2LnlcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgbW92ZWROb2Rlcy5tZXJnZShlbGVtZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9zZXRMYXlvdXRQb3NpdGlvbkZvckVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGlmKCBkcmF3bk5vZGVzID09IG51bU5vZGVzICl7XG4gICAgICAgICAgICBsYXlvdXQub25lKCdsYXlvdXRyZWFkeScsIG9wdGlvbnMucmVhZHkpO1xuICAgICAgICAgICAgbGF5b3V0LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0cmVhZHknLCBsYXlvdXQ6IGxheW91dCB9KTtcbiAgICAgICAgICB9IFxuICAgICAgICAgIFxuICAgICAgICAgIGRyYXduTm9kZXMrKztcbiAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIHNldCBpbml0aWFsIG5vZGUgcG9pbnRzXG4gICAgICBub2Rlcy5lYWNoKGZ1bmN0aW9uKGksIGVsZSl7XG4gICAgICAgIGlmKCAhb3B0aW9ucy5yYW5kb20gKXtcbiAgICAgICAgICBzZXRMYXlvdXRQb3NpdGlvbkZvckVsZW1lbnQoZWxlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIHVwZGF0ZSBub2RlIHBvc2l0aW9ucyB3aGVuIGRyYWdnaW5nXG4gICAgICB2YXIgZHJhZ0hhbmRsZXI7XG4gICAgICBub2Rlcy5vbigncG9zaXRpb24nLCBkcmFnSGFuZGxlciA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKCBzaW1VcGRhdGluZ1BvcyApeyByZXR1cm47IH1cblxuICAgICAgICBzZXRMYXlvdXRQb3NpdGlvbkZvckVsZW1lbnQodGhpcyk7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgZnVuY3Rpb24gc2V0TGF5b3V0UG9zaXRpb25Gb3JFbGVtZW50KGVsZW1lbnQpe1xuICAgICAgICB2YXIgZmRJZCA9IGVsZW1lbnQuc2NyYXRjaCgnc3ByaW5neScpLm1vZGVsLmlkO1xuICAgICAgICB2YXIgZmRQID0gZmRSZW5kZXJlci5sYXlvdXQubm9kZVBvaW50c1tmZElkXS5wO1xuICAgICAgICB2YXIgcG9zID0gZWxlbWVudC5wb3NpdGlvbigpO1xuICAgICAgICB2YXIgcG9zaXRpb25JbkZkID0gKHBvcy54ICE9IG51bGwgJiYgcG9zLnkgIT0gbnVsbCkgPyBmcm9tU2NyZWVuKGVsZW1lbnQucG9zaXRpb24oKSkgOiB7XG4gICAgICAgICAgeDogTWF0aC5yYW5kb20oKSAqIDQgLSAyLFxuICAgICAgICAgIHk6IE1hdGgucmFuZG9tKCkgKiA0IC0gMlxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgZmRQLnggPSBwb3NpdGlvbkluRmQueDtcbiAgICAgICAgZmRQLnkgPSBwb3NpdGlvbkluRmQueTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIGdyYWJiYWJsZU5vZGVzID0gbm9kZXMuZmlsdGVyKFwiOmdyYWJiYWJsZVwiKTtcbiAgICAgIFxuICAgICAgZnVuY3Rpb24gc3RhcnQoKXtcbiAgICAgICAgc2VsZi5zdG9wcGVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gZGlzYWJsZSBncmFiYmluZyBpZiBzbyBzZXRcbiAgICAgICAgaWYoIG9wdGlvbnMudW5ncmFiaWZ5V2hpbGVTaW11bGF0aW5nICl7XG4gICAgICAgICAgZ3JhYmJhYmxlTm9kZXMudW5ncmFiaWZ5KCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGZkUmVuZGVyZXIuc3RhcnQoKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgc2VsZi5zdG9wU3lzdGVtID0gZnVuY3Rpb24oKXtcbiAgICAgICAgc2VsZi5zdG9wcGVkID0gdHJ1ZTtcblxuICAgICAgICBncmFwaC5maWx0ZXJOb2RlcyhmdW5jdGlvbigpe1xuICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gcmVtb3ZlIGFsbCBub2Rlc1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGlmKCBvcHRpb25zLnVuZ3JhYmlmeVdoaWxlU2ltdWxhdGluZyApe1xuICAgICAgICAgIGdyYWJiYWJsZU5vZGVzLmdyYWJpZnkoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBvcHRpb25zLmZpdCApe1xuICAgICAgICAgIGN5LmZpdCggb3B0aW9ucy5wYWRkaW5nICk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIG5vZGVzLm9mZignZHJhZyBwb3NpdGlvbicsIGRyYWdIYW5kbGVyKTtcblxuICAgICAgICBsYXlvdXQub25lKCdsYXlvdXRzdG9wJywgb3B0aW9ucy5zdG9wKTtcbiAgICAgICAgbGF5b3V0LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0c3RvcCcsIGxheW91dDogbGF5b3V0IH0pO1xuXG4gICAgICAgIHNlbGYuc3RvcFN5c3RlbSA9IG51bGw7XG4gICAgICB9O1xuICAgICAgXG4gICAgICBzdGFydCgpO1xuICAgICAgaWYoICFvcHRpb25zLmluZmluaXRlICl7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICBzZWxmLnN0b3AoKTtcbiAgICAgICAgfSwgb3B0aW9ucy5tYXhTaW11bGF0aW9uVGltZSk7XG4gICAgICB9XG5cbiAgICB9KTsgLy8gcmVxdWlyZVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG5cbiAgU3ByaW5neUxheW91dC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCl7XG4gICAgaWYoIHRoaXMuc3RvcFN5c3RlbSAhPSBudWxsICl7XG4gICAgICB0aGlzLnN0b3BTeXN0ZW0oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcbiAgXG4gICQkKCdsYXlvdXQnLCAnc3ByaW5neScsIFNwcmluZ3lMYXlvdXQpO1xuXG4gIFxufSkoY3l0b3NjYXBlKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgICBcbiAgZnVuY3Rpb24gTnVsbFJlbmRlcmVyKG9wdGlvbnMpe1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgXG4gIE51bGxSZW5kZXJlci5wcm90b3R5cGUucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlID0gZnVuY3Rpb24oKXtcbiAgfTtcblxuICBOdWxsUmVuZGVyZXIucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgLy8gdGhlIG51bGwgcmVuZGVyZXIgZG9lcyBub3RoaW5nXG4gIH07XG4gIFxuICAkJCgncmVuZGVyZXInLCAnbnVsbCcsIE51bGxSZW5kZXJlcik7XG4gIFxufSkoIGN5dG9zY2FwZSApO1xuIiwiLyohXG4gKiBAb3ZlcnZpZXcgZXM2LXByb21pc2UgLSBhIHRpbnkgaW1wbGVtZW50YXRpb24gb2YgUHJvbWlzZXMvQSsuXG4gKiBAY29weXJpZ2h0IENvcHlyaWdodCAoYykgMjAxNCBZZWh1ZGEgS2F0eiwgVG9tIERhbGUsIFN0ZWZhbiBQZW5uZXIgYW5kIGNvbnRyaWJ1dG9ycyAoQ29udmVyc2lvbiB0byBFUzYgQVBJIGJ5IEpha2UgQXJjaGliYWxkKVxuICogQGxpY2Vuc2UgICBMaWNlbnNlZCB1bmRlciBNSVQgbGljZW5zZVxuICogICAgICAgICAgICBTZWUgaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2pha2VhcmNoaWJhbGQvZXM2LXByb21pc2UvbWFzdGVyL0xJQ0VOU0VcbiAqIEB2ZXJzaW9uICAgMy4wLjJcbiAqL1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHV0aWxzJCRvYmplY3RPckZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSR1dGlscyQkaXNGdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc01heWJlVGhlbmFibGUoeCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsO1xuICAgIH1cblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkdXRpbHMkJF9pc0FycmF5O1xuICAgIGlmICghQXJyYXkuaXNBcnJheSkge1xuICAgICAgbGliJGVzNiRwcm9taXNlJHV0aWxzJCRfaXNBcnJheSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkdXRpbHMkJF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbiAgICB9XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc0FycmF5ID0gbGliJGVzNiRwcm9taXNlJHV0aWxzJCRfaXNBcnJheTtcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJGxlbiA9IDA7XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkdmVydHhOZXh0O1xuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkY3VzdG9tU2NoZWR1bGVyRm47XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXAgPSBmdW5jdGlvbiBhc2FwKGNhbGxiYWNrLCBhcmcpIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRxdWV1ZVtsaWIkZXM2JHByb21pc2UkYXNhcCQkbGVuXSA9IGNhbGxiYWNrO1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHF1ZXVlW2xpYiRlczYkcHJvbWlzZSRhc2FwJCRsZW4gKyAxXSA9IGFyZztcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRsZW4gKz0gMjtcbiAgICAgIGlmIChsaWIkZXM2JHByb21pc2UkYXNhcCQkbGVuID09PSAyKSB7XG4gICAgICAgIC8vIElmIGxlbiBpcyAyLCB0aGF0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byBzY2hlZHVsZSBhbiBhc3luYyBmbHVzaC5cbiAgICAgICAgLy8gSWYgYWRkaXRpb25hbCBjYWxsYmFja3MgYXJlIHF1ZXVlZCBiZWZvcmUgdGhlIHF1ZXVlIGlzIGZsdXNoZWQsIHRoZXlcbiAgICAgICAgLy8gd2lsbCBiZSBwcm9jZXNzZWQgYnkgdGhpcyBmbHVzaCB0aGF0IHdlIGFyZSBzY2hlZHVsaW5nLlxuICAgICAgICBpZiAobGliJGVzNiRwcm9taXNlJGFzYXAkJGN1c3RvbVNjaGVkdWxlckZuKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGN1c3RvbVNjaGVkdWxlckZuKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRmbHVzaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHNjaGVkdWxlRmx1c2goKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzZXRTY2hlZHVsZXIoc2NoZWR1bGVGbikge1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGN1c3RvbVNjaGVkdWxlckZuID0gc2NoZWR1bGVGbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2V0QXNhcChhc2FwRm4pIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRhc2FwID0gYXNhcEZuO1xuICAgIH1cblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkYnJvd3NlcldpbmRvdyA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRicm93c2VyR2xvYmFsID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJGJyb3dzZXJXaW5kb3cgfHwge307XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRCcm93c2VyTXV0YXRpb25PYnNlcnZlciA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRicm93c2VyR2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgbGliJGVzNiRwcm9taXNlJGFzYXAkJGJyb3dzZXJHbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJGlzTm9kZSA9IHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiB7fS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXSc7XG5cbiAgICAvLyB0ZXN0IGZvciB3ZWIgd29ya2VyIGJ1dCBub3QgaW4gSUUxMFxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkaXNXb3JrZXIgPSB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICB0eXBlb2YgaW1wb3J0U2NyaXB0cyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCc7XG5cbiAgICAvLyBub2RlXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZU5leHRUaWNrKCkge1xuICAgICAgLy8gbm9kZSB2ZXJzaW9uIDAuMTAueCBkaXNwbGF5cyBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgd2hlbiBuZXh0VGljayBpcyB1c2VkIHJlY3Vyc2l2ZWx5XG4gICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2N1am9qcy93aGVuL2lzc3Vlcy80MTAgZm9yIGRldGFpbHNcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhsaWIkZXM2JHByb21pc2UkYXNhcCQkZmx1c2gpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyB2ZXJ0eFxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VWZXJ0eFRpbWVyKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkdmVydHhOZXh0KGxpYiRlczYkcHJvbWlzZSRhc2FwJCRmbHVzaCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VNdXRhdGlvbk9ic2VydmVyKCkge1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgdmFyIG9ic2VydmVyID0gbmV3IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRCcm93c2VyTXV0YXRpb25PYnNlcnZlcihsaWIkZXM2JHByb21pc2UkYXNhcCQkZmx1c2gpO1xuICAgICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgICBvYnNlcnZlci5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBub2RlLmRhdGEgPSAoaXRlcmF0aW9ucyA9ICsraXRlcmF0aW9ucyAlIDIpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyB3ZWIgd29ya2VyXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZU1lc3NhZ2VDaGFubmVsKCkge1xuICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJGZsdXNoO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZVNldFRpbWVvdXQoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHNldFRpbWVvdXQobGliJGVzNiRwcm9taXNlJGFzYXAkJGZsdXNoLCAxKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRxdWV1ZSA9IG5ldyBBcnJheSgxMDAwKTtcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkZmx1c2goKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRsZW47IGkrPTIpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHF1ZXVlW2ldO1xuICAgICAgICB2YXIgYXJnID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHF1ZXVlW2krMV07XG5cbiAgICAgICAgY2FsbGJhY2soYXJnKTtcblxuICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkcXVldWVbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRxdWV1ZVtpKzFdID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkbGVuID0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXR0ZW1wdFZlcnR4KCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHIgPSByZXF1aXJlO1xuICAgICAgICB2YXIgdmVydHggPSByKCd2ZXJ0eCcpO1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkdmVydHhOZXh0ID0gdmVydHgucnVuT25Mb29wIHx8IHZlcnR4LnJ1bk9uQ29udGV4dDtcbiAgICAgICAgcmV0dXJuIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VWZXJ0eFRpbWVyKCk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VTZXRUaW1lb3V0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzY2hlZHVsZUZsdXNoO1xuICAgIC8vIERlY2lkZSB3aGF0IGFzeW5jIG1ldGhvZCB0byB1c2UgdG8gdHJpZ2dlcmluZyBwcm9jZXNzaW5nIG9mIHF1ZXVlZCBjYWxsYmFja3M6XG4gICAgaWYgKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRpc05vZGUpIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzY2hlZHVsZUZsdXNoID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZU5leHRUaWNrKCk7XG4gICAgfSBlbHNlIGlmIChsaWIkZXM2JHByb21pc2UkYXNhcCQkQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzY2hlZHVsZUZsdXNoID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZU11dGF0aW9uT2JzZXJ2ZXIoKTtcbiAgICB9IGVsc2UgaWYgKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRpc1dvcmtlcikge1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHNjaGVkdWxlRmx1c2ggPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlTWVzc2FnZUNoYW5uZWwoKTtcbiAgICB9IGVsc2UgaWYgKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRicm93c2VyV2luZG93ID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzY2hlZHVsZUZsdXNoID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJGF0dGVtcHRWZXJ0eCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2NoZWR1bGVGbHVzaCA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VTZXRUaW1lb3V0KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbm9vcCgpIHt9XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORyAgID0gdm9pZCAwO1xuICAgIHZhciBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRGVUxGSUxMRUQgPSAxO1xuICAgIHZhciBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRSRUpFQ1RFRCAgPSAyO1xuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEdFVF9USEVOX0VSUk9SID0gbmV3IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEVycm9yT2JqZWN0KCk7XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRzZWxmRnVsZmlsbG1lbnQoKSB7XG4gICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihcIllvdSBjYW5ub3QgcmVzb2x2ZSBhIHByb21pc2Ugd2l0aCBpdHNlbGZcIik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkY2Fubm90UmV0dXJuT3duKCkge1xuICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoJ0EgcHJvbWlzZXMgY2FsbGJhY2sgY2Fubm90IHJldHVybiB0aGF0IHNhbWUgcHJvbWlzZS4nKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRnZXRUaGVuKHByb21pc2UpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW47XG4gICAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEdFVF9USEVOX0VSUk9SLmVycm9yID0gZXJyb3I7XG4gICAgICAgIHJldHVybiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRHRVRfVEhFTl9FUlJPUjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCR0cnlUaGVuKHRoZW4sIHZhbHVlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoZW4uY2FsbCh2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRoYW5kbGVGb3JlaWduVGhlbmFibGUocHJvbWlzZSwgdGhlbmFibGUsIHRoZW4pIHtcbiAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcChmdW5jdGlvbihwcm9taXNlKSB7XG4gICAgICAgIHZhciBzZWFsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGVycm9yID0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkdHJ5VGhlbih0aGVuLCB0aGVuYWJsZSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBpZiAoc2VhbGVkKSB7IHJldHVybjsgfVxuICAgICAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICAgICAgaWYgKHRoZW5hYmxlICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgICAgaWYgKHNlYWxlZCkgeyByZXR1cm47IH1cbiAgICAgICAgICBzZWFsZWQgPSB0cnVlO1xuXG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgICAgIH0sICdTZXR0bGU6ICcgKyAocHJvbWlzZS5fbGFiZWwgfHwgJyB1bmtub3duIHByb21pc2UnKSk7XG5cbiAgICAgICAgaWYgKCFzZWFsZWQgJiYgZXJyb3IpIHtcbiAgICAgICAgICBzZWFsZWQgPSB0cnVlO1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0sIHByb21pc2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlKSB7XG4gICAgICBpZiAodGhlbmFibGUuX3N0YXRlID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRGVUxGSUxMRUQpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCB0aGVuYWJsZS5fcmVzdWx0KTtcbiAgICAgIH0gZWxzZSBpZiAodGhlbmFibGUuX3N0YXRlID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRSRUpFQ1RFRCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgdGhlbmFibGUuX3Jlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRzdWJzY3JpYmUodGhlbmFibGUsIHVuZGVmaW5lZCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSkge1xuICAgICAgaWYgKG1heWJlVGhlbmFibGUuY29uc3RydWN0b3IgPT09IHByb21pc2UuY29uc3RydWN0b3IpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdGhlbiA9IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGdldFRoZW4obWF5YmVUaGVuYWJsZSk7XG5cbiAgICAgICAgaWYgKHRoZW4gPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEdFVF9USEVOX0VSUk9SKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEdFVF9USEVOX0VSUk9SLmVycm9yKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGVuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgICAgICB9IGVsc2UgaWYgKGxpYiRlczYkcHJvbWlzZSR1dGlscyQkaXNGdW5jdGlvbih0aGVuKSkge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlLCB0aGVuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSkge1xuICAgICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRzZWxmRnVsZmlsbG1lbnQoKSk7XG4gICAgICB9IGVsc2UgaWYgKGxpYiRlczYkcHJvbWlzZSR1dGlscyQkb2JqZWN0T3JGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRwdWJsaXNoUmVqZWN0aW9uKHByb21pc2UpIHtcbiAgICAgIGlmIChwcm9taXNlLl9vbmVycm9yKSB7XG4gICAgICAgIHByb21pc2UuX29uZXJyb3IocHJvbWlzZS5fcmVzdWx0KTtcbiAgICAgIH1cblxuICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcHVibGlzaChwcm9taXNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIHZhbHVlKSB7XG4gICAgICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBFTkRJTkcpIHsgcmV0dXJuOyB9XG5cbiAgICAgIHByb21pc2UuX3Jlc3VsdCA9IHZhbHVlO1xuICAgICAgcHJvbWlzZS5fc3RhdGUgPSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRGVUxGSUxMRUQ7XG5cbiAgICAgIGlmIChwcm9taXNlLl9zdWJzY3JpYmVycy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXAobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcHVibGlzaCwgcHJvbWlzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHJlYXNvbikge1xuICAgICAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQRU5ESU5HKSB7IHJldHVybjsgfVxuICAgICAgcHJvbWlzZS5fc3RhdGUgPSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRSRUpFQ1RFRDtcbiAgICAgIHByb21pc2UuX3Jlc3VsdCA9IHJlYXNvbjtcblxuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXAobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcHVibGlzaFJlamVjdGlvbiwgcHJvbWlzZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkc3Vic2NyaWJlKHBhcmVudCwgY2hpbGQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKSB7XG4gICAgICB2YXIgc3Vic2NyaWJlcnMgPSBwYXJlbnQuX3N1YnNjcmliZXJzO1xuICAgICAgdmFyIGxlbmd0aCA9IHN1YnNjcmliZXJzLmxlbmd0aDtcblxuICAgICAgcGFyZW50Ll9vbmVycm9yID0gbnVsbDtcblxuICAgICAgc3Vic2NyaWJlcnNbbGVuZ3RoXSA9IGNoaWxkO1xuICAgICAgc3Vic2NyaWJlcnNbbGVuZ3RoICsgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRlVMRklMTEVEXSA9IG9uRnVsZmlsbG1lbnQ7XG4gICAgICBzdWJzY3JpYmVyc1tsZW5ndGggKyBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRSRUpFQ1RFRF0gID0gb25SZWplY3Rpb247XG5cbiAgICAgIGlmIChsZW5ndGggPT09IDAgJiYgcGFyZW50Ll9zdGF0ZSkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcChsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRwdWJsaXNoLCBwYXJlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHB1Ymxpc2gocHJvbWlzZSkge1xuICAgICAgdmFyIHN1YnNjcmliZXJzID0gcHJvbWlzZS5fc3Vic2NyaWJlcnM7XG4gICAgICB2YXIgc2V0dGxlZCA9IHByb21pc2UuX3N0YXRlO1xuXG4gICAgICBpZiAoc3Vic2NyaWJlcnMubGVuZ3RoID09PSAwKSB7IHJldHVybjsgfVxuXG4gICAgICB2YXIgY2hpbGQsIGNhbGxiYWNrLCBkZXRhaWwgPSBwcm9taXNlLl9yZXN1bHQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3Vic2NyaWJlcnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgY2hpbGQgPSBzdWJzY3JpYmVyc1tpXTtcbiAgICAgICAgY2FsbGJhY2sgPSBzdWJzY3JpYmVyc1tpICsgc2V0dGxlZF07XG5cbiAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgY2hpbGQsIGNhbGxiYWNrLCBkZXRhaWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrKGRldGFpbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHJvbWlzZS5fc3Vic2NyaWJlcnMubGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRFcnJvck9iamVjdCgpIHtcbiAgICAgIHRoaXMuZXJyb3IgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRUUllfQ0FUQ0hfRVJST1IgPSBuZXcgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRXJyb3JPYmplY3QoKTtcblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHRyeUNhdGNoKGNhbGxiYWNrLCBkZXRhaWwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhkZXRhaWwpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFRSWV9DQVRDSF9FUlJPUi5lcnJvciA9IGU7XG4gICAgICAgIHJldHVybiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRUUllfQ0FUQ0hfRVJST1I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgcHJvbWlzZSwgY2FsbGJhY2ssIGRldGFpbCkge1xuICAgICAgdmFyIGhhc0NhbGxiYWNrID0gbGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc0Z1bmN0aW9uKGNhbGxiYWNrKSxcbiAgICAgICAgICB2YWx1ZSwgZXJyb3IsIHN1Y2NlZWRlZCwgZmFpbGVkO1xuXG4gICAgICBpZiAoaGFzQ2FsbGJhY2spIHtcbiAgICAgICAgdmFsdWUgPSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCR0cnlDYXRjaChjYWxsYmFjaywgZGV0YWlsKTtcblxuICAgICAgICBpZiAodmFsdWUgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFRSWV9DQVRDSF9FUlJPUikge1xuICAgICAgICAgIGZhaWxlZCA9IHRydWU7XG4gICAgICAgICAgZXJyb3IgPSB2YWx1ZS5lcnJvcjtcbiAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3VjY2VlZGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRjYW5ub3RSZXR1cm5Pd24oKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gZGV0YWlsO1xuICAgICAgICBzdWNjZWVkZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBFTkRJTkcpIHtcbiAgICAgICAgLy8gbm9vcFxuICAgICAgfSBlbHNlIGlmIChoYXNDYWxsYmFjayAmJiBzdWNjZWVkZWQpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGZhaWxlZCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgfSBlbHNlIGlmIChzZXR0bGVkID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRGVUxGSUxMRUQpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVEKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaW5pdGlhbGl6ZVByb21pc2UocHJvbWlzZSwgcmVzb2x2ZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc29sdmVyKGZ1bmN0aW9uIHJlc29sdmVQcm9taXNlKHZhbHVlKXtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gcmVqZWN0UHJvbWlzZShyZWFzb24pIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yKENvbnN0cnVjdG9yLCBpbnB1dCkge1xuICAgICAgdmFyIGVudW1lcmF0b3IgPSB0aGlzO1xuXG4gICAgICBlbnVtZXJhdG9yLl9pbnN0YW5jZUNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XG4gICAgICBlbnVtZXJhdG9yLnByb21pc2UgPSBuZXcgQ29uc3RydWN0b3IobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbm9vcCk7XG5cbiAgICAgIGlmIChlbnVtZXJhdG9yLl92YWxpZGF0ZUlucHV0KGlucHV0KSkge1xuICAgICAgICBlbnVtZXJhdG9yLl9pbnB1dCAgICAgPSBpbnB1dDtcbiAgICAgICAgZW51bWVyYXRvci5sZW5ndGggICAgID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICBlbnVtZXJhdG9yLl9yZW1haW5pbmcgPSBpbnB1dC5sZW5ndGg7XG5cbiAgICAgICAgZW51bWVyYXRvci5faW5pdCgpO1xuXG4gICAgICAgIGlmIChlbnVtZXJhdG9yLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwoZW51bWVyYXRvci5wcm9taXNlLCBlbnVtZXJhdG9yLl9yZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVudW1lcmF0b3IubGVuZ3RoID0gZW51bWVyYXRvci5sZW5ndGggfHwgMDtcbiAgICAgICAgICBlbnVtZXJhdG9yLl9lbnVtZXJhdGUoKTtcbiAgICAgICAgICBpZiAoZW51bWVyYXRvci5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKGVudW1lcmF0b3IucHJvbWlzZSwgZW51bWVyYXRvci5fcmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChlbnVtZXJhdG9yLnByb21pc2UsIGVudW1lcmF0b3IuX3ZhbGlkYXRpb25FcnJvcigpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX3ZhbGlkYXRlSW5wdXQgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgcmV0dXJuIGxpYiRlczYkcHJvbWlzZSR1dGlscyQkaXNBcnJheShpbnB1dCk7XG4gICAgfTtcblxuICAgIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yLnByb3RvdHlwZS5fdmFsaWRhdGlvbkVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdBcnJheSBNZXRob2RzIG11c3QgYmUgcHJvdmlkZWQgYW4gQXJyYXknKTtcbiAgICB9O1xuXG4gICAgbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJEVudW1lcmF0b3IucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9yZXN1bHQgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIH07XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJGRlZmF1bHQgPSBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkRW51bWVyYXRvcjtcblxuICAgIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yLnByb3RvdHlwZS5fZW51bWVyYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZW51bWVyYXRvciA9IHRoaXM7XG5cbiAgICAgIHZhciBsZW5ndGggID0gZW51bWVyYXRvci5sZW5ndGg7XG4gICAgICB2YXIgcHJvbWlzZSA9IGVudW1lcmF0b3IucHJvbWlzZTtcbiAgICAgIHZhciBpbnB1dCAgID0gZW51bWVyYXRvci5faW5wdXQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBwcm9taXNlLl9zdGF0ZSA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORyAmJiBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZW51bWVyYXRvci5fZWFjaEVudHJ5KGlucHV0W2ldLCBpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJEVudW1lcmF0b3IucHJvdG90eXBlLl9lYWNoRW50cnkgPSBmdW5jdGlvbihlbnRyeSwgaSkge1xuICAgICAgdmFyIGVudW1lcmF0b3IgPSB0aGlzO1xuICAgICAgdmFyIGMgPSBlbnVtZXJhdG9yLl9pbnN0YW5jZUNvbnN0cnVjdG9yO1xuXG4gICAgICBpZiAobGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc01heWJlVGhlbmFibGUoZW50cnkpKSB7XG4gICAgICAgIGlmIChlbnRyeS5jb25zdHJ1Y3RvciA9PT0gYyAmJiBlbnRyeS5fc3RhdGUgIT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBFTkRJTkcpIHtcbiAgICAgICAgICBlbnRyeS5fb25lcnJvciA9IG51bGw7XG4gICAgICAgICAgZW51bWVyYXRvci5fc2V0dGxlZEF0KGVudHJ5Ll9zdGF0ZSwgaSwgZW50cnkuX3Jlc3VsdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW51bWVyYXRvci5fd2lsbFNldHRsZUF0KGMucmVzb2x2ZShlbnRyeSksIGkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbnVtZXJhdG9yLl9yZW1haW5pbmctLTtcbiAgICAgICAgZW51bWVyYXRvci5fcmVzdWx0W2ldID0gZW50cnk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yLnByb3RvdHlwZS5fc2V0dGxlZEF0ID0gZnVuY3Rpb24oc3RhdGUsIGksIHZhbHVlKSB7XG4gICAgICB2YXIgZW51bWVyYXRvciA9IHRoaXM7XG4gICAgICB2YXIgcHJvbWlzZSA9IGVudW1lcmF0b3IucHJvbWlzZTtcblxuICAgICAgaWYgKHByb21pc2UuX3N0YXRlID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQRU5ESU5HKSB7XG4gICAgICAgIGVudW1lcmF0b3IuX3JlbWFpbmluZy0tO1xuXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUkVKRUNURUQpIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVudW1lcmF0b3IuX3Jlc3VsdFtpXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChlbnVtZXJhdG9yLl9yZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCBlbnVtZXJhdG9yLl9yZXN1bHQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX3dpbGxTZXR0bGVBdCA9IGZ1bmN0aW9uKHByb21pc2UsIGkpIHtcbiAgICAgIHZhciBlbnVtZXJhdG9yID0gdGhpcztcblxuICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkc3Vic2NyaWJlKHByb21pc2UsIHVuZGVmaW5lZCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgZW51bWVyYXRvci5fc2V0dGxlZEF0KGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEZVTEZJTExFRCwgaSwgdmFsdWUpO1xuICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgIGVudW1lcmF0b3IuX3NldHRsZWRBdChsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRSRUpFQ1RFRCwgaSwgcmVhc29uKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHByb21pc2UkYWxsJCRhbGwoZW50cmllcykge1xuICAgICAgcmV0dXJuIG5ldyBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkZGVmYXVsdCh0aGlzLCBlbnRyaWVzKS5wcm9taXNlO1xuICAgIH1cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHByb21pc2UkYWxsJCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkYWxsJCRhbGw7XG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmFjZSQkcmFjZShlbnRyaWVzKSB7XG4gICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICAgICAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3IobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbm9vcCk7XG5cbiAgICAgIGlmICghbGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc0FycmF5KGVudHJpZXMpKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGFuIGFycmF5IHRvIHJhY2UuJykpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbmd0aCA9IGVudHJpZXMubGVuZ3RoO1xuXG4gICAgICBmdW5jdGlvbiBvbkZ1bGZpbGxtZW50KHZhbHVlKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvblJlamVjdGlvbihyZWFzb24pIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBwcm9taXNlLl9zdGF0ZSA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORyAmJiBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkc3Vic2NyaWJlKENvbnN0cnVjdG9yLnJlc29sdmUoZW50cmllc1tpXSksIHVuZGVmaW5lZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJhY2UkJGRlZmF1bHQgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyYWNlJCRyYWNlO1xuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlc29sdmUkJHJlc29sdmUob2JqZWN0KSB7XG4gICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICAgICAgaWYgKG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QuY29uc3RydWN0b3IgPT09IENvbnN0cnVjdG9yKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG5vb3ApO1xuICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCBvYmplY3QpO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZXNvbHZlJCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVzb2x2ZSQkcmVzb2x2ZTtcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZWplY3QkJHJlamVjdChyZWFzb24pIHtcbiAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuICAgICAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3IobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbm9vcCk7XG4gICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVqZWN0JCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVqZWN0JCRyZWplY3Q7XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJGNvdW50ZXIgPSAwO1xuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHByb21pc2UkJG5lZWRzUmVzb2x2ZXIoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGEgcmVzb2x2ZXIgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBwcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHByb21pc2UkJG5lZWRzTmV3KCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1Byb21pc2UnOiBQbGVhc2UgdXNlIHRoZSAnbmV3JyBvcGVyYXRvciwgdGhpcyBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbiAgICB9XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJGRlZmF1bHQgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZTtcbiAgICAvKipcbiAgICAgIFByb21pc2Ugb2JqZWN0cyByZXByZXNlbnQgdGhlIGV2ZW50dWFsIHJlc3VsdCBvZiBhbiBhc3luY2hyb25vdXMgb3BlcmF0aW9uLiBUaGVcbiAgICAgIHByaW1hcnkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggYSBwcm9taXNlIGlzIHRocm91Z2ggaXRzIGB0aGVuYCBtZXRob2QsIHdoaWNoXG4gICAgICByZWdpc3RlcnMgY2FsbGJhY2tzIHRvIHJlY2VpdmUgZWl0aGVyIGEgcHJvbWlzZSdzIGV2ZW50dWFsIHZhbHVlIG9yIHRoZSByZWFzb25cbiAgICAgIHdoeSB0aGUgcHJvbWlzZSBjYW5ub3QgYmUgZnVsZmlsbGVkLlxuXG4gICAgICBUZXJtaW5vbG9neVxuICAgICAgLS0tLS0tLS0tLS1cblxuICAgICAgLSBgcHJvbWlzZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHdpdGggYSBgdGhlbmAgbWV0aG9kIHdob3NlIGJlaGF2aW9yIGNvbmZvcm1zIHRvIHRoaXMgc3BlY2lmaWNhdGlvbi5cbiAgICAgIC0gYHRoZW5hYmxlYCBpcyBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gdGhhdCBkZWZpbmVzIGEgYHRoZW5gIG1ldGhvZC5cbiAgICAgIC0gYHZhbHVlYCBpcyBhbnkgbGVnYWwgSmF2YVNjcmlwdCB2YWx1ZSAoaW5jbHVkaW5nIHVuZGVmaW5lZCwgYSB0aGVuYWJsZSwgb3IgYSBwcm9taXNlKS5cbiAgICAgIC0gYGV4Y2VwdGlvbmAgaXMgYSB2YWx1ZSB0aGF0IGlzIHRocm93biB1c2luZyB0aGUgdGhyb3cgc3RhdGVtZW50LlxuICAgICAgLSBgcmVhc29uYCBpcyBhIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoeSBhIHByb21pc2Ugd2FzIHJlamVjdGVkLlxuICAgICAgLSBgc2V0dGxlZGAgdGhlIGZpbmFsIHJlc3Rpbmcgc3RhdGUgb2YgYSBwcm9taXNlLCBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQuXG5cbiAgICAgIEEgcHJvbWlzZSBjYW4gYmUgaW4gb25lIG9mIHRocmVlIHN0YXRlczogcGVuZGluZywgZnVsZmlsbGVkLCBvciByZWplY3RlZC5cblxuICAgICAgUHJvbWlzZXMgdGhhdCBhcmUgZnVsZmlsbGVkIGhhdmUgYSBmdWxmaWxsbWVudCB2YWx1ZSBhbmQgYXJlIGluIHRoZSBmdWxmaWxsZWRcbiAgICAgIHN0YXRlLiAgUHJvbWlzZXMgdGhhdCBhcmUgcmVqZWN0ZWQgaGF2ZSBhIHJlamVjdGlvbiByZWFzb24gYW5kIGFyZSBpbiB0aGVcbiAgICAgIHJlamVjdGVkIHN0YXRlLiAgQSBmdWxmaWxsbWVudCB2YWx1ZSBpcyBuZXZlciBhIHRoZW5hYmxlLlxuXG4gICAgICBQcm9taXNlcyBjYW4gYWxzbyBiZSBzYWlkIHRvICpyZXNvbHZlKiBhIHZhbHVlLiAgSWYgdGhpcyB2YWx1ZSBpcyBhbHNvIGFcbiAgICAgIHByb21pc2UsIHRoZW4gdGhlIG9yaWdpbmFsIHByb21pc2UncyBzZXR0bGVkIHN0YXRlIHdpbGwgbWF0Y2ggdGhlIHZhbHVlJ3NcbiAgICAgIHNldHRsZWQgc3RhdGUuICBTbyBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IHJlamVjdHMgd2lsbFxuICAgICAgaXRzZWxmIHJlamVjdCwgYW5kIGEgcHJvbWlzZSB0aGF0ICpyZXNvbHZlcyogYSBwcm9taXNlIHRoYXQgZnVsZmlsbHMgd2lsbFxuICAgICAgaXRzZWxmIGZ1bGZpbGwuXG5cblxuICAgICAgQmFzaWMgVXNhZ2U6XG4gICAgICAtLS0tLS0tLS0tLS1cblxuICAgICAgYGBganNcbiAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIC8vIG9uIHN1Y2Nlc3NcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG5cbiAgICAgICAgLy8gb24gZmFpbHVyZVxuICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgIH0pO1xuXG4gICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgLy8gb24gZnVsZmlsbG1lbnRcbiAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICAvLyBvbiByZWplY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIEFkdmFuY2VkIFVzYWdlOlxuICAgICAgLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgIFByb21pc2VzIHNoaW5lIHdoZW4gYWJzdHJhY3RpbmcgYXdheSBhc3luY2hyb25vdXMgaW50ZXJhY3Rpb25zIHN1Y2ggYXNcbiAgICAgIGBYTUxIdHRwUmVxdWVzdGBzLlxuXG4gICAgICBgYGBqc1xuICAgICAgZnVuY3Rpb24gZ2V0SlNPTih1cmwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCk7XG4gICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGhhbmRsZXI7XG4gICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdqc29uJztcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgICAgICB4aHIuc2VuZCgpO1xuXG4gICAgICAgICAgZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IHRoaXMuRE9ORSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy5yZXNwb25zZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignZ2V0SlNPTjogYCcgKyB1cmwgKyAnYCBmYWlsZWQgd2l0aCBzdGF0dXM6IFsnICsgdGhpcy5zdGF0dXMgKyAnXScpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBnZXRKU09OKCcvcG9zdHMuanNvbicpLnRoZW4oZnVuY3Rpb24oanNvbikge1xuICAgICAgICAvLyBvbiBmdWxmaWxsbWVudFxuICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgIC8vIG9uIHJlamVjdGlvblxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgVW5saWtlIGNhbGxiYWNrcywgcHJvbWlzZXMgYXJlIGdyZWF0IGNvbXBvc2FibGUgcHJpbWl0aXZlcy5cblxuICAgICAgYGBganNcbiAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgZ2V0SlNPTignL3Bvc3RzJyksXG4gICAgICAgIGdldEpTT04oJy9jb21tZW50cycpXG4gICAgICBdKS50aGVuKGZ1bmN0aW9uKHZhbHVlcyl7XG4gICAgICAgIHZhbHVlc1swXSAvLyA9PiBwb3N0c0pTT05cbiAgICAgICAgdmFsdWVzWzFdIC8vID0+IGNvbW1lbnRzSlNPTlxuXG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBAY2xhc3MgUHJvbWlzZVxuICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gcmVzb2x2ZXJcbiAgICAgIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgICAgIEBjb25zdHJ1Y3RvclxuICAgICovXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UocmVzb2x2ZXIpIHtcbiAgICAgIHRoaXMuX2lkID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkJGNvdW50ZXIrKztcbiAgICAgIHRoaXMuX3N0YXRlID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fcmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fc3Vic2NyaWJlcnMgPSBbXTtcblxuICAgICAgaWYgKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG5vb3AgIT09IHJlc29sdmVyKSB7XG4gICAgICAgIGlmICghbGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc0Z1bmN0aW9uKHJlc29sdmVyKSkge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRuZWVkc1Jlc29sdmVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UpKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJG5lZWRzTmV3KCk7XG4gICAgICAgIH1cblxuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRpbml0aWFsaXplUHJvbWlzZSh0aGlzLCByZXNvbHZlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UuYWxsID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkYWxsJCRkZWZhdWx0O1xuICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLnJhY2UgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyYWNlJCRkZWZhdWx0O1xuICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLnJlc29sdmUgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZXNvbHZlJCRkZWZhdWx0O1xuICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLnJlamVjdCA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlamVjdCQkZGVmYXVsdDtcbiAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5fc2V0U2NoZWR1bGVyID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHNldFNjaGVkdWxlcjtcbiAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5fc2V0QXNhcCA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzZXRBc2FwO1xuICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLl9hc2FwID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXA7XG5cbiAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5wcm90b3R5cGUgPSB7XG4gICAgICBjb25zdHJ1Y3RvcjogbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UsXG5cbiAgICAvKipcbiAgICAgIFRoZSBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLFxuICAgICAgd2hpY2ggcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGVcbiAgICAgIHJlYXNvbiB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cblxuICAgICAgYGBganNcbiAgICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbih1c2VyKXtcbiAgICAgICAgLy8gdXNlciBpcyBhdmFpbGFibGVcbiAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAgIC8vIHVzZXIgaXMgdW5hdmFpbGFibGUsIGFuZCB5b3UgYXJlIGdpdmVuIHRoZSByZWFzb24gd2h5XG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBDaGFpbmluZ1xuICAgICAgLS0tLS0tLS1cblxuICAgICAgVGhlIHJldHVybiB2YWx1ZSBvZiBgdGhlbmAgaXMgaXRzZWxmIGEgcHJvbWlzZS4gIFRoaXMgc2Vjb25kLCAnZG93bnN0cmVhbSdcbiAgICAgIHByb21pc2UgaXMgcmVzb2x2ZWQgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmaXJzdCBwcm9taXNlJ3MgZnVsZmlsbG1lbnRcbiAgICAgIG9yIHJlamVjdGlvbiBoYW5kbGVyLCBvciByZWplY3RlZCBpZiB0aGUgaGFuZGxlciB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuXG4gICAgICBgYGBqc1xuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHJldHVybiB1c2VyLm5hbWU7XG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIHJldHVybiAnZGVmYXVsdCBuYW1lJztcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHVzZXJOYW1lKSB7XG4gICAgICAgIC8vIElmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgdXNlck5hbWVgIHdpbGwgYmUgdGhlIHVzZXIncyBuYW1lLCBvdGhlcndpc2UgaXRcbiAgICAgICAgLy8gd2lsbCBiZSBgJ2RlZmF1bHQgbmFtZSdgXG4gICAgICB9KTtcblxuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgdXNlciwgYnV0IHN0aWxsIHVuaGFwcHknKTtcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jyk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBuZXZlciByZWFjaGVkXG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIC8vIGlmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgcmVhc29uYCB3aWxsIGJlICdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScuXG4gICAgICAgIC8vIElmIGBmaW5kVXNlcmAgcmVqZWN0ZWQsIGByZWFzb25gIHdpbGwgYmUgJ2BmaW5kVXNlcmAgcmVqZWN0ZWQgYW5kIHdlJ3JlIHVuaGFwcHknLlxuICAgICAgfSk7XG4gICAgICBgYGBcbiAgICAgIElmIHRoZSBkb3duc3RyZWFtIHByb21pc2UgZG9lcyBub3Qgc3BlY2lmeSBhIHJlamVjdGlvbiBoYW5kbGVyLCByZWplY3Rpb24gcmVhc29ucyB3aWxsIGJlIHByb3BhZ2F0ZWQgZnVydGhlciBkb3duc3RyZWFtLlxuXG4gICAgICBgYGBqc1xuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBQZWRhZ29naWNhbEV4Y2VwdGlvbignVXBzdHJlYW0gZXJyb3InKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgLy8gVGhlIGBQZWRnYWdvY2lhbEV4Y2VwdGlvbmAgaXMgcHJvcGFnYXRlZCBhbGwgdGhlIHdheSBkb3duIHRvIGhlcmVcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIEFzc2ltaWxhdGlvblxuICAgICAgLS0tLS0tLS0tLS0tXG5cbiAgICAgIFNvbWV0aW1lcyB0aGUgdmFsdWUgeW91IHdhbnQgdG8gcHJvcGFnYXRlIHRvIGEgZG93bnN0cmVhbSBwcm9taXNlIGNhbiBvbmx5IGJlXG4gICAgICByZXRyaWV2ZWQgYXN5bmNocm9ub3VzbHkuIFRoaXMgY2FuIGJlIGFjaGlldmVkIGJ5IHJldHVybmluZyBhIHByb21pc2UgaW4gdGhlXG4gICAgICBmdWxmaWxsbWVudCBvciByZWplY3Rpb24gaGFuZGxlci4gVGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIHRoZW4gYmUgcGVuZGluZ1xuICAgICAgdW50aWwgdGhlIHJldHVybmVkIHByb21pc2UgaXMgc2V0dGxlZC4gVGhpcyBpcyBjYWxsZWQgKmFzc2ltaWxhdGlvbiouXG5cbiAgICAgIGBgYGpzXG4gICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAgICAgLy8gVGhlIHVzZXIncyBjb21tZW50cyBhcmUgbm93IGF2YWlsYWJsZVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgSWYgdGhlIGFzc2ltbGlhdGVkIHByb21pc2UgcmVqZWN0cywgdGhlbiB0aGUgZG93bnN0cmVhbSBwcm9taXNlIHdpbGwgYWxzbyByZWplY3QuXG5cbiAgICAgIGBgYGpzXG4gICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAgICAgLy8gSWYgYGZpbmRDb21tZW50c0J5QXV0aG9yYCBmdWxmaWxscywgd2UnbGwgaGF2ZSB0aGUgdmFsdWUgaGVyZVxuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIHJlamVjdHMsIHdlJ2xsIGhhdmUgdGhlIHJlYXNvbiBoZXJlXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBTaW1wbGUgRXhhbXBsZVxuICAgICAgLS0tLS0tLS0tLS0tLS1cblxuICAgICAgU3luY2hyb25vdXMgRXhhbXBsZVxuXG4gICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBmaW5kUmVzdWx0KCk7XG4gICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgIC8vIGZhaWx1cmVcbiAgICAgIH1cbiAgICAgIGBgYFxuXG4gICAgICBFcnJiYWNrIEV4YW1wbGVcblxuICAgICAgYGBganNcbiAgICAgIGZpbmRSZXN1bHQoZnVuY3Rpb24ocmVzdWx0LCBlcnIpe1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgUHJvbWlzZSBFeGFtcGxlO1xuXG4gICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICBmaW5kUmVzdWx0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgICAgICAvLyBzdWNjZXNzXG4gICAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgICAgICAvLyBmYWlsdXJlXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBBZHZhbmNlZCBFeGFtcGxlXG4gICAgICAtLS0tLS0tLS0tLS0tLVxuXG4gICAgICBTeW5jaHJvbm91cyBFeGFtcGxlXG5cbiAgICAgIGBgYGphdmFzY3JpcHRcbiAgICAgIHZhciBhdXRob3IsIGJvb2tzO1xuXG4gICAgICB0cnkge1xuICAgICAgICBhdXRob3IgPSBmaW5kQXV0aG9yKCk7XG4gICAgICAgIGJvb2tzICA9IGZpbmRCb29rc0J5QXV0aG9yKGF1dGhvcik7XG4gICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgIC8vIGZhaWx1cmVcbiAgICAgIH1cbiAgICAgIGBgYFxuXG4gICAgICBFcnJiYWNrIEV4YW1wbGVcblxuICAgICAgYGBganNcblxuICAgICAgZnVuY3Rpb24gZm91bmRCb29rcyhib29rcykge1xuXG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGZhaWx1cmUocmVhc29uKSB7XG5cbiAgICAgIH1cblxuICAgICAgZmluZEF1dGhvcihmdW5jdGlvbihhdXRob3IsIGVycil7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmaW5kQm9vb2tzQnlBdXRob3IoYXV0aG9yLCBmdW5jdGlvbihib29rcywgZXJyKSB7XG4gICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGZvdW5kQm9va3MoYm9va3MpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgICBmYWlsdXJlKHJlYXNvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgUHJvbWlzZSBFeGFtcGxlO1xuXG4gICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICBmaW5kQXV0aG9yKCkuXG4gICAgICAgIHRoZW4oZmluZEJvb2tzQnlBdXRob3IpLlxuICAgICAgICB0aGVuKGZ1bmN0aW9uKGJvb2tzKXtcbiAgICAgICAgICAvLyBmb3VuZCBib29rc1xuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIEBtZXRob2QgdGhlblxuICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gb25GdWxmaWxsZWRcbiAgICAgIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0ZWRcbiAgICAgIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgICAgIEByZXR1cm4ge1Byb21pc2V9XG4gICAgKi9cbiAgICAgIHRoZW46IGZ1bmN0aW9uKG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzO1xuICAgICAgICB2YXIgc3RhdGUgPSBwYXJlbnQuX3N0YXRlO1xuXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRlVMRklMTEVEICYmICFvbkZ1bGZpbGxtZW50IHx8IHN0YXRlID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRSRUpFQ1RFRCAmJiAhb25SZWplY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGlsZCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG5vb3ApO1xuICAgICAgICB2YXIgcmVzdWx0ID0gcGFyZW50Ll9yZXN1bHQ7XG5cbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzW3N0YXRlIC0gMV07XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXAoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGludm9rZUNhbGxiYWNrKHN0YXRlLCBjaGlsZCwgY2FsbGJhY2ssIHJlc3VsdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkc3Vic2NyaWJlKHBhcmVudCwgY2hpbGQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH0sXG5cbiAgICAvKipcbiAgICAgIGBjYXRjaGAgaXMgc2ltcGx5IHN1Z2FyIGZvciBgdGhlbih1bmRlZmluZWQsIG9uUmVqZWN0aW9uKWAgd2hpY2ggbWFrZXMgaXQgdGhlIHNhbWVcbiAgICAgIGFzIHRoZSBjYXRjaCBibG9jayBvZiBhIHRyeS9jYXRjaCBzdGF0ZW1lbnQuXG5cbiAgICAgIGBgYGpzXG4gICAgICBmdW5jdGlvbiBmaW5kQXV0aG9yKCl7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGRuJ3QgZmluZCB0aGF0IGF1dGhvcicpO1xuICAgICAgfVxuXG4gICAgICAvLyBzeW5jaHJvbm91c1xuICAgICAgdHJ5IHtcbiAgICAgICAgZmluZEF1dGhvcigpO1xuICAgICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICAgIH1cblxuICAgICAgLy8gYXN5bmMgd2l0aCBwcm9taXNlc1xuICAgICAgZmluZEF1dGhvcigpLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBAbWV0aG9kIGNhdGNoXG4gICAgICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGlvblxuICAgICAgVXNlZnVsIGZvciB0b29saW5nLlxuICAgICAgQHJldHVybiB7UHJvbWlzZX1cbiAgICAqL1xuICAgICAgJ2NhdGNoJzogZnVuY3Rpb24ob25SZWplY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGlvbik7XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcG9seWZpbGwkJHBvbHlmaWxsKCkge1xuICAgICAgdmFyIGxvY2FsO1xuXG4gICAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBsb2NhbCA9IGdsb2JhbDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgbG9jYWwgPSBzZWxmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBsb2NhbCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvbHlmaWxsIGZhaWxlZCBiZWNhdXNlIGdsb2JhbCBvYmplY3QgaXMgdW5hdmFpbGFibGUgaW4gdGhpcyBlbnZpcm9ubWVudCcpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIFAgPSBsb2NhbC5Qcm9taXNlO1xuXG4gICAgICBpZiAoUCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUC5yZXNvbHZlKCkpID09PSAnW29iamVjdCBQcm9taXNlXScgJiYgIVAuY2FzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxvY2FsLlByb21pc2UgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkZGVmYXVsdDtcbiAgICB9XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRwb2x5ZmlsbCQkZGVmYXVsdCA9IGxpYiRlczYkcHJvbWlzZSRwb2x5ZmlsbCQkcG9seWZpbGw7XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHVtZCQkRVM2UHJvbWlzZSA9IHtcbiAgICAgICdQcm9taXNlJzogbGliJGVzNiRwcm9taXNlJHByb21pc2UkJGRlZmF1bHQsXG4gICAgICAncG9seWZpbGwnOiBsaWIkZXM2JHByb21pc2UkcG9seWZpbGwkJGRlZmF1bHRcbiAgICB9O1xuXG4gICAgLyogZ2xvYmFsIGRlZmluZTp0cnVlIG1vZHVsZTp0cnVlIHdpbmRvdzogdHJ1ZSAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZVsnYW1kJ10pIHtcbiAgICAgIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGxpYiRlczYkcHJvbWlzZSR1bWQkJEVTNlByb21pc2U7IH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlWydleHBvcnRzJ10pIHtcbiAgICAgIG1vZHVsZVsnZXhwb3J0cyddID0gbGliJGVzNiRwcm9taXNlJHVtZCQkRVM2UHJvbWlzZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpc1snRVM2UHJvbWlzZSddID0gbGliJGVzNiRwcm9taXNlJHVtZCQkRVM2UHJvbWlzZTtcbiAgICB9XG5cbiAgICBsaWIkZXM2JHByb21pc2UkcG9seWZpbGwkJGRlZmF1bHQoKTtcbn0pLmNhbGwodGhpcyk7XG5cbiIsIi8vICAgICBVbmRlcnNjb3JlLmpzIDEuOC4zXG4vLyAgICAgaHR0cDovL3VuZGVyc2NvcmVqcy5vcmdcbi8vICAgICAoYykgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4vLyAgICAgVW5kZXJzY29yZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8vIEJhc2VsaW5lIHNldHVwXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRXN0YWJsaXNoIHRoZSByb290IG9iamVjdCwgYHdpbmRvd2AgaW4gdGhlIGJyb3dzZXIsIG9yIGBleHBvcnRzYCBvbiB0aGUgc2VydmVyLlxuICB2YXIgcm9vdCA9IHRoaXM7XG5cbiAgLy8gU2F2ZSB0aGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGBfYCB2YXJpYWJsZS5cbiAgdmFyIHByZXZpb3VzVW5kZXJzY29yZSA9IHJvb3QuXztcblxuICAvLyBTYXZlIGJ5dGVzIGluIHRoZSBtaW5pZmllZCAoYnV0IG5vdCBnemlwcGVkKSB2ZXJzaW9uOlxuICB2YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSwgT2JqUHJvdG8gPSBPYmplY3QucHJvdG90eXBlLCBGdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbiAgLy8gQ3JlYXRlIHF1aWNrIHJlZmVyZW5jZSB2YXJpYWJsZXMgZm9yIHNwZWVkIGFjY2VzcyB0byBjb3JlIHByb3RvdHlwZXMuXG4gIHZhclxuICAgIHB1c2ggICAgICAgICAgICAgPSBBcnJheVByb3RvLnB1c2gsXG4gICAgc2xpY2UgICAgICAgICAgICA9IEFycmF5UHJvdG8uc2xpY2UsXG4gICAgdG9TdHJpbmcgICAgICAgICA9IE9ialByb3RvLnRvU3RyaW5nLFxuICAgIGhhc093blByb3BlcnR5ICAgPSBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAvLyBBbGwgKipFQ01BU2NyaXB0IDUqKiBuYXRpdmUgZnVuY3Rpb24gaW1wbGVtZW50YXRpb25zIHRoYXQgd2UgaG9wZSB0byB1c2VcbiAgLy8gYXJlIGRlY2xhcmVkIGhlcmUuXG4gIHZhclxuICAgIG5hdGl2ZUlzQXJyYXkgICAgICA9IEFycmF5LmlzQXJyYXksXG4gICAgbmF0aXZlS2V5cyAgICAgICAgID0gT2JqZWN0LmtleXMsXG4gICAgbmF0aXZlQmluZCAgICAgICAgID0gRnVuY1Byb3RvLmJpbmQsXG4gICAgbmF0aXZlQ3JlYXRlICAgICAgID0gT2JqZWN0LmNyZWF0ZTtcblxuICAvLyBOYWtlZCBmdW5jdGlvbiByZWZlcmVuY2UgZm9yIHN1cnJvZ2F0ZS1wcm90b3R5cGUtc3dhcHBpbmcuXG4gIHZhciBDdG9yID0gZnVuY3Rpb24oKXt9O1xuXG4gIC8vIENyZWF0ZSBhIHNhZmUgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgdXNlIGJlbG93LlxuICB2YXIgXyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBfKSByZXR1cm4gb2JqO1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBfKSkgcmV0dXJuIG5ldyBfKG9iaik7XG4gICAgdGhpcy5fd3JhcHBlZCA9IG9iajtcbiAgfTtcblxuICAvLyBFeHBvcnQgdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciAqKk5vZGUuanMqKiwgd2l0aFxuICAvLyBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBmb3IgdGhlIG9sZCBgcmVxdWlyZSgpYCBBUEkuIElmIHdlJ3JlIGluXG4gIC8vIHRoZSBicm93c2VyLCBhZGQgYF9gIGFzIGEgZ2xvYmFsIG9iamVjdC5cbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gXztcbiAgICB9XG4gICAgZXhwb3J0cy5fID0gXztcbiAgfSBlbHNlIHtcbiAgICByb290Ll8gPSBfO1xuICB9XG5cbiAgLy8gQ3VycmVudCB2ZXJzaW9uLlxuICBfLlZFUlNJT04gPSAnMS44LjMnO1xuXG4gIC8vIEludGVybmFsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBlZmZpY2llbnQgKGZvciBjdXJyZW50IGVuZ2luZXMpIHZlcnNpb25cbiAgLy8gb2YgdGhlIHBhc3NlZC1pbiBjYWxsYmFjaywgdG8gYmUgcmVwZWF0ZWRseSBhcHBsaWVkIGluIG90aGVyIFVuZGVyc2NvcmVcbiAgLy8gZnVuY3Rpb25zLlxuICB2YXIgb3B0aW1pemVDYiA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQsIGFyZ0NvdW50KSB7XG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgcmV0dXJuIGZ1bmM7XG4gICAgc3dpdGNoIChhcmdDb3VudCA9PSBudWxsID8gMyA6IGFyZ0NvdW50KSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSwgb3RoZXIpO1xuICAgICAgfTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEEgbW9zdGx5LWludGVybmFsIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGNhbGxiYWNrcyB0aGF0IGNhbiBiZSBhcHBsaWVkXG4gIC8vIHRvIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24sIHJldHVybmluZyB0aGUgZGVzaXJlZCByZXN1bHQg4oCUIGVpdGhlclxuICAvLyBpZGVudGl0eSwgYW4gYXJiaXRyYXJ5IGNhbGxiYWNrLCBhIHByb3BlcnR5IG1hdGNoZXIsIG9yIGEgcHJvcGVydHkgYWNjZXNzb3IuXG4gIHZhciBjYiA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0LCBhcmdDb3VudCkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gXy5pZGVudGl0eTtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKHZhbHVlKSkgcmV0dXJuIG9wdGltaXplQ2IodmFsdWUsIGNvbnRleHQsIGFyZ0NvdW50KTtcbiAgICBpZiAoXy5pc09iamVjdCh2YWx1ZSkpIHJldHVybiBfLm1hdGNoZXIodmFsdWUpO1xuICAgIHJldHVybiBfLnByb3BlcnR5KHZhbHVlKTtcbiAgfTtcbiAgXy5pdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGNiKHZhbHVlLCBjb250ZXh0LCBJbmZpbml0eSk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGFzc2lnbmVyIGZ1bmN0aW9ucy5cbiAgdmFyIGNyZWF0ZUFzc2lnbmVyID0gZnVuY3Rpb24oa2V5c0Z1bmMsIHVuZGVmaW5lZE9ubHkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggPCAyIHx8IG9iaiA9PSBudWxsKSByZXR1cm4gb2JqO1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XSxcbiAgICAgICAgICAgIGtleXMgPSBrZXlzRnVuYyhzb3VyY2UpLFxuICAgICAgICAgICAgbCA9IGtleXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmICghdW5kZWZpbmVkT25seSB8fCBvYmpba2V5XSA9PT0gdm9pZCAwKSBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgbmV3IG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gYW5vdGhlci5cbiAgdmFyIGJhc2VDcmVhdGUgPSBmdW5jdGlvbihwcm90b3R5cGUpIHtcbiAgICBpZiAoIV8uaXNPYmplY3QocHJvdG90eXBlKSkgcmV0dXJuIHt9O1xuICAgIGlmIChuYXRpdmVDcmVhdGUpIHJldHVybiBuYXRpdmVDcmVhdGUocHJvdG90eXBlKTtcbiAgICBDdG9yLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEN0b3I7XG4gICAgQ3Rvci5wcm90b3R5cGUgPSBudWxsO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIHByb3BlcnR5ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PSBudWxsID8gdm9pZCAwIDogb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICAvLyBIZWxwZXIgZm9yIGNvbGxlY3Rpb24gbWV0aG9kcyB0byBkZXRlcm1pbmUgd2hldGhlciBhIGNvbGxlY3Rpb25cbiAgLy8gc2hvdWxkIGJlIGl0ZXJhdGVkIGFzIGFuIGFycmF5IG9yIGFzIGFuIG9iamVjdFxuICAvLyBSZWxhdGVkOiBodHRwOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy10b2xlbmd0aFxuICAvLyBBdm9pZHMgYSB2ZXJ5IG5hc3R5IGlPUyA4IEpJVCBidWcgb24gQVJNLTY0LiAjMjA5NFxuICB2YXIgTUFYX0FSUkFZX0lOREVYID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcbiAgdmFyIGdldExlbmd0aCA9IHByb3BlcnR5KCdsZW5ndGgnKTtcbiAgdmFyIGlzQXJyYXlMaWtlID0gZnVuY3Rpb24oY29sbGVjdGlvbikge1xuICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoY29sbGVjdGlvbik7XG4gICAgcmV0dXJuIHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgJiYgbGVuZ3RoID49IDAgJiYgbGVuZ3RoIDw9IE1BWF9BUlJBWV9JTkRFWDtcbiAgfTtcblxuICAvLyBDb2xsZWN0aW9uIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFRoZSBjb3JuZXJzdG9uZSwgYW4gYGVhY2hgIGltcGxlbWVudGF0aW9uLCBha2EgYGZvckVhY2hgLlxuICAvLyBIYW5kbGVzIHJhdyBvYmplY3RzIGluIGFkZGl0aW9uIHRvIGFycmF5LWxpa2VzLiBUcmVhdHMgYWxsXG4gIC8vIHNwYXJzZSBhcnJheS1saWtlcyBhcyBpZiB0aGV5IHdlcmUgZGVuc2UuXG4gIF8uZWFjaCA9IF8uZm9yRWFjaCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBpLCBsZW5ndGg7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHtcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVyYXRlZShvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKG9ialtrZXlzW2ldXSwga2V5c1tpXSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudC5cbiAgXy5tYXAgPSBfLmNvbGxlY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdHMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICByZXN1bHRzW2luZGV4XSA9IGl0ZXJhdGVlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgcmVkdWNpbmcgZnVuY3Rpb24gaXRlcmF0aW5nIGxlZnQgb3IgcmlnaHQuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJlZHVjZShkaXIpIHtcbiAgICAvLyBPcHRpbWl6ZWQgaXRlcmF0b3IgZnVuY3Rpb24gYXMgdXNpbmcgYXJndW1lbnRzLmxlbmd0aFxuICAgIC8vIGluIHRoZSBtYWluIGZ1bmN0aW9uIHdpbGwgZGVvcHRpbWl6ZSB0aGUsIHNlZSAjMTk5MS5cbiAgICBmdW5jdGlvbiBpdGVyYXRvcihvYmosIGl0ZXJhdGVlLCBtZW1vLCBrZXlzLCBpbmRleCwgbGVuZ3RoKSB7XG4gICAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XG4gICAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICAgIG1lbW8gPSBpdGVyYXRlZShtZW1vLCBvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgbWVtbywgY29udGV4dCkge1xuICAgICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0LCA0KTtcbiAgICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgICAgaW5kZXggPSBkaXIgPiAwID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICAvLyBEZXRlcm1pbmUgdGhlIGluaXRpYWwgdmFsdWUgaWYgbm9uZSBpcyBwcm92aWRlZC5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgICAgICBtZW1vID0gb2JqW2tleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4XTtcbiAgICAgICAgaW5kZXggKz0gZGlyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdG9yKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGtleXMsIGluZGV4LCBsZW5ndGgpO1xuICAgIH07XG4gIH1cblxuICAvLyAqKlJlZHVjZSoqIGJ1aWxkcyB1cCBhIHNpbmdsZSByZXN1bHQgZnJvbSBhIGxpc3Qgb2YgdmFsdWVzLCBha2EgYGluamVjdGAsXG4gIC8vIG9yIGBmb2xkbGAuXG4gIF8ucmVkdWNlID0gXy5mb2xkbCA9IF8uaW5qZWN0ID0gY3JlYXRlUmVkdWNlKDEpO1xuXG4gIC8vIFRoZSByaWdodC1hc3NvY2lhdGl2ZSB2ZXJzaW9uIG9mIHJlZHVjZSwgYWxzbyBrbm93biBhcyBgZm9sZHJgLlxuICBfLnJlZHVjZVJpZ2h0ID0gXy5mb2xkciA9IGNyZWF0ZVJlZHVjZSgtMSk7XG5cbiAgLy8gUmV0dXJuIHRoZSBmaXJzdCB2YWx1ZSB3aGljaCBwYXNzZXMgYSB0cnV0aCB0ZXN0LiBBbGlhc2VkIGFzIGBkZXRlY3RgLlxuICBfLmZpbmQgPSBfLmRldGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIGtleTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuICAgICAga2V5ID0gXy5maW5kSW5kZXgob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBfLmZpbmRLZXkob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAoa2V5ICE9PSB2b2lkIDAgJiYga2V5ICE9PSAtMSkgcmV0dXJuIG9ialtrZXldO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgcGFzcyBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYHNlbGVjdGAuXG4gIF8uZmlsdGVyID0gXy5zZWxlY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBsaXN0KSkgcmVzdWx0cy5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBmb3Igd2hpY2ggYSB0cnV0aCB0ZXN0IGZhaWxzLlxuICBfLnJlamVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5uZWdhdGUoY2IocHJlZGljYXRlKSksIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIERldGVybWluZSB3aGV0aGVyIGFsbCBvZiB0aGUgZWxlbWVudHMgbWF0Y2ggYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBhbGxgLlxuICBfLmV2ZXJ5ID0gXy5hbGwgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmICghcHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIG9iamVjdCBtYXRjaGVzIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgYW55YC5cbiAgXy5zb21lID0gXy5hbnkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmIChwcmVkaWNhdGUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiB0aGUgYXJyYXkgb3Igb2JqZWN0IGNvbnRhaW5zIGEgZ2l2ZW4gaXRlbSAodXNpbmcgYD09PWApLlxuICAvLyBBbGlhc2VkIGFzIGBpbmNsdWRlc2AgYW5kIGBpbmNsdWRlYC5cbiAgXy5jb250YWlucyA9IF8uaW5jbHVkZXMgPSBfLmluY2x1ZGUgPSBmdW5jdGlvbihvYmosIGl0ZW0sIGZyb21JbmRleCwgZ3VhcmQpIHtcbiAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgaWYgKHR5cGVvZiBmcm9tSW5kZXggIT0gJ251bWJlcicgfHwgZ3VhcmQpIGZyb21JbmRleCA9IDA7XG4gICAgcmV0dXJuIF8uaW5kZXhPZihvYmosIGl0ZW0sIGZyb21JbmRleCkgPj0gMDtcbiAgfTtcblxuICAvLyBJbnZva2UgYSBtZXRob2QgKHdpdGggYXJndW1lbnRzKSBvbiBldmVyeSBpdGVtIGluIGEgY29sbGVjdGlvbi5cbiAgXy5pbnZva2UgPSBmdW5jdGlvbihvYmosIG1ldGhvZCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHZhciBpc0Z1bmMgPSBfLmlzRnVuY3Rpb24obWV0aG9kKTtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0Z1bmMgPyBtZXRob2QgOiB2YWx1ZVttZXRob2RdO1xuICAgICAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IGZ1bmMgOiBmdW5jLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBtYXBgOiBmZXRjaGluZyBhIHByb3BlcnR5LlxuICBfLnBsdWNrID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBfLnByb3BlcnR5KGtleSkpO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbHRlcmA6IHNlbGVjdGluZyBvbmx5IG9iamVjdHNcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy53aGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaW5kYDogZ2V0dGluZyB0aGUgZmlyc3Qgb2JqZWN0XG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8uZmluZFdoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLmZpbmQob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1heGltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWF4ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSAtSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IC1JbmZpbml0eSxcbiAgICAgICAgdmFsdWUsIGNvbXB1dGVkO1xuICAgIGlmIChpdGVyYXRlZSA9PSBudWxsICYmIG9iaiAhPSBudWxsKSB7XG4gICAgICBvYmogPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBvYmpbaV07XG4gICAgICAgIGlmICh2YWx1ZSA+IHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBsaXN0KTtcbiAgICAgICAgaWYgKGNvbXB1dGVkID4gbGFzdENvbXB1dGVkIHx8IGNvbXB1dGVkID09PSAtSW5maW5pdHkgJiYgcmVzdWx0ID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtaW5pbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBfLm1pbiA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IEluZmluaXR5LFxuICAgICAgICB2YWx1ZSwgY29tcHV0ZWQ7XG4gICAgaWYgKGl0ZXJhdGVlID09IG51bGwgJiYgb2JqICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IG9ialtpXTtcbiAgICAgICAgaWYgKHZhbHVlIDwgcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgICBpZiAoY29tcHV0ZWQgPCBsYXN0Q29tcHV0ZWQgfHwgY29tcHV0ZWQgPT09IEluZmluaXR5ICYmIHJlc3VsdCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gU2h1ZmZsZSBhIGNvbGxlY3Rpb24sIHVzaW5nIHRoZSBtb2Rlcm4gdmVyc2lvbiBvZiB0aGVcbiAgLy8gW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlcuKAk1lhdGVzX3NodWZmbGUpLlxuICBfLnNodWZmbGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgc2V0ID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IHNldC5sZW5ndGg7XG4gICAgdmFyIHNodWZmbGVkID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIHJhbmQ7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByYW5kID0gXy5yYW5kb20oMCwgaW5kZXgpO1xuICAgICAgaWYgKHJhbmQgIT09IGluZGV4KSBzaHVmZmxlZFtpbmRleF0gPSBzaHVmZmxlZFtyYW5kXTtcbiAgICAgIHNodWZmbGVkW3JhbmRdID0gc2V0W2luZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIHNodWZmbGVkO1xuICB9O1xuXG4gIC8vIFNhbXBsZSAqKm4qKiByYW5kb20gdmFsdWVzIGZyb20gYSBjb2xsZWN0aW9uLlxuICAvLyBJZiAqKm4qKiBpcyBub3Qgc3BlY2lmaWVkLCByZXR1cm5zIGEgc2luZ2xlIHJhbmRvbSBlbGVtZW50LlxuICAvLyBUaGUgaW50ZXJuYWwgYGd1YXJkYCBhcmd1bWVudCBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBtYXBgLlxuICBfLnNhbXBsZSA9IGZ1bmN0aW9uKG9iaiwgbiwgZ3VhcmQpIHtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSB7XG4gICAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgICByZXR1cm4gb2JqW18ucmFuZG9tKG9iai5sZW5ndGggLSAxKV07XG4gICAgfVxuICAgIHJldHVybiBfLnNodWZmbGUob2JqKS5zbGljZSgwLCBNYXRoLm1heCgwLCBuKSk7XG4gIH07XG5cbiAgLy8gU29ydCB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uIHByb2R1Y2VkIGJ5IGFuIGl0ZXJhdGVlLlxuICBfLnNvcnRCeSA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICByZXR1cm4gXy5wbHVjayhfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIGNyaXRlcmlhOiBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpXG4gICAgICB9O1xuICAgIH0pLnNvcnQoZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYTtcbiAgICAgIHZhciBiID0gcmlnaHQuY3JpdGVyaWE7XG4gICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICBpZiAoYSA+IGIgfHwgYSA9PT0gdm9pZCAwKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEgPCBiIHx8IGIgPT09IHZvaWQgMCkgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlZnQuaW5kZXggLSByaWdodC5pbmRleDtcbiAgICB9KSwgJ3ZhbHVlJyk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdXNlZCBmb3IgYWdncmVnYXRlIFwiZ3JvdXAgYnlcIiBvcGVyYXRpb25zLlxuICB2YXIgZ3JvdXAgPSBmdW5jdGlvbihiZWhhdmlvcikge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgICB2YXIga2V5ID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBvYmopO1xuICAgICAgICBiZWhhdmlvcihyZXN1bHQsIHZhbHVlLCBrZXkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gR3JvdXBzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24uIFBhc3MgZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZVxuICAvLyB0byBncm91cCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGNyaXRlcmlvbi5cbiAgXy5ncm91cEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgaWYgKF8uaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7IGVsc2UgcmVzdWx0W2tleV0gPSBbdmFsdWVdO1xuICB9KTtcblxuICAvLyBJbmRleGVzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24sIHNpbWlsYXIgdG8gYGdyb3VwQnlgLCBidXQgZm9yXG4gIC8vIHdoZW4geW91IGtub3cgdGhhdCB5b3VyIGluZGV4IHZhbHVlcyB3aWxsIGJlIHVuaXF1ZS5cbiAgXy5pbmRleEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgLy8gQ291bnRzIGluc3RhbmNlcyBvZiBhbiBvYmplY3QgdGhhdCBncm91cCBieSBhIGNlcnRhaW4gY3JpdGVyaW9uLiBQYXNzXG4gIC8vIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGUgdG8gY291bnQgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAvLyBjcml0ZXJpb24uXG4gIF8uY291bnRCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIGlmIChfLmhhcyhyZXN1bHQsIGtleSkpIHJlc3VsdFtrZXldKys7IGVsc2UgcmVzdWx0W2tleV0gPSAxO1xuICB9KTtcblxuICAvLyBTYWZlbHkgY3JlYXRlIGEgcmVhbCwgbGl2ZSBhcnJheSBmcm9tIGFueXRoaW5nIGl0ZXJhYmxlLlxuICBfLnRvQXJyYXkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIFtdO1xuICAgIGlmIChfLmlzQXJyYXkob2JqKSkgcmV0dXJuIHNsaWNlLmNhbGwob2JqKTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkgcmV0dXJuIF8ubWFwKG9iaiwgXy5pZGVudGl0eSk7XG4gICAgcmV0dXJuIF8udmFsdWVzKG9iaik7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gYW4gb2JqZWN0LlxuICBfLnNpemUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiAwO1xuICAgIHJldHVybiBpc0FycmF5TGlrZShvYmopID8gb2JqLmxlbmd0aCA6IF8ua2V5cyhvYmopLmxlbmd0aDtcbiAgfTtcblxuICAvLyBTcGxpdCBhIGNvbGxlY3Rpb24gaW50byB0d28gYXJyYXlzOiBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIHNhdGlzZnkgdGhlIGdpdmVuXG4gIC8vIHByZWRpY2F0ZSwgYW5kIG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgZG8gbm90IHNhdGlzZnkgdGhlIHByZWRpY2F0ZS5cbiAgXy5wYXJ0aXRpb24gPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIHBhc3MgPSBbXSwgZmFpbCA9IFtdO1xuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikge1xuICAgICAgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBvYmopID8gcGFzcyA6IGZhaWwpLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBbcGFzcywgZmFpbF07XG4gIH07XG5cbiAgLy8gQXJyYXkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgZmlyc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBBbGlhc2VkIGFzIGBoZWFkYCBhbmQgYHRha2VgLiBUaGUgKipndWFyZCoqIGNoZWNrXG4gIC8vIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5maXJzdCA9IF8uaGVhZCA9IF8udGFrZSA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVswXTtcbiAgICByZXR1cm4gXy5pbml0aWFsKGFycmF5LCBhcnJheS5sZW5ndGggLSBuKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBsYXN0IGVudHJ5IG9mIHRoZSBhcnJheS4gRXNwZWNpYWxseSB1c2VmdWwgb25cbiAgLy8gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gYWxsIHRoZSB2YWx1ZXMgaW5cbiAgLy8gdGhlIGFycmF5LCBleGNsdWRpbmcgdGhlIGxhc3QgTi5cbiAgXy5pbml0aWFsID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIDAsIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIChuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbikpKTtcbiAgfTtcblxuICAvLyBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgbGFzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ubGFzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gXy5yZXN0KGFycmF5LCBNYXRoLm1heCgwLCBhcnJheS5sZW5ndGggLSBuKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgZmlyc3QgZW50cnkgb2YgdGhlIGFycmF5LiBBbGlhc2VkIGFzIGB0YWlsYCBhbmQgYGRyb3BgLlxuICAvLyBFc3BlY2lhbGx5IHVzZWZ1bCBvbiB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyBhbiAqKm4qKiB3aWxsIHJldHVyblxuICAvLyB0aGUgcmVzdCBOIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ucmVzdCA9IF8udGFpbCA9IF8uZHJvcCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCBuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbik7XG4gIH07XG5cbiAgLy8gVHJpbSBvdXQgYWxsIGZhbHN5IHZhbHVlcyBmcm9tIGFuIGFycmF5LlxuICBfLmNvbXBhY3QgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgXy5pZGVudGl0eSk7XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgYSByZWN1cnNpdmUgYGZsYXR0ZW5gIGZ1bmN0aW9uLlxuICB2YXIgZmxhdHRlbiA9IGZ1bmN0aW9uKGlucHV0LCBzaGFsbG93LCBzdHJpY3QsIHN0YXJ0SW5kZXgpIHtcbiAgICB2YXIgb3V0cHV0ID0gW10sIGlkeCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXggfHwgMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGlucHV0KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBpbnB1dFtpXTtcbiAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiYgKF8uaXNBcnJheSh2YWx1ZSkgfHwgXy5pc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAgIC8vZmxhdHRlbiBjdXJyZW50IGxldmVsIG9mIGFycmF5IG9yIGFyZ3VtZW50cyBvYmplY3RcbiAgICAgICAgaWYgKCFzaGFsbG93KSB2YWx1ZSA9IGZsYXR0ZW4odmFsdWUsIHNoYWxsb3csIHN0cmljdCk7XG4gICAgICAgIHZhciBqID0gMCwgbGVuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICBvdXRwdXQubGVuZ3RoICs9IGxlbjtcbiAgICAgICAgd2hpbGUgKGogPCBsZW4pIHtcbiAgICAgICAgICBvdXRwdXRbaWR4KytdID0gdmFsdWVbaisrXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghc3RyaWN0KSB7XG4gICAgICAgIG91dHB1dFtpZHgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcblxuICAvLyBGbGF0dGVuIG91dCBhbiBhcnJheSwgZWl0aGVyIHJlY3Vyc2l2ZWx5IChieSBkZWZhdWx0KSwgb3IganVzdCBvbmUgbGV2ZWwuXG4gIF8uZmxhdHRlbiA9IGZ1bmN0aW9uKGFycmF5LCBzaGFsbG93KSB7XG4gICAgcmV0dXJuIGZsYXR0ZW4oYXJyYXksIHNoYWxsb3csIGZhbHNlKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSB2ZXJzaW9uIG9mIHRoZSBhcnJheSB0aGF0IGRvZXMgbm90IGNvbnRhaW4gdGhlIHNwZWNpZmllZCB2YWx1ZShzKS5cbiAgXy53aXRob3V0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gXy5kaWZmZXJlbmNlKGFycmF5LCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIHRoZSBhcnJheS4gSWYgdGhlIGFycmF5IGhhcyBhbHJlYWR5XG4gIC8vIGJlZW4gc29ydGVkLCB5b3UgaGF2ZSB0aGUgb3B0aW9uIG9mIHVzaW5nIGEgZmFzdGVyIGFsZ29yaXRobS5cbiAgLy8gQWxpYXNlZCBhcyBgdW5pcXVlYC5cbiAgXy51bmlxID0gXy51bmlxdWUgPSBmdW5jdGlvbihhcnJheSwgaXNTb3J0ZWQsIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaWYgKCFfLmlzQm9vbGVhbihpc1NvcnRlZCkpIHtcbiAgICAgIGNvbnRleHQgPSBpdGVyYXRlZTtcbiAgICAgIGl0ZXJhdGVlID0gaXNTb3J0ZWQ7XG4gICAgICBpc1NvcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaXRlcmF0ZWUgIT0gbnVsbCkgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBzZWVuID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaV0sXG4gICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlLCBpLCBhcnJheSkgOiB2YWx1ZTtcbiAgICAgIGlmIChpc1NvcnRlZCkge1xuICAgICAgICBpZiAoIWkgfHwgc2VlbiAhPT0gY29tcHV0ZWQpIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgc2VlbiA9IGNvbXB1dGVkO1xuICAgICAgfSBlbHNlIGlmIChpdGVyYXRlZSkge1xuICAgICAgICBpZiAoIV8uY29udGFpbnMoc2VlbiwgY29tcHV0ZWQpKSB7XG4gICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIV8uY29udGFpbnMocmVzdWx0LCB2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgdW5pb246IGVhY2ggZGlzdGluY3QgZWxlbWVudCBmcm9tIGFsbCBvZlxuICAvLyB0aGUgcGFzc2VkLWluIGFycmF5cy5cbiAgXy51bmlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfLnVuaXEoZmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUpKTtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgZXZlcnkgaXRlbSBzaGFyZWQgYmV0d2VlbiBhbGwgdGhlXG4gIC8vIHBhc3NlZC1pbiBhcnJheXMuXG4gIF8uaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gYXJyYXlbaV07XG4gICAgICBpZiAoXy5jb250YWlucyhyZXN1bHQsIGl0ZW0pKSBjb250aW51ZTtcbiAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgYXJnc0xlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmICghXy5jb250YWlucyhhcmd1bWVudHNbal0sIGl0ZW0pKSBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChqID09PSBhcmdzTGVuZ3RoKSByZXN1bHQucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBUYWtlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gb25lIGFycmF5IGFuZCBhIG51bWJlciBvZiBvdGhlciBhcnJheXMuXG4gIC8vIE9ubHkgdGhlIGVsZW1lbnRzIHByZXNlbnQgaW4ganVzdCB0aGUgZmlyc3QgYXJyYXkgd2lsbCByZW1haW4uXG4gIF8uZGlmZmVyZW5jZSA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIHJlc3QgPSBmbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSwgMSk7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICByZXR1cm4gIV8uY29udGFpbnMocmVzdCwgdmFsdWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFppcCB0b2dldGhlciBtdWx0aXBsZSBsaXN0cyBpbnRvIGEgc2luZ2xlIGFycmF5IC0tIGVsZW1lbnRzIHRoYXQgc2hhcmVcbiAgLy8gYW4gaW5kZXggZ28gdG9nZXRoZXIuXG4gIF8uemlwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8udW56aXAoYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBDb21wbGVtZW50IG9mIF8uemlwLiBVbnppcCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyBhbmQgZ3JvdXBzXG4gIC8vIGVhY2ggYXJyYXkncyBlbGVtZW50cyBvbiBzaGFyZWQgaW5kaWNlc1xuICBfLnVuemlwID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgJiYgXy5tYXgoYXJyYXksIGdldExlbmd0aCkubGVuZ3RoIHx8IDA7XG4gICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gXy5wbHVjayhhcnJheSwgaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENvbnZlcnRzIGxpc3RzIGludG8gb2JqZWN0cy4gUGFzcyBlaXRoZXIgYSBzaW5nbGUgYXJyYXkgb2YgYFtrZXksIHZhbHVlXWBcbiAgLy8gcGFpcnMsIG9yIHR3byBwYXJhbGxlbCBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoIC0tIG9uZSBvZiBrZXlzLCBhbmQgb25lIG9mXG4gIC8vIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgXy5vYmplY3QgPSBmdW5jdGlvbihsaXN0LCB2YWx1ZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChsaXN0KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldXSA9IHZhbHVlc1tpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldWzBdXSA9IGxpc3RbaV1bMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gR2VuZXJhdG9yIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgZmluZEluZGV4IGFuZCBmaW5kTGFzdEluZGV4IGZ1bmN0aW9uc1xuICBmdW5jdGlvbiBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcihkaXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXksIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpO1xuICAgICAgdmFyIGluZGV4ID0gZGlyID4gMCA/IDAgOiBsZW5ndGggLSAxO1xuICAgICAgZm9yICg7IGluZGV4ID49IDAgJiYgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IGRpcikge1xuICAgICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBvbiBhbiBhcnJheS1saWtlIHRoYXQgcGFzc2VzIGEgcHJlZGljYXRlIHRlc3RcbiAgXy5maW5kSW5kZXggPSBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcigxKTtcbiAgXy5maW5kTGFzdEluZGV4ID0gY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIoLTEpO1xuXG4gIC8vIFVzZSBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gdG8gZmlndXJlIG91dCB0aGUgc21hbGxlc3QgaW5kZXggYXQgd2hpY2hcbiAgLy8gYW4gb2JqZWN0IHNob3VsZCBiZSBpbnNlcnRlZCBzbyBhcyB0byBtYWludGFpbiBvcmRlci4gVXNlcyBiaW5hcnkgc2VhcmNoLlxuICBfLnNvcnRlZEluZGV4ID0gZnVuY3Rpb24oYXJyYXksIG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcbiAgICB2YXIgdmFsdWUgPSBpdGVyYXRlZShvYmopO1xuICAgIHZhciBsb3cgPSAwLCBoaWdoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbbWlkXSkgPCB2YWx1ZSkgbG93ID0gbWlkICsgMTsgZWxzZSBoaWdoID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gbG93O1xuICB9O1xuXG4gIC8vIEdlbmVyYXRvciBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGluZGV4T2YgYW5kIGxhc3RJbmRleE9mIGZ1bmN0aW9uc1xuICBmdW5jdGlvbiBjcmVhdGVJbmRleEZpbmRlcihkaXIsIHByZWRpY2F0ZUZpbmQsIHNvcnRlZEluZGV4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBpZHgpIHtcbiAgICAgIHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICAgIGlmICh0eXBlb2YgaWR4ID09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChkaXIgPiAwKSB7XG4gICAgICAgICAgICBpID0gaWR4ID49IDAgPyBpZHggOiBNYXRoLm1heChpZHggKyBsZW5ndGgsIGkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVuZ3RoID0gaWR4ID49IDAgPyBNYXRoLm1pbihpZHggKyAxLCBsZW5ndGgpIDogaWR4ICsgbGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzb3J0ZWRJbmRleCAmJiBpZHggJiYgbGVuZ3RoKSB7XG4gICAgICAgIGlkeCA9IHNvcnRlZEluZGV4KGFycmF5LCBpdGVtKTtcbiAgICAgICAgcmV0dXJuIGFycmF5W2lkeF0gPT09IGl0ZW0gPyBpZHggOiAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtICE9PSBpdGVtKSB7XG4gICAgICAgIGlkeCA9IHByZWRpY2F0ZUZpbmQoc2xpY2UuY2FsbChhcnJheSwgaSwgbGVuZ3RoKSwgXy5pc05hTik7XG4gICAgICAgIHJldHVybiBpZHggPj0gMCA/IGlkeCArIGkgOiAtMTtcbiAgICAgIH1cbiAgICAgIGZvciAoaWR4ID0gZGlyID4gMCA/IGkgOiBsZW5ndGggLSAxOyBpZHggPj0gMCAmJiBpZHggPCBsZW5ndGg7IGlkeCArPSBkaXIpIHtcbiAgICAgICAgaWYgKGFycmF5W2lkeF0gPT09IGl0ZW0pIHJldHVybiBpZHg7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgfVxuXG4gIC8vIFJldHVybiB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYW4gaXRlbSBpbiBhbiBhcnJheSxcbiAgLy8gb3IgLTEgaWYgdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS5cbiAgLy8gSWYgdGhlIGFycmF5IGlzIGxhcmdlIGFuZCBhbHJlYWR5IGluIHNvcnQgb3JkZXIsIHBhc3MgYHRydWVgXG4gIC8vIGZvciAqKmlzU29ydGVkKiogdG8gdXNlIGJpbmFyeSBzZWFyY2guXG4gIF8uaW5kZXhPZiA9IGNyZWF0ZUluZGV4RmluZGVyKDEsIF8uZmluZEluZGV4LCBfLnNvcnRlZEluZGV4KTtcbiAgXy5sYXN0SW5kZXhPZiA9IGNyZWF0ZUluZGV4RmluZGVyKC0xLCBfLmZpbmRMYXN0SW5kZXgpO1xuXG4gIC8vIEdlbmVyYXRlIGFuIGludGVnZXIgQXJyYXkgY29udGFpbmluZyBhbiBhcml0aG1ldGljIHByb2dyZXNzaW9uLiBBIHBvcnQgb2ZcbiAgLy8gdGhlIG5hdGl2ZSBQeXRob24gYHJhbmdlKClgIGZ1bmN0aW9uLiBTZWVcbiAgLy8gW3RoZSBQeXRob24gZG9jdW1lbnRhdGlvbl0oaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L2Z1bmN0aW9ucy5odG1sI3JhbmdlKS5cbiAgXy5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgaWYgKHN0b3AgPT0gbnVsbCkge1xuICAgICAgc3RvcCA9IHN0YXJ0IHx8IDA7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIHN0ZXAgPSBzdGVwIHx8IDE7XG5cbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCksIDApO1xuICAgIHZhciByYW5nZSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrLCBzdGFydCArPSBzdGVwKSB7XG4gICAgICByYW5nZVtpZHhdID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmdlO1xuICB9O1xuXG4gIC8vIEZ1bmN0aW9uIChhaGVtKSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGV4ZWN1dGUgYSBmdW5jdGlvbiBhcyBhIGNvbnN0cnVjdG9yXG4gIC8vIG9yIGEgbm9ybWFsIGZ1bmN0aW9uIHdpdGggdGhlIHByb3ZpZGVkIGFyZ3VtZW50c1xuICB2YXIgZXhlY3V0ZUJvdW5kID0gZnVuY3Rpb24oc291cmNlRnVuYywgYm91bmRGdW5jLCBjb250ZXh0LCBjYWxsaW5nQ29udGV4dCwgYXJncykge1xuICAgIGlmICghKGNhbGxpbmdDb250ZXh0IGluc3RhbmNlb2YgYm91bmRGdW5jKSkgcmV0dXJuIHNvdXJjZUZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgdmFyIHNlbGYgPSBiYXNlQ3JlYXRlKHNvdXJjZUZ1bmMucHJvdG90eXBlKTtcbiAgICB2YXIgcmVzdWx0ID0gc291cmNlRnVuYy5hcHBseShzZWxmLCBhcmdzKTtcbiAgICBpZiAoXy5pc09iamVjdChyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIGZ1bmN0aW9uIGJvdW5kIHRvIGEgZ2l2ZW4gb2JqZWN0IChhc3NpZ25pbmcgYHRoaXNgLCBhbmQgYXJndW1lbnRzLFxuICAvLyBvcHRpb25hbGx5KS4gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYEZ1bmN0aW9uLmJpbmRgIGlmXG4gIC8vIGF2YWlsYWJsZS5cbiAgXy5iaW5kID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCkge1xuICAgIGlmIChuYXRpdmVCaW5kICYmIGZ1bmMuYmluZCA9PT0gbmF0aXZlQmluZCkgcmV0dXJuIG5hdGl2ZUJpbmQuYXBwbHkoZnVuYywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICBpZiAoIV8uaXNGdW5jdGlvbihmdW5jKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQmluZCBtdXN0IGJlIGNhbGxlZCBvbiBhIGZ1bmN0aW9uJyk7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIGJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhlY3V0ZUJvdW5kKGZ1bmMsIGJvdW5kLCBjb250ZXh0LCB0aGlzLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICB9O1xuICAgIHJldHVybiBib3VuZDtcbiAgfTtcblxuICAvLyBQYXJ0aWFsbHkgYXBwbHkgYSBmdW5jdGlvbiBieSBjcmVhdGluZyBhIHZlcnNpb24gdGhhdCBoYXMgaGFkIHNvbWUgb2YgaXRzXG4gIC8vIGFyZ3VtZW50cyBwcmUtZmlsbGVkLCB3aXRob3V0IGNoYW5naW5nIGl0cyBkeW5hbWljIGB0aGlzYCBjb250ZXh0LiBfIGFjdHNcbiAgLy8gYXMgYSBwbGFjZWhvbGRlciwgYWxsb3dpbmcgYW55IGNvbWJpbmF0aW9uIG9mIGFyZ3VtZW50cyB0byBiZSBwcmUtZmlsbGVkLlxuICBfLnBhcnRpYWwgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgdmFyIGJvdW5kQXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICB2YXIgYm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IDAsIGxlbmd0aCA9IGJvdW5kQXJncy5sZW5ndGg7XG4gICAgICB2YXIgYXJncyA9IEFycmF5KGxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyZ3NbaV0gPSBib3VuZEFyZ3NbaV0gPT09IF8gPyBhcmd1bWVudHNbcG9zaXRpb24rK10gOiBib3VuZEFyZ3NbaV07XG4gICAgICB9XG4gICAgICB3aGlsZSAocG9zaXRpb24gPCBhcmd1bWVudHMubGVuZ3RoKSBhcmdzLnB1c2goYXJndW1lbnRzW3Bvc2l0aW9uKytdKTtcbiAgICAgIHJldHVybiBleGVjdXRlQm91bmQoZnVuYywgYm91bmQsIHRoaXMsIHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9O1xuXG4gIC8vIEJpbmQgYSBudW1iZXIgb2YgYW4gb2JqZWN0J3MgbWV0aG9kcyB0byB0aGF0IG9iamVjdC4gUmVtYWluaW5nIGFyZ3VtZW50c1xuICAvLyBhcmUgdGhlIG1ldGhvZCBuYW1lcyB0byBiZSBib3VuZC4gVXNlZnVsIGZvciBlbnN1cmluZyB0aGF0IGFsbCBjYWxsYmFja3NcbiAgLy8gZGVmaW5lZCBvbiBhbiBvYmplY3QgYmVsb25nIHRvIGl0LlxuICBfLmJpbmRBbGwgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgaSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCwga2V5O1xuICAgIGlmIChsZW5ndGggPD0gMSkgdGhyb3cgbmV3IEVycm9yKCdiaW5kQWxsIG11c3QgYmUgcGFzc2VkIGZ1bmN0aW9uIG5hbWVzJyk7XG4gICAgZm9yIChpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBhcmd1bWVudHNbaV07XG4gICAgICBvYmpba2V5XSA9IF8uYmluZChvYmpba2V5XSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBNZW1vaXplIGFuIGV4cGVuc2l2ZSBmdW5jdGlvbiBieSBzdG9yaW5nIGl0cyByZXN1bHRzLlxuICBfLm1lbW9pemUgPSBmdW5jdGlvbihmdW5jLCBoYXNoZXIpIHtcbiAgICB2YXIgbWVtb2l6ZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIGNhY2hlID0gbWVtb2l6ZS5jYWNoZTtcbiAgICAgIHZhciBhZGRyZXNzID0gJycgKyAoaGFzaGVyID8gaGFzaGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBrZXkpO1xuICAgICAgaWYgKCFfLmhhcyhjYWNoZSwgYWRkcmVzcykpIGNhY2hlW2FkZHJlc3NdID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGNhY2hlW2FkZHJlc3NdO1xuICAgIH07XG4gICAgbWVtb2l6ZS5jYWNoZSA9IHt9O1xuICAgIHJldHVybiBtZW1vaXplO1xuICB9O1xuXG4gIC8vIERlbGF5cyBhIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgYW5kIHRoZW4gY2FsbHNcbiAgLy8gaXQgd2l0aCB0aGUgYXJndW1lbnRzIHN1cHBsaWVkLlxuICBfLmRlbGF5ID0gZnVuY3Rpb24oZnVuYywgd2FpdCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9LCB3YWl0KTtcbiAgfTtcblxuICAvLyBEZWZlcnMgYSBmdW5jdGlvbiwgc2NoZWR1bGluZyBpdCB0byBydW4gYWZ0ZXIgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXNcbiAgLy8gY2xlYXJlZC5cbiAgXy5kZWZlciA9IF8ucGFydGlhbChfLmRlbGF5LCBfLCAxKTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBhdCBtb3N0IG9uY2VcbiAgLy8gZHVyaW5nIGEgZ2l2ZW4gd2luZG93IG9mIHRpbWUuIE5vcm1hbGx5LCB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHdpbGwgcnVuXG4gIC8vIGFzIG11Y2ggYXMgaXQgY2FuLCB3aXRob3V0IGV2ZXIgZ29pbmcgbW9yZSB0aGFuIG9uY2UgcGVyIGB3YWl0YCBkdXJhdGlvbjtcbiAgLy8gYnV0IGlmIHlvdSdkIGxpa2UgdG8gZGlzYWJsZSB0aGUgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2UsIHBhc3NcbiAgLy8gYHtsZWFkaW5nOiBmYWxzZX1gLiBUbyBkaXNhYmxlIGV4ZWN1dGlvbiBvbiB0aGUgdHJhaWxpbmcgZWRnZSwgZGl0dG8uXG4gIF8udGhyb3R0bGUgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgdmFyIGNvbnRleHQsIGFyZ3MsIHJlc3VsdDtcbiAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzID0gMDtcbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBfLm5vdygpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm93ID0gXy5ub3coKTtcbiAgICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkgcHJldmlvdXMgPSBub3c7XG4gICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBpZiAocmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gd2FpdCkge1xuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKCF0aW1lb3V0ICYmIG9wdGlvbnMudHJhaWxpbmcgIT09IGZhbHNlKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3RcbiAgLy8gYmUgdHJpZ2dlcmVkLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgc3RvcHMgYmVpbmcgY2FsbGVkIGZvclxuICAvLyBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGVcbiAgLy8gbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cbiAgXy5kZWJvdW5jZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAgIHZhciB0aW1lb3V0LCBhcmdzLCBjb250ZXh0LCB0aW1lc3RhbXAsIHJlc3VsdDtcblxuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxhc3QgPSBfLm5vdygpIC0gdGltZXN0YW1wO1xuXG4gICAgICBpZiAobGFzdCA8IHdhaXQgJiYgbGFzdCA+PSAwKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0IC0gbGFzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHRpbWVzdGFtcCA9IF8ubm93KCk7XG4gICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICAgIGlmICghdGltZW91dCkgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgICAgaWYgKGNhbGxOb3cpIHtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3QgZnVuY3Rpb24gcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBzZWNvbmQsXG4gIC8vIGFsbG93aW5nIHlvdSB0byBhZGp1c3QgYXJndW1lbnRzLCBydW4gY29kZSBiZWZvcmUgYW5kIGFmdGVyLCBhbmRcbiAgLy8gY29uZGl0aW9uYWxseSBleGVjdXRlIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cbiAgXy53cmFwID0gZnVuY3Rpb24oZnVuYywgd3JhcHBlcikge1xuICAgIHJldHVybiBfLnBhcnRpYWwod3JhcHBlciwgZnVuYyk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIG5lZ2F0ZWQgdmVyc2lvbiBvZiB0aGUgcGFzc2VkLWluIHByZWRpY2F0ZS5cbiAgXy5uZWdhdGUgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIGEgbGlzdCBvZiBmdW5jdGlvbnMsIGVhY2hcbiAgLy8gY29uc3VtaW5nIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgZm9sbG93cy5cbiAgXy5jb21wb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIHN0YXJ0ID0gYXJncy5sZW5ndGggLSAxO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpID0gc3RhcnQ7XG4gICAgICB2YXIgcmVzdWx0ID0gYXJnc1tzdGFydF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHdoaWxlIChpLS0pIHJlc3VsdCA9IGFyZ3NbaV0uY2FsbCh0aGlzLCByZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCBvbiBhbmQgYWZ0ZXIgdGhlIE50aCBjYWxsLlxuICBfLmFmdGVyID0gZnVuY3Rpb24odGltZXMsIGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aW1lcyA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCB1cCB0byAoYnV0IG5vdCBpbmNsdWRpbmcpIHRoZSBOdGggY2FsbC5cbiAgXy5iZWZvcmUgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIHZhciBtZW1vO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzID4gMCkge1xuICAgICAgICBtZW1vID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgaWYgKHRpbWVzIDw9IDEpIGZ1bmMgPSBudWxsO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGF0IG1vc3Qgb25lIHRpbWUsIG5vIG1hdHRlciBob3dcbiAgLy8gb2Z0ZW4geW91IGNhbGwgaXQuIFVzZWZ1bCBmb3IgbGF6eSBpbml0aWFsaXphdGlvbi5cbiAgXy5vbmNlID0gXy5wYXJ0aWFsKF8uYmVmb3JlLCAyKTtcblxuICAvLyBPYmplY3QgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBLZXlzIGluIElFIDwgOSB0aGF0IHdvbid0IGJlIGl0ZXJhdGVkIGJ5IGBmb3Iga2V5IGluIC4uLmAgYW5kIHRodXMgbWlzc2VkLlxuICB2YXIgaGFzRW51bUJ1ZyA9ICF7dG9TdHJpbmc6IG51bGx9LnByb3BlcnR5SXNFbnVtZXJhYmxlKCd0b1N0cmluZycpO1xuICB2YXIgbm9uRW51bWVyYWJsZVByb3BzID0gWyd2YWx1ZU9mJywgJ2lzUHJvdG90eXBlT2YnLCAndG9TdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICdoYXNPd25Qcm9wZXJ0eScsICd0b0xvY2FsZVN0cmluZyddO1xuXG4gIGZ1bmN0aW9uIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKSB7XG4gICAgdmFyIG5vbkVudW1JZHggPSBub25FbnVtZXJhYmxlUHJvcHMubGVuZ3RoO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IG9iai5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgcHJvdG8gPSAoXy5pc0Z1bmN0aW9uKGNvbnN0cnVjdG9yKSAmJiBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpIHx8IE9ialByb3RvO1xuXG4gICAgLy8gQ29uc3RydWN0b3IgaXMgYSBzcGVjaWFsIGNhc2UuXG4gICAgdmFyIHByb3AgPSAnY29uc3RydWN0b3InO1xuICAgIGlmIChfLmhhcyhvYmosIHByb3ApICYmICFfLmNvbnRhaW5zKGtleXMsIHByb3ApKSBrZXlzLnB1c2gocHJvcCk7XG5cbiAgICB3aGlsZSAobm9uRW51bUlkeC0tKSB7XG4gICAgICBwcm9wID0gbm9uRW51bWVyYWJsZVByb3BzW25vbkVudW1JZHhdO1xuICAgICAgaWYgKHByb3AgaW4gb2JqICYmIG9ialtwcm9wXSAhPT0gcHJvdG9bcHJvcF0gJiYgIV8uY29udGFpbnMoa2V5cywgcHJvcCkpIHtcbiAgICAgICAga2V5cy5wdXNoKHByb3ApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFJldHJpZXZlIHRoZSBuYW1lcyBvZiBhbiBvYmplY3QncyBvd24gcHJvcGVydGllcy5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYE9iamVjdC5rZXlzYFxuICBfLmtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIFtdO1xuICAgIGlmIChuYXRpdmVLZXlzKSByZXR1cm4gbmF0aXZlS2V5cyhvYmopO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gICAgLy8gQWhlbSwgSUUgPCA5LlxuICAgIGlmIChoYXNFbnVtQnVnKSBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cyk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgYWxsIHRoZSBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QuXG4gIF8uYWxsS2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgICAvLyBBaGVtLCBJRSA8IDkuXG4gICAgaWYgKGhhc0VudW1CdWcpIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSB0aGUgdmFsdWVzIG9mIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXG4gIF8udmFsdWVzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHZhbHVlcyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWVzW2ldID0gb2JqW2tleXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudCBvZiB0aGUgb2JqZWN0XG4gIC8vIEluIGNvbnRyYXN0IHRvIF8ubWFwIGl0IHJldHVybnMgYW4gb2JqZWN0XG4gIF8ubWFwT2JqZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIF8ua2V5cyhvYmopLFxuICAgICAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdHMgPSB7fSxcbiAgICAgICAgICBjdXJyZW50S2V5O1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBjdXJyZW50S2V5ID0ga2V5c1tpbmRleF07XG4gICAgICAgIHJlc3VsdHNbY3VycmVudEtleV0gPSBpdGVyYXRlZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBDb252ZXJ0IGFuIG9iamVjdCBpbnRvIGEgbGlzdCBvZiBgW2tleSwgdmFsdWVdYCBwYWlycy5cbiAgXy5wYWlycyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBwYWlycyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcGFpcnNbaV0gPSBba2V5c1tpXSwgb2JqW2tleXNbaV1dXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhaXJzO1xuICB9O1xuXG4gIC8vIEludmVydCB0aGUga2V5cyBhbmQgdmFsdWVzIG9mIGFuIG9iamVjdC4gVGhlIHZhbHVlcyBtdXN0IGJlIHNlcmlhbGl6YWJsZS5cbiAgXy5pbnZlcnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0W29ialtrZXlzW2ldXV0gPSBrZXlzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHNvcnRlZCBsaXN0IG9mIHRoZSBmdW5jdGlvbiBuYW1lcyBhdmFpbGFibGUgb24gdGhlIG9iamVjdC5cbiAgLy8gQWxpYXNlZCBhcyBgbWV0aG9kc2BcbiAgXy5mdW5jdGlvbnMgPSBfLm1ldGhvZHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9ialtrZXldKSkgbmFtZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXMuc29ydCgpO1xuICB9O1xuXG4gIC8vIEV4dGVuZCBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgcHJvcGVydGllcyBpbiBwYXNzZWQtaW4gb2JqZWN0KHMpLlxuICBfLmV4dGVuZCA9IGNyZWF0ZUFzc2lnbmVyKF8uYWxsS2V5cyk7XG5cbiAgLy8gQXNzaWducyBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgb3duIHByb3BlcnRpZXMgaW4gdGhlIHBhc3NlZC1pbiBvYmplY3QocylcbiAgLy8gKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ24pXG4gIF8uZXh0ZW5kT3duID0gXy5hc3NpZ24gPSBjcmVhdGVBc3NpZ25lcihfLmtleXMpO1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGtleSBvbiBhbiBvYmplY3QgdGhhdCBwYXNzZXMgYSBwcmVkaWNhdGUgdGVzdFxuICBfLmZpbmRLZXkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKSwga2V5O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKHByZWRpY2F0ZShvYmpba2V5XSwga2V5LCBvYmopKSByZXR1cm4ga2V5O1xuICAgIH1cbiAgfTtcblxuICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgb25seSBjb250YWluaW5nIHRoZSB3aGl0ZWxpc3RlZCBwcm9wZXJ0aWVzLlxuICBfLnBpY2sgPSBmdW5jdGlvbihvYmplY3QsIG9pdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSB7fSwgb2JqID0gb2JqZWN0LCBpdGVyYXRlZSwga2V5cztcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihvaXRlcmF0ZWUpKSB7XG4gICAgICBrZXlzID0gXy5hbGxLZXlzKG9iaik7XG4gICAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2Iob2l0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5cyA9IGZsYXR0ZW4oYXJndW1lbnRzLCBmYWxzZSwgZmFsc2UsIDEpO1xuICAgICAgaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmopIHsgcmV0dXJuIGtleSBpbiBvYmo7IH07XG4gICAgICBvYmogPSBPYmplY3Qob2JqKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XG4gICAgICBpZiAoaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqKSkgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IHdpdGhvdXQgdGhlIGJsYWNrbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ub21pdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKGl0ZXJhdGVlKSkge1xuICAgICAgaXRlcmF0ZWUgPSBfLm5lZ2F0ZShpdGVyYXRlZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5tYXAoZmxhdHRlbihhcmd1bWVudHMsIGZhbHNlLCBmYWxzZSwgMSksIFN0cmluZyk7XG4gICAgICBpdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuICFfLmNvbnRhaW5zKGtleXMsIGtleSk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gXy5waWNrKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIEZpbGwgaW4gYSBnaXZlbiBvYmplY3Qgd2l0aCBkZWZhdWx0IHByb3BlcnRpZXMuXG4gIF8uZGVmYXVsdHMgPSBjcmVhdGVBc3NpZ25lcihfLmFsbEtleXMsIHRydWUpO1xuXG4gIC8vIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgZ2l2ZW4gcHJvdG90eXBlIG9iamVjdC5cbiAgLy8gSWYgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIGFyZSBwcm92aWRlZCB0aGVuIHRoZXkgd2lsbCBiZSBhZGRlZCB0byB0aGVcbiAgLy8gY3JlYXRlZCBvYmplY3QuXG4gIF8uY3JlYXRlID0gZnVuY3Rpb24ocHJvdG90eXBlLCBwcm9wcykge1xuICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgaWYgKHByb3BzKSBfLmV4dGVuZE93bihyZXN1bHQsIHByb3BzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIChzaGFsbG93LWNsb25lZCkgZHVwbGljYXRlIG9mIGFuIG9iamVjdC5cbiAgXy5jbG9uZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICAgIHJldHVybiBfLmlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogXy5leHRlbmQoe30sIG9iaik7XG4gIH07XG5cbiAgLy8gSW52b2tlcyBpbnRlcmNlcHRvciB3aXRoIHRoZSBvYmosIGFuZCB0aGVuIHJldHVybnMgb2JqLlxuICAvLyBUaGUgcHJpbWFyeSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiwgaW5cbiAgLy8gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGludGVybWVkaWF0ZSByZXN1bHRzIHdpdGhpbiB0aGUgY2hhaW4uXG4gIF8udGFwID0gZnVuY3Rpb24ob2JqLCBpbnRlcmNlcHRvcikge1xuICAgIGludGVyY2VwdG9yKG9iaik7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm5zIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZiBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5pc01hdGNoID0gZnVuY3Rpb24ob2JqZWN0LCBhdHRycykge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKGF0dHJzKSwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSByZXR1cm4gIWxlbmd0aDtcbiAgICB2YXIgb2JqID0gT2JqZWN0KG9iamVjdCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoYXR0cnNba2V5XSAhPT0gb2JqW2tleV0gfHwgIShrZXkgaW4gb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuXG4gIC8vIEludGVybmFsIHJlY3Vyc2l2ZSBjb21wYXJpc29uIGZ1bmN0aW9uIGZvciBgaXNFcXVhbGAuXG4gIHZhciBlcSA9IGZ1bmN0aW9uKGEsIGIsIGFTdGFjaywgYlN0YWNrKSB7XG4gICAgLy8gSWRlbnRpY2FsIG9iamVjdHMgYXJlIGVxdWFsLiBgMCA9PT0gLTBgLCBidXQgdGhleSBhcmVuJ3QgaWRlbnRpY2FsLlxuICAgIC8vIFNlZSB0aGUgW0hhcm1vbnkgYGVnYWxgIHByb3Bvc2FsXShodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmVnYWwpLlxuICAgIGlmIChhID09PSBiKSByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PT0gMSAvIGI7XG4gICAgLy8gQSBzdHJpY3QgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkgYmVjYXVzZSBgbnVsbCA9PSB1bmRlZmluZWRgLlxuICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gYSA9PT0gYjtcbiAgICAvLyBVbndyYXAgYW55IHdyYXBwZWQgb2JqZWN0cy5cbiAgICBpZiAoYSBpbnN0YW5jZW9mIF8pIGEgPSBhLl93cmFwcGVkO1xuICAgIGlmIChiIGluc3RhbmNlb2YgXykgYiA9IGIuX3dyYXBwZWQ7XG4gICAgLy8gQ29tcGFyZSBgW1tDbGFzc11dYCBuYW1lcy5cbiAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKTtcbiAgICBpZiAoY2xhc3NOYW1lICE9PSB0b1N0cmluZy5jYWxsKGIpKSByZXR1cm4gZmFsc2U7XG4gICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgIC8vIFN0cmluZ3MsIG51bWJlcnMsIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGRhdGVzLCBhbmQgYm9vbGVhbnMgYXJlIGNvbXBhcmVkIGJ5IHZhbHVlLlxuICAgICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzpcbiAgICAgIC8vIFJlZ0V4cHMgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncyBmb3IgY29tcGFyaXNvbiAoTm90ZTogJycgKyAvYS9pID09PSAnL2EvaScpXG4gICAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgICAgICAvLyBQcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCB3cmFwcGVycyBhcmUgZXF1aXZhbGVudDsgdGh1cywgYFwiNVwiYCBpc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXG4gICAgICAgIHJldHVybiAnJyArIGEgPT09ICcnICsgYjtcbiAgICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XG4gICAgICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuXG4gICAgICAgIC8vIE9iamVjdChOYU4pIGlzIGVxdWl2YWxlbnQgdG8gTmFOXG4gICAgICAgIGlmICgrYSAhPT0gK2EpIHJldHVybiArYiAhPT0gK2I7XG4gICAgICAgIC8vIEFuIGBlZ2FsYCBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBmb3Igb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXG4gICAgICAgIHJldHVybiArYSA9PT0gMCA/IDEgLyArYSA9PT0gMSAvIGIgOiArYSA9PT0gK2I7XG4gICAgICBjYXNlICdbb2JqZWN0IERhdGVdJzpcbiAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxuICAgICAgICAvLyBDb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWVyaWMgcHJpbWl0aXZlIHZhbHVlcy4gRGF0ZXMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyXG4gICAgICAgIC8vIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9ucy4gTm90ZSB0aGF0IGludmFsaWQgZGF0ZXMgd2l0aCBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnNcbiAgICAgICAgLy8gb2YgYE5hTmAgYXJlIG5vdCBlcXVpdmFsZW50LlxuICAgICAgICByZXR1cm4gK2EgPT09ICtiO1xuICAgIH1cblxuICAgIHZhciBhcmVBcnJheXMgPSBjbGFzc05hbWUgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgaWYgKCFhcmVBcnJheXMpIHtcbiAgICAgIGlmICh0eXBlb2YgYSAhPSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBPYmplY3RzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWl2YWxlbnQsIGJ1dCBgT2JqZWN0YHMgb3IgYEFycmF5YHNcbiAgICAgIC8vIGZyb20gZGlmZmVyZW50IGZyYW1lcyBhcmUuXG4gICAgICB2YXIgYUN0b3IgPSBhLmNvbnN0cnVjdG9yLCBiQ3RvciA9IGIuY29uc3RydWN0b3I7XG4gICAgICBpZiAoYUN0b3IgIT09IGJDdG9yICYmICEoXy5pc0Z1bmN0aW9uKGFDdG9yKSAmJiBhQ3RvciBpbnN0YW5jZW9mIGFDdG9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5pc0Z1bmN0aW9uKGJDdG9yKSAmJiBiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoJ2NvbnN0cnVjdG9yJyBpbiBhICYmICdjb25zdHJ1Y3RvcicgaW4gYikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBBc3N1bWUgZXF1YWxpdHkgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljXG4gICAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXG5cbiAgICAvLyBJbml0aWFsaXppbmcgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgLy8gSXQncyBkb25lIGhlcmUgc2luY2Ugd2Ugb25seSBuZWVkIHRoZW0gZm9yIG9iamVjdHMgYW5kIGFycmF5cyBjb21wYXJpc29uLlxuICAgIGFTdGFjayA9IGFTdGFjayB8fCBbXTtcbiAgICBiU3RhY2sgPSBiU3RhY2sgfHwgW107XG4gICAgdmFyIGxlbmd0aCA9IGFTdGFjay5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cbiAgICAgIGlmIChhU3RhY2tbbGVuZ3RoXSA9PT0gYSkgcmV0dXJuIGJTdGFja1tsZW5ndGhdID09PSBiO1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucHVzaChhKTtcbiAgICBiU3RhY2sucHVzaChiKTtcblxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgIGlmIChhcmVBcnJheXMpIHtcbiAgICAgIC8vIENvbXBhcmUgYXJyYXkgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5LlxuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gRGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllcy5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoIWVxKGFbbGVuZ3RoXSwgYltsZW5ndGhdLCBhU3RhY2ssIGJTdGFjaykpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHMuXG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhhKSwga2V5O1xuICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAvLyBFbnN1cmUgdGhhdCBib3RoIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllcyBiZWZvcmUgY29tcGFyaW5nIGRlZXAgZXF1YWxpdHkuXG4gICAgICBpZiAoXy5rZXlzKGIpLmxlbmd0aCAhPT0gbGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgLy8gRGVlcCBjb21wYXJlIGVhY2ggbWVtYmVyXG4gICAgICAgIGtleSA9IGtleXNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKCEoXy5oYXMoYiwga2V5KSAmJiBlcShhW2tleV0sIGJba2V5XSwgYVN0YWNrLCBiU3RhY2spKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IG9iamVjdCBmcm9tIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucG9wKCk7XG4gICAgYlN0YWNrLnBvcCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIFBlcmZvcm0gYSBkZWVwIGNvbXBhcmlzb24gdG8gY2hlY2sgaWYgdHdvIG9iamVjdHMgYXJlIGVxdWFsLlxuICBfLmlzRXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGVxKGEsIGIpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gYXJyYXksIHN0cmluZywgb3Igb2JqZWN0IGVtcHR5P1xuICAvLyBBbiBcImVtcHR5XCIgb2JqZWN0IGhhcyBubyBlbnVtZXJhYmxlIG93bi1wcm9wZXJ0aWVzLlxuICBfLmlzRW1wdHkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB0cnVlO1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopICYmIChfLmlzQXJyYXkob2JqKSB8fCBfLmlzU3RyaW5nKG9iaikgfHwgXy5pc0FyZ3VtZW50cyhvYmopKSkgcmV0dXJuIG9iai5sZW5ndGggPT09IDA7XG4gICAgcmV0dXJuIF8ua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgRE9NIGVsZW1lbnQ/XG4gIF8uaXNFbGVtZW50ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuICEhKG9iaiAmJiBvYmoubm9kZVR5cGUgPT09IDEpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYW4gYXJyYXk/XG4gIC8vIERlbGVnYXRlcyB0byBFQ01BNSdzIG5hdGl2ZSBBcnJheS5pc0FycmF5XG4gIF8uaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIGFuIG9iamVjdD9cbiAgXy5pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIG9iajtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiAhIW9iajtcbiAgfTtcblxuICAvLyBBZGQgc29tZSBpc1R5cGUgbWV0aG9kczogaXNBcmd1bWVudHMsIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc051bWJlciwgaXNEYXRlLCBpc1JlZ0V4cCwgaXNFcnJvci5cbiAgXy5lYWNoKFsnQXJndW1lbnRzJywgJ0Z1bmN0aW9uJywgJ1N0cmluZycsICdOdW1iZXInLCAnRGF0ZScsICdSZWdFeHAnLCAnRXJyb3InXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIF9bJ2lzJyArIG5hbWVdID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCAnICsgbmFtZSArICddJztcbiAgICB9O1xuICB9KTtcblxuICAvLyBEZWZpbmUgYSBmYWxsYmFjayB2ZXJzaW9uIG9mIHRoZSBtZXRob2QgaW4gYnJvd3NlcnMgKGFoZW0sIElFIDwgOSksIHdoZXJlXG4gIC8vIHRoZXJlIGlzbid0IGFueSBpbnNwZWN0YWJsZSBcIkFyZ3VtZW50c1wiIHR5cGUuXG4gIGlmICghXy5pc0FyZ3VtZW50cyhhcmd1bWVudHMpKSB7XG4gICAgXy5pc0FyZ3VtZW50cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIF8uaGFzKG9iaiwgJ2NhbGxlZScpO1xuICAgIH07XG4gIH1cblxuICAvLyBPcHRpbWl6ZSBgaXNGdW5jdGlvbmAgaWYgYXBwcm9wcmlhdGUuIFdvcmsgYXJvdW5kIHNvbWUgdHlwZW9mIGJ1Z3MgaW4gb2xkIHY4LFxuICAvLyBJRSAxMSAoIzE2MjEpLCBhbmQgaW4gU2FmYXJpIDggKCMxOTI5KS5cbiAgaWYgKHR5cGVvZiAvLi8gIT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgSW50OEFycmF5ICE9ICdvYmplY3QnKSB7XG4gICAgXy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PSAnZnVuY3Rpb24nIHx8IGZhbHNlO1xuICAgIH07XG4gIH1cblxuICAvLyBJcyBhIGdpdmVuIG9iamVjdCBhIGZpbml0ZSBudW1iZXI/XG4gIF8uaXNGaW5pdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gaXNGaW5pdGUob2JqKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChvYmopKTtcbiAgfTtcblxuICAvLyBJcyB0aGUgZ2l2ZW4gdmFsdWUgYE5hTmA/IChOYU4gaXMgdGhlIG9ubHkgbnVtYmVyIHdoaWNoIGRvZXMgbm90IGVxdWFsIGl0c2VsZikuXG4gIF8uaXNOYU4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gXy5pc051bWJlcihvYmopICYmIG9iaiAhPT0gK29iajtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgYm9vbGVhbj9cbiAgXy5pc0Jvb2xlYW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBCb29sZWFuXSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBlcXVhbCB0byBudWxsP1xuICBfLmlzTnVsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IG51bGw7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSB1bmRlZmluZWQ/XG4gIF8uaXNVbmRlZmluZWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB2b2lkIDA7XG4gIH07XG5cbiAgLy8gU2hvcnRjdXQgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBwcm9wZXJ0eSBkaXJlY3RseVxuICAvLyBvbiBpdHNlbGYgKGluIG90aGVyIHdvcmRzLCBub3Qgb24gYSBwcm90b3R5cGUpLlxuICBfLmhhcyA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xuICB9O1xuXG4gIC8vIFV0aWxpdHkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUnVuIFVuZGVyc2NvcmUuanMgaW4gKm5vQ29uZmxpY3QqIG1vZGUsIHJldHVybmluZyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0c1xuICAvLyBwcmV2aW91cyBvd25lci4gUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJvb3QuXyA9IHByZXZpb3VzVW5kZXJzY29yZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBLZWVwIHRoZSBpZGVudGl0eSBmdW5jdGlvbiBhcm91bmQgZm9yIGRlZmF1bHQgaXRlcmF0ZWVzLlxuICBfLmlkZW50aXR5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLy8gUHJlZGljYXRlLWdlbmVyYXRpbmcgZnVuY3Rpb25zLiBPZnRlbiB1c2VmdWwgb3V0c2lkZSBvZiBVbmRlcnNjb3JlLlxuICBfLmNvbnN0YW50ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgfTtcblxuICBfLm5vb3AgPSBmdW5jdGlvbigpe307XG5cbiAgXy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuXG4gIC8vIEdlbmVyYXRlcyBhIGZ1bmN0aW9uIGZvciBhIGdpdmVuIG9iamVjdCB0aGF0IHJldHVybnMgYSBnaXZlbiBwcm9wZXJ0eS5cbiAgXy5wcm9wZXJ0eU9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PSBudWxsID8gZnVuY3Rpb24oKXt9IDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgcHJlZGljYXRlIGZvciBjaGVja2luZyB3aGV0aGVyIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBzZXQgb2ZcbiAgLy8gYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8ubWF0Y2hlciA9IF8ubWF0Y2hlcyA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgYXR0cnMgPSBfLmV4dGVuZE93bih7fSwgYXR0cnMpO1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBfLmlzTWF0Y2gob2JqLCBhdHRycyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSdW4gYSBmdW5jdGlvbiAqKm4qKiB0aW1lcy5cbiAgXy50aW1lcyA9IGZ1bmN0aW9uKG4sIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIGFjY3VtID0gQXJyYXkoTWF0aC5tYXgoMCwgbikpO1xuICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCwgMSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIGFjY3VtW2ldID0gaXRlcmF0ZWUoaSk7XG4gICAgcmV0dXJuIGFjY3VtO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gbWluIGFuZCBtYXggKGluY2x1c2l2ZSkuXG4gIF8ucmFuZG9tID0gZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgIG1heCA9IG1pbjtcbiAgICAgIG1pbiA9IDA7XG4gICAgfVxuICAgIHJldHVybiBtaW4gKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xuICB9O1xuXG4gIC8vIEEgKHBvc3NpYmx5IGZhc3Rlcikgd2F5IHRvIGdldCB0aGUgY3VycmVudCB0aW1lc3RhbXAgYXMgYW4gaW50ZWdlci5cbiAgXy5ub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH07XG5cbiAgIC8vIExpc3Qgb2YgSFRNTCBlbnRpdGllcyBmb3IgZXNjYXBpbmcuXG4gIHZhciBlc2NhcGVNYXAgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiN4Mjc7JyxcbiAgICAnYCc6ICcmI3g2MDsnXG4gIH07XG4gIHZhciB1bmVzY2FwZU1hcCA9IF8uaW52ZXJ0KGVzY2FwZU1hcCk7XG5cbiAgLy8gRnVuY3Rpb25zIGZvciBlc2NhcGluZyBhbmQgdW5lc2NhcGluZyBzdHJpbmdzIHRvL2Zyb20gSFRNTCBpbnRlcnBvbGF0aW9uLlxuICB2YXIgY3JlYXRlRXNjYXBlciA9IGZ1bmN0aW9uKG1hcCkge1xuICAgIHZhciBlc2NhcGVyID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgIHJldHVybiBtYXBbbWF0Y2hdO1xuICAgIH07XG4gICAgLy8gUmVnZXhlcyBmb3IgaWRlbnRpZnlpbmcgYSBrZXkgdGhhdCBuZWVkcyB0byBiZSBlc2NhcGVkXG4gICAgdmFyIHNvdXJjZSA9ICcoPzonICsgXy5rZXlzKG1hcCkuam9pbignfCcpICsgJyknO1xuICAgIHZhciB0ZXN0UmVnZXhwID0gUmVnRXhwKHNvdXJjZSk7XG4gICAgdmFyIHJlcGxhY2VSZWdleHAgPSBSZWdFeHAoc291cmNlLCAnZycpO1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHN0cmluZyA9PSBudWxsID8gJycgOiAnJyArIHN0cmluZztcbiAgICAgIHJldHVybiB0ZXN0UmVnZXhwLnRlc3Qoc3RyaW5nKSA/IHN0cmluZy5yZXBsYWNlKHJlcGxhY2VSZWdleHAsIGVzY2FwZXIpIDogc3RyaW5nO1xuICAgIH07XG4gIH07XG4gIF8uZXNjYXBlID0gY3JlYXRlRXNjYXBlcihlc2NhcGVNYXApO1xuICBfLnVuZXNjYXBlID0gY3JlYXRlRXNjYXBlcih1bmVzY2FwZU1hcCk7XG5cbiAgLy8gSWYgdGhlIHZhbHVlIG9mIHRoZSBuYW1lZCBgcHJvcGVydHlgIGlzIGEgZnVuY3Rpb24gdGhlbiBpbnZva2UgaXQgd2l0aCB0aGVcbiAgLy8gYG9iamVjdGAgYXMgY29udGV4dDsgb3RoZXJ3aXNlLCByZXR1cm4gaXQuXG4gIF8ucmVzdWx0ID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSwgZmFsbGJhY2spIHtcbiAgICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHZvaWQgMCA6IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlID0gZmFsbGJhY2s7XG4gICAgfVxuICAgIHJldHVybiBfLmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbChvYmplY3QpIDogdmFsdWU7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgaW50ZWdlciBpZCAodW5pcXVlIHdpdGhpbiB0aGUgZW50aXJlIGNsaWVudCBzZXNzaW9uKS5cbiAgLy8gVXNlZnVsIGZvciB0ZW1wb3JhcnkgRE9NIGlkcy5cbiAgdmFyIGlkQ291bnRlciA9IDA7XG4gIF8udW5pcXVlSWQgPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICB2YXIgaWQgPSArK2lkQ291bnRlciArICcnO1xuICAgIHJldHVybiBwcmVmaXggPyBwcmVmaXggKyBpZCA6IGlkO1xuICB9O1xuXG4gIC8vIEJ5IGRlZmF1bHQsIFVuZGVyc2NvcmUgdXNlcyBFUkItc3R5bGUgdGVtcGxhdGUgZGVsaW1pdGVycywgY2hhbmdlIHRoZVxuICAvLyBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gIF8udGVtcGxhdGVTZXR0aW5ncyA9IHtcbiAgICBldmFsdWF0ZSAgICA6IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgaW50ZXJwb2xhdGUgOiAvPCU9KFtcXHNcXFNdKz8pJT4vZyxcbiAgICBlc2NhcGUgICAgICA6IC88JS0oW1xcc1xcU10rPyklPi9nXG4gIH07XG5cbiAgLy8gV2hlbiBjdXN0b21pemluZyBgdGVtcGxhdGVTZXR0aW5nc2AsIGlmIHlvdSBkb24ndCB3YW50IHRvIGRlZmluZSBhblxuICAvLyBpbnRlcnBvbGF0aW9uLCBldmFsdWF0aW9uIG9yIGVzY2FwaW5nIHJlZ2V4LCB3ZSBuZWVkIG9uZSB0aGF0IGlzXG4gIC8vIGd1YXJhbnRlZWQgbm90IHRvIG1hdGNoLlxuICB2YXIgbm9NYXRjaCA9IC8oLileLztcblxuICAvLyBDZXJ0YWluIGNoYXJhY3RlcnMgbmVlZCB0byBiZSBlc2NhcGVkIHNvIHRoYXQgdGhleSBjYW4gYmUgcHV0IGludG8gYVxuICAvLyBzdHJpbmcgbGl0ZXJhbC5cbiAgdmFyIGVzY2FwZXMgPSB7XG4gICAgXCInXCI6ICAgICAgXCInXCIsXG4gICAgJ1xcXFwnOiAgICAgJ1xcXFwnLFxuICAgICdcXHInOiAgICAgJ3InLFxuICAgICdcXG4nOiAgICAgJ24nLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICB2YXIgZXNjYXBlciA9IC9cXFxcfCd8XFxyfFxcbnxcXHUyMDI4fFxcdTIwMjkvZztcblxuICB2YXIgZXNjYXBlQ2hhciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZXNbbWF0Y2hdO1xuICB9O1xuXG4gIC8vIEphdmFTY3JpcHQgbWljcm8tdGVtcGxhdGluZywgc2ltaWxhciB0byBKb2huIFJlc2lnJ3MgaW1wbGVtZW50YXRpb24uXG4gIC8vIFVuZGVyc2NvcmUgdGVtcGxhdGluZyBoYW5kbGVzIGFyYml0cmFyeSBkZWxpbWl0ZXJzLCBwcmVzZXJ2ZXMgd2hpdGVzcGFjZSxcbiAgLy8gYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXG4gIC8vIE5COiBgb2xkU2V0dGluZ3NgIG9ubHkgZXhpc3RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgXy50ZW1wbGF0ZSA9IGZ1bmN0aW9uKHRleHQsIHNldHRpbmdzLCBvbGRTZXR0aW5ncykge1xuICAgIGlmICghc2V0dGluZ3MgJiYgb2xkU2V0dGluZ3MpIHNldHRpbmdzID0gb2xkU2V0dGluZ3M7XG4gICAgc2V0dGluZ3MgPSBfLmRlZmF1bHRzKHt9LCBzZXR0aW5ncywgXy50ZW1wbGF0ZVNldHRpbmdzKTtcblxuICAgIC8vIENvbWJpbmUgZGVsaW1pdGVycyBpbnRvIG9uZSByZWd1bGFyIGV4cHJlc3Npb24gdmlhIGFsdGVybmF0aW9uLlxuICAgIHZhciBtYXRjaGVyID0gUmVnRXhwKFtcbiAgICAgIChzZXR0aW5ncy5lc2NhcGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmludGVycG9sYXRlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAgIChzZXR0aW5ncy5ldmFsdWF0ZSB8fCBub01hdGNoKS5zb3VyY2VcbiAgICBdLmpvaW4oJ3wnKSArICd8JCcsICdnJyk7XG5cbiAgICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGVzY2FwaW5nIHN0cmluZyBsaXRlcmFscyBhcHByb3ByaWF0ZWx5LlxuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHNvdXJjZSA9IFwiX19wKz0nXCI7XG4gICAgdGV4dC5yZXBsYWNlKG1hdGNoZXIsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGUsIGludGVycG9sYXRlLCBldmFsdWF0ZSwgb2Zmc2V0KSB7XG4gICAgICBzb3VyY2UgKz0gdGV4dC5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKGVzY2FwZXIsIGVzY2FwZUNoYXIpO1xuICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBlc2NhcGUgKyBcIikpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xcbidcIjtcbiAgICAgIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBpbnRlcnBvbGF0ZSArIFwiKSk9PW51bGw/Jyc6X190KStcXG4nXCI7XG4gICAgICB9IGVsc2UgaWYgKGV2YWx1YXRlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZSArIFwiXFxuX19wKz0nXCI7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkb2JlIFZNcyBuZWVkIHRoZSBtYXRjaCByZXR1cm5lZCB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IG9mZmVzdC5cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcbiAgICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gICAgLy8gSWYgYSB2YXJpYWJsZSBpcyBub3Qgc3BlY2lmaWVkLCBwbGFjZSBkYXRhIHZhbHVlcyBpbiBsb2NhbCBzY29wZS5cbiAgICBpZiAoIXNldHRpbmdzLnZhcmlhYmxlKSBzb3VyY2UgPSAnd2l0aChvYmp8fHt9KXtcXG4nICsgc291cmNlICsgJ31cXG4nO1xuXG4gICAgc291cmNlID0gXCJ2YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4sXCIgK1xuICAgICAgXCJwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xcblwiICtcbiAgICAgIHNvdXJjZSArICdyZXR1cm4gX19wO1xcbic7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIHJlbmRlciA9IG5ldyBGdW5jdGlvbihzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJywgJ18nLCBzb3VyY2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGUuc291cmNlID0gc291cmNlO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICB2YXIgdGVtcGxhdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gcmVuZGVyLmNhbGwodGhpcywgZGF0YSwgXyk7XG4gICAgfTtcblxuICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIHNvdXJjZSBhcyBhIGNvbnZlbmllbmNlIGZvciBwcmVjb21waWxhdGlvbi5cbiAgICB2YXIgYXJndW1lbnQgPSBzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJztcbiAgICB0ZW1wbGF0ZS5zb3VyY2UgPSAnZnVuY3Rpb24oJyArIGFyZ3VtZW50ICsgJyl7XFxuJyArIHNvdXJjZSArICd9JztcblxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfTtcblxuICAvLyBBZGQgYSBcImNoYWluXCIgZnVuY3Rpb24uIFN0YXJ0IGNoYWluaW5nIGEgd3JhcHBlZCBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5jaGFpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBpbnN0YW5jZSA9IF8ob2JqKTtcbiAgICBpbnN0YW5jZS5fY2hhaW4gPSB0cnVlO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcblxuICAvLyBPT1BcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG4gIC8vIElmIFVuZGVyc2NvcmUgaXMgY2FsbGVkIGFzIGEgZnVuY3Rpb24sIGl0IHJldHVybnMgYSB3cmFwcGVkIG9iamVjdCB0aGF0XG4gIC8vIGNhbiBiZSB1c2VkIE9PLXN0eWxlLiBUaGlzIHdyYXBwZXIgaG9sZHMgYWx0ZXJlZCB2ZXJzaW9ucyBvZiBhbGwgdGhlXG4gIC8vIHVuZGVyc2NvcmUgZnVuY3Rpb25zLiBXcmFwcGVkIG9iamVjdHMgbWF5IGJlIGNoYWluZWQuXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnRpbnVlIGNoYWluaW5nIGludGVybWVkaWF0ZSByZXN1bHRzLlxuICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24oaW5zdGFuY2UsIG9iaikge1xuICAgIHJldHVybiBpbnN0YW5jZS5fY2hhaW4gPyBfKG9iaikuY2hhaW4oKSA6IG9iajtcbiAgfTtcblxuICAvLyBBZGQgeW91ciBvd24gY3VzdG9tIGZ1bmN0aW9ucyB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubWl4aW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICBfLmVhY2goXy5mdW5jdGlvbnMob2JqKSwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBfW25hbWVdID0gb2JqW25hbWVdO1xuICAgICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbdGhpcy5fd3JhcHBlZF07XG4gICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCh0aGlzLCBmdW5jLmFwcGx5KF8sIGFyZ3MpKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQWRkIGFsbCBvZiB0aGUgVW5kZXJzY29yZSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICBfLm1peGluKF8pO1xuXG4gIC8vIEFkZCBhbGwgbXV0YXRvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIF8uZWFjaChbJ3BvcCcsICdwdXNoJywgJ3JldmVyc2UnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmogPSB0aGlzLl93cmFwcGVkO1xuICAgICAgbWV0aG9kLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcbiAgICAgIGlmICgobmFtZSA9PT0gJ3NoaWZ0JyB8fCBuYW1lID09PSAnc3BsaWNlJykgJiYgb2JqLmxlbmd0aCA9PT0gMCkgZGVsZXRlIG9ialswXTtcbiAgICAgIHJldHVybiByZXN1bHQodGhpcywgb2JqKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBBZGQgYWxsIGFjY2Vzc29yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgXy5lYWNoKFsnY29uY2F0JywgJ2pvaW4nLCAnc2xpY2UnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIG1ldGhvZC5hcHBseSh0aGlzLl93cmFwcGVkLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBFeHRyYWN0cyB0aGUgcmVzdWx0IGZyb20gYSB3cmFwcGVkIGFuZCBjaGFpbmVkIG9iamVjdC5cbiAgXy5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JhcHBlZDtcbiAgfTtcblxuICAvLyBQcm92aWRlIHVud3JhcHBpbmcgcHJveHkgZm9yIHNvbWUgbWV0aG9kcyB1c2VkIGluIGVuZ2luZSBvcGVyYXRpb25zXG4gIC8vIHN1Y2ggYXMgYXJpdGhtZXRpYyBhbmQgSlNPTiBzdHJpbmdpZmljYXRpb24uXG4gIF8ucHJvdG90eXBlLnZhbHVlT2YgPSBfLnByb3RvdHlwZS50b0pTT04gPSBfLnByb3RvdHlwZS52YWx1ZTtcblxuICBfLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnJyArIHRoaXMuX3dyYXBwZWQ7XG4gIH07XG5cbiAgLy8gQU1EIHJlZ2lzdHJhdGlvbiBoYXBwZW5zIGF0IHRoZSBlbmQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBBTUQgbG9hZGVyc1xuICAvLyB0aGF0IG1heSBub3QgZW5mb3JjZSBuZXh0LXR1cm4gc2VtYW50aWNzIG9uIG1vZHVsZXMuIEV2ZW4gdGhvdWdoIGdlbmVyYWxcbiAgLy8gcHJhY3RpY2UgZm9yIEFNRCByZWdpc3RyYXRpb24gaXMgdG8gYmUgYW5vbnltb3VzLCB1bmRlcnNjb3JlIHJlZ2lzdGVyc1xuICAvLyBhcyBhIG5hbWVkIG1vZHVsZSBiZWNhdXNlLCBsaWtlIGpRdWVyeSwgaXQgaXMgYSBiYXNlIGxpYnJhcnkgdGhhdCBpc1xuICAvLyBwb3B1bGFyIGVub3VnaCB0byBiZSBidW5kbGVkIGluIGEgdGhpcmQgcGFydHkgbGliLCBidXQgbm90IGJlIHBhcnQgb2ZcbiAgLy8gYW4gQU1EIGxvYWQgcmVxdWVzdC4gVGhvc2UgY2FzZXMgY291bGQgZ2VuZXJhdGUgYW4gZXJyb3Igd2hlbiBhblxuICAvLyBhbm9ueW1vdXMgZGVmaW5lKCkgaXMgY2FsbGVkIG91dHNpZGUgb2YgYSBsb2FkZXIgcmVxdWVzdC5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZSgndW5kZXJzY29yZScsIFtdLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG59LmNhbGwodGhpcykpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxib2R5PlxcbiAgPGRpdiBjbGFzcz1cXFwiZ3JhcGhcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjeVxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwic3RhdHVzIGxvYWRlclxcXCI+PC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjb250cm9sc1xcXCI+XFxuICAgICAgPGRpdj5JbnRlcmFjdGlvbiB0eXBlOjwvZGl2PlxcbiAgICAgIDxkaXY+XFxuICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJnZW5ldGljXFxcIj5HZW5ldGljPC9idXR0b24+PGJ1dHRvbiBjbGFzcz1cXFwiZGVmYXVsdCBzZWxlY3RlZFxcXCI+Qm90aDwvYnV0dG9uPjxidXR0b24gY2xhc3M9XFxcInBoeXNpY2FsXFxcIj5QaHlzaWNhbDwvYnV0dG9uPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwibm9kZURldGFpbHNcXFwiPlxcbiAgICA8aDIgY2xhc3M9XFxcIm5vZGVUaXRsZVxcXCI+PC9oMj5cXG4gICAgPGRsIGNsYXNzPVxcXCJub2RlSW5mbyBpbnRyb1xcXCI+XFxuICAgICAgPGR0IGNsYXNzPVxcXCJpbnRyb1xcXCI+Q2xpY2sgb24gYSBnZW5lIHRvIGdldCBtb3JlIGluZm8gYWJvdXQgaXQuPC9kdD5cXG4gICAgICA8IS0tIGR5bmFtaWNhbGx5IG91dHB1dCBkYXRhIGhlcmUuICAtLT5cXG4gICAgPC9kbD5cXG4gIDwvZGl2PlxcbjwvYm9keT5cXG5cIjtcbiJdfQ==
